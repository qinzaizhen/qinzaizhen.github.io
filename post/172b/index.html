<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Spring bean定义文件解析 | 水娃火娃石榴娃</title><meta name="author" content="水娃"><meta name="copyright" content="水娃"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Bean 定义文件的解析初始化工厂123456&amp;#x2F;&amp;#x2F; 1. 初始化一个bean 工厂DefaultListableBeanFactory factory &amp;#x3D; new DefaultListableBeanFactory();&amp;#x2F;&amp;#x2F; 2. 初始化XmlBeanDefinitionReader,负责从xml"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://qzztf.com/post/172b/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/image/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/image/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/image/pwa/16.png"/><link rel="mask-icon" href="/image/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?86553a0f289bcfb307062507dc247eb2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring bean定义文件解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-16 15:25:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="水娃火娃石榴娃"><span class="site-name">水娃火娃石榴娃</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring bean定义文件解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-05-13T06:36:27.000Z" title="发表于 2019-05-13 14:36:27">2019-05-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-16T07:25:26.155Z" title="更新于 2024-06-16 15:25:26">2024-06-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring bean定义文件解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Bean-定义文件的解析"><a href="#Bean-定义文件的解析" class="headerlink" title="Bean 定义文件的解析"></a>Bean 定义文件的解析</h1><h2 id="初始化工厂"><a href="#初始化工厂" class="headerlink" title="初始化工厂"></a>初始化工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化一个bean 工厂</span></span><br><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"><span class="comment">// 2. 初始化XmlBeanDefinitionReader,负责从xml文件中读取bean定义</span></span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line"><span class="comment">// 3. 加载bean 定义的入口方法</span></span><br><span class="line">reader.loadBeanDefinitions(<span class="string">&quot;classpath:app.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码使用起来很简单，创建一个工厂和阅读器，传入配置文件的位置。</p>
<p>我们可以考虑一下，这些代码做了什么。</p>
<ol>
<li>XmlBeanDefinitionReader 是如何定位配置文件的?</li>
<li>如何解析配置文件的？</li>
<li>XmlBeanDefinitionReader的构造函数传入了一个BeanDefinitionRegistry对象，这个对象是用来注册bean定义的，那么是如何注册的呢？</li>
</ol>
<h2 id="ResourceLoader-定位资源文件"><a href="#ResourceLoader-定位资源文件" class="headerlink" title="ResourceLoader 定位资源文件"></a>ResourceLoader 定位资源文件</h2><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>Spring将各种资源统一抽象为<code>Resource</code>,并使用<code>ResourceLoader</code>来定位<code>Resource</code>。如果资源以物理形式存在，那么它可以为每个资源打开一个InputStream，但是URL或文件句柄只能由某些特定资源返回。实际的行为取决于实现类。</p>
<h4 id="Resource的结构"><a href="#Resource的结构" class="headerlink" title="Resource的结构"></a><code>Resource</code>的结构</h4><p>下面是Resource的类关系图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/172b/resource%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="resource类关系图"></p>
<p>下面是Resource的类结构图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/post/172b/resource%E7%BB%93%E6%9E%84.png" alt="resource结构"></p>
<p><code>Resource</code>继承自<code>InputStreamSource</code>, 得到了获取<code>InputStream</code>的能力，可以以流的形式读取资源文件。</p>
<p>定义的方法：</p>
<ul>
<li>boolean exists()：确定此资源是实际物理存在。此方法执行确定的存在性检查，而资源句柄的存在仅保证有效的描述符句柄。</li>
<li>boolean isReadable()：指示是否可以通过<code>getInputStream()</code>读取此资源的非空内容。对于存在的典型资源描述符会返回<code>true</code>，因为从5.1开始它严格地暗示了<code>exist()</code>语义。请注意，在尝试读取实际内容时仍然可能失败。但是，如果返回值为<code>false</code>，则表示资源内容无法读取。</li>
<li>boolean isOpen(): 指示此资源是否表示具有打开流的句柄。如果为<code>true</code>，则不能多次读取InputStream，必须读取并关闭该资源，以避免资源泄漏。对于典型的资源描述符将为false。</li>
<li>boolean isFile()：确定此资源是否表示文件系统中的文件。返回<code>true</code>标志着(但不保证)<code>getFile()</code>将调用成功。<br>这在默认情况下返回<code>false</code>.</li>
<li>URL getURL(): 返回此资源的URL句柄。</li>
<li>URI getURI(): 返回此资源的URI句柄。</li>
<li>File getFile(): 返回此资源的文件句柄。如果资源不能被解析为绝对文件路径，也就是说，如果资源在文件系统中不可用将抛出<code>FileNotFoundException</code>异常。</li>
<li>ReadableByteChannel readableChannel()：返回一个<code>ReadableByteChannel</code>。希望每次调用都创建一个新的通道。<br>默认实现返回<code>Channels.newChannel(getInputStream())</code>。</li>
<li>long contentLength()：确定此资源的内容长度。</li>
<li>long lastModified()：确定此资源最后修改的时间戳。</li>
<li>Resource createRelative(String relativePath)：创建与此资源相对路径的资源。</li>
<li>String getFilename()：确定此资源的文件名，通常是路径的最后一部分:例如，“myfile.txt”。如果此类资源没有文件名，则返回<code>null</code>。</li>
<li>String getDescription(): 返回此资源的描述，用于处理该资源时的错误输出。实现类可以从它们的<code>toString</code>方法返回这个值。</li>
</ul>
<h4 id="Resource-的子接口"><a href="#Resource-的子接口" class="headerlink" title="Resource 的子接口"></a>Resource 的子接口</h4><h5 id="ContextResource"><a href="#ContextResource" class="headerlink" title="ContextResource"></a>ContextResource</h5><p>用于从封闭的“上下文”(例如从<code>javax.servlet.ServletContext</code>)加载资源的扩展接口，也可以从普通类路径或相对于文件系统路径(没有显式指定前缀，因此应用于相对于本地<code>ResourceLoader</code>的上下文)。</p>
<p>定义的方法：</p>
<ul>
<li>String getPathWithinContext()：返回包含在“上下文”中的路径。通常是相对于上下文特定的根目录的路径，例如<code>ServletContext</code>根目录或<code>PortletContext</code>根目录。</li>
</ul>
<h5 id="WritableResource"><a href="#WritableResource" class="headerlink" title="WritableResource"></a>WritableResource</h5><p>支持对资源进行写入的扩展接口。该接口提供一个<code>OutputStream</code>访问器。</p>
<p>定义的方法：</p>
<ul>
<li>boolean isWritable()：指示是否可以通过<code>getOutputStream()</code>向此资源写入内容。适用于典型的资源描述符;注意，实际在尝试写入时仍然可能失败。但是，如果值为false，则表示资源内容不能修改</li>
<li>OutputStream getOutputStream()：返回底层资源的<code>OutputStream</code>，允许(过度)写入其内容.</li>
<li>WritableByteChannel writableChannel(): 返回一个<code>WritableByteChannel</code>。希望每个调用都创建一个新的通道。默认实现返回<code>Channels.newChannel(getOutputStream())</code>。</li>
</ul>
<h5 id="HttpResource"><a href="#HttpResource" class="headerlink" title="HttpResource"></a>HttpResource</h5><p>将资源写入HTTP响应的扩展接口</p>
<p>定义的方法：</p>
<ul>
<li>HttpHeaders getResponseHeaders(): 服务于当前资源的HTTP响应头。</li>
</ul>
<h4 id="常用的Resource实现类"><a href="#常用的Resource实现类" class="headerlink" title="常用的Resource实现类"></a>常用的<code>Resource</code>实现类</h4><h5 id="ClassPathResource"><a href="#ClassPathResource" class="headerlink" title="ClassPathResource"></a>ClassPathResource</h5><p>类路径资源的实现类。使用给定的类加载器或给定的类来加载资源。如果类路径资源驻留在文件系统中，而不是JAR中的资源，则支持<code>java.io.File</code>方式来加载。该类始终支持URL方式来加载。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;app.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件：&quot;</span> + resource.getFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URI：&quot;</span> + resource.getURI());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line">Resource resourceRelative = resource.createRelative(<span class="string">&quot;relative.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;相对路径资源：&quot;</span> + resourceRelative);</span><br><span class="line">System.out.println(<span class="string">&quot;相对路径资源是否存在：&quot;</span> + resourceRelative.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;相对路径资源文件：&quot;</span> + resourceRelative.getFile());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">资源文件是否存在：<span class="keyword">true</span></span><br><span class="line">资源文件是否是文件：<span class="keyword">true</span></span><br><span class="line">资源文件是否可读：<span class="keyword">true</span></span><br><span class="line">资源文件名称：app.xml</span><br><span class="line">资源文件：F:\spring-code-study\chapter3\target\classes\app.xml</span><br><span class="line">资源文件描述：class path resource [app.xml]</span><br><span class="line">资源文件URL：file:/F:/spring-code-study/chapter3/target/classes/app.xml</span><br><span class="line">资源文件URI：file:/F:/spring-code-study/chapter3/target/classes/app.xml</span><br><span class="line">资源文件长度：<span class="number">307</span></span><br><span class="line">资源文件最后修改时间：Mon Apr <span class="number">08</span> <span class="number">10</span>:<span class="number">40</span>:<span class="number">17</span> CST <span class="number">2019</span></span><br><span class="line">资源文件数据：&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line">相对路径资源：class path resource [relative.xml]</span><br><span class="line">相对路径资源是否存在：<span class="keyword">false</span></span><br><span class="line">Exception in thread &quot;main&quot; java.io.FileNotFoundException: class path resource [relative.xml] cannot be resolved to URL because it does not exist</span><br><span class="line">	at org.springframework.core.io.ClassPathResource.getURL(ClassPathResource.java:<span class="number">195</span>)</span><br><span class="line">	at org.springframework.core.io.AbstractFileResolvingResource.getFile(AbstractFileResolvingResource.java:<span class="number">150</span>)</span><br><span class="line">	at cn.sexycode.spring.study.chapter3.ClassPathResourceDemo.main(ClassPathResourceDemo.java:<span class="number">30</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="FileSystemResource"><a href="#FileSystemResource" class="headerlink" title="FileSystemResource"></a>FileSystemResource</h5><p>处理<code>java.io.File</code>和<code>java.nio.file.Path</code>文件系统的资源实现。支持作为一个文件，也可以作为一个URL。扩展自<code>WritableResource</code>接口。</p>
<p><strong>注意:从Spring Framework 5.0开始，这个资源实现使用NIO.2 API进行读/写交互。从5.1开始，它可能使用一个<code>java.nio.file.Path</code>句柄实例化，在这种情况下，它将通过NIO.2执行所有文件系统交互，<br>只能通过<code>getFile()</code>来返回<code>File</code></strong></p>
<h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>加载资源的策略接口(例如类路径或文件系统资源)。<code>org.springframework.context.ApplicationContext</code>需要提供此功能，以及扩展<code>org.springframework.core.io.support.ResourcePatternResolver</code>支持。<br><code>DefaultResourceLoader</code>是一个独立的实现，可以在<code>ApplicationContext</code>之外使用，也可以由<code>ResourceEditor</code>使用。<br>当在<code>ApplicationContext</code>中使用时，可以使用特定上下文的资源加载策略从字符串填充Resource类型和Resource数组的Bean属性。</p>
<p>ResourceLoader提供的方法：</p>
<ul>
<li>Resource getResource(String location)：返回指定资源位置的资源句柄。<br>句柄应该始终是一个可重用的资源描述符，允许多次调用<code>Resource#getInputStream()</code>。<br>必须支持完全限定的url，例如。“file:C:/test.dat”。<br>必须支持类路径伪url，例如。“classpath:test.dat”。<br>应该支持相对文件路径，例如。“WEB-INF/test.dat”。(这是基于特定实现的，通常由<code>ApplicationContext</code>实现类提供。)</li>
</ul>
<p><strong>注意，资源句柄并不意味着资源实际存在;还是需要调用<code>Resource#exists</code>检查资源是否存在</strong></p>
<h4 id="ResourcePatternResolver子接口"><a href="#ResourcePatternResolver子接口" class="headerlink" title="ResourcePatternResolver子接口"></a><code>ResourcePatternResolver</code>子接口</h4><p>用于将位置模式(例如，ant样式的路径模式)解析为资源对象的策略接口。<br>这是ResourceLoader接口的扩展。可以检查传入的ResourceLoader(例如，当运行在上下文中时，通过<code>ResourceLoaderAware</code>传入的<code>ApplicationContext</code>)是否也实现了这个接口。<br><code>PathMatchingResourcePatternResolver</code>是一个独立的实现，可以在ApplicationContext之外使用，<code>ResourceArrayPropertyEditor</code>也使用它来填充bean的<code>Resource</code> 数组属性。<br>可以与任何类型的位置模式(例如<code>/WEB-INF/*-context.xml</code>):输入模式必须匹配策略实现。这个接口只指定转换方法，而不是特定的模式格式。<br>这个接口还为类路径中所有匹配的资源提供了一个新的资源前缀<code>classpath*:</code>。注意，在这种情况下，资源位置应该是一个没有占位符的路径(例如 <code>/beans.xml</code>);JAR文件或类目录可以包含多个同名文件</p>
<p>此接口提供的方法：</p>
<ul>
<li>Resource[] getResources(String locationPattern)：将给定的位置模式解析为资源对象。应该尽可能避免指向相同物理资源的重复资源项。结果应该具有set语义</li>
</ul>
<h4 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h4><h5 id="DefaultResourceLoader"><a href="#DefaultResourceLoader" class="headerlink" title="DefaultResourceLoader"></a>DefaultResourceLoader</h5><p><code>ResourceLoader</code>接口的默认实现。由<code>ResourceEditor</code>使用，并作为<code>org.springframework.context.support.AbstractApplicationContext</code>的基类。也可以单独使用。<br>如果位置值是URL，则返回UrlResource;如果非URL路径或“classpath:”伪URL，则返回ClassPathResource。</p>
<p>这里提到了URL, URL 是用来在互联网中描述一个资源位置的，主要包括协议，主机，路径等组成部分。</p>
<p>Spring 支持的URL:</p>
<ul>
<li>classpath: 表示classpath下的资源文件</li>
<li>file： 表示文件系统中的资源文件</li>
<li>jar： 表示jar包中的资源文件</li>
<li>war： 表示war包中的资源文件</li>
<li>zip：zip包中的资源文件</li>
<li>wsjar： WebSphere jar文件</li>
<li>vfszip：JBoss jar文件</li>
<li>vfsfile：JBoss 文件系统</li>
<li>vfs：通用的JBoss VFS 文件</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">DefaultResourceLoader resourceLoader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line"><span class="comment">//读取file文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------读取本地文件------------------&quot;</span> );</span><br><span class="line">Resource resource = resourceLoader.getResource(<span class="string">&quot;file:///F:\\spring-code-study\\chapter3\\target\\classes/app.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件是否可写：&quot; + ((FileSystemResource)resource).isWritable());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件：&quot;</span> + resource.getFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URI：&quot;</span> + resource.getURI());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取jar包中的文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------读取jar文件----------------------&quot;</span> );</span><br><span class="line">resource = resourceLoader.getResource(<span class="string">&quot;jar:file:///F:\\spring-code-study\\chapter3\\target\\chapter3-1.0-SNAPSHOT.jar!/app.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件是否可写：&quot; + ((FileSystemResource)resource).isWritable());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件：&quot; + resource.getFile());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件URI：&quot; + resource.getURI());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取网络文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------读取网络文件-----------------&quot;</span> );</span><br><span class="line">resource = resourceLoader.getResource(<span class="string">&quot;https://raw.githubusercontent.com/qzzsunly/spring-code-study/master/chapter3/src/main/resources/app.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件是否可写：&quot; + ((FileSystemResource)resource).isWritable());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件：&quot; + resource.getFile());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件URI：&quot; + resource.getURI());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取classpath下的文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------读取classpath文件-----------------&quot;</span> );</span><br><span class="line">resource = resourceLoader.getResource(<span class="string">&quot;classpath:app.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件是否可写：&quot; + ((FileSystemResource)resource).isWritable());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件：&quot; + resource.getFile());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件URI：&quot; + resource.getURI());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------读取本地文件------------------</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：true</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app.xml</span><br><span class="line">资源文件：F:\spring-code-study\chapter3\target\classes\app.xml</span><br><span class="line">资源文件描述：URL [file:&#x2F;F:&#x2F;spring-code-study&#x2F;chapter3&#x2F;target&#x2F;classes&#x2F;app.xml]</span><br><span class="line">资源文件URL：file:&#x2F;F:&#x2F;spring-code-study&#x2F;chapter3&#x2F;target&#x2F;classes&#x2F;app.xml</span><br><span class="line">资源文件URI：file:&#x2F;F:&#x2F;spring-code-study&#x2F;chapter3&#x2F;target&#x2F;classes&#x2F;app.xml</span><br><span class="line">资源文件长度：307</span><br><span class="line">资源文件最后修改时间：Mon Apr 08 10:40:17 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line">------------------------------------读取jar文件----------------------</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：false</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app.xml</span><br><span class="line">资源文件描述：URL [jar:file:&#x2F;&#x2F;&#x2F;F:\spring-code-study\chapter3\target\chapter3-1.0-SNAPSHOT.jar!&#x2F;app.xml]</span><br><span class="line">资源文件URL：jar:file:&#x2F;&#x2F;&#x2F;F:\spring-code-study\chapter3\target\chapter3-1.0-SNAPSHOT.jar!&#x2F;app.xml</span><br><span class="line">资源文件长度：307</span><br><span class="line">资源文件最后修改时间：Wed Apr 10 09:05:03 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line">------------------------------------读取网络文件-----------------</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：false</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app.xml</span><br><span class="line">资源文件描述：URL [https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;qzzsunly&#x2F;spring-code-study&#x2F;master&#x2F;chapter3&#x2F;src&#x2F;main&#x2F;resources&#x2F;app.xml]</span><br><span class="line">资源文件URL：https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;qzzsunly&#x2F;spring-code-study&#x2F;master&#x2F;chapter3&#x2F;src&#x2F;main&#x2F;resources&#x2F;app.xml</span><br><span class="line">资源文件长度：302</span><br><span class="line">资源文件最后修改时间：Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">资源文件数据：&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line">------------------------------------读取classpath文件-----------------</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：true</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app.xml</span><br><span class="line">资源文件描述：class path resource [app.xml]</span><br><span class="line">资源文件URL：file:&#x2F;F:&#x2F;spring-code-study&#x2F;chapter3&#x2F;target&#x2F;classes&#x2F;app.xml</span><br><span class="line">资源文件长度：307</span><br><span class="line">资源文件最后修改时间：Mon Apr 08 10:40:17 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>从上面的例子中可以看到使用<code>ResourceLoader</code>和<code>Resource</code>接口，我们可以很方便的读取文件内容。</p>
<h5 id="PathMatchingResourcePatternResolver"><a href="#PathMatchingResourcePatternResolver" class="headerlink" title="PathMatchingResourcePatternResolver"></a>PathMatchingResourcePatternResolver</h5><p>此实现支持ant风格的通配符形式路径。在有多个文件的情况下，我们可以利用这个类来加载多个配置文件。</p>
<h6 id="在没有通配符的情况"><a href="#在没有通配符的情况" class="headerlink" title="在没有通配符的情况"></a>在没有通配符的情况</h6><p>如果指定的路径没有<code>classpath*:</code>前缀，将通过底层ResourceLoader的getResource()返回单个的资源。比如“file:C:/context”。“classpath:/context”这样的伪url，以及简单的无前缀路径，如“/WEB-INF/context.xml”，后者将基于底层ResourceLoader的方式解析(例如，用于WebApplicationContext的ServletContextResource)。</p>
<h6 id="Ant-风格的路径"><a href="#Ant-风格的路径" class="headerlink" title="Ant 风格的路径"></a>Ant 风格的路径</h6><p>当路径包含一个ant样式的模式时，例如:<code>/WEB-INF/*-context.xml</code>、<code>com/mycompany/**/applicationContext.xml</code>、<code>file:C:/some/path/*-context.xml</code>、<code>classpath:com/mycompany/**/applicationContext.xml</code>, 解析器遵循一个更复杂但是已定义好的算法来尝试解析通配符。它为最后一个非通配符部分的路径生成一个资源，并获取一个URL。如果该URL不是<code>jar:</code> URL或特定于容器的变体(例如WebLogic中的<code>zip:</code>，WebSphere中的<code>wsjar</code>等等)，那么将从它获取<code>java.io.File</code>，并通过遍历文件系统来解析通配符。对于jar URL，解析器要么从中获取java.net.JarURLConnection，要么手动解析jar URL，然后遍历jar文件的内容来以解析通配符</p>
<h6 id="可移植性影响"><a href="#可移植性影响" class="headerlink" title="可移植性影响"></a>可移植性影响</h6><p>如果指定的路径已经是文件URL(由于基本ResourceLoader是基于文件系统的，所以可以显式或隐式地使用)，那么通配符就可以方便移植。如果指定的路径是类路径，那么解析器必须通过调用<code>Classloader.getResource()</code>获得最后一个非通配符路径部分的URL。由于这只是路径的一个节点(而不是末尾的文件)，所以它实际上是未定义的(在ClassLoader 的文档中有提及)。实际上，它通常是一个表示目录的<code>java.io.File</code>，其中类路径资源解析为文件系统位置，或者是某种jar URL，其中类路径解析为jar所在位置。尽管如此，这个操作仍然存在可移植性问题。为了从最后一个非通配符部分获取jar URL，解析器必须能够从中获得<code>java.net.JarURLConnection</code>，或者手动解析jar URL，以便能够遍历jar的内容并解析通配符。这将在大多数环境中工作，但在其他环境中可能会失败，强烈建议在依赖jar之前，在你的特定环境中彻底测试jar包资源的通配符解析。</p>
<h6 id="classpath-前缀"><a href="#classpath-前缀" class="headerlink" title="classpath*:前缀"></a>classpath*:前缀</h6><p>支持通过<code>classpath*:</code>前缀检索同名的多个类路径资源。例如,<code>classpath*:META-INF/beans.xml</code>将找到classpath下所有的<code>beans.xml</code>文件，无论是在<code>classes</code>目录中还是在JAR文件中。这对于自动检测每个jar文件中的相同位置的相同名称的配置文件特别有用。在内部是通过<code>ClassLoader.getResources()</code>方法实现的，并且是完全可移植的。<code>classpath*:</code>前缀还可以结合<code>PathMatcher</code> 模式，例如<code>classpath*:META-INF/*-beans.xml</code>。在本例中，解析策略相当简单:在最后一个非通配符路径部分上调用<code>ClassLoader.getResources()</code>来获取类加载器层次结构中所有匹配的资源，然后在每个资源之外使用上面描述的相同路径匹配器解析策略来处理通配符子路径。</p>
<h6 id="另注"><a href="#另注" class="headerlink" title="另注"></a>另注</h6><p>警告: 注意，<code>classpath*:</code>与ant样式的模式结合使用时，根目录在文件系统中必须存在。这意味着像<code>classpath*:*.xml</code>这样的模式不会从jar文件的根中检索文件，而是只从扩展目录的根中检索。这源于JDK的<code>ClassLoader.getResources()</code>方法中的一个限制，该方法传入空字符串只返回文件系统位置(指示潜在的要搜索的根目录)。这个<code>ResourcePatternResolver</code>实现试图通过URLClassLoader自省和<code>java.class.path</code>清单来减轻jar根目录查找的限制;但是不保证可移植性。<br><strong>警告: 当<code>classpath:</code>搭配Ant风格时，如果在多个类路径位置都能搜索到根包，则不能保证资源能够找到匹配的资源。这是因为如<br><code>com/mycompany/package1/service-context.xml</code>这样的资源可能只在一个位置，但当尝试解析这样路径时:<code>com/mycompany/**/service-context.xml</code>,解析器在处理<code>getResource(com/mycompany”)</code>返回的(第一个)URL，如果此存在于多个类加载器时，则实际的想要的资源可能不在返回的类加载器中。因此，在这种情况下，最好使用具有相同ant样式模式的<code>classpath*:</code>，它将搜索包含根包的所有类路径。</strong></p>
<h6 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PathMatchingResourcePatternResolver resourceLoader = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line"><span class="comment">//读取file文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------读取多个文件------------------&quot;</span>);</span><br><span class="line">Resource[] resources = resourceLoader.getResources(<span class="string">&quot;classpath:app*.xml&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件是否可写：&quot; + ((FileSystemResource)resource).isWritable());</span></span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件：&quot;</span> + resource.getFile());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件URI：&quot;</span> + resource.getURI());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------读取多个文件------------------</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：true</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app0.xml</span><br><span class="line">资源文件：F:\spring-code-study\chapter3\target\classes\app0.xml</span><br><span class="line">资源文件描述：file [F:\spring-code-study\chapter3\target\classes\app0.xml]</span><br><span class="line">资源文件URL：file:/F:/spring-code-study/chapter3/target/classes/app0.xml</span><br><span class="line">资源文件URI：file:/F:/spring-code-study/chapter3/target/classes/app0.xml</span><br><span class="line">资源文件长度：331</span><br><span class="line">资源文件最后修改时间：Wed Apr 10 20:57:17 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--配置文件0--&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：true</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app1.xml</span><br><span class="line">资源文件：F:\spring-code-study\chapter3\target\classes\app1.xml</span><br><span class="line">资源文件描述：file [F:\spring-code-study\chapter3\target\classes\app1.xml]</span><br><span class="line">资源文件URL：file:/F:/spring-code-study/chapter3/target/classes/app1.xml</span><br><span class="line">资源文件URI：file:/F:/spring-code-study/chapter3/target/classes/app1.xml</span><br><span class="line">资源文件长度：331</span><br><span class="line">资源文件最后修改时间：Wed Apr 10 10:46:52 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--配置文件1--&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：true</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app2.xml</span><br><span class="line">资源文件：F:\spring-code-study\chapter3\target\classes\app2.xml</span><br><span class="line">资源文件描述：file [F:\spring-code-study\chapter3\target\classes\app2.xml]</span><br><span class="line">资源文件URL：file:/F:/spring-code-study/chapter3/target/classes/app2.xml</span><br><span class="line">资源文件URI：file:/F:/spring-code-study/chapter3/target/classes/app2.xml</span><br><span class="line">资源文件长度：331</span><br><span class="line">资源文件最后修改时间：Wed Apr 10 10:46:50 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--配置文件2--&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<h2 id="BeanDefinitionReader-加载bean定义资源"><a href="#BeanDefinitionReader-加载bean定义资源" class="headerlink" title="BeanDefinitionReader 加载bean定义资源"></a>BeanDefinitionReader 加载bean定义资源</h2><p>通过<code>ResourceLoader</code> 定位资源文件之后，那么就该<code>BeanDefinitionReader</code>开始着手加载bean定义了。</p>
<p>定义的方法：</p>
<ul>
<li>int loadBeanDefinitions(Resource resource)：从单个资源中加载，返回发现的bean 定义数量</li>
<li>int loadBeanDefinitions(Resource… resources)：从多个资源中加载</li>
<li>int loadBeanDefinitions(String location)：从单个资源位置加载</li>
<li>int loadBeanDefinitions(String… locations)：从多个资源位置加载</li>
</ul>
<p>从方法定义中可以看出，<code>BeanDefinitionReader</code>提供了多个从各种资源中加载bean定义的功能。</p>
<h3 id="BeanDefinitionReader-实现类"><a href="#BeanDefinitionReader-实现类" class="headerlink" title="BeanDefinitionReader 实现类"></a>BeanDefinitionReader 实现类</h3><p>Spring 提供了三个实现类，用于从不同格式的资源文件中加载bean定义。</p>
<h4 id="PropertiesBeanDefinitionReader"><a href="#PropertiesBeanDefinitionReader" class="headerlink" title="PropertiesBeanDefinitionReader"></a>PropertiesBeanDefinitionReader</h4><p>该类用于从properties文件中加载bean定义。</p>
<h4 id="GroovyBeanDefinitionReader"><a href="#GroovyBeanDefinitionReader" class="headerlink" title="GroovyBeanDefinitionReader"></a>GroovyBeanDefinitionReader</h4><p>基于Groovy的 reader。<br>这个bean定义reader还可以读取XML bean定义文件，允许与Groovy bean定义文件无缝搭配。</p>
<h4 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a>XmlBeanDefinitionReader</h4><p>读取xml bean定义文件，将资源解析成xml w3c document, 内部委托给<code>BeanDefinitionDocumentReader</code>接口(具体实现类是<code>DefaultBeanDefinitionDocumentReader</code>)去加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">		<span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">		<span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">		<span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">		<span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">		<span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">		<span class="comment">//任何内部的 &lt;beans&gt; 标签，将会递归调用这个方法， 为了正确地传播和保存&lt;beans&gt; 的`default-`属性值，需要跟踪当前(父)委托，它有可能为空。</span></span><br><span class="line">		<span class="comment">//因为子beans 需要继承父beans的一些默认属性，比如说default-lazy-init=&quot;default&quot;, </span></span><br><span class="line">		<span class="comment">//创建新的(子)委托，并使用父委托的引用进行回退，然后最终将this.delegate重置为其原始(父)引用。这种行为模拟了一堆委托，实际上并不需要委托。</span></span><br><span class="line">		BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">		<span class="comment">// 为当前根节点创建新的委托解析器</span></span><br><span class="line">		<span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前标签是不是在默认命名空间中，默认命名空间代表&lt;benas&gt;标签所在的命名空间</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		    <span class="comment">//当前&lt;beans&gt; 标签指定了profile属性，则跟当前环境中激活的profile进行比较，如果是未激活，则跳过当前&lt;beans&gt; 标签</span></span><br><span class="line">			String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">				String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">						profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">				<span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">				<span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">				<span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">								<span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		preProcessXml(root);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//解析当前&lt;beans&gt;标签</span></span><br><span class="line">		parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">		postProcessXml(root);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.delegate = parent;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinitionParserDelegate 对象是用来具体解析每个元素的，为什么需要创建一个新的。可以</p>
<p>再看看parseBeanDefinitions方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果当前元素属于默认命名空间，这里其实就是指&lt;beans&gt;标签</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    NodeList nl = root.getChildNodes();</span><br><span class="line">    <span class="comment">//遍历子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                <span class="comment">//如果该标签属性默认命名空间，Uri为空，或者是 http://www.springframework.org/schema/beans</span></span><br><span class="line">                <span class="comment">// import标签</span></span><br><span class="line">                <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">                    <span class="comment">// 先处理路径中的点位符，如：$&#123;user.dir&#125;</span></span><br><span class="line">                    <span class="comment">// 判断引入的资源是否绝对路径(classpath:, classpath*:, url资源)，再调用reader的loadBeanDefinitions 方法</span></span><br><span class="line">                    <span class="comment">// 相对路径则使用 当前的资源创建相对路径资源（getReaderContext().getResource().createRelative(location)）</span></span><br><span class="line">                    <span class="comment">//再调用reader的loadBeanDefinitions 方法</span></span><br><span class="line">                    importBeanDefinitionResource(ele);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//alias 标签</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">                    <span class="comment">//调用org.springframework.core.AliasRegistry.registerAlias 方法注册别名</span></span><br><span class="line">                    processAliasRegistration(ele);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// bean 标签</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">                    processBeanDefinition(ele, delegate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 内部 beans 标签， 则递归调用 doRegisterBeanDefinitions()方法，</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">                    <span class="comment">// recurse</span></span><br><span class="line">                    doRegisterBeanDefinitions(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是自定义标签，那么调用自定义标签解析</span></span><br><span class="line">                delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果是自定义标签，那么调用自定义标签解析</span></span><br><span class="line">    delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要看一下 processBeanDefinition 方法，这个方法用来解析bean定义。<br>processBeanDefinition(): </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用了BeanDefinitionParserDelegate 来解析出BeanDefinitionHolder对象，这个对象中封装了 BeanDefinition 以及bean名称对象。</span></span><br><span class="line"><span class="comment">//BeanDefinition 是用来描述bean 定义的对象，主要包括 class, lazy-init ，依赖对象， 初始化方法，销毁方法，作用域, 父级bean定义等信息，这些信息都解析自xml bean标签。如果在有自定义的子标签和属性，则进一步调用自定义的 NamespaceHandler</span></span><br><span class="line"></span><br><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"><span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//处理标签中的自定义元素和自定义子标签， 调用自定义的 NamespaceHandler 来解析。</span></span><br><span class="line">    <span class="comment">// 这里返回的 BeanDefinitionHolder 可以是原始的，也可以是自己经过处理的。一切看 NamespaceHandler 里如何定义的</span></span><br><span class="line">    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">        <span class="comment">// 注册最终的 BeanDefinitionHolder</span></span><br><span class="line">        BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">        getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Send registration event.</span></span><br><span class="line">    getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看一下BeanDefinitionParserDelegate的parseBeanDefinitionElement方法，主要包括BeanDefinition的属性的设置，以及bean下的元素标签解析，bean 定义名称等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">		String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">		List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">		    <span class="comment">// 解析bean name， 可以有多个，用 ,;  隔开</span></span><br><span class="line">			String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">			aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		String beanName = id;</span><br><span class="line">		<span class="comment">// id 为空，则用第一个name 作为id</span></span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">			beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">		    <span class="comment">//判断名称是否唯一</span></span><br><span class="line">			checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 具体解析标签的每个元素，包括init-method, 构造参数等，设置 beanDefinition对应的属性</span></span><br><span class="line">		AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">		<span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">						beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">								beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">						<span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">						<span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">						<span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">						String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">						<span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">								beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">								!<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">							aliases.add(beanClassName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">						logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">								<span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">					error(ex.getMessage(), ele);</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NamespaceHandler-解析自定义标签"><a href="#NamespaceHandler-解析自定义标签" class="headerlink" title="NamespaceHandler 解析自定义标签"></a>NamespaceHandler 解析自定义标签</h3><p>除了默认命名空间<code>http://www.springframework.org/schema/beans</code>之外，其他的都是自定义命名空间，需要用到<code>NamespaceHandler</code>来解析自定义标签。<code>NamespaceHandlerResolver</code>会找到命名空间所对应的<code>NamespaceHandler</code>。<code>NamespaceHandlerResolver</code>接口的默认实现类<code>DefaultNamespaceHandlerResolver</code> 会加载<code>META-INF/spring.handlers</code>文件，并根据命名空间地址来实例化<code>NamespaceHandler</code>实现类。Spring beans包下的这个文件内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/c=org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/p=org.springframework.beans.factory.xml.SimplePropertyNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler</span><br></pre></td></tr></table></figure>
<p><code>命名空间地址=解析器实现类</code>这样的形式。</p>
<h4 id="常用的-NamespaceHandler"><a href="#常用的-NamespaceHandler" class="headerlink" title="常用的 NamespaceHandler"></a>常用的 NamespaceHandler</h4><ul>
<li><p>SimplePropertyNamespaceHandler：简单的NamespaceHandler实现，它将特定属性直接映射到bean属性。需要注意的重要一点是，NamespaceHandler无法预知所有可能的属性名。下面是使用NamespaceHandler的一个例子: <bean id="rob" class="..TestBean" p:name="Rob Harrop" p:spouse-ref="sally">, 这里的<code>p:name</code>直接对应于类“TestBean”上的<code>name</code>属性。<code>p:spouse-ref</code>属性对应于<code>spouse</code>属性，将value 所对应的bean注入到该属性中。</bean></p>
</li>
<li><p>SimpleConstructorNamespaceHandler：设置构造函数参数。如： <bean id="author" class="..TestBean " c:name="Enescu" c:work-ref="compositions"> 。这里，“c:name”直接对应于类“TestBean”构造函数中声明的“name”参数。“c:work-ref”属性对应于“work”参数，它不作为具体值，而是包含作为参数的bean的名称。注意:这个实现支持命名参数, 下标——不支持类型。此外，容器使用这些名称作为提示，默认情况下，容器会进行类型自省 。</bean></p>
</li>
<li><p>NamespaceHandlerSupport：实现自定义NamespaceHandler的支持类。各个节点的解析和装饰分别通过<code>BeanDefinitionParser</code>和<code>BeanDefinitionDecorator</code>策略接口完成。提供<code>registerBeanDefinitionParser</code>和<code>registerBeanDefinitionDecorator</code>方法，用于注册<code>BeanDefinitionParser</code>或<code>BeanDefinitionDecorator</code>来处理特定元素。</p>
</li>
<li><p>AopNamespaceHandler: 用于 <code>aop</code> 命名空间的NamespaceHandler。为<a href="aop:config">aop:config</a>标签提供一个BeanDefinitionParser。<code>config</code>标记可以包含嵌套的<code>pointcut</code>、<code>advisor</code>和<code>aspect</code>标签。<code>pointcut</code>标签允许使用简单的语法创建命名的<code>AspectJExpressionPointcut</code> bean: &lt;aop:pointcut id=”getNameCalls” expression=”execution(* *..ITestBean.getName(..))”/&gt;. 使用<code>advisor</code>标签，你可以配置<code>org.springframework.aop.Advisor</code>并将其自动应用于你的<code>org.springframework.beans.factory.BeanFactory</code>中的所有相关bean。<code>advisor</code>标签支持内联和引用<code>org.springframework.aop.Pointcut</code>: &lt;aop:advisor id=”getAgeAdvisor”</p>
<pre><code> pointcut=&quot;execution(* *..ITestBean.getAge(..))&quot;
 advice-ref=&quot;getAgeCounter&quot;/&gt;
</code></pre>
<p> &lt;aop:advisor id=”getNameAdvisor”</p>
<pre><code> pointcut-ref=&quot;getNameCalls&quot;
 advice-ref=&quot;getNameCounter&quot;/&gt;
</code></pre>
<p> 标签对应的解析器：config -&gt; ConfigBeanDefinitionParser, aspectj-autoproxy -&gt; AspectJAutoProxyBeanDefinitionParser, scoped-proxy -&gt; ScopedProxyBeanDefinitionDecorator</p>
</li>
<li><p>ContextNamespaceHandler: 解析 <code>context</code> 命名空间。 标签对应的解析器：property-placeholder -&gt; PropertyPlaceholderBeanDefinitionParser, property-override -&gt; PropertyOverrideBeanDefinitionParser, annotation-config -&gt; AnnotationConfigBeanDefinitionParser, component-scan -&gt; ComponentScanBeanDefinitionParser, load-time-weaver -&gt; LoadTimeWeaverBeanDefinitionParser, spring-configured -&gt; SpringConfiguredBeanDefinitionParser, mbean-export -&gt; MBeanExportBeanDefinitionParser, mbean-server -&gt; MBeanServerBeanDefinitionParser   </p>
</li>
<li><p>LangNamespaceHandler: 解析 <code>lang</code> 命名空间。NamespaceHandler 支持由动态语言(如Groovy、JRuby和BeanShell)支持的对象织入。下面是一个示例(来自参考文档)，它详细描述了Groovy支持的bean的织入:<br>&lt;lang:groovy id=”messenger”</p>
<pre><code> refresh-check-delay=&quot;5000&quot;
 script-source=&quot;classpath:Messenger.groovy&quot;&gt;
</code></pre>
<p> &lt;lang:property name=”message” value=”I Can Do The Frug”/&gt;<br><br>标签对应的解析器：groovy, bsh, std -&gt; ScriptBeanDefinitionParser, defaults -&gt; ScriptingDefaultsParser</p>
</li>
<li><p>UtilNamespaceHandler: 解析<code>util</code> 命名空间。标签对应的解析器：constant -&gt; ConstantBeanDefinitionParser, property-path -&gt; PropertyPathBeanDefinitionParser， list -&gt; ListBeanDefinitionParser , set -&gt; SetBeanDefinitionParser, map -&gt; MapBeanDefinitionParser , properties -&gt; PropertiesBeanDefinitionParser.</p>
</li>
<li><p>TaskNamespaceHandler: 解析<code>task</code> 命名空间. 标签对应的解析器：annotation-driven -&gt; AnnotationDrivenBeanDefinitionParser, executor -&gt; ExecutorBeanDefinitionParser , scheduled-tasks -&gt; ScheduledTasksBeanDefinitionParser, scheduler -&gt; SchedulerBeanDefinitionParser.</p>
</li>
<li><p>CacheNamespaceHandler: 允许使用XML或注释配置声明式缓存管理的NamespaceHandler。这个名称空间处理程序是Spring缓存管理工具中的核心功能。标签对应的解析器： annotation-driven -&gt; AnnotationDrivenCacheBeanDefinitionParser，advice -&gt; CacheAdviceParser. </p>
</li>
<li><p>MvcNamespaceHandler: 用于Spring MVC配置命名空间的NamespaceHandler . 标签对应的解析器：annotation-driven -&gt; AnnotationDrivenBeanDefinitionParser </p>
</li>
<li><p>JeeNamespaceHandler: 解析 <code>jee</code> 命名空间。标签对应的解析器：jndi-lookup -&gt; JndiLookupBeanDefinitionParser, local-slsb -&gt; LocalStatelessSessionBeanDefinitionParser, remote-slsb -&gt; RemoteStatelessSessionBeanDefinitionParser.</p>
</li>
</ul>
<h3 id="BeanDefinitionParser"><a href="#BeanDefinitionParser" class="headerlink" title="BeanDefinitionParser"></a>BeanDefinitionParser</h3><p><code>DefaultBeanDefinitionDocumentReader</code>用于处理自定义顶级标签的接口。实现类可以根据需要自由地将自定义标签中的元数据转换成任意多的bean定义。<br>解析器从关联的<code>NamespaceHandler</code>中为自定义标签所在的命名空间定位一个<code>BeanDefinitionParser</code>。通过<code>NamespaceHandlerSupport</code>的<code>registerBeanDefinitionParser</code>方法注册</p>
<h4 id="提供的方法"><a href="#提供的方法" class="headerlink" title="提供的方法"></a>提供的方法</h4><p>BeanDefinition parse(Element element, ParserContext parserContext)：解析指定的元素并将结果bean定义注册到所提供的ParserContext中嵌入的<code>BeanDefinitionRegistry</code>。<br>如果要以嵌套方式使用(例如作为<code>&lt;property/&gt;</code>标记中的内部标记)，实现类必须返回从解析中得到的主要bean定义。如果实现不以嵌套方式使用，则可能返回null。</p>
<h4 id="常用实现类-1"><a href="#常用实现类-1" class="headerlink" title="常用实现类"></a>常用实现类</h4><p>常用的就是上面所列的每个 <code>NamespaceHandler</code>中注册的解析器。</p>
<ul>
<li>ConfigBeanDefinitionParser：解析 <code>&lt;aop:config&gt;</code> 标签</li>
<li>AspectJAutoProxyBeanDefinitionParser: 解析 <code>&lt;aop:aspectj-autoproxy&gt;</code> 标签</li>
<li>ScopedProxyBeanDefinitionDecorator：解析 <code>&lt;aop:scoped-proxy&gt;</code> 标签</li>
<li>PropertyPlaceholderBeanDefinitionParser：解析 <code>&lt;context:property-placeholder&gt;</code> 标签</li>
<li>PropertyOverrideBeanDefinitionParser: 解析 <code>&lt;context:property-override&gt;</code> 标签</li>
<li>AnnotationConfigBeanDefinitionParser：解析 <code>&lt;context:annotation-config&gt;</code> 标签</li>
<li>ComponentScanBeanDefinitionParser: 解析 <code>&lt;context:component-scan&gt;</code> 标签</li>
<li>LoadTimeWeaverBeanDefinitionParser： 解析 <code>&lt;context:load-time-weaver&gt;</code> 标签</li>
<li>SpringConfiguredBeanDefinitionParser：解析 <code>&lt;context:spring-configured&gt;</code> 标签</li>
<li>MBeanExportBeanDefinitionParser：解析 <code>&lt;context:mbean-export&gt;</code> 标签</li>
<li>MBeanServerBeanDefinitionParser：解析 <code>&lt;context:mbean-server&gt;</code> 标签</li>
<li>ScriptBeanDefinitionParser：解析 <code>&lt;lang:groovy&gt;</code>,<code>&lt;lang:bsh&gt;</code>,<code>&lt;lang:std&gt;</code>。 实例化时需要传入一个脚本工厂类名。分别是 <code>org.springframework.scripting.groovy.GroovyScriptFactory</code>, <code>org.springframework.scripting.bsh.BshScriptFactory</code>, <code>org.springframework.scripting.support.StandardScriptFactory</code> </li>
<li>ScriptingDefaultsParser: 解析 <code>&lt;lang:defaults&gt;</code> 标签</li>
<li>ConstantBeanDefinitionParser：解析 <code>&lt;util:constant&gt;</code> 标签</li>
<li>PropertyPathBeanDefinitionParser：解析 <code>&lt;util:property-path&gt;</code> 标签</li>
<li>ListBeanDefinitionParser：解析 <code>&lt;util:list&gt;</code> 标签</li>
<li>SetBeanDefinitionParser：解析 <code>&lt;util:set&gt;</code> 标签</li>
<li>MapBeanDefinitionParser：解析 <code>&lt;util:map&gt;</code> 标签</li>
<li>PropertiesBeanDefinitionParser：解析 <code>&lt;util:properties&gt;</code> 标签</li>
<li>AnnotationDrivenBeanDefinitionParser：解析 <code>&lt;mvc:annotation-driven&gt;</code>，<code>&lt;task:annotation-driven&gt;</code> 标签</li>
<li>DefaultServletHandlerBeanDefinitionParser：解析 <code>&lt;mvc:default-servlet-handler&gt;</code> 标签</li>
<li>InterceptorsBeanDefinitionParser：解析 <code>&lt;mvc:interceptors&gt;</code> 标签</li>
<li>ResourcesBeanDefinitionParser：解析 <code>&lt;mvc:resources&gt;</code> 标签</li>
<li>ViewControllerBeanDefinitionParser：解析 <code>&lt;mvc:view-controller&gt;</code>,<code>&lt;mvc:redirect-view-controller&gt;</code>, <code>&lt;mvc:status-controller&gt;</code> 标签</li>
<li>ViewResolversBeanDefinitionParser：解析 <code>&lt;mvc:view-resolvers&gt; </code>标签</li>
<li>TilesConfigurerBeanDefinitionParser：解析 <code>&lt;mvc:tiles-configurer&gt;</code> 标签</li>
<li>FreeMarkerConfigurerBeanDefinitionParser：解析 <code>&lt;mvc:freemarker-configurer&gt;</code> 标签</li>
<li>GroovyMarkupConfigurerBeanDefinitionParser：解析 <code>&lt;mvc:groovy-configurer&gt;</code> 标签</li>
<li>ScriptTemplateConfigurerBeanDefinitionParser：解析 <code>&lt;mvc:script-template-configurer&gt;</code>标签</li>
<li>CorsBeanDefinitionParser：解析 <code>&lt;mvc:cors&gt;</code> 标签</li>
<li>ExecutorBeanDefinitionParser: 解析 <code>&lt;task:executor&gt;</code> 标签</li>
<li>ScheduledTasksBeanDefinitionParser: 解析 <code>&lt;task:scheduled-tasks&gt;</code> 标签</li>
<li>SchedulerBeanDefinitionParser: 解析 <code>&lt;task:scheduler&gt;</code> 标签</li>
<li>AnnotationDrivenCacheBeanDefinitionParser: 解析 <code>&lt;cache:annotation-driven&gt;</code> 标签</li>
<li>CacheAdviceParser: 解析 <code>&lt;cache:advice&gt;</code> 标签</li>
<li>JndiLookupBeanDefinitionParser: 解析 <code>&lt;jee:jndi-lookup&gt;</code> 标签</li>
<li>LocalStatelessSessionBeanDefinitionParser: 解析 <code>&lt;jee:local-slsb&gt;</code> 标签</li>
<li>RemoteStatelessSessionBeanDefinitionParser: 解析 <code>&lt;jee:remote-slsb&gt;</code> 标签</li>
</ul>
<h3 id="BeanDefinitionDecorator"><a href="#BeanDefinitionDecorator" class="headerlink" title="BeanDefinitionDecorator"></a>BeanDefinitionDecorator</h3><p><code>DefaultBeanDefinitionDocumentReader</code>使用的接口来处理自定义的嵌套标签(直接位于<code>&lt;bean&gt;</code>)标签下)。还可以装饰<code>&lt;bean&gt;</code>标签的自定义属性。实现类可以自由地将自定义标签中的元数据转换为所需的任意多个bean定义，并转换所包含的bean定义标签，甚至可能返回一个完全不同的<code>org.springframework.bean .factory.config.BeanDefinition</code>替换原来的。<br><code>BeanDefinitionDecorator</code> 应该意识到它们可能是解析链的一部分。特别是，应该知道，以前的BeanDefinitionDecorator可能已经用<code>ProxyFactoryBean</code>定义替换了原来的BeanDefinition，该定义允许添加自定义拦截器。希望向封闭bean添加拦截器的 <code>BeanDefinitionDecorator</code>应该扩展<code>AbstractInterceptorDrivenBeanDefinitionDecorator</code>，它处理解析链，确保只创建一个代理，并且它包含链中的所有拦截器。 解析器从<code>NamespaceHandler</code>中为自定义标签所在的命名空间定位一个<code>BeanDefinitionDecorator</code></p>
<h4 id="常用实现类-2"><a href="#常用实现类-2" class="headerlink" title="常用实现类"></a>常用实现类</h4><ul>
<li>ScopedProxyBeanDefinitionDecorator：负责解析<code>&lt;aop:scope-proxy/&gt;</code>标签</li>
<li>AbstractInterceptorDrivenBeanDefinitionDecorator：希望向生成的bean添加拦截器的<code>BeanDefinitionDecorator</code>的基本实现。这个基类控制<code>ProxyFactoryBean</code> bean 定义的创建，并将原始定义包装为<code>ProxyFactoryBean</code>目标属性的内部bean定义。正确处理链接，确保只创建一个<code>ProxyFactoryBean</code> 定义。如果前面的BeanDefinitionDecorator已经创建了<code>ProxyFactoryBean</code>，则只需将拦截器添加到现有定义中。子类只需要向它们希望添加的拦截器创建bean定义</li>
</ul>
<h2 id="BeanDefinitionRegistry-注册bean-定义"><a href="#BeanDefinitionRegistry-注册bean-定义" class="headerlink" title="BeanDefinitionRegistry 注册bean 定义"></a>BeanDefinitionRegistry 注册bean 定义</h2><p>BeanDefinitionReaderUtils.registerBeanDefinition()方法内部调用了org.springframework.beans.factory.support.BeanDefinitionRegistry.registerBeanDefinition 方法， 具体的实现就是beanFactory实现类（<code>org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition</code>）了。</p>
<p>DefaultListableBeanFactory.registerBeanDefinition():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//校验 BeanDefinition 的逻辑合法</span></span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果存在同名 bean 定义</span></span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="comment">//不允许bean 定义覆盖</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">                        existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//注册新的 bean 定义，如果正在创建 bean 实例</span></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="comment">//不能再修改启动时的集合，为了稳定的遍历</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">                    Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">                    updatedSingletons.remove(beanName);</span><br><span class="line">                    <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//还在注册阶段，直接放进去就完事了</span></span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 重置给定bean的所有bean定义缓存，包括派生自该bean的bean的缓存。</span></span><br><span class="line">        <span class="comment">//   在替换或删除现有bean定义之后调用，触发clearMergedBeanDefinition、destroySingleton和MergedBeanDefinitionPostProcessor。</span></span><br><span class="line">        <span class="comment">//   在给定bean和所有具有给定bean作为父bean的bean定义上重置beandefinition</span></span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://qzztf.com">水娃</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://qzztf.com/post/172b/">http://qzztf.com/post/172b/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://qzztf.com" target="_blank">水娃火娃石榴娃</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Bean/">Bean</a><a class="post-meta__tags" href="/tags/%E8%A7%A3%E6%9E%90/">解析</a></div><div class="post_share"><div class="social-share" data-image="/image/avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/e88/" title="错误: 未报告的异常错误X; 必须对其进行捕获或声明以便抛出"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">错误: 未报告的异常错误X; 必须对其进行捕获或声明以便抛出</div></div></a></div><div class="next-post pull-right"><a href="/post/75b6/" title="Spring自定义命名空间解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring自定义命名空间解析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/72a3/" title="Bean初始化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-21</div><div class="title">Bean初始化</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">水娃</div><div class="author-info__description">水娃的博客 | java</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qzztf"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Bean-%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">Bean 定义文件的解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E5%8E%82"><span class="toc-number">1.1.</span> <span class="toc-text">初始化工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceLoader-%E5%AE%9A%E4%BD%8D%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">ResourceLoader 定位资源文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Resource"><span class="toc-number">1.2.1.</span> <span class="toc-text">Resource</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Resource%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Resource的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Resource-%E7%9A%84%E5%AD%90%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">Resource 的子接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ContextResource"><span class="toc-number">1.2.1.2.1.</span> <span class="toc-text">ContextResource</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WritableResource"><span class="toc-number">1.2.1.2.2.</span> <span class="toc-text">WritableResource</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HttpResource"><span class="toc-number">1.2.1.2.3.</span> <span class="toc-text">HttpResource</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84Resource%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">常用的Resource实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ClassPathResource"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">ClassPathResource</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FileSystemResource"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">FileSystemResource</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourceLoader"><span class="toc-number">1.2.2.</span> <span class="toc-text">ResourceLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ResourcePatternResolver%E5%AD%90%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">ResourcePatternResolver子接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">常用实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DefaultResourceLoader"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">DefaultResourceLoader</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PathMatchingResourcePatternResolver"><span class="toc-number">1.2.2.2.2.</span> <span class="toc-text">PathMatchingResourcePatternResolver</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E6%B2%A1%E6%9C%89%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.2.2.2.2.1.</span> <span class="toc-text">在没有通配符的情况</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Ant-%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.2.2.2.2.2.</span> <span class="toc-text">Ant 风格的路径</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7%E5%BD%B1%E5%93%8D"><span class="toc-number">1.2.2.2.2.3.</span> <span class="toc-text">可移植性影响</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#classpath-%E5%89%8D%E7%BC%80"><span class="toc-number">1.2.2.2.2.4.</span> <span class="toc-text">classpath*:前缀</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%A6%E6%B3%A8"><span class="toc-number">1.2.2.2.2.5.</span> <span class="toc-text">另注</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.2.2.2.6.</span> <span class="toc-text">使用示例</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanDefinitionReader-%E5%8A%A0%E8%BD%BDbean%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90"><span class="toc-number">1.3.</span> <span class="toc-text">BeanDefinitionReader 加载bean定义资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanDefinitionReader-%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">BeanDefinitionReader 实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PropertiesBeanDefinitionReader"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">PropertiesBeanDefinitionReader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GroovyBeanDefinitionReader"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">GroovyBeanDefinitionReader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XmlBeanDefinitionReader"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">XmlBeanDefinitionReader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NamespaceHandler-%E8%A7%A3%E6%9E%90%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE"><span class="toc-number">1.3.2.</span> <span class="toc-text">NamespaceHandler 解析自定义标签</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-NamespaceHandler"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">常用的 NamespaceHandler</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanDefinitionParser"><span class="toc-number">1.3.3.</span> <span class="toc-text">BeanDefinitionParser</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">提供的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB-1"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">常用实现类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanDefinitionDecorator"><span class="toc-number">1.3.4.</span> <span class="toc-text">BeanDefinitionDecorator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB-2"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">常用实现类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanDefinitionRegistry-%E6%B3%A8%E5%86%8Cbean-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.</span> <span class="toc-text">BeanDefinitionRegistry 注册bean 定义</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/5441/" title="Spring Cloud Gateway整合Spring Doc">Spring Cloud Gateway整合Spring Doc</a><time datetime="2023-04-02T12:49:15.000Z" title="发表于 2023-04-02 20:49:15">2023-04-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/f507/" title="处理字典值反显问题.md">处理字典值反显问题.md</a><time datetime="2023-04-02T12:46:42.000Z" title="发表于 2023-04-02 20:46:42">2023-04-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/9fa5/" title="Spring AOP 调用同一个对象的方法">Spring AOP 调用同一个对象的方法</a><time datetime="2020-12-05T14:55:47.000Z" title="发表于 2020-12-05 22:55:47">2020-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/39fc/" title="Spring AOP基本用法3">Spring AOP基本用法3</a><time datetime="2020-09-23T02:26:55.000Z" title="发表于 2020-09-23 10:26:55">2020-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/f93d/" title="Spring AOP基本用法2">Spring AOP基本用法2</a><time datetime="2020-09-23T02:25:58.000Z" title="发表于 2020-09-23 10:25:58">2020-09-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 水娃</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '248e3cebde8537449dbb',
      clientSecret: 'a9c539e71782374d81eb91ad932288cd41809575',
      repo: 'blog-s-gitalk',
      owner: 'qinzaizhen',
      admin: ['qzztf'],
      id: 'd2a37e7abceeb761740cd0e5aed71820',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>