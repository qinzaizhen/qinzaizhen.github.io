<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Spring Boot 四-Spring Boot 特性 | 水娃火娃石榴娃</title><meta name="author" content="水娃"><meta name="copyright" content="水娃"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本节将深入介绍Spring Boot的细节。在这里，你可以了解你想要使用和定制的关键特性。如果还没有，你可能需要阅读第2部分，“开始”和第3部分，“使用Spring引导”部分，这样你就可以很好地了解基础知识。 SpringApplicationSpringApplication类提供了一种方便的方法"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://qzztf.com/post/29b6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/image/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/image/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/image/pwa/16.png"/><link rel="mask-icon" href="/image/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?86553a0f289bcfb307062507dc247eb2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring Boot 四-Spring Boot 特性',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-16 15:25:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="水娃火娃石榴娃"><span class="site-name">水娃火娃石榴娃</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring Boot 四-Spring Boot 特性</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2017-08-15T13:13:56.000Z" title="发表于 2017-08-15 21:13:56">2017-08-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-16T07:25:26.154Z" title="更新于 2024-06-16 15:25:26">2024-06-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">33.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>122分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring Boot 四-Spring Boot 特性"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本节将深入介绍Spring Boot的细节。在这里，你可以了解你想要使用和定制的关键特性。如果还没有，你可能需要阅读第2部分，“<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#getting-started">开始</a>”和第3部分，“<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#using-boot">使用Spring引导</a>”部分，这样你就可以很好地了解基础知识。</p>
<h2 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h2><p><code>SpringApplication</code>类提供了一种方便的方法来引导一个从<code>main()</code>方法启动的Spring应用程序。在许多情况下，你可以将其委托给静态<code>SpringApplication.run</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(MySpringConfiguration.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你的应用程序启动时，你应该会看到类似的东西:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> &#x2F;\\ &#x2F; ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#39;_ | &#39;_| | &#39;_ \&#x2F; _&#96; | \ \ \ \</span><br><span class="line"> \\&#x2F;  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#39;  |____| .__|_| |_|_| |_\__, | &#x2F; &#x2F; &#x2F; &#x2F;</span><br><span class="line"> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|_|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|___&#x2F;&#x3D;&#x2F;_&#x2F;_&#x2F;_&#x2F;</span><br><span class="line"> :: Spring Boot ::   v2.0.0.BUILD-SNAPSHOT</span><br><span class="line"></span><br><span class="line">2013-07-31 00:08:16.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (&#x2F;apps&#x2F;myapp.jar started by pwebb)</span><br><span class="line">2013-07-31 00:08:16.166  INFO 56603 --- [           main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy</span><br><span class="line">2014-03-04 13:09:54.912  INFO 41370 --- [           main] .t.TomcatServletWebServerFactory : Server initialized with port: 8080</span><br><span class="line">2014-03-04 13:09:56.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)</span><br></pre></td></tr></table></figure>

<p>默认<code>INFO</code>日志信息将显示出来，包括启动应用程序的用户等相关的启动细节。</p>
<h3 id="启动失败"><a href="#启动失败" class="headerlink" title="启动失败"></a>启动失败</h3><p>如果你的应用程序无法启动，注册的<code>FailureAnalyzers</code>就有机会提供一个专门的错误消息和一个具体的操作来解决这个问题。例如，如果你在端口8080上启动一个web应用程序，并且该端口已经在使用，你应该会看到类似的东西:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Embedded servlet container failed to start. Port 8080 was already in use.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Identify and stop the process that&#39;s listening on port 8080 or configure this application to listen on another port.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring Boot提供了无数的<code>FailureAnalyzer</code>实现，并且你可以<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-failure-analyzer">很容易地添加自己</a>的实现。</p>
</blockquote>
<p>如果没有失败分析程序能够处理这个异常，你仍然可以显示完整的自动配置报告，以更好地理解出错的地方。所以你需要启用<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-external-config"><code>debug</code>属性</a>或为<code>org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer</code>启用<code>DEBUG</code>日志记录。</p>
<p>例如，如果你正在使用<code>java-jar</code>运行你的应用程序，你可以启用以下的<code>debug</code>属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug</span><br></pre></td></tr></table></figure>

<h3 id="自定义Banner"><a href="#自定义Banner" class="headerlink" title="自定义Banner"></a>自定义Banner</h3><p>在启动时打印的banner可以通过添加一个<code>banner.txt</code>文件到类路径或者通过设置<code>banner.location</code>指向该文件的位置来改变。如果这个文件有不同寻常的编码，你可以设置<code>banner.charset</code>(默认为<code>UTF-8</code>)。除了文本文件之外，你还可以添加一个<code>banner.gif</code>,<code>banner.jpg</code>或<code>banner.png</code>图像文件到类路径，或者设置一个<code>banner.image.location</code>属性。图像将被转换成ASCII字符，并在任何文本banner上打印。</p>
<p>在你的banner.txt文件中你可以使用以下占位符:</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>$&#123;application.version&#125;</code></td>
<td>在<code>MANIFEST.MF</code>中声明的应用程序的版本号。例如，<code>Implementation-Version: 1.0</code>被打印为<code>1.0</code>。</td>
</tr>
<tr>
<td><code>$&#123;application.formatted-version&#125;</code></td>
<td>在<code>MANIFEST.MF</code>中声明的应用程序的格式化版本号(用括号括起来，用v作前缀)。例如<code>(v1.0)</code>。</td>
</tr>
<tr>
<td><code>$&#123;spring-boot.version&#125;</code></td>
<td>你正在使用的Spring Boot版本。例如<code>2.0.0.BUILD-SNAPSHOT</code>。</td>
</tr>
<tr>
<td><code>$&#123;spring-boot.formatted-version&#125;</code></td>
<td>你正在使用的Spring Boot版本格式化输出形式（用括号括起来，用v作前缀）。例如<code>(v2.0.0.BUILD-SNAPSHOT)</code>。</td>
</tr>
<tr>
<td><code>$&#123;Ansi.NAME&#125;</code> (or <code>$&#123;AnsiColor.NAME&#125;</code>, <code>$&#123;AnsiBackground.NAME&#125;</code>, <code>$&#123;AnsiStyle.NAME&#125;</code>)</td>
<td><code>NAME</code>是ANSI转义码的名字。有关详细信息,请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java"><code>AnsiPropertySource</code></a>。</td>
</tr>
<tr>
<td><code>$&#123;application.title&#125;</code></td>
<td>在<code>MANIFEST.MF</code>中声明的应用程序的标题。例如，<code>Implementation-Title: MyApp</code>被打印为<code>MyApp</code>。</td>
</tr>
</tbody></table>
<blockquote>
<p><code>SpringApplication.setBanner(…)</code>方法可以用来以编程方式生成一个banner 。使用<code>org.springframework.boot.Banner</code>接口，并实现您自己的<code>printBanner()</code>方法。</p>
</blockquote>
<p>你还可以使用<code>spring.main.banner-mode</code>属性，以确定是否必须在<code>System.out</code>（<code>console</code>）打印banner，使用已配置的日志记录器(<code>log</code>)或根本不打印(<code>off</code>)。</p>
<p>打印的banner将以<code>springBootBanner</code>的名字注册为一个单例bean。</p>
<blockquote>
<p>YAML映射<code>off</code>为<code>false</code>，因此如果你想禁用应用程序中的banner，请确保添加引号。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">   <span class="attr">main:</span></span><br><span class="line">      <span class="attr">banner-mode:</span> <span class="string">&quot;off&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="自定义SpringApplication"><a href="#自定义SpringApplication" class="headerlink" title="自定义SpringApplication"></a>自定义SpringApplication</h3><p>如果<code>SpringApplication</code>默认值不符合你的胃口，你可以创建一个本地实例并自定义它。例如，关闭banner:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication app = <span class="keyword">new</span> SpringApplication(MySpringConfiguration.class);</span><br><span class="line">    app.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">    app.run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>传递给<code>SpringApplication</code>的构造函数参数是spring bean 的配置源。在大多数情况下，这些都是对<code>@Configuration</code>类的引用，但是它们也可以是对XML配置的引用，或者是对应该被扫描的包的引用。</p>
</blockquote>
<p>还可以使用<code>application.properties</code>文件配置<code>SpringApplication</code>。请参阅<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-external-config">第24章，扩展配置</a>以获得详细信息。</p>
<p>关于配置选项的完整列表，请参阅<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/SpringApplication.html"><code>SpringApplication</code> Javadoc</a>。</p>
<h3 id="流式builder-API"><a href="#流式builder-API" class="headerlink" title="流式builder API"></a>流式builder API</h3><p>如果你需要构建一个<code>ApplicationContext</code>层次结构(具有父/子关系的多个上下文)，或者您更喜欢使用“流式的”构建器API，那么您可以使用<code>SpringApplicationBuilder</code>。</p>
<p><code>SpringApplicationBuilder</code>允许你将多个方法调用链接在一起，并包含允许你创建层次结构的<code>parent</code>和<code>child</code>方法。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder()</span><br><span class="line">        .sources(Parent.class)</span><br><span class="line">        .child(Application.class)</span><br><span class="line">        .bannerMode(Banner.Mode.OFF)</span><br><span class="line">        .run(args);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在创建<code>ApplicationContext</code>层次结构时，会有一些限制，例如，Web组件必须包含在子上下文中，并且父子上下文将使用相同的环境变量<code>Environment</code>。请参阅<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/builder/SpringApplicationBuilder.html"><code>SpringApplicationBuilder</code> Javadoc</a>来获得完整的详细信息。</p>
</blockquote>
<h3 id="事件和监听器"><a href="#事件和监听器" class="headerlink" title="事件和监听器"></a>事件和监听器</h3><p>除了通常的Spring Framework 事件，如 <a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/event/ContextRefreshedEvent.html"><code>ContextRefreshedEvent</code></a>，一个<code>SpringApplication</code>会发送一些额外的应用事件。</p>
<blockquote>
<p>有些事件实际上是在创建<code>ApplicationContext</code>之前触发的，因此你不能将这些监听器注册为一个<code>@Bean</code>。你可以通过<code>SpringApplication.addListeners(…)</code>或<code>SpringApplicationBuilder.listeners(…)</code>方法来注册。如果你希望这些侦听器能自动注册，不管应用程序是如何创建的，可以添加一个<code>META-INF/spring.factories</code>文件到项目中并使用<code>org.springframework.context.ApplicationListener</code> key来引用它们。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationListener&#x3D;com.example.project.MyListener</span><br></pre></td></tr></table></figure>

<p>应用事件按照以下顺序发送:</p>
<ol>
<li>一个<code>ApplicationStartingEvent</code>是在开始运行时发送的，但是在任何处理之前，除了监听器和初始化器的注册。</li>
<li>在上下文中使用的<code>Environment</code>已知但在创建上下文之前，将发送<code>ApplicationEnvironmentPreparedEvent</code>。</li>
<li>一个<code>ApplicationPreparedEvent</code>是在刷新启动之前发送的，但是在bean定义被加载之后。</li>
<li>一个<code>ApplicationReadyEvent</code>是在刷新之后发送的，并且已经处理了任何相关的回调，以表明应用程序已经准备好处理请求。</li>
<li>如果在启动时出现异常，就会发送<code>ApplicationFailedEvent</code>。</li>
</ol>
<blockquote>
<p>通常不需要使用应用程序事件，但是知道它们的存在可以做到得心应手。在内部，Spring Boot使用事件来处理各种任务。</p>
</blockquote>
<h3 id="Web-环境"><a href="#Web-环境" class="headerlink" title="Web 环境"></a>Web 环境</h3><p><code>SpringApplication</code>将尝试为你创建合适的<code>ApplicationContext</code>。默认情况下,将使用一个<code>AnnotationConfigApplicationContext</code>或<code>AnnotationConfigServletWebServerApplicationContext </code>,这取决于你是否正在开发一个web应用程序。</p>
<p>用于确定“web environment”的算法相当简单(基于是否存在几个类)。如果需要覆盖缺省值，可以使用<code>setWebEnvironment(boolean webEnvironment)</code>。</p>
<p>也可以完全控制将通过调用<code>setApplicationContextClass（...）</code>使用的<code>ApplicationContext</code>类型。</p>
<blockquote>
<p>在JUnit测试中使用<code>SpringApplication</code>时，通常需要调用<code>setWebEnvironment(false)</code>。</p>
</blockquote>
<h3 id="访问应用参数"><a href="#访问应用参数" class="headerlink" title="访问应用参数"></a>访问应用参数</h3><p>如果需要访问传递给<code>SpringApplication.run（...）</code>的应用程序参数，则可以注入<code>org.springframework.boot.ApplicationArguments</code> bean。 <code>ApplicationArguments</code>接口提供对原始<code>String []</code>参数以及解析过的<code>option</code>和<code>non-option</code>参数的访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.*</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.*</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> debug = args.containsOption(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">        List&lt;String&gt; files = args.getNonOptionArgs();</span><br><span class="line">        <span class="comment">// if run with &quot;--debug logfile.txt&quot; debug=true, files=[&quot;logfile.txt&quot;]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring Boot还将向Spring <code>Environment</code>注册一个<code>CommandLinePropertySource</code>。 这允许你也可以使用<code>@Value</code>注解注入单个应用参数。</p>
</blockquote>
<h3 id="使用ApplicationRunner，CommandLineRunner"><a href="#使用ApplicationRunner，CommandLineRunner" class="headerlink" title="使用ApplicationRunner，CommandLineRunner"></a>使用ApplicationRunner，CommandLineRunner</h3><p>当你需要在<code>SpringApplication</code>启动时运行一些特定的代码，你可以实现<code>ApplicationRunner</code>或<code>CommandLineRunner</code>接口。 这两个接口都以相同的方式工作，并提供一个单独的<code>run</code>方法，并在<code>SpringApplication.run（...）</code>完成之前调用。</p>
<p><code>CommandLineRunner</code>接口提供对应用程序参数的访问，并将参数作为一个简单的字符串数组，而<code>ApplicationRunner</code>使用上述的<code>ApplicationArguments</code>接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.*</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.*</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do something...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果几个<code>CommandLineRunner</code>或<code>ApplicationRunner</code> bean 必须在一个特定的顺序被调用,你可以额外实现<code>org.springframework.core.Ordered</code>接口，也可以使用<code>org.springframework.core.annotation.Order</code>注解。</p>
<h3 id="应用退出"><a href="#应用退出" class="headerlink" title="应用退出"></a>应用退出</h3><p>每个<code>SpringApplication</code>将在JVM上注册一个关闭钩子，以确保<code>ApplicationContext</code>在退出时优雅地关闭。所有标准的Spring生命周期回调(例如<code>DisposableBean </code>，或者<code>@PreDestroy</code>)都可以使用。</p>
<p>此外,如果希望在<code>SpringApplication.exit()</code>被调用时返回特定的退出代码,bean 可以实现<code>org.springframework.boot.ExitCodeGenerator</code>接口。这个退出代码可以传递给<code>System.exit()</code>以作为状态代码返回它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExitCodeApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ExitCodeGenerator <span class="title">exitCodeGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> () -&gt; <span class="number">42</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.exit(SpringApplication</span><br><span class="line">				.exit(SpringApplication.run(ExitCodeApplication.class, args)));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，异常类可以实现<code>ExitCodeGenerator</code>接口。 遇到这样的异常时，Spring Boot将返回由它实现的<code>getExitCode（）</code>方法提供的退出码。</p>
<h3 id="管理员功能"><a href="#管理员功能" class="headerlink" title="管理员功能"></a>管理员功能</h3><p>可以通过指定<code>spring.application.admin.enabled</code>属性来为应用程序启用与管理相关的功能。 这会在<code>MBeanServer</code>平台上暴露<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot/src/main/java/org/springframework/boot/admin/SpringApplicationAdminMXBean.java"><code>SpringApplicationAdminMXBean</code></a>。 你可以使用此功能远程管理你的Spring Boot应用程序。 这对于任何服务包装器实现也是有用的。</p>
<blockquote>
<p>如果你想知道应用程序在哪个HTTP端口上运行，请使用<code>local.server.port</code> key来获取该属性。</p>
</blockquote>
<blockquote>
<p>启用此功能时请小心，因为MBean公开了关闭应用程序的方法。</p>
</blockquote>
<h2 id="扩展配置"><a href="#扩展配置" class="headerlink" title="扩展配置"></a>扩展配置</h2><p>Spring Boot 允许扩展配置，因此我们的应用可以在不同的环境中运行。可以使用properties文件，YAML文件，环境变量和命令行参数来扩展配置。属性值可以通过<code>@Value</code>注解直接注入到bean中，通过Spring环境变量<code>Environment</code>来访问或者通过<code>@ConfigurationProperties</code>注解绑定到结构化对象中。</p>
<p>Spring Boot用特定的<code>PropertySource</code>顺序来对属性值进行覆盖。顺序如下：</p>
<ol>
<li>当开发者工具启用时，开发者工具全局设置（<code>$&#123;home&#125;/.spring-boot-devtools.properties</code>,windows用户在<code>C:\Users\qinzaizhen\</code>目录中，<code>qinzaizhen</code>为用户名）</li>
<li>测试用例中<code>@TestPropertySource</code>注解添加进来的属性</li>
<li><code>@SpringBootTest#properties</code>添加的属性</li>
<li>命令行参数</li>
<li><code>SPRING_APPLICATION_JSON</code>添加的参数（环境变量或系统属性中嵌入的json）</li>
<li><code>ServletConfig</code>初始化参数</li>
<li><code>ServletContext</code>初始化参数</li>
<li><code>java:comp/env</code> JNDI属性</li>
<li>Java系统属性<code>System.getProperties()</code></li>
<li>操作系统环境变量</li>
<li><code>random.*</code>形式的<code>RandomValuePropertySource</code></li>
<li>jar包外的<code>application-&#123;profile&#125;.properties</code>和YAML文件</li>
<li>jar包中的<code>application-&#123;profile&#125;.properties</code>和YAML文件</li>
<li>jar包外的<code>application.properties</code>和YAML文件</li>
<li>jar包中的<code>application.properties</code>和YAML文件</li>
<li><code>@Configuration</code>类上<code>@PropertySource</code>注解指定的文件</li>
<li>通过<code>SpringApplication.setDefaultProperties</code>指定的默认属性</li>
</ol>
<p>例如下面的一个类，需要注入<code>name</code>的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.*</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在程序的classpath中可以用<code>application.properties</code>文件提供<code>name</code>的默认值。当在新环境中运行时，jar包外的<code>application.properties</code>可以覆盖<code>name</code>的值;在一次性的测试中，可以通过在控制台中指定个一个<code>name</code>的值（如：<code>java -jar app.jar --name=&quot;Spring&quot;</code>）。</p>
<p><code>SPRING_APPLICATION_JSON</code>可以在控制台输入之后变成一个环境变量，比如在Unix shell中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> SPRING_APPLICATION_JSON=<span class="string">&#x27;&#123;&quot;foo&quot;:&#123;&quot;bar&quot;:&quot;spam&quot;&#125;&#125;&#x27;</span> java -jar myapp.jar</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，Spring的<code>Environment</code>中将会是<code>foo.bar=spam</code>。也可以通过设置一个系统属性<code>$ java -Dspring.application.json=&#39;&#123;&quot;foo&quot;:&quot;bar&quot;&#125;&#39; -jar myapp.jar</code>，或者是控制台参数</p>
<blockquote>
<p>$ java -jar myapp.jar –spring.application.json=’{“foo”:”bar”}’ 未成功，找不到这个属性，而且会导致上面的<code>SPRING_APPLICATION_JSON</code>环境变量失效</p>
</blockquote>
<p>或者通过JNDI变量：<code>java:comp/env/spring.application.json</code>。</p>
<p>比如环境变量的方式：</p>
<p>先设置环境变量，然后再运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\springboot-demo\demo4\target&gt;set SPRING_APPLICATION_JSON=&#123;&quot;developer.name&quot;:&quot;a</span><br><span class="line">aaaaaaaaaa&quot;&#125;</span><br><span class="line"></span><br><span class="line">E:\springboot-demo\demo4\target&gt;java -jar springboot.demo4-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>控制台打印出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2017-08-08 21:46:24.783 DEBUG 44644 --- [           main] l.q.springboot.demo.domain.AppListener   : 属性值(此处中文有乱码)： aaaaaaaaaaa</span><br></pre></td></tr></table></figure>
<h3 id="配置随机值"><a href="#配置随机值" class="headerlink" title="配置随机值"></a>配置随机值</h3><p><code>RandomValuePropertySource</code>用来注入随机值非常方便（比如注入到秘钥或测试用例中）。可以产生int,long,uuid和字符串。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my.secret&#x3D;$&#123;random.value&#125;</span><br><span class="line">my.number&#x3D;$&#123;random.int&#125;</span><br><span class="line">my.bignumber&#x3D;$&#123;random.long&#125;</span><br><span class="line">my.uuid&#x3D;$&#123;random.uuid&#125;</span><br><span class="line">my.number.less.than.ten&#x3D;$&#123;random.int(10)&#125;</span><br><span class="line">my.number.in.range&#x3D;$&#123;random.int[1024,65536]&#125;</span><br></pre></td></tr></table></figure>
<p><code>random.int*</code>格式是<code>OPEN value (,max) CLOSE</code>，这里的<code>OPEN,CLOSE</code>可以是任何的字符，<code>value,max</code>是整数。如果<code>max</code>有值，那么<code>value</code>就是最小值，而<code>max</code>就是最大值（不包括<code>max</code>）。**<code>OPEN</code>,<code>CLOSE</code>可以是任何字符，但是如果是上面一样作为属性值，不可使用<code>&#123;</code>,<code>&#125;</code>。可以是<code>my.number.in.range=$&#123;random.int[1024,65536)&#125;</code>，意义是一样的。如果是<code>my.number.in.range=$&#123;random.int[1024,65536&#125;&#125;</code>，那么传到<code>RandomValuePropertySource</code>中的表达式为<code>random.int[1024,65536</code>，这样在算范围的时候就成了<code>1024,6553</code>**。</p>
<h3 id="访问控制台参数"><a href="#访问控制台参数" class="headerlink" title="访问控制台参数"></a>访问控制台参数</h3><p><code>SpringApplication</code>默认会将控制台选项参数（以<code>--</code>开头，如：<code>--server.port=9000</code>）转换为一个属性并且将它添加到Spring的环境变量中去。上面提到过控制台参数的优先级比其他的属性源高。<br>如果不想添加控制台属性添加到Spring环境变量中，可以通过<code>SpringApplication.setAddCommandLineProperties(false)</code>来禁用这个功能。</p>
<h3 id="应用属性文件"><a href="#应用属性文件" class="headerlink" title="应用属性文件"></a>应用属性文件</h3><p><code>SpringApplication</code>会按照以下顺序加载<code>application.properties</code>文件，并且将它他们添加到Spring环境变量中。</p>
<ol>
<li>当前目录的<code>/config</code>子目录</li>
<li>当前目录</li>
<li>classpath下<code>/config</code>包</li>
<li>classpath根目录</li>
</ol>
<p>如果不想用<code>application.properties</code>作为配置文件名，可以通过配置<code>spring.config.name</code>环境变量来更改。还可以明确通过<code>spring.config.location</code>环境变量指定配置文件的位置（多个目录或者文件路径用<code>,</code>隔开）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar myproject.jar --spring.config.name&#x3D;myproject</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar myproject.jar --spring.config.location&#x3D;classpath:&#x2F;default.properties,classpath:&#x2F;override.properties</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>spring.config.name</code>和<code>spring.config.location</code>在很早的时候用来决定哪些文件需要加载，因此它们必须得在环境变量中声明（常见的是操作系统的环境变量，系统属性或者控制台参数）。</p>
</blockquote>
<p>如果<code>spring.config.location</code>包含目录（相对文件来说），需要以<code>/</code>结尾（并且在开始加载之前，会拼接<code>spring.config.name</code>指定的名称，包括特定profile的文件名）。<code>spring.config.location</code>中指定的文件还是跟原来一样，不支持特定profile变体，并且会被任何的特定profile属性覆盖。</p>
<p>配置文件是按照反方向的顺序查找的。配置文件的位置默认是<code>classpath:/,classpath:/config/,file:./,file:./config/</code>。查找的顺序是反的：</p>
<ol>
<li><code>file:./config/</code>：jar包所在目录创建<code>config</code>目录和<code>application.properties</code></li>
<li><code>file:./</code>：jar目录中创建<code>application.properties</code></li>
<li><code>classpath:/config/</code>：resources目录中创建<code>config</code>目录和<code>application.properties</code></li>
<li><code>classpath:/</code>：resources根目录创建<code>application.properties</code></li>
</ol>
<blockquote>
<p>测试<code>file:./config/，file:./</code>这两个时，先打包成jar包，然后再在jar包同目录下创建<code>config</code>目录，里面新建<code>application.properties</code>文件，同理在jar包同目录下新建<code>application.properties</code>文件，两种情况分别测试。跟<code>@SpringBootApplication</code>注解的类放在同目录是无法测试这类情况的。<br>如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myapp.jar</span><br><span class="line">&#x2F;config&#x2F;application.properties</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017-08-12 10:37:45.677  INFO 17459 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@18ef96: startup date [Sat Aug 12 10:37:45 CST 2017]; root of context hierarchy</span><br><span class="line">属性值：current directory &#x2F;config</span><br></pre></td></tr></table></figure>

<p>当使用自定义位置时，会添加到默认位置中。自定义位置会在默认位置之前查找。例如，如果自定义位置是<code>classpath:/custom-config/,file:./custom-config/</code>，那么查找的顺序是：</p>
<ol>
<li><code>file:./custom-config/</code>: 在jar包目录创建对应的目录和文件（成功）</li>
<li><code>classpath:/custom-config/</code> ：在resources目录创建对应的目录和文件（未成功）</li>
<li><code>file:./config/</code></li>
<li><code>file:./</code></li>
<li><code>classpath:/config/</code></li>
<li><code>classpath:/</code></li>
</ol>
<p>这种查找顺序允许你在某个文件中指定一些默认值，然后有在其他文件中有选择性地覆盖这些值。你可以在其中一个默认位置的<code>application.properties</code>（或者其他通过<code>spring.config.name</code>指定的名称）文件中指定默认值。这些默认值可以在运行的时候被其他任一自定义位置的不同文件覆盖。</p>
<blockquote>
<p>如果使用环境变量而不是系统属性，大多数操作系统禁止点分隔的名称，但是可以使用下划线来代替（如：<code>STRING_CONFIG_NAME</code>代替<code>spring.config.name</code> (windows下测试有效)）。</p>
</blockquote>
<p><strong>设置环境变量<code>STRING_CONFIG_LOCATION</code>和<code>spring.config.location</code>无效。</strong></p>
<p>如果在容器中运行，JDNI属性(在<code>java:comp/env</code>中的)或者servlet上下文初始化参数可以代替环境变量或系统属性。</p>
<h3 id="Profile-specific属性"><a href="#Profile-specific属性" class="headerlink" title="Profile-specific属性"></a>Profile-specific属性</h3><p>除<code>application.properties</code>文件之外，还可以定义<code>application-&#123;profile&#125;.properties</code>格式的特定profile的属性。当没有指定profile时，<code>Environment</code>会使用一些默认的profiles（默认为<code>[default]</code>）,比如没有明确指定profile时，将会加载<code>application-default.properties</code>。</p>
<p>特定profile的属性和标准的<code>application.properties</code>一样从相同的位置加载进来，同时特定profile会覆盖非特定profile的文件，不管这个特定profile的文件是不是在jar包中。</p>
<p>如果指定了多个profile，最后一个将会生效。例如：通过<code>spring.profiles.active</code>属性来指定的profile在那些通过<code>SpringApplication</code>API 配置的profile后面被添加进来，因此会获取优先权。</p>
<blockquote>
<p>如果在<code>spring.config.location</code>设置的任何文件中的特定profile文件将不会生效。如果<code>spring.profiles.active</code>指定的profile名称和<code>spring.config.location</code>中的profile名称一样，是会生效的，不一样的话则不会生效。<br>比如：<code>spring.profiles.active=dev</code>，则<code>java -jar myapp.jar --spring.config.location=application-dev.properties</code>会生效，但是<code>java -jar myapp.jar --spring.config.location=application-pro.properties</code>则不会生效。<br>如果想让它生效，可以在<code>spring.config.location</code>中使用目录（实验结果如上）。</p>
</blockquote>
<h3 id="属性文件中的Placeholders"><a href="#属性文件中的Placeholders" class="headerlink" title="属性文件中的Placeholders"></a>属性文件中的Placeholders</h3><p><code>application.properties</code>文件中的值可以用<code>Environment</code>中存在的值过滤，因此可以引用之前定义过的值（比如：系统属性）。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="meta">app.description</span>=<span class="string">$&#123;app.name&#125; is a Spring Boot application</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以使用这个特性来对一些存在的Spring Boot属性定义短变量。<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-use-short-command-line-arguments">具体查看</a>。</p>
</blockquote>
<h3 id="YAML-代替属性文件"><a href="#YAML-代替属性文件" class="headerlink" title="YAML 代替属性文件"></a>YAML 代替属性文件</h3><p>YAML是JSON的一个超集，也是一个非常方便设置分层配置数据的格式。当在classpath中发现了<a target="_blank" rel="noopener" href="http://www.snakeyaml.org/">Snake YAML</a>包时，<code>SpringApplication</code>类会自动支持YAML作为属性的一种可选方案。</p>
<blockquote>
<p>如果使用spring-boot-starter，Snake YAML会自动加载进来。</p>
</blockquote>
<h4 id="加载YAML"><a href="#加载YAML" class="headerlink" title="加载YAML"></a>加载YAML</h4><p>Spring Framework 提供了两个方便的类用来加载YAML文档。<code>YamlPropertiesFactoryBean</code>将会把YAML加载为<code>properties</code>，<code>YamlMapFactoryBean</code>将会加载为<code>Map</code>。</p>
<p>例如下面的YAML文档：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environments:</span></span><br><span class="line">    <span class="attr">dev:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://dev.bar.com</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Developer</span> <span class="string">Setup</span></span><br><span class="line">    <span class="attr">prod:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://foo.bar.com</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">My</span> <span class="string">Cool</span> <span class="string">App</span></span><br></pre></td></tr></table></figure>
<p>将会被转换成下面的属性：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">environments.dev.url</span>=<span class="string">http://dev.bar.com</span></span><br><span class="line"><span class="meta">environments.dev.name</span>=<span class="string">Developer Setup</span></span><br><span class="line"><span class="meta">environments.prod.url</span>=<span class="string">http://foo.bar.com</span></span><br><span class="line"><span class="meta">environments.prod.name</span>=<span class="string">My Cool App</span></span><br></pre></td></tr></table></figure>
<p>YAML中的list会表示成带<code>[index]</code>的key，比如这个YAML：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line">   <span class="attr">servers:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">dev.bar.com</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">foo.bar.com</span></span><br></pre></td></tr></table></figure>
<p>将会被转换成：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">my.servers[0]</span>=<span class="string">dev.bar.com</span></span><br><span class="line"><span class="meta">my.servers[1]</span>=<span class="string">foo.bar.com</span></span><br></pre></td></tr></table></figure>
<p>使用Spring<code>DataBinder</code>工具（<code>@ConfigurationProperties</code>正好做这个事情）来绑定这样的属性需要在目标对象中定义<code>java.util.List</code>(或<code>Set</code>)属性并且需要提供一个setter方法或者通过一个可变的值实例化它，如下面的例子可以绑定上面的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; servers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.servers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当通过上面的方式配置list覆盖时要格外注意，它不会像预想的那样工作，。在上面的例子中，当<code>my.servers</code>在多个地方重复定义了，每个元素都是被覆盖的对象，而不是该list。为了确保有最高优先级的<code>@PropertySource</code>可以覆盖list，需要将它定义为一个单独的属性。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line">   <span class="attr">servers:</span> <span class="string">dev.bar.com,foo.bar.com</span></span><br></pre></td></tr></table></figure>
<p>(未明白是什么场景)</p>
<h4 id="将YMAL作为属性暴露到Spring-环境中"><a href="#将YMAL作为属性暴露到Spring-环境中" class="headerlink" title="将YMAL作为属性暴露到Spring 环境中"></a>将YMAL作为属性暴露到Spring 环境中</h4><p><code>YamlPropertySourceLoader</code>类可以用来暴露YAML，将它作为Spring <code>Environment</code>的一个<code>PropertySource</code>。你可以使用熟悉的<code>@Value</code>注解来访问YAML属性。</p>
<h4 id="多个profile-的YAML文件"><a href="#多个profile-的YAML文件" class="headerlink" title="多个profile 的YAML文件"></a>多个profile 的YAML文件</h4><p>可以通过<code>spring.profiles</code> key 在一个YAML文档中指定多个特定profile。比如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">profiles:</span> <span class="string">development</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">profiles:</span> <span class="string">production</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.120</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，当profile <code>development</code>激活时<code>server.address</code>属性将是<code>127.0.0.1</code>。如果<code>development</code>和<code>production</code> profile未激活时，那么<code>server.address</code>的值将是<code>192.168.1.100</code>。</p>
<p>在应用上下文启动时，如果没有明显地指定profile时，那么默认的profile将会激活。所以在下面的YAML中我们为<code>security.user.password</code>设置了一个值，<strong>仅在</strong> “default” profile中可用。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">weak</span></span><br></pre></td></tr></table></figure>
<p>然而在下面这个例子中，password一直都有值，因为它不属于任何profile，并且在需要的时候必须得在其他的profile中显示地进行重设。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">weak</span></span><br></pre></td></tr></table></figure>
<p>Spring profile设计的<code>spring.profiles</code>元素可以使用<code>!</code>字符来否定。如果在一个文档中否定和非否定的profile被指定，至少必须匹配一个非否定的pfofile，否定的profile可以不匹配。</p>
<h4 id="YAML-缺陷"><a href="#YAML-缺陷" class="headerlink" title="YAML 缺陷"></a>YAML 缺陷</h4><p>YAML文件无法通过<code>@PropertySource</code>注解加载。如果想通过这种方式加载，需要使用properties文件。</p>
<h4 id="合并YAML列表"><a href="#合并YAML列表" class="headerlink" title="合并YAML列表"></a>合并YAML列表</h4><p>在上面已经知道，YAML中的内容将会完全转换成properties。在profile中覆盖list时这个处理有可能与直觉背道而驰。例如，假设<code>MyPojo</code>对象有<code>name</code>和<code>description</code>两个属性，并且默认为<code>null</code>。从<code>FooProperties</code>对象中暴露出<code>MyPojo</code>的一个list。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;foo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MyPojo&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;MyPojo&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有以下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">foo:</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">my</span> <span class="string">description</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">foo:</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my</span> <span class="string">another</span> <span class="string">name</span></span><br></pre></td></tr></table></figure>
<p>如果<code>dev</code> profile没有激活，那么<code>FooProperties.list</code>将会包含一个<code>MyPojo</code>。然而当<code>dev</code> profile 激活时，这个<code>list</code>仍然只有一个实体（name 为“my another name” ，description 为 <code>null</code>）。这样配置不会为这个list增加第二个<code>MyPojo</code>，而且不会合并元素。</p>
<p>当在多个pfofile中声明一个集合时，将会使用最高优先级的那个（并且只有这一个）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">foo:</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">my</span> <span class="string">description</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">another</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">another</span> <span class="string">description</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">foo:</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my</span> <span class="string">another</span> <span class="string">name</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，考虑到profile <code>dev</code>激活时，<code>FooProperties.list</code>将会包含<em>一</em>个<code>MyPojo</code>实体（name 为“my another name” 并且 description 为<code>null</code>）。</p>
<h3 id="类型安全的配置属性"><a href="#类型安全的配置属性" class="headerlink" title="类型安全的配置属性"></a>类型安全的配置属性</h3><p>在使用<code>@value(&quot;$&#123;property&#125;&quot;)</code>注解注入配置属性时，有可能会很麻烦，尤其是如果使用多个属性或者数据具有层次性时。Spring Boot 提供了一个可选的方法来处理属性，它允许强类型控制并且校验这些配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;foo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Security security = <span class="keyword">new</span> Security();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetAddress <span class="title">getRemoteAddress</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRemoteAddress</span><span class="params">(InetAddress remoteAddress)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Security <span class="title">getSecurity</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; roles = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.singleton(<span class="string">&quot;USER&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getRoles</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoles</span><span class="params">(List&lt;String&gt; roles)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的POJO定义了下面的这些属性：</p>
<ul>
<li><code>foo.enabled</code>，默认为<code>false</code></li>
<li><code>foo.remote-address</code>，能够从<code>String</code>强转过来。</li>
<li><code>foo.security.username</code>，一个内部属性，名称由属性的名称决定。特别是返回类型完全不被使用而且可能是<code>SecurityProperties</code></li>
<li><code>foo.security.password</code></li>
<li><code>foo.security.roles</code>，<code>String</code>集合</li>
</ul>
<blockquote>
<p>get和set方法通常是必须要有的，因为绑定是通过标准的Java Bean 内省包，就像在Spring MVC里一样。有一些情况下set方法可以省略：</p>
<ul>
<li>Maps，只要他们初始化了，需要一个get方法不需要set方法，因为他们可以被binder修改。</li>
<li>Collections和arrays可以通过下标（尤其是和YAML一起时）或者使用单行逗号分隔的值（属性）。在后一种情况下，set方法必须要有。强烈建议一直添加set方法。如果实例化了一个集合，确保可以修改（如上例）</li>
<li>如果内部POJO属性初始化了（如上面例子中的<code>Security</code>属性），不需要set方法。如果想要binder通过它的默认构造函数来实例化，需要提供set方法。<br>有人使用Lombok项目来自动生成get和set方法。确保Lombok没有为这些类型生成任何常规的构造方法，因为容器在实例化这种对象时会自动调用构造方法。</li>
</ul>
</blockquote>
<blockquote>
<p>查看<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-external-config-vs-value"><code>@Value</code>和<code>@ConfigurationProperties</code>之间的区别</a></p>
</blockquote>
<p>还需要在<code>@EnableConfigurationProperties</code>注解中进行注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(FooProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>@ConfigurationProperties</code> bean 通过这种方式注册之后，这个bean会有一个方便的名称：<code>&lt;prefix&gt;-&lt;fqn&gt;</code>，这里的<code>&lt;prefix&gt;</code>是<code>@ConfigurationProperties</code>中定义的环境的key 前缀，<code>&lt;fqn&gt;</code>是这个bean的全名称。如果注解没有提供任何的前缀，将会使用这个bean的全名称。上面例子中的bean名称为<code>foo-com.exapmle.FooProperties</code>。</p>
</blockquote>
<p>尽管上面的配置将会为<code>FooProperties</code>创建一个常规的bean，但是建议<code>@ConfigurationProperties</code>只处理跟环境相关的，特别是不从上下文中注册其他的bean。之前说过，<code>@EnableConfigurationProperties</code>注解也会自动地应用到项目中，因此任何现存的<code>@ConfigurationProperties</code>注解过的bean将会配置到环境中。可以简配上面的<code>MyConfiguration</code>通过确保<code>FooProperties</code>已经是一个bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;foo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... see above</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种配置方式特别适合<code>@SpringApplication</code>外面YAML配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">foo:</span></span><br><span class="line">    <span class="attr">remote-address:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">security:</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">foo</span></span><br><span class="line">        <span class="attr">roles:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">USER</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ADMIN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># additional configuration as required</span></span><br></pre></td></tr></table></figure>
<p>要使用<code>@ConfigurationProperties</code>注解的bean，可以直接像其他bean一样将它们注入进来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FooProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(FooProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server(<span class="keyword">this</span>.properties.getRemoteAddress());</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>@ConfigurationProperties</code>还可以生成描述数据文件，这些文件可以被IDE用来自动提示。<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#configuration-metadata">详情查看</a></p>
</blockquote>
<h4 id="第三方配置"><a href="#第三方配置" class="headerlink" title="第三方配置"></a>第三方配置</h4><p>除了使用@configurationproperties来注解一个类，还可以在public的@bean方法上使用它。当你想绑定属性到那些不受控制的第三方组件时这将会非常有用。<br>要在bean中使用<code>Environment</code>的属性，需要在bean注册的地方添加<code>@ConfigurationProperties</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;bar&quot;)</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BarComponent <span class="title">barComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何以<code>bar</code>开头的属性都将会绑定到这个<code>BarComponent</code> bean 上，就像上面的<code>FooProperties</code>一样。</p>
<h4 id="松散绑定"><a href="#松散绑定" class="headerlink" title="松散绑定"></a>松散绑定</h4><p>Spring Boot使用一些松散的规则来绑定<code>Environment</code>属性到<code>@ConfigurationProperties</code> bean上，因此<code>Environment</code>属性名称和bean的属性名称没有必要完全匹配。这些有用的例子包括虚线（如：<code>context-path</code>绑定到<code>contextPath</code>）和大写（如：<code>PORT</code>绑定到<code>port</code>）环境属性。</p>
<p>例如下面给出的<code>@ConfigurationProperties</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OwnerProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面所有的属性都可以使用：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>person.firstName</code></td>
<td>标准的驼峰形式</td>
</tr>
<tr>
<td><code>person.first-name</code></td>
<td>短横线隔开，在<code>.properties</code>和<code>.yml</code>文件中推荐使用这种形式</td>
</tr>
<tr>
<td><code>person.first_name</code></td>
<td>下划线符号，<code>.properties</code>和<code>.yml</code>文件中可选的一种形式</td>
</tr>
<tr>
<td><code>PERSON_FIRSTNAME</code></td>
<td>大写形式。推荐在系统环境变量中使用</td>
</tr>
</tbody></table>
<blockquote>
<p>注解的<code>prefix</code>值必须是短横线隔开的形式，如：小写并且以<code>-</code>分隔。这里如果只有<code>person</code>就没有必要隔开了。</p>
</blockquote>
<h6>松散绑定规则</h6>

<table>
<thead>
<tr>
<th>属性来源</th>
<th>简单值</th>
<th>List值</th>
</tr>
</thead>
<tbody><tr>
<td>Properties文件</td>
<td>驼峰形式，短横线隔开，下划线符号</td>
<td>用<code>[]</code>的标准list形式或者逗号隔开的值</td>
</tr>
<tr>
<td>YAML文件</td>
<td>驼峰形式，短横线隔开，下划线符号</td>
<td>标准的YAML list形式或者逗号隔开的值</td>
</tr>
<tr>
<td>环境变量</td>
<td>以下划线作为分隔符的大写形式。<code>_</code>不要在属性名中使用</td>
<td>下划线包围的数字形式。如：<code>MY_FOO_1_BAR = my.foo[1].bar</code></td>
</tr>
<tr>
<td>系统属性</td>
<td>驼峰形式，短横线隔开，下划线符号</td>
<td>用<code>[]</code>的标准list形式或者逗号隔开的值</td>
</tr>
</tbody></table>
<blockquote>
<p>建议尽可能地用小写短横线格式来存储属性。如：<code>my.property-name=foo</code></p>
</blockquote>
<h4 id="属性转换"><a href="#属性转换" class="headerlink" title="属性转换"></a>属性转换</h4><p>在属性绑定到<code>@configurationProperties</code> bean的过程中，Spring会尝试强制转换为正确的类型。如果需要自定义类型转换，可以提供一个<code>ConversionService</code> bean（bean的id为<code>conversionService</code>）或者自定义属性编辑器（通过一个<code>CustomEditorConfigurer</code> bean），或者是自定义<code>Converters</code>（通过<code>@ConfigurationPropertiesBinding</code>注解）。</p>
<blockquote>
<p>由于<code>ConversionService</code>在应用的生命周期中使用的非常早，因此需要确保减少它的依赖。典型地，你需要的任何依赖可能在创建时间没有完全初始化。如果<code>ConversionService</code>在配置key强转的过程中不需要，并且仅仅依赖于<code>@ConfigurationPropertiesBinding</code>限制的自定义转换器，你有可能想对它重命名。</p>
</blockquote>
<h4 id="ConfigurationProperties-校验"><a href="#ConfigurationProperties-校验" class="headerlink" title="@ConfigurationProperties 校验"></a>@ConfigurationProperties 校验</h4><p>Spring Boot会尝试校验那些使用了Spring的<code>@Validated</code>注解的<code>@ConfigurationProperties</code>类。可以直接在配置类上使用JSR-303 <code>javax.validation</code>约束注解。只需要确保在classpath中有一个兼容的JSR-303实现，然后再在类属性上加上约束注解就可以了。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;foo&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... getters and setters</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了校验内部属性，必须在属性上使用<code>Valid</code>注解来触发校验。例如，下面的<code>FooProperties</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;connection&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Security security = <span class="keyword">new</span> Security();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... getters and setters</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotEmpty</span></span><br><span class="line">        <span class="keyword">public</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... getters and setters</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以通过创建一个bean定义为<code>configurationPropertiesValidator</code>的方式增加一个自定义Spring <code>Validator</code>。<code>@Bean</code>方法应该声明为<code>static</code>。配置属性校验器创建的时机在应用 的生命周期中非常早，因此将<code>@Bean</code>方法声明为static可以让这个bean的创建不需要实例化<code>@Configuration</code>。这避免了饥饿实例化引起的一些问题。 </p>
<blockquote>
<p><code>spring-boot-actuator</code>模块包含了一个端点，暴露了所有的<code>@ConfigurationProperties</code> bean。在浏览器中访问<code>/configprops</code>或者使用相同的JSX端点。<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#production-ready-endpoints">详情查看</a></p>
</blockquote>
<h4 id="ConfigurationProperties-与-Value对比"><a href="#ConfigurationProperties-与-Value对比" class="headerlink" title="@ConfigurationProperties 与 @Value对比"></a>@ConfigurationProperties 与 @Value对比</h4><p><code>@Value</code>是核心容器的一个功能，不提供<code>@ConfigurationProperties </code>类似的类型安全的功能。下面的表格总结了两个注解支持的功能。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody><tr>
<td>不严格绑定</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>元数据支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL 表达式</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>如果为自己的组件定义了一些配置键值，建议将他们放在一个POJO对象中，并且用<code>@ConfigurationProperties</code>注解。同时要注意由于<code>@Value</code>不支持松散绑定，因此当需要提供环境变量的值时最好不用<code>@Value</code>。</p>
<p>最后，虽然可以用<code>@Value</code>编写<code>SpEL</code>表达式，但这些从应用程序属性文件中的表达式不会处理。</p>
<h2 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h2><p>Spring Profile提供了一种隔离部分应用配置的方式，同时使它只在某种确定的环境中可用。任何<code>@Component</code>或<code>@Configuration</code>可以标记<code>@Profile</code>注解来限制它们被加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Spring常规的方式中，可以使用<code>spring.profile.active</code> <code>Environment</code>属性来指定激活哪个profile。可以在任何常规方式中指定这个属性，比如可以在<code>application.properties</code>文件中指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active&#x3D;dev,hsqldb</span><br></pre></td></tr></table></figure>

<p>或者在控制台指定：<code>--spring.profiles.active=dev,hsqldb</code>。</p>
<h3 id="增加激活的profile"><a href="#增加激活的profile" class="headerlink" title="增加激活的profile"></a>增加激活的profile</h3><p><code>spring.profiles.active</code>属性跟其他属性一样遵循相同的顺序规则，最高优先级的将会生效。意思是可以指定在<code>application.properties</code>文件中指定激活的profile，然后在控制台中替换掉它。</p>
<p>有时增加激活的profile而不是替换掉它们将会对特定profile属性非常有用。<code>spring.profiles.include</code>属性可以用来无条件地增加激活的profile。<code>SpringApplication</code>入口也拥胡一个API来设置附加的profile（如在那些通过<code>spring.profiles.active</code>属性设置的profile之上）：<code>setAdditionalProfiles()</code>方法。</p>
<p>例如：当一个应用通过<code>--spring.profiles.active=prod</code>开关来运行时，<code>proddb</code>和<code>prodmq</code> profile也会被激活：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">my.property:</span> <span class="string">fromyamlfile</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring.profiles:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">spring.profiles.include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">proddb</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">prodmq</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>记住一点：<code>spring.profiles</code>属性可以定义在YAML文档中，用来决定什么时候这个特殊的文档被包含在配置中。更多查看<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-change-configuration-depending-on-the-environment"> Change configuration depending on the environment</a>。</p>
</blockquote>
<h3 id="以编程方式设置profile"><a href="#以编程方式设置profile" class="headerlink" title="以编程方式设置profile"></a>以编程方式设置profile</h3><p>在应用启动之前可以通过调用<code>SpringApplication.setAdditionalProfiles()</code>方法以编程的方式来设置激活的profile。用Spring <code>ConfigurableEnvironment</code>接口也可以激活profile。</p>
<h3 id="特定Profile配置文件"><a href="#特定Profile配置文件" class="headerlink" title="特定Profile配置文件"></a>特定Profile配置文件</h3><p><code>application.properties</code>（或<code>application.yml</code>）和通过<code>@ConfigurationProperties</code>引用的文件中的特定profile变量都会被加载。详细查看<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-external-config-profile-specific-properties">Section 24.4, “Profile-specific properties”</a></p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>Spring Boot 内部使用 <a target="_blank" rel="noopener" href="http://commons.apache.org/logging">Commons Log</a>记录日志，但是放开了日志实现。为<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/7/docs/api/java/util/logging/package-summary.html">Java Util Logging</a>，<a target="_blank" rel="noopener" href="http://logging.apache.org/log4j/2.x/">Log4J2</a>和<a target="_blank" rel="noopener" href="http://logback.qos.ch/">Logback</a>提供了默认的配置。每个logger都预先配置了输出到控制台和选择输出到文件。</p>
<p>如果使用了”Starters”，默认会使用Logback来记录日志。还包括适当的Logback路由，以确保使用Java Util Logging、Commons Logging、Log4J或SLF4J的依赖库都能正常工作。</p>
<blockquote>
<p>Java 有很多日志框架可选。不要对上面的选择很困惑。一般不需要改变日志的依赖，并且Spring Boot 默认就会工作地很好。</p>
</blockquote>
<h3 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h3><p>Spring Boot默认的日志输出格式类似下面这种：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2014-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52</span><br><span class="line">2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms</span><br><span class="line">2014-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: &#x27;dispatcherServlet&#x27; to [/]</span><br><span class="line">2014-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: &#x27;hiddenHttpMethodFilter&#x27; to: [/*]</span><br></pre></td></tr></table></figure>
<p>输出了以下内容：</p>
<ul>
<li>日期和时间：毫秒级精度，容易排序</li>
<li>日志级别-<code>ERROR</code>,<code>WARN</code>,<code>INFO</code>,<code>DEBUG</code>或<code>TRACE</code></li>
<li>进程ID</li>
<li>用一个<code>---</code>分隔符来区分真正的日志内容起始</li>
<li>线程名称- 用方括号包裹起来（在控制台输出时有可能被截断）</li>
<li>日志记录器名称-这个通常是类名称（通常是短小的）</li>
<li>日志内容</li>
</ul>
<blockquote>
<p>Logback 没有<code>FATAL</code>这个级别（映射到ERROR）。</p>
</blockquote>
<h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><p>默认地的日志配置会将日志打印到控制台。默认会记录<code>ERROR</code>,<code>WARN</code>和<code>INFO</code>级别的日志。可以在启动的时候通过<code>--debug</code>来开启”debug”模式。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myapp.jar --debug</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以在<code>application.properties</code>文件指定<code>debug=true</code>。</p>
</blockquote>
<p>当debug模式启用时，选择的核心日志记录器（嵌入式容器，Hibernate和Spring Boot）将会记录更多更多信息。启用debug模式并不会配置应用程序以<code>DEBUG</code>级别来记录所有消息。</p>
<p>可以选择通过<code>--trace</code>标记（或者<code>application.properties</code>文件中<code>trace=true</code>）来启用”trace”模式。这将为选择的核心日志记录器（嵌入式容器，Hibernate schema生成和整个的Spring框架）启用trace日志记录。</p>
<h4 id="彩色编码输出"><a href="#彩色编码输出" class="headerlink" title="彩色编码输出"></a>彩色编码输出</h4><p>如果终端支持ANSI，将会以彩色输出来帮助阅读。可以设置<code>spring.output.ansi.enabled</code>为一个受支持的值来覆盖自动探测。</p>
<p>使用<code>%clr</code>转换词来配置彩色编码。在它最简单的形式中，转换器将以日志级别来为输出涂色。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%clr(%5p)</span><br></pre></td></tr></table></figure>

<p>日志级别对应的颜色如下：</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td><code>FATAL</code></td>
<td>Red</td>
</tr>
<tr>
<td><code>ERROR</code></td>
<td>Red</td>
</tr>
<tr>
<td><code>WARN</code></td>
<td>Yellow</td>
</tr>
<tr>
<td><code>INFO</code></td>
<td>Green</td>
</tr>
<tr>
<td><code>DEBUG</code></td>
<td>Green</td>
</tr>
<tr>
<td><code>TRACE</code></td>
<td>Green</td>
</tr>
</tbody></table>
<p>或者，可以指定应该使用的颜色或样式，以便将其作为转换的选项。例如，将文字的颜色变为黄色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;yellow&#125;</span><br></pre></td></tr></table></figure>
<p>支持下面的颜色和样式：</p>
<ul>
<li><code>blue</code></li>
<li><code>cyan</code></li>
<li><code>faint</code></li>
<li><code>green</code></li>
<li><code>magenta</code></li>
<li><code>red</code></li>
<li><code>yellow</code></li>
</ul>
<h3 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h3><p>Spring Boot 默认只会记录到控制台而不会记录到文件。如果还想记录到文件中需要设置<code>logging.file</code>或者<code>logging.path</code>属性值（例如在<code>application.properties</code>中）。</p>
<p>下面的表格指出了<code>logging.*</code>属性值是如何一起工作的：<br>日志属性</p>
<p><code>logging.file</code>|<code>logging.path</code>|示例|描述<br>–|–|–<br>（无）|（无）| |只在控制台记录日志<br>指定文件|（无）|<code>my.log</code>|记录到指定的日志文件。名称可以是一个绝对路径或者相对于现在的目录的路径<br>（无）|指定目录|<code>/var/log</code>|记录日志到指定目录中<code>spring.log</code>文件中。名称可以是绝对路径或者是相对现在目录的路径</p>
<p>当日志文件达到10MB 时将会被自动切分，并且同控制台输出一样，默认会将<code>ERROR</code>,<code>WARN</code>和<code>INFO</code>级别的日志记录下来。</p>
<blockquote>
<p>日志系统在应用的生命周期中初始化的时机比较早，因此不会发现通过<code>@propertySource</code>注解加载的文件中的这些日志属性。</p>
</blockquote>
<blockquote>
<p>日志属性与实际的日志实现相独立的。因此特定的配置属性（例如针对Logback的<code>logback.configurationFile</code>）不归Spring Boot管理。</p>
</blockquote>
<h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>所有支持的日志系统都可以通过使用<code>logger.level.*=LEVEL</code>在Spring 环境（例如<code>application.properties</code>）中设置日志级别，这里的<code>LEVEL</code>是<code>TRACE</code>,<code>DEBUG</code>,<code>INFO</code>,<code>WARN</code>,<code>ERROR</code>,<code>FATAL</code>,<code>OFF</code>中其中之一。<code>root</code>记录器可以通过<code>logging.level.root</code>来配置。例如<code>application.properties</code>：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">logging.level.root</span>=<span class="string">WARN</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.web</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate</span>=<span class="string">ERROR</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring Boot默认会重新映射Thymeleaf <code>INFO</code>日志到<code>DEBUG</code>级别。这个有助于减少标准日志输出的干扰。想要知道如何在自己的配置中应用重新映射可以查看<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot/src/main/java/org/springframework/boot/logging/logback/LevelRemappingAppender.java"><code>LevelRemappingAppender</code></a>了解更多细节。</p>
</blockquote>
<h3 id="自定义日志配置"><a href="#自定义日志配置" class="headerlink" title="自定义日志配置"></a>自定义日志配置</h3><p>在classpath中加入适当的依赖包就可以激活不同的日志系统，并且root classpath中提供一个配置文件来进行深度自定义，或者在Spring的<code>Environment</code>中指定<code>logging.config</code>属性。</p>
<p>可以通过<code>org.springframework.boot.logging.LoggingSystem</code>系统属性来强制Spring Boot使用常规的日志系统。这个值应该是实现了<code>LoggingSystem</code>接口的类的全名称。也可以使用<code>none</code>值来完全禁用掉Spring Boot的日志配置。</p>
<blockquote>
<p>由于日志系统在<code>ApplicationContext</code>创建之前实例化，不可能通过Spring <code>@Configuration</code>文件中的<code>@PropertySources</code>来控制日志系统。系统属性和常规的Spring Boot扩展配置文件可以正常工作。</p>
</blockquote>
<p>根据日志系统的不同下面的配置文件将会被加载：</p>
<table>
<thead>
<tr>
<th>日志系统</th>
<th>自定义</th>
</tr>
</thead>
<tbody><tr>
<td>Logback</td>
<td><code>logback-spring.xml</code>,<code>logback-spring.groovy</code>,<code>logback.xml</code>或<code>logback.groovy</code></td>
</tr>
<tr>
<td>Log4j2</td>
<td><code>log4j2-spring.xml</code>或<code>log4j2.xml</code></td>
</tr>
<tr>
<td>JDK(Java Util Logging)</td>
<td><code>logging.properties</code></td>
</tr>
</tbody></table>
<blockquote>
<p>建议尽可能使用<code>-spring</code>变体日志配置文件（比如<code>logback-spring.xml</code>）而不是<code>logback.xml</code>。如果使用标准的配置位置，Spring无法完全控制日志初始化。</p>
</blockquote>
<blockquote>
<p>这里有一些关于Java Util Logging 已知的类加载问题，当使用“可执行jar包” 的时候可能引起问题。建议尽可能避免使用它。</p>
</blockquote>
<p>为了帮助自定义，下面是一些其他的从Spring <code>Environment</code>变量转换为系统属性的属性：</p>
<table>
<thead>
<tr>
<th>Spring Environment</th>
<th>系统属性</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td><code>logging.exception-conversion-word</code></td>
<td><code>LOG_EXCEPTION_CONVERSION_WORD</code></td>
<td>当出现异常时使用的转换词</td>
</tr>
<tr>
<td><code>logging.file</code></td>
<td><code>LOG_FILE</code></td>
<td>如果定义了会用在默认的日志配置中</td>
</tr>
<tr>
<td><code>logging.path</code></td>
<td><code>LOG_PATH</code></td>
<td>如果定义了会用在默认的日志配置中</td>
</tr>
<tr>
<td><code>logging.pattern.console</code></td>
<td><code>CONSOLE_LOG_PATTERN</code></td>
<td>用在控制台中的日志格式（stdout）。（只支持默认的logback设置）</td>
</tr>
<tr>
<td><code>logging.pattern.file</code></td>
<td><code>FILE_LOG_PATTERN</code></td>
<td>日志文件中的日志格式（如果<code>LOG_FILE</code>启用了）。（只支持默认的logback设置）</td>
</tr>
<tr>
<td><code>logging.pattern.level</code></td>
<td><code>LOG_LEVEL_PATTERN</code></td>
<td>渲染日志级别的格式（默认为<code>%5p</code>）。（只支持默认的logback设置）</td>
</tr>
<tr>
<td><code>PID</code></td>
<td><code>PID</code></td>
<td>当前进程的ID（如果可能，并且还没有被定义为操作系统环境变量）</td>
</tr>
</tbody></table>
<p>所有支持的日志系统都可以在解析配置文件时参考系统属性。可以在<code>spring-boot.jar</code>的默认配置中找到例子。（类似的路径<code>spring-boot-2.0.0.BUILD-SNAPSHOT.jar\org\springframework\boot\logging\logback\defaults.xml</code>）</p>
<blockquote>
<p>如果想在日志属性中使用placeholder，可以使用<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-external-config-placeholders-in-properties">Spring Boot 的语法</a>而不是底层框架的语法。尤其是使用Logback时，需要使用<code>:</code>作为属性名和默认值之间的分隔符，而不是<code>:-</code>。</p>
</blockquote>
<blockquote>
<p>可以通过覆盖<code>LOG_LEVEL_PATTERN</code>（或<code>logging.pattern.level</code>）来添加MDC和其他专门的内容到日志行中。例如如果使用<code>logging.pattern.level=user:%X&#123;user&#125; %5p</code>，然后如果user存在的话默认的日志格式将会包含一个MDC user 实体，例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-09-30 12:30:04.031 user:juergen INFO 22174 --- [  nio-8080-exec-0] demo.Controller</span><br><span class="line">Handling authenticated request</span><br></pre></td></tr></table></figure>

<h3 id="Logback扩展"><a href="#Logback扩展" class="headerlink" title="Logback扩展"></a>Logback扩展</h3><p>Spring Boot包含许多对Logback的扩展，可以帮助高级配置。可以在<code>logback-spring.xml</code>文件中使用这些扩展。</p>
<blockquote>
<p>不能在标准的<code>logback.xml</code>文件中使用扩展，因为它加载的时机太早。要么使用<code>logback-spring.xml</code>或者定义<code>logging.config</code>属性。</p>
</blockquote>
<blockquote>
<p>这些扩展不能与Logback的<a target="_blank" rel="noopener" href="http://logback.qos.ch/manual/configuration.html#autoScan">配置扫描</a>一起使用。如果尝试这么做，修改配置文件会引起下面的类似的问题：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]</span><br><span class="line">ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]]</span><br></pre></td></tr></table></figure>

<h4 id="特定Profile配置"><a href="#特定Profile配置" class="headerlink" title="特定Profile配置"></a>特定Profile配置</h4><p><code>&lt;springProfile&gt;</code>标签可以通过激活Spring profile来选择性地包含或排除配置块。Profile块在<code>&lt;configuration&gt;</code>元素中w任意位置都受支持。使用<code>name</code>属性来指定哪个profile 接受这个配置。通过逗号分隔的列表可以指定多个profile。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;staging&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev, staging&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;dev&quot; or &quot;staging&quot; profiles are active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;!production&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;production&quot; profile is not active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="环境属性"><a href="#环境属性" class="headerlink" title="环境属性"></a>环境属性</h4><p><code>&lt;pringProperty&gt;</code>标签可以从Spring环境中获得属性，以便在Logback中使用。如果你想在logback的配置中访问<code>application.properties</code>文件中的值这个功能会非常有用。这个标签的工作方式和Logback的标准<code>&lt;property&gt;</code>标签类似，但不是指定一个直接的值，你指定了属性的来源（从<code>Environment</code>中）。如果需要将属性存储在<code>local</code>范围以外的地方，那么可以使用scope属性。如果需要一个后备值以防这个属性没有在<code>Environment</code>中指定，可以使用<code>defaultValue</code>属性。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fluentHost&quot;</span> <span class="attr">source</span>=<span class="string">&quot;myapp.fluentd.host&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">defaultValue</span>=<span class="string">&quot;localhost&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FLUENT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.more.appenders.DataFluentAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remoteHost</span>&gt;</span>$&#123;fluentHost&#125;<span class="tag">&lt;/<span class="name">remoteHost</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>source</code>值必须通过使用短横线形式（<code>my.property-name</code>）。但是添加到<code>Environment</code>中的属性值可以使用松散绑定的规则。</p>
</blockquote>
<h2 id="开发web应用"><a href="#开发web应用" class="headerlink" title="开发web应用"></a>开发web应用</h2><p>Spring Boot非常适合用来开发web应用。通过嵌入的Tomcat，Jetty，Undertow或者Netty，可以轻松地创建一个自包含的HTTP服务器。大多数web应用可以通过使用<code>spring-boot-starter-web</code>模块来建立和快速启动。也可以选择通过<code>spring-boot-starter-webflux</code>模块来创建响应式web应用。</p>
<p>如果还没有开发过Spring Boot web应用于，可以跟着<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#getting-started-first-application">快速开始</a>章节中的例子学习。</p>
<h3 id="Spring-Web-MVC-框架"><a href="#Spring-Web-MVC-框架" class="headerlink" title="Spring Web MVC 框架"></a>Spring Web MVC 框架</h3><p>Spring WEB MVC 框架（经常简称为’Spring MVC’）是一个富”model view controller” web框架。Spring MVC 让你创建特殊的<code>@Controller</code>和<code>@RestController</code> bean 来处理到来的HTTP请求。controller中的方法通过<code>@RequestMapping</code>注解映射到HTTP。</p>
<p>下面是一个典型的产生JSON数据的<code>@RestController</code>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/&#123;user&#125;&quot;, method=RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/&#123;user&#125;/customers&quot;, method=RequestMethod.GET)</span></span><br><span class="line">    <span class="function">List&lt;Customer&gt; <span class="title">getUserCustomers</span><span class="params">(<span class="meta">@PathVariable</span> Long user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/&#123;user&#125;&quot;, method=RequestMethod.DELETE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Spring MVC 是Spring Framework核心的一部分，<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/web.html#mvc">查看详情</a>。这里有一些关于<a target="_blank" rel="noopener" href="http://spring.io/guides">Spring MVC的指导</a>。</p>
<h4 id="Spring-MVC自动配置"><a href="#Spring-MVC自动配置" class="headerlink" title="Spring MVC自动配置"></a>Spring MVC自动配置</h4><p>Spring Boot为Spring MVC提供了自动配置功能，可以和大多数应用工作地很好。</p>
<p>Spring Boot自动配置在默认的基础上添加了以下功能：</p>
<ul>
<li>包括<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResoler</code> bean。</li>
<li>支持服务静态资源，包括支持WebJars。</li>
<li>自动注册<code>Converter</code>,<code>GenericConverter</code>,<code>Formatter</code> bean。</li>
<li><code>HttpMessageConverter</code>支持。</li>
<li>自动注册<code>MessageCodesResolver</code>。</li>
<li>静态<code>index.html</code>支持。</li>
<li>自定义<code>Favicon</code>支持。</li>
<li>自动使用<code>ConfigurableWebBindingInitializer</code> bean。</li>
</ul>
<p>如果想要保持Spring Boot MVC的功能，并且只想要添加额外的MVC 配置（interceptor, formatter, view controller等等），可以添加自己的类型为<code>WebMvcConfigurer</code>的<code>@Configuration</code>类，但是<strong>不要</strong>加<code>@EnableWebMvc</code>。如果希望提供自定义的<code>RequestMappingHandlerMapping</code>，<code>RequestMappingHandlerAdapter</code>或者<code>ExceptionHandlerExceptionResolver</code>实例,可以声明一个<code>WebMvcRegistrationsAdapter</code>实例，并且提供这些组件。</p>
<p>如果想要完全控制Spring MVC，可以添加自己的<code>@Configuration</code>类，并以<code>@EnableWebMvc</code>注解。</p>
<h4 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h4><p>Spring MVC 使用<code>HttpMessageConverter</code>接口来转换HTTP请求和响应。包括了一些合理的开箱即用的默认功能，例如Object可以自动转换为JSON（使用Jackson库）或者XML（如果可用的话使用Jackson XML扩展，否则使用JAXB）。String 默认使<code>用UTF-8</code>编码。</p>
<p>如果需要添加或者自定义converter可以使用Spring Boot 的<code>HttpMessageConverters</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.web.HttpMessageConverters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">customConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpMessageConverter&lt;?&gt; additional = ...</span><br><span class="line">        HttpMessageConverter&lt;?&gt; another = ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(additional, another);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何传递给context的<code>HttpMessageConverter</code> bean 都会添加到converter列表中。也可以通过这种方式覆盖缺省的converter。</p>
<h4 id="自定义JSON序列化和反序列化"><a href="#自定义JSON序列化和反序列化" class="headerlink" title="自定义JSON序列化和反序列化"></a>自定义JSON序列化和反序列化</h4><p>如果使用Jackson来序列化和反序列化JSON数据，可能想要编写自己的<code>JsonSerializer</code>和<code>JsonDeserializer</code>类。自定义serializer通常通过一个模块注册到Jackson，但是Spring Boot提供了一替代的<code>@jsoncomponent</code>注解，它使直接注册Spring bean变得更加容易。</p>
<p>可以直接在<code>JsonSerializer</code>或者<code>JsonDeserializer</code>实现类上使用<code>@JsonComponent</code>。也可以在包含内部serializers/deserializers类的类上使用。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.*;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.jackson.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Serializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">SomeObject</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">SomeObject</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ApplicationContext</code>中所有的<code>@JsonComponent</code> bean都将会自动注册到Jackson，并且由于<code>@JsonComponent</code>由<code>@Component</code>元注解注解，常规的组件扫描规则也将适用于这些组件。</p>
<p>Spring Boot也提供了<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java"><code>JsonObjectSerializer</code></a>和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java"><code>JsonObjectDeserializer</code></a>基类，它们在序列化对象时为标准的Jackson版本提供了有用的替代方法。</p>
<h4 id="MessageCodesResolver"><a href="#MessageCodesResolver" class="headerlink" title="MessageCodesResolver"></a>MessageCodesResolver</h4><p>Spring MVC有一个用于生成错误代码的策略，用于从绑定错误中呈现错误消息：<code>MessageCodesResolver</code>。如果设置了<code>spring.mvc.message-codes-resolver.format</code>属性<code>PREFIX_ERROR_CODE</code>或者<code>POSTFIX-ERROR_CODE</code>（可以查看<code>DefaultMessageCodesResolver.Format</code>枚举），Spring Boot会为你创建一个。</p>
<h4 id="静态内容"><a href="#静态内容" class="headerlink" title="静态内容"></a>静态内容</h4><p>Spring Boot默认会在classpath中的<code>/static</code>(或<code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>)目录提供静态服务，或者从<code>ServlectContext</code>的根目录。它使用Spring MVC中的<code>ResourceHttpRequestHandler</code>因此可以通过添加自己的<code>WebMvcConfigurer</code>并且重载<code>addResourceHandlers</code>方法来修改它的行为。</p>
<p>在独立的web应用程序中，也启用了来自容器的默认servlet，并充当备用服务器，如果Spring决定不处理它，则从<code>ServletContext</code>的根中提供内容。大多数情况下，这种情况不会发生（除非修改了默认的MVC配置）因为Spring会一直可以通过<code>DispatcherServlet</code>来处理请求。</p>
<p>resource默认映射到<code>/**</code>，但是可以通过<code>spring.mvc.static-path-pattern</code>来调整。例如重定向所有的resource到<code>/resources/**</code>可以向下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.static-path-pattern&#x3D;&#x2F;resources&#x2F;**</span><br></pre></td></tr></table></figure>
<p>也可以通过<code>spring.resources.static-locations</code>（通过一个目录列表替换掉默认值）来自定义静态resource位置。如果这么做默认的欢迎页面侦测将会切换到自定义的位置，因此如果启动时在定义的位置中有任意的<code>index.html</code>，它将会是应用的主页。</p>
<p>除了上面的标准静态resource位置之外，<a target="_blank" rel="noopener" href="http://www.webjars.org/">Webjar内容</a>是一个特殊的例子。任何<code>/webjars/**</code>路径的资源都将从jar文件中得到服务，如果它们被打包成webjar格式。</p>
<blockquote>
<p>如果应用会被打包成jar，不要使用<code>src/main/webapp</code>目录。尽管这个目录是一个公用的标准，但是它仅仅是在打包成war的时候生效，并且在生成jar时它会被大多数构建工具默默地忽略掉。</p>
</blockquote>
<p>Spring Boot 也支持Spring MVC提供的高级resource处理功能，允许使用诸如静态资源缓存破坏或使用Webjar的版本无关url。</p>
<p>要使用Webjar的版本无关url，添加<code>webjars-locator</code>依赖就可以了。然后申明Webjar，以jQuery举例，<code>“/webjars/jquery/dist/jquery.min.js”</code>会变成<code>“/webjars/jquery/x.y.z/dist/jquery.min.js”</code>，这里的<code>x.y.z</code>就是Webjar版本。</p>
<blockquote>
<p>如果使用的是JBoss，需要声明<code>sebjars-locator-jboss-vfs</code>依赖代替<code>webjars-locator</code>，否则所有的Webjars会解析为<code>404</code>。</p>
</blockquote>
<p>要使用缓存破坏，下面的配置将会为所有静态resource配置一个缓存破坏策略，有效地添加了一个hash值到URL中，例如<code>&lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.chain.strategy.content.enabled&#x3D;true</span><br><span class="line">spring.resources.chain.strategy.content.paths&#x3D;&#x2F;**</span><br></pre></td></tr></table></figure>

<blockquote>
<p>自动配置了在运行时对Thymeleaf和FreeMarker模板中的资源链接重新编写，这得益于<code>ResourceUrlEncodingFilter</code>。当使用JSP时应该手动声明这个filter。其他的模板引擎目前还不能自动支持，但是可以使用自定义模板宏/helper，以及使用<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/javadoc-api/org/springframework/web/servlet/resource/ResourceUrlProvider.html"><code>ResourceUrlProvider</code></a>。</p>
</blockquote>
<p>当动态加载resource时，如JavaScript模块加载器，重命名文件不是一个选项。这也是为什么其他的策略依旧支持并且可以相互组合。“fixed” 策略将会在URL中添加一个静态的版本号，无需修改文件名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.chain.strategy.content.enabled&#x3D;true</span><br><span class="line">spring.resources.chain.strategy.content.paths&#x3D;&#x2F;**</span><br><span class="line">spring.resources.chain.strategy.fixed.enabled&#x3D;true</span><br><span class="line">spring.resources.chain.strategy.fixed.paths&#x3D;&#x2F;js&#x2F;lib&#x2F;</span><br><span class="line">spring.resources.chain.strategy.fixed.version&#x3D;v12</span><br></pre></td></tr></table></figure>
<p>在上面的配置中，JavaScript加载位于<code>&quot;/js/lib/&quot;</code>的模块时将会使用”fixed” 版本策略<code>&quot;/v12/js/lib/mymodule.js&quot;</code>，然而其他的resource将仍然使用<code>&lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&gt;</code>。</p>
<p>可以查看<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ResourceProperties.java"><code>ResourceProperties</code></a>了解更多支持的选项</p>
<blockquote>
<p>这个功能在这个专用的<a target="_blank" rel="noopener" href="https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources">博客</a>和Spring Framework的<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/web.html#mvc-config-static-resources">文档</a>上有完整的说明。</p>
</blockquote>
<h4 id="自定义Favicon"><a href="#自定义Favicon" class="headerlink" title="自定义Favicon"></a>自定义Favicon</h4><p>Spring Boot在配置的静态内容位置和classpath根目录（按此顺序）中查找<code>favicon.ico</code>。如果找到了，将自动作为应用的favicon。</p>
<h4 id="ConfigurableWebBindingInitializer"><a href="#ConfigurableWebBindingInitializer" class="headerlink" title="ConfigurableWebBindingInitializer"></a>ConfigurableWebBindingInitializer</h4><p>Spring MVC使用<code>WebBindingInitializer</code>来为特殊请求初始化一个<code>WebDataBinder</code>。如果创建了自己的<code>ConfigurableWebBindingInitializer</code> <code>@Bean</code>，Spring Boot将自动配置Spring MVC使用它。</p>
<h4 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h4><p>跟REST服务一样，也可以使用Spring MVC来提供动态HTML内容。Spring MVC 支持一系列模板技术，包括Thymeleaf，FreeMarker和JSP。许多其他的模板引擎也发布了他们自己的Spring MVC集成方案。</p>
<p>Spring Boot包括针对以下模板引擎的自动配置功能：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://freemarker.org/docs/">FreeMarker</a></li>
<li><a target="_blank" rel="noopener" href="http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine">Groovy</a></li>
<li><a target="_blank" rel="noopener" href="http://www.thymeleaf.org/">Thymeleaf</a></li>
<li><a target="_blank" rel="noopener" href="http://mustache.github.io/">Mustache</a></li>
</ul>
<blockquote>
<p>有可能的话应该尽量避免使用JSP ，在使用嵌入式servlet容器时有一些<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-jsp-limitations">已知的限制</a>。</p>
</blockquote>
<p>当你在使用其中一种模板引擎并使用默认配置时，将会从<code>src/main/resources/templates</code>目录中自动发现模板。</p>
<blockquote>
<p>IntelliJ IDEA根据运行应用程序的方式不同classpath排序不一样。在IDE中通过main方法启动应用和使用Maven和Gradle或者打包的jar来运行会导致不同的顺序。这会导致Spring Boot在classpath中查找模板失败。如果你碰到了这个问题，可以在IDE中重新对classpath排序，将模块的class和resource放在首位。或者可以配置模板前缀来查找classpath中的每个模板目录：<code>classpath*:/templates/</code>。</p>
</blockquote>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>Spring Boot提供了一个默认的<code>/error</code>映射，以一种合理的方式处理所有错误，并且作为一个全局的错误页面注册到servlet容器中。对于机器客户端，它将生成一个JSON响应，其中包括错误的详细信息、HTTP状态和异常消息。对于浏览器客户端有一个“whitelabel”错误视图，它以HTML格式（或者添加一个<code>View</code>解析到<code>error</code>来自定义）呈现相同的数据。要完全替换掉默认的行为，可以实现<code>ErrorController</code>然后注册一个这种类型的bean定义，或者只需添加类型ErrorAttributes的bean，就可以使用现有的机制，但可以替换内容。</p>
<blockquote>
<p><code>BasicErrorController</code>可以用作自定义<code>ErrorController</code>的基类。当你需要添加一个handler来处理新的content type（默认专门处理<code>text/html</code>并为其他所有内容提供一个后路）时会非常有用。要达到这个目的只需要继承<code>BasicErrorController</code>然后添加一个拥有<code>produces</code>属性的<code>@RequestMapping</code>的公共方法，然后创建一个这个类型的bean。</p>
</blockquote>
<p>也可以定义一个<code>@ControllerAdvice</code>为特定的controller或者异常类型返回自定义的JSON内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(basePackageClasses = FooController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooControllerAdvice</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(YourException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) &#123;</span><br><span class="line">        HttpStatus status = getStatus(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> CustomErrorType(status.value(), ex.getMessage()), status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> HttpStatus <span class="title">getStatus</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Integer statusCode = (Integer) request.getAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (statusCode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HttpStatus.valueOf(statusCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，如果一个与<code>FooController</code>在同一个包中的Controller抛出<code>YourException</code>，那么将使用一个CustomerErrorType  POJO的json，而不是ErrorAttributes。</p>
<h5 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h5><p>如果要为给定的状态码显示自定义的HTML错误页面，可以在<code>/error</code>文件夹中添加一个文件。错误页面可以是静态HTML（例如在何意静态resource目录下添加的文件）或使用模板。文件名应该是确定的状态码或者一系列。</p>
<p>例如，将<code>404</code>映射到一个静态文件，文件夹结构应该像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src&#x2F;</span><br><span class="line"> +- main&#x2F;</span><br><span class="line">     +- java&#x2F;</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources&#x2F;</span><br><span class="line">         +- public&#x2F;</span><br><span class="line">             +- error&#x2F;</span><br><span class="line">             |   +- 404.html</span><br><span class="line">             +- &lt;other public assets&gt;</span><br></pre></td></tr></table></figure>
<p>要映射所有<code>5xx</code>的错误，并且使用FreeMarker模板，目录应该是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src&#x2F;</span><br><span class="line"> +- main&#x2F;</span><br><span class="line">     +- java&#x2F;</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources&#x2F;</span><br><span class="line">         +- templates&#x2F;</span><br><span class="line">             +- error&#x2F;</span><br><span class="line">             |   +- 5xx.ftl</span><br><span class="line">             +- &lt;other templates&gt;</span><br></pre></td></tr></table></figure>

<p>更复杂的映射可以添加实现了<code>ErrorViewResolver</code>接口的bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorViewResolver</span> <span class="keyword">implements</span> <span class="title">ErrorViewResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use the request or status to optionally return a ModelAndView</span></span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用常规的Spring MVC特性比如<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/web.html#mvc-exceptionhandlers"><code>@ExceptonHandler</code></a>方法和<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/web.html#mvc-ann-controller-advice"><code>@ControllerAdvice</code></a>。<code>ErrorController</code>会处理任何未处理的异常。</p>
<h5 id="在Spring-MVC之外映射错误页面"><a href="#在Spring-MVC之外映射错误页面" class="headerlink" title="在Spring MVC之外映射错误页面"></a>在Spring MVC之外映射错误页面</h5><p>对那些没有使用Spring MVC的应用，可以使用<code>ErrorPageRegister</code>接口来直接注册<code>ErrorPages</code>。这个抽象概念直接与底层的嵌入式servlet容器一起工作即使没有Spring MVC <code>DispatcherServlet</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ErrorPageRegistrar <span class="title">errorPageRegistrar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyErrorPageRegistrar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorPageRegistrar</span> <span class="keyword">implements</span> <span class="title">ErrorPageRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerErrorPages</span><span class="params">(ErrorPageRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.BAD_REQUEST, <span class="string">&quot;/400&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果注册的<code>ErrorPage</code>的路径被一个<code>Filter</code>处理而结束了（比如和一些非Spring的web框架一样，比如Jersey和Wicket），然后这个<code>Filter</code>必须得明确地注册为<code>ERROR</code> dispatcher。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    registration.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">    ...</span><br><span class="line">    registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(默认<code>FilterRegistrationBean</code> 不包含<code>ERROR</code> dispatcher类型)。</p>
<h5 id="WebSphere-应用服务器中错误处理"><a href="#WebSphere-应用服务器中错误处理" class="headerlink" title="WebSphere 应用服务器中错误处理"></a>WebSphere 应用服务器中错误处理</h5><p>当部署到一个servlet容器时，Spring Boot使用它的错误页面过滤器来转发请求到适当的错误页面，并携带错误码。如果response还没有提交，这个请求只能转发到正确的错误页面。WebSphere 8.0或者以上版本默认会根据正确完成servlet的service方法来提交response。应该设置<code>com.ibm.ws.webcontainer.invokeFlushAfterService</code>为<code>false</code>来禁止这个行为。</p>
<h4 id="Spring-HATEOAS"><a href="#Spring-HATEOAS" class="headerlink" title="Spring HATEOAS"></a>Spring HATEOAS</h4><p>如果正在开发的RESTful API 使用多媒体，Spring Boot 为Spring HATEOAS提供了自动配置，能够与大多数应用一起工作。自动配置替换了使用<code>@EnableHypermediaSupport</code>的必要性并且注册了一些bean使构建多媒体应用变得简单，这些bean包括一个<code>LinkDiscoverers</code>(为了应用端支持)和一个为了正确整理response到需要的表现形式而配置的<code>ObjectMapper</code>。这个<code>ObjectMapper</code>将基于<code>spring.jackson.*</code>属性或者可能存在的<code>Jackson2ObjectMapperBuilder</code> bean 进行自定义。</p>
<p>可以通过使用<code>@EnableHypermediaSupport</code>来控制Spring HATEOAS的配置。要注意的是这将会禁用上面提到的<code>ObjectMapper</code>自定义。</p>
<h4 id="CORS支持"><a href="#CORS支持" class="headerlink" title="CORS支持"></a>CORS支持</h4><p><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">跨域资源共享</a>是一被大多数浏览器实现的W3C标准，它允许你以一种灵活的方式来指定哪种类型的跨域请求是被授权的，代替使用一些不安全和不强大的方式比如IFRAME 和JSONP。</p>
<p>从4.2开始，Spring MVC<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/web.html#cors">跨域支持</a>开箱即用。在Spring Boot应用中与<code>@CrossOrigin</code>注解一起使用<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/web.html#controller-method-cors-configuration">controller方法CORS配置</a>不需要使用任何特定的配置。可以通过注册拥有一个自定义的<code>addCorsMappings(CorsRegistry)</code>的WebMvcConfigurer` bean 来定义<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/web.html#global-cors-configuration">全局的CORS配置</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">corsConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addMapping(<span class="string">&quot;/api/**&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring-WebFlux框架"><a href="#Spring-WebFlux框架" class="headerlink" title="Spring WebFlux框架"></a>Spring WebFlux框架</h3><h4 id="Spring-WebFlux自动配置"><a href="#Spring-WebFlux自动配置" class="headerlink" title="Spring WebFlux自动配置"></a>Spring WebFlux自动配置</h4><h4 id="HttpMessageReaders-和-HttpMessageWriters-HTTP编码"><a href="#HttpMessageReaders-和-HttpMessageWriters-HTTP编码" class="headerlink" title="HttpMessageReaders 和 HttpMessageWriters HTTP编码"></a>HttpMessageReaders 和 HttpMessageWriters HTTP编码</h4><h4 id="静态内容-1"><a href="#静态内容-1" class="headerlink" title="静态内容"></a>静态内容</h4><h4 id="模板引擎-1"><a href="#模板引擎-1" class="headerlink" title="模板引擎"></a>模板引擎</h4><h3 id="JAX-RS-和Jersey"><a href="#JAX-RS-和Jersey" class="headerlink" title="JAX-RS 和Jersey"></a>JAX-RS 和Jersey</h3><p>如果你更喜欢REST端点的jax-rs编程模型，可以使用一个可用的实现来代替Spring MVC。Jersey 1.x和 Apache CXF在将他们的<code>Servlet</code>和<code>Filter</code>作为<code>@Bean</code>注册到应用上下文中的情况下就已经工作的很好了。Jersey 2.x有一些本地Spring支持，所以我们也在Spring Boot 中通过一个starter 提供了自动配置支持。</p>
<p>开始开发Jersey 2.x只需要添加<code>spring-boot-starter-jersey</code>依赖然后写一个<code>ResourceConfig</code>类型的<code>@Bean</code>并在这里注册所有的端点就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JerseyConfig</span> <span class="keyword">extends</span> <span class="title">ResourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JerseyConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        register(Endpoint.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Jersey对扫描可执行档案的支持是相当有限的。例如在运行一个可执行的war包时它不能扫描<code>WEB-INF/classes</code>目录的包中发现的endpoint。为了避免这个限制，不应该使用<code>packages</code>方法并且endpoint应该像上面一样通过<code>register</code>方法单独注册。</p>
<p>也可以注册任意数量的实现<code>ResourceConfigCustomizer</code>接口的bean来进行更高级的自定义。</p>
<p>所有注册的endpoint都应该有<code>@Component</code>和HTTP resource注解（如<code>@GET</code>）,例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Path(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Endpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>Endpoint</code>是一个Spring <code>@Component</code>，因此它的生命周期由Spring来管理，并且你可以<code>@Autowired</code> 依赖并且通过<code>@Value</code>注入外部的配置。Jersey servlet默认会注册并映射到<code>/*</code>。可以通过添加<code>@ApplicationPath</code>到<code>ResourceConfig</code>修改这个映射。</p>
<p>Jersey默认将会作为<code>@ServletRegistrationBean</code>类型的<code>@Bean</code>中的一个Servlet，这个<code>@ServletRegistrationBean</code>名称为<code>jerseyServletRegistration</code>。默认情况下这个servlet会延迟初始化，但是你可以通过<code>spring.jersey.servlet.load-on-startup</code>来自定义。可以创建一个自己的相同名称的bean来禁用或者覆盖这个bean。也可以使用一个Filter通过设置<code>spring.jersey.type=filter</code>来代替这个Servlet（在这种情况下，要替换或覆盖的@Bean是<code>jerseyFilterRegistration</code>）。这个servlet有个<code>@Order</code>注解，可以通过<code>spring.jersey.filter.order</code>来设置。注册Servlet和Filter可以给定初始化参数，使用<code>spring.jersey.init.*</code>来指定一个属性map。</p>
<p>这里有一个<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-jersey">Jersey例子</a>可以看到如何设置。还有一个<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-jersey1">Jersey 1.x 例子</a>。注意在Jersey 1.x例子中spring-boot maven插件配置了不打包某些Jersey的jar，这样他们可以被JAX-RS的实现扫描到（因为这个例子要求在Filter注册中对它们进行扫描）。如果你有任何JAX-RS resource打包成了内部jar时，可能也需要这么做。</p>
<h3 id="嵌入式servlet容器支持"><a href="#嵌入式servlet容器支持" class="headerlink" title="嵌入式servlet容器支持"></a>嵌入式servlet容器支持</h3><p>Spring Boot 支持嵌入式Tomcat，Jetty，Undertow服务器。大多数开发者只需要使用对应的”Starter”来获取完整配置的实例。嵌入式服务器默认会在<code>8080</code>端口监听HTTP请求。</p>
<blockquote>
<p>如果你选择在CentOS上使用Tomcat则要注意，默认情况下会使用一个临时目录来存储编绎的JSP和上传的文件等。当你的应用程序运行导致失败时，该目录有可能被<code>tmpwatch</code>删除。要避免这样你可能想要自定义<code>tmpwatch</code>配置，这样<code>tomcat.*</code>目录不会删除，或者配置<code>server.tomcat.basedir</code>这样的话嵌入式Tomcat会使用不同的目录。</p>
</blockquote>
<h4 id="Servlet，Filter和listerner"><a href="#Servlet，Filter和listerner" class="headerlink" title="Servlet，Filter和listerner"></a>Servlet，Filter和listerner</h4><p>当使用嵌入式servlet容器时既可以使用Spring Bean又可以扫描Servlet组件来注册Servlet，Filter和来自servlet规范的所有listener（例如<code>HttpSessionListener</code>）。</p>
<h4 id="Servlet上下文初始化"><a href="#Servlet上下文初始化" class="headerlink" title="Servlet上下文初始化"></a>Servlet上下文初始化</h4><p>任何一个Spring bean的的<code>Servlet</code>，<code>Filter</code>或者Serlvet<code>*Listener</code>的实例都将在嵌入式容器中注册。如果想从<code>application.properties</code>中引用一个值，这将非常方便。</p>
<p>默认情况下如果context只包含一个Servlet，它将会映射到<code>/</code>。在有多个Servlet Bean的情况下，bean的名称将会作为path的前缀。Filter会映射到<code>/*</code>。如果基于约定的映射不足够灵活,可以使用<code>ServletRegistrationBean</code>,<code>FilterRegistrationBean</code>和<code>ServletListenerRegistrationBean</code>类来完全控制。</p>
<h4 id="ServletWebServerApplicationContext"><a href="#ServletWebServerApplicationContext" class="headerlink" title="ServletWebServerApplicationContext"></a>ServletWebServerApplicationContext</h4><p>嵌入式servlet容器不会直接执行Servlet 3.0以上的<code>javax.servlet.ServletContainerInitializer</code>接口，或者是Spring的<code>org.springframework.web.WebApplicationInitializer</code>接口。这是一个刻意的设计，目的是为了减少在war中运行的第三方库会破坏Spring Boot应用程序的风险。</p>
<p>如果你需要在Spring Boot应用中执行servlet上下文初始化，需要注册一个实现了<code>org.springframework.boot.web.servlet.ServletContextInitializer</code>接口的bean。唯一的<code>onStartup</code>方法提供了访问<code>ServletContext</code>的能力，并且可以在必要的情况下轻松地用来作为已知<code>WebApplicationInitializer</code>的桥接器。</p>
<h5 id="扫描Servlet，Filter和lisenter"><a href="#扫描Servlet，Filter和lisenter" class="headerlink" title="扫描Servlet，Filter和lisenter"></a>扫描Servlet，Filter和lisenter</h5><p>当使用嵌入式容器时，可以使用<code>@ServletComponentScan</code>来启用对注解了<code>@WebServlet</code>，<code>@WebFilter</code>和<code>@WebListener</code>类进行自动注册。</p>
<blockquote>
<p><code>@ServletComponentScan</code>在独立容器中时没有效果，在这里将会使用容器的自有发现机制。</p>
</blockquote>
<h4 id="ServletWebServerApplicatonContext"><a href="#ServletWebServerApplicatonContext" class="headerlink" title="ServletWebServerApplicatonContext"></a>ServletWebServerApplicatonContext</h4><p>Spring Boot为嵌入式容器支持使用了一个新的<code>ApplicationContext</code>类型。<code>ServletWebServerApplicationContext</code>是一个专门的<code>WebApplicationContext</code>类型，通过搜索一个单独的<code>ServletWebServerFactory</code> bean来引导自己。通常是一个<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>或者是<code>UndertowServletWebServerFactory</code>将被自动配置。</p>
<blockquote>
<p>通常不需要感知这些实现类。大多数应用会自动配置并且将为你创建合适的<code>ApplicationContext</code>和<code>ServletWebServerFactory</code>。</p>
</blockquote>
<h4 id="自定义嵌入式servlet容器"><a href="#自定义嵌入式servlet容器" class="headerlink" title="自定义嵌入式servlet容器"></a>自定义嵌入式servlet容器</h4><p>可以通过使用Spring <code>Environment</code>属性来配置常见的servlet容器设置。通常你将在<code>application.properties</code>文件中定义这些属性。</p>
<p>常见的服务器设置包括：</p>
<ul>
<li>网络设置：侦听HTTP请求的端口（<code>server.port</code>），接口地址绑定到<code>server.address</code>等等。</li>
<li>Session设置：session是否执久化（<code>server.session.persistence</code>），session超时时间（<code>server.session.timeout</code>），session数据的位置（<code>server.session.store-dir</code>）和session-cookie配置（<code>server.session.cookie.*</code>）。</li>
<li>错误管理：错误页面的位置（<code>server.error.path</code>）等。</li>
<li><a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-configure-ssl">SSL</a></li>
<li><a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#how-to-enable-http-response-compression">HTTP压缩</a></li>
</ul>
<p>Spring Boot尽可能多地暴露通用设置，但这并不总是可行的。对于那些情况下，专用的命名空间提供特定服务器的自定义（查看<code>server.tomcat</code>和<code>server.undertow</code>）。例如可以使用嵌入式servlet容器的特定功能配置<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-configure-accesslogs">访问日志</a>。</p>
<blockquote>
<p>查看<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java"><code>ServerProperties</code></a>类获取详细清单。</p>
</blockquote>
<h5 id="编程式自定义"><a href="#编程式自定义" class="headerlink" title="编程式自定义"></a>编程式自定义</h5><p>如果需要通过编程来自定义嵌入式servlet容器，可以注册一个实现了<code>WebServerFactoryCustomizer</code> 接口的Spring bean。<code>WebServerFactoryCustomizer</code>提供了访问<code>ConfigurableServletWebServerFactory</code>的方法，<code>ConfigurableServletWebServerFactory</code>包含了大量定制setter方法。在Tomcat，Jetty和Undertow中存在专门的变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.WebServerFactoryCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationBean</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableServletWebServerFactory server)</span> </span>&#123;</span><br><span class="line">        server.setPort(<span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="直接自定义ConfigurableServletWebServerFactory"><a href="#直接自定义ConfigurableServletWebServerFactory" class="headerlink" title="直接自定义ConfigurableServletWebServerFactory"></a>直接自定义ConfigurableServletWebServerFactory</h5><p>如果上面的自定义方式太局限，可以注册自己的<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>，<code>UndertowServletWebServerFactory</code> bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableServletWebServerFactory <span class="title">webServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TomcatServletWebServerFactory factory = <span class="keyword">new</span> TomcatServletWebServerFactory();</span><br><span class="line">    factory.setPort(<span class="number">9000</span>);</span><br><span class="line">    factory.setSessionTimeout(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    factory.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="string">&quot;/notfound.html&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set方法提供了许多配置选项。如果你需要做一些更独特的事情，还提供了几个受保护的方法“钩子”。更多详情请查看源代码文档。</p>
<h4 id="JSP限制"><a href="#JSP限制" class="headerlink" title="JSP限制"></a>JSP限制</h4><p>当使用嵌入式servlet容器（并且被打包成可执行包）运行Spring Boot应用时，对JSP的支持有一些限制。</p>
<ul>
<li>对于Tomcat，如果使用war包，它就可以工作，即可执行的war将工作，并且也可以部署到一个标准容器(不限于，但包括Tomcat）。一个可执行的jar不能工作，因为在Tomcat中有一个硬编码的文件模式。</li>
<li>对于Jetty，如果使用war包，它就可以工作，即可执行的war将工作，并且也可以部署到一个标准容器。</li>
<li>Undertow不支持JSP。</li>
<li>创建自定义的<code>error.jsp</code>页面不会覆盖默认的<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-error-handling">错误处理</a>视图，而是应该使用自定义错误页面。</li>
</ul>
<p>这里有一个<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-web-jsp">JSP例子</a>可以看到如何设置。</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>如果在classpath中发现了Spring Security，那么web应用所有的HTTP端点会默认使用”basic”认证。可以添加<code>@EnableGlobalMethodSecurity</code>来添加方法级别的安全。更多信息可以查看<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-security/site/docs/5.0.0.BUILD-SNAPSHOT/reference/htmlsingle#jc-method">Spring Security Reference</a>。</p>
<p>默认的<code>AuthenticationManager</code>有一个单独的用户（“user” 用户名和随机密码，密码在应用程序启动时打印在INFO级别）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Using default security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你调整了日志配置，确保<code>org.springframework.boot.autoconfigure.security</code>类型设置为<code>INFO</code>级别，否则默认密码不会打印。</p>
</blockquote>
<p>可以通过提供<code>security.user.password</code>属性来修改密码。这个和其他有用的属性通过<code>SecurityProperties</code>（属性前缀为”security”）扩展。</p>
<h3 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h3><h4 id="授权服务器"><a href="#授权服务器" class="headerlink" title="授权服务器"></a>授权服务器</h4><h4 id="资源服务器"><a href="#资源服务器" class="headerlink" title="资源服务器"></a>资源服务器</h4><h3 id="User信息中的Token类型"><a href="#User信息中的Token类型" class="headerlink" title="User信息中的Token类型"></a>User信息中的Token类型</h3><h3 id="自定义User信息-RestTemplate"><a href="#自定义User信息-RestTemplate" class="headerlink" title="自定义User信息 RestTemplate"></a>自定义User信息 RestTemplate</h3><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><h4 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h4><h3 id="Actuator-安全"><a href="#Actuator-安全" class="headerlink" title="Actuator 安全"></a>Actuator 安全</h3><h2 id="SQL数据库"><a href="#SQL数据库" class="headerlink" title="SQL数据库"></a>SQL数据库</h2><p>Spring Framework对SQL数据库提供了大量支持。从使用<code>JdbcTemplate</code>直接的JDBC访问到完全的“对象关系映射”技术如Hibernate。Spring Data提供了额外的功能级别，直接从接口创建<code>Repository</code>实现，并使用约定从方法名称生成查询。</p>
<h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><p>Java的<code>javax.sql.DataSource</code>接口提供了与数据库连接工作的标准方法。传统上，数据源使用<code>URL</code>和一些凭证来建立数据库连接。</p>
<blockquote>
<p>还可以查看<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-configure-a-datasource">“如何操作”</a>的部分，以获得更高级的示例，尤其是要对数据源的配置进行完全控制。</p>
</blockquote>
<h4 id="嵌入式数据库支持"><a href="#嵌入式数据库支持" class="headerlink" title="嵌入式数据库支持"></a>嵌入式数据库支持</h4><p>使用内存中嵌入式数据库开发应用程序通常很方便。明显地内存数据库不提供持久化；你需要当应用程序启动时填充数据库，并准备在应用程序结束时抛出数据。</p>
<blockquote>
<p>这里有<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-database-initialization">如何初始化数据库</a>。</p>
</blockquote>
<p>Spring Boot可以自动配置嵌入式<a target="_blank" rel="noopener" href="http://www.h2database.com/">H2</a>，<a target="_blank" rel="noopener" href="http://hsqldb.org/">HSQL</a>和<a target="_blank" rel="noopener" href="http://db.apache.org/derby/">Derby</a>数据库。不需要提供任何连接URL，只需要简单地包含想要使用的嵌入式数据库的构建依赖。</p>
<blockquote>
<p>如果在测试用例中使用这个功能，你可能注意到了整个测试用命重用了相同的数据库，而不管使用了多少个应用上下文。如果你想确保每个上下文使用独立的嵌入式数据库，你应该设置<code>spring.datasource.generate-unique-name</code>为<code>true</code>。</p>
</blockquote>
<p>例如典型的POM依赖是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要对spring jdbc的依赖，以便自动配置嵌入式数据库。在这个例子中它通过<code>spring-boot-starter-data-jpa</code>来传递这个依赖。</p>
</blockquote>
<blockquote>
<p>如果出于某种原因，你确实为嵌入式数据库配置了连接URL，那么应该注意确保数据库的自动关闭是禁用的。如果你正在使用H2，你应该使用<code>DB_CLOSE_ON_EXIT=FALSE</code>来禁用。如果使用HSQLDB，应该确保没有使用<code>shutdown=true</code>。禁用数据库的自动关闭功能可以让Spring Boot在数据库关闭时进行控制，从而确保在不再需要访问数据库时发生这种情况。</p>
</blockquote>
<h4 id="连接生产库"><a href="#连接生产库" class="headerlink" title="连接生产库"></a>连接生产库</h4><p>还可以使用<code>DataSource</code>池自动配置生产数据库连接。下面是选择具体实现的算法：</p>
<ul>
<li>我们更喜欢HikariCP因为它的性能和并发性，所以如果它可用，我们总是选择它。</li>
<li>否则如果Tomcat<code>DataSource</code>连接池可用，就会使用它。</li>
<li>HikariCP 和Tomcat<code>DataSource</code>连接池都不可用并且 Commons DBCP2可用则使用它。</li>
</ul>
<p>如果你使用<code>spring-boot-starter-jdbc</code>或者<code>spring-boot-starter-data-jpa</code> “starter” 则会自动依赖<code>HikariCP</code>。</p>
<blockquote>
<p>可以通过设置<code>spring.datasource.type</code>属性来完全绕开这个算法并且指定连接池。如果你在Tomcat容器中运行你的应用程序，那么这一点尤为重要，因为默认提供了<code>tomcat-jdbc</code>。</p>
</blockquote>
<blockquote>
<p>可以手动配置额外的连接池。如果你定义了自己的<code>DataSource</code> bean，则不会发生自动配置。</p>
</blockquote>
<p><code>spring.datasource.*</code>中的扩展配置属性可以控制数据源配置。例如，你可以在<code>application.properties</code>中声明以下块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;test</span><br><span class="line">spring.datasource.username&#x3D;dbuser</span><br><span class="line">spring.datasource.password&#x3D;dbpass</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你至少应该使用<code>spring.datasource.url</code>属性来指定url或者Sprig Boot 会尝试自动配置一个嵌入式数据库。</p>
</blockquote>
<blockquote>
<p>你通常不需要指定<code>driver-class-name</code>，因为对于大多数数据库Spring boot 可以从url中推断出来。</p>
</blockquote>
<blockquote>
<p>对于创建<code>DataSource</code>池，我们需要能够验证一个有效的<code>Driver</code>类是否可用，所以我们在做任何事情之前都要检查它。例如，如果你设了<code>spring.datasource.driver-class-name=com.mysql.jdbc</code>,那么这个类就必须是可加载的。</p>
</blockquote>
<p>更多受支持的选项，请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java"><code>DataSourceProperties</code></a>。这些是标准的选项，不管实际是什么实现都可以工作。也可以通过它们各自的前缀（<code>spring.datasource.hikari.*</code>,<code>spring.datasource.tomcat.*</code>，和<code>spring.datasource.dbcp2.*</code>）微调特定实现设置。请参阅你正在使用的连接池实现的文档获取更多细节。</p>
<p>例如如果你正在使用<a target="_blank" rel="noopener" href="http://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html#Common_Attributes">Tomcat连接池</a>，可以自定义许多额外的设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Number of ms to wait before throwing an exception if no connection is available.</span><br><span class="line">spring.datasource.tomcat.max-wait&#x3D;10000</span><br><span class="line"></span><br><span class="line"># Maximum number of active connections that can be allocated from this pool at the same time.</span><br><span class="line">spring.datasource.tomcat.max-active&#x3D;50</span><br><span class="line"></span><br><span class="line"># Validate the connection before borrowing it from the pool.</span><br><span class="line">spring.datasource.tomcat.test-on-borrow&#x3D;true</span><br></pre></td></tr></table></figure>

<h4 id="连接JNDI数据库"><a href="#连接JNDI数据库" class="headerlink" title="连接JNDI数据库"></a>连接JNDI数据库</h4><p>如果你正在将Spring Boot应用程序部署到应用程序服务器，那么你可能需要使用应用程序服务器的内置特性来配置和管理数据源，并使用JNDI访问它。</p>
<p><code>spring.datasource.jndi-name</code>属性可以用作<code>spring.datasource.url</code>,<code>spring.datasource.username</code>和<code>spring.datasource.password</code>属性的另一种选择从特定的JNDI位置访问<code>DataSource</code>。例如下面<code>applicaion.properties</code>中的块展示了如何访问JBoss定义的<code>DataSource</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.jndi-name&#x3D;java:jboss&#x2F;datasources&#x2F;customers</span><br></pre></td></tr></table></figure>

<h3 id="使用JdbcTemplate"><a href="#使用JdbcTemplate" class="headerlink" title="使用JdbcTemplate"></a>使用JdbcTemplate</h3><p>Spring 的<code>JdbcTemplate</code>和<code>NamedParameterJdbcTemplate</code>类是自动配置的并且可以直接<code>@Autowire</code>他们到你自己的bean中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以通过<code>spring.jdbc.template.*</code>来自定义template的一些属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jdbc.template.max-rows&#x3D;500</span><br></pre></td></tr></table></figure>

<blockquote>
<p>NamedParameterJdbcTemplate在背后重用相同的JdbcTemplate实例。如果定义了多个<code>JdbcTemplate</code>并且不存在主要的候选者，不会自动配置<code>NamedParameterJdbcTemplate</code>。</p>
</blockquote>
<h3 id="JPA和Spring-Data"><a href="#JPA和Spring-Data" class="headerlink" title="JPA和Spring Data"></a>JPA和Spring Data</h3><p>Java Persistence API 是一种允许你映射对象到关系型数据的技术。<code>spring-boot-starter-data-jpa</code> POM提供了一种快速开始的方式。它提供了下面关键的依赖：</p>
<ul>
<li>Hibernate - 最流行的JPA实现之一</li>
<li>Spring Data JPA - 使实现基于JPA的repositories变得容易</li>
<li>Spring ORM - Spring Framework的核心ORM支持</li>
</ul>
<blockquote>
<p>在这里不涉及到太多JPA和Spring Data细节。可以访问<a target="_blank" rel="noopener" href="http://spring.io/guides/gs/accessing-data-jpa/">Accessing Data with JPA</a>指南和阅读<a target="_blank" rel="noopener" href="http://spring.io/guides/gs/accessing-data-jpa/">Spring Data JPA</a>和<a target="_blank" rel="noopener" href="http://hibernate.org/orm/documentation/">Hibernate </a>文档。</p>
</blockquote>
<h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><p>传统上，JPA “Entity”的类是在<code>persistence.xml</code>文件中指定的。在Spring Boot 中这个文件不是必需的，而是使用“Entity Scanning”。默认情况下在主配置类（某个注解了<code>@EnableAutoConfiguration</code> 或<code>@SpringBootApplication</code>的类）下面的所有包都会被搜索到。</p>
<p>任何注解了<code>@Entity</code>,<code>@Embeddable</code>或<code>@MappedSuperclass</code>的类都是被考虑的对象。一个典型的实体类应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... additional members, often include @OneToMany mappings</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">City</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// no-args constructor required by JPA spec</span></span><br><span class="line">        <span class="comment">// this one is protected since it shouldn&#x27;t be used directly</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">City</span><span class="params">(String name, String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.country = country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... etc</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以使用<code>@EntityScan</code>注解来自定义扫描位置。更多查看<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-separate-entity-definitions-from-spring-configuration">Section 78.4, “Separate @Entity definitions from Spring configuration” </a></p>
</blockquote>
<h4 id="Spring-Data-JPA仓库"><a href="#Spring-Data-JPA仓库" class="headerlink" title="Spring Data JPA仓库"></a>Spring Data JPA仓库</h4><p>Spring Data JPA repository是你可以定义来访问数据的接口。JPA查询会从你的方法名自动创建查询。例如，<code>CityRepository</code>接口可能声明了<code>findAllByState(String state)</code>方法来根据给定状态查找所有的城市。</p>
<p>对于更复杂的查询你可以使用Spring Data的<code>Query</code>注解来注解你的方法。</p>
<p>Spring Data repository通常继承自<code>Repository</code>或者<code>CrudRepository</code>接口。如果使用自动配置，将会从包含主配置类（注解了<code>@EnableAutoConfiguration</code>或<code>@SpringBooApplication</code>的类）的包中往下查找repository。</p>
<p>这里有一个典型的Spring Data repository：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Page&lt;City&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">City <span class="title">findByNameAndCountryAllIgnoringCase</span><span class="params">(String name, String country)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们仅仅触及Spring Data JPA的表面。可以查看<a target="_blank" rel="noopener" href="http://projects.spring.io/spring-data-jpa/">文档</a>获取完整的细节。</p>
</blockquote>
<h4 id="创建和删除JPA数据库"><a href="#创建和删除JPA数据库" class="headerlink" title="创建和删除JPA数据库"></a>创建和删除JPA数据库</h4><p>默认情况下，JPA数据库<strong>只</strong>在使用嵌入式数据库（H2,HSQL或Derby）时才会自动创建。你也可以使用<code>spring.jpa.*</code>属性明确地配置JPA<code>。例如可以在</code>application.properties`中添加下面的配置来创建和删除表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.hibernate.ddl-auto&#x3D;create-drop</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Hibernate自有内部属性名称是<code>hibernate.hbm2ddl.auto</code>（如果你能记住它更好）。你可以和其他Hibernate原生属性一样设置它，使用<code>spring.jpa.properties.*</code>（这个前缀在添加到entity manager之前被剥离出来）。例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.properties.hibernate.globally_quoted_identifiers&#x3D;true</span><br></pre></td></tr></table></figure>
<p>传给Hibernate entity manager的是<code>hiberbate.globally_quoted_identifiers</code>。</p>
<p>默认情况下DDL执行（或验证）推迟到<code>ApplicationContext</code>启动之后。还有一个<code>spring.jpa.generate-ddl</code>标志，但是在Hibernate autoconfig启用的情况下不会使用因为<code>ddl-auto</code>设置更细粒度。</p>
<h4 id="在View中打开EntityManager"><a href="#在View中打开EntityManager" class="headerlink" title="在View中打开EntityManager"></a>在View中打开EntityManager</h4><p>如果正在运行一个web应用，Spring Boot默认会注册<code>OpenEntityManageerInViewInterceptor</code>来应用“Open EntityManager in View” 模式，例如来在web视图允许延迟加载。如果你不想要这种行为，你应用在<code>applicaiont.properties</code>中设置<code>spring.jpa.open-in-view</code>来<code>false</code>。</p>
<h3 id="使用H2的web控制台"><a href="#使用H2的web控制台" class="headerlink" title="使用H2的web控制台"></a>使用H2的web控制台</h3><h4 id="修改H2控制台的路径"><a href="#修改H2控制台的路径" class="headerlink" title="修改H2控制台的路径"></a>修改H2控制台的路径</h4><h4 id="加密H2的控制台"><a href="#加密H2的控制台" class="headerlink" title="加密H2的控制台"></a>加密H2的控制台</h4><h3 id="使用jOOQ"><a href="#使用jOOQ" class="headerlink" title="使用jOOQ"></a>使用jOOQ</h3><h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><h4 id="使用DSLContext"><a href="#使用DSLContext" class="headerlink" title="使用DSLContext"></a>使用DSLContext</h4><h4 id="jOOQ-SQL方言"><a href="#jOOQ-SQL方言" class="headerlink" title="jOOQ SQL方言"></a>jOOQ SQL方言</h4><h4 id="自定义jOOQ"><a href="#自定义jOOQ" class="headerlink" title="自定义jOOQ"></a>自定义jOOQ</h4><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><p>Spring Data提供额外的项目来帮助你访问一些NoSQL技术，包括<a target="_blank" rel="noopener" href="http://projects.spring.io/spring-data-mongodb/">MongoDB</a>，<a target="_blank" rel="noopener" href="http://projects.spring.io/spring-data-neo4j/">Neo4J</a>，<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-elasticsearch/">Elasticsearch</a>，<a target="_blank" rel="noopener" href="http://projects.spring.io/spring-data-solr/">Solr</a>，<a target="_blank" rel="noopener" href="http://projects.spring.io/spring-data-redis/">Redis</a>，<a target="_blank" rel="noopener" href="http://projects.spring.io/spring-data-gemfire/">Gemfire</a>，<a target="_blank" rel="noopener" href="http://projects.spring.io/spring-data-cassandra/">Cassandra</a>，<a target="_blank" rel="noopener" href="http://projects.spring.io/spring-data-couchbase/">Couchbase</a>和<a target="_blank" rel="noopener" href="http://projects.spring.io/spring-data-ldap/">LDAP</a>。Spring Boot 对Redis，MongoDB，Neo4j，Elastcisearch，Solr，Cassandra，Couchbase和LDAP提供了自动配置；你可以使用其他项目，但是你需要自己配置它们。</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis 是一个缓存，消息代理和功能丰富的键值存储。Spring Boot为<a target="_blank" rel="noopener" href="https://github.com/xetorthio/jedis/">Jedis</a> 和<a target="_blank" rel="noopener" href="https://github.com/mp911de/lettuce/">Lettuce</a> 客户端库提供基本的自动配置并由Spring Data Redis在它们之上提供抽象。</p>
<p>默认有一个<code>spring-boot-starter-data-redis</code> “Starter” 以方便的方式收集依赖并且默认使用 <a target="_blank" rel="noopener" href="https://github.com/xetorthio/jedis/">Jedis</a>。如果你正在构建一个响应式应用程序，那么<code>spring-stardata-data-redis-reactive</code> “Starter” 将会让你继续前进。</p>
<h4 id="连接到Redis"><a href="#连接到Redis" class="headerlink" title="连接到Redis"></a>连接到Redis</h4><p>你可以像任何其他Spring Bean一样注入自动配置的<code>RedisConnectionFactory</code>，<code>StringRedisTemplate</code>或者<code>RedisTemplate</code> 实例。默认情况下这些实例会尝试使用<code>localhost:6379</code>来连接到Redis 服务器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(StringRedisTemplate template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你也可以注册任意数量的实现<code>JedisClientConfigurationBuilderCustomizer</code> 的bean 来实现更高级的定制。如果你正在使用Lettuce，可以使用<code>LettuceClientConfigurationBuilderCustomizer</code>。</p>
</blockquote>
<p>如果你在任何自己的自动配置类型上加了<code>@Bean</code>，它会替代默认的（除了在RedisTemplate的情况下，排除是基于bean名称“redisTemplate”而不是其类型）。如果commons-pool2在classpath中，则默认情况下你将获得一个连接池工厂。</p>
<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><h4 id="连接到MongoDB数据库"><a href="#连接到MongoDB数据库" class="headerlink" title="连接到MongoDB数据库"></a>连接到MongoDB数据库</h4><h4 id="MongoTemplate"><a href="#MongoTemplate" class="headerlink" title="MongoTemplate"></a>MongoTemplate</h4><h4 id="Spring-Data-MongoDB仓库"><a href="#Spring-Data-MongoDB仓库" class="headerlink" title="Spring Data MongoDB仓库"></a>Spring Data MongoDB仓库</h4><h4 id="嵌入式Mongo"><a href="#嵌入式Mongo" class="headerlink" title="嵌入式Mongo"></a>嵌入式Mongo</h4><h3 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h3><h4 id="连接到Neo4j数据库"><a href="#连接到Neo4j数据库" class="headerlink" title="连接到Neo4j数据库"></a>连接到Neo4j数据库</h4><h4 id="使用嵌入式模式"><a href="#使用嵌入式模式" class="headerlink" title="使用嵌入式模式"></a>使用嵌入式模式</h4><h4 id="Neo4jSession"><a href="#Neo4jSession" class="headerlink" title="Neo4jSession"></a>Neo4jSession</h4><h4 id="Spring-Data-Neo4j仓库"><a href="#Spring-Data-Neo4j仓库" class="headerlink" title="Spring Data Neo4j仓库"></a>Spring Data Neo4j仓库</h4><h4 id="仓库示例"><a href="#仓库示例" class="headerlink" title="仓库示例"></a>仓库示例</h4><h3 id="Gemfire"><a href="#Gemfire" class="headerlink" title="Gemfire"></a>Gemfire</h3><h3 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h3><h4 id="连接到Solr"><a href="#连接到Solr" class="headerlink" title="连接到Solr"></a>连接到Solr</h4><h4 id="Spring-Data-Solr仓库"><a href="#Spring-Data-Solr仓库" class="headerlink" title="Spring Data Solr仓库"></a>Spring Data Solr仓库</h4><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><h4 id="使用Jest连接Elasticsearch"><a href="#使用Jest连接Elasticsearch" class="headerlink" title="使用Jest连接Elasticsearch"></a>使用Jest连接Elasticsearch</h4><h4 id="使用Spring-Data连接Elasticsearch"><a href="#使用Spring-Data连接Elasticsearch" class="headerlink" title="使用Spring Data连接Elasticsearch"></a>使用Spring Data连接Elasticsearch</h4><h4 id="Spring-Data-Elasticsearch-仓库"><a href="#Spring-Data-Elasticsearch-仓库" class="headerlink" title="Spring Data Elasticsearch 仓库"></a>Spring Data Elasticsearch 仓库</h4><h3 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h3><h4 id="连接到Cassandra"><a href="#连接到Cassandra" class="headerlink" title="连接到Cassandra"></a>连接到Cassandra</h4><h4 id="Spring-Data-Cassandra仓库"><a href="#Spring-Data-Cassandra仓库" class="headerlink" title="Spring Data Cassandra仓库"></a>Spring Data Cassandra仓库</h4><h3 id="Couchbase"><a href="#Couchbase" class="headerlink" title="Couchbase"></a>Couchbase</h3><h4 id="连接到Couchbase"><a href="#连接到Couchbase" class="headerlink" title="连接到Couchbase"></a>连接到Couchbase</h4><h4 id="Spring-Data-Couchbase仓库"><a href="#Spring-Data-Couchbase仓库" class="headerlink" title="Spring Data Couchbase仓库"></a>Spring Data Couchbase仓库</h4><h3 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h3><h4 id="连接到LDAP服务器"><a href="#连接到LDAP服务器" class="headerlink" title="连接到LDAP服务器"></a>连接到LDAP服务器</h4><h4 id="Spring-Data-LDAP仓库"><a href="#Spring-Data-LDAP仓库" class="headerlink" title="Spring Data LDAP仓库"></a>Spring Data LDAP仓库</h4><h4 id="嵌入式内存LDAP服务器"><a href="#嵌入式内存LDAP服务器" class="headerlink" title="嵌入式内存LDAP服务器"></a>嵌入式内存LDAP服务器</h4><h3 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h3><h4 id="连接到InfluxDB"><a href="#连接到InfluxDB" class="headerlink" title="连接到InfluxDB"></a>连接到InfluxDB</h4><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Spring Framework为透明地向应用程序添加缓存提供了支持。在其核心，抽象层将缓存应用于方法，从而减少基于缓存中可用信息的执行数量。缓存逻辑是透明地应用的，不会对调用程序产生任何干扰。只要通过@Enablecaching注解启用了缓存支持，Spring Boot就会自动配置缓存基础结构。</p>
<blockquote>
<p>查看Spring Framework文件<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/integration.html#cache">相关章节</a>获取更多信息。</p>
</blockquote>
<p>简而言之，将缓存添加到服务的操作中就像向其方法添加相关注释一样简单:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(&quot;piDecimals&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computePiDecimal</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例演示如何在可能代价高昂的操作中使用缓存。在调用<code>computePiDecimal</code>之前，抽象层会在<code>piDecimals</code>缓存中查找匹配参数<code>i</code>的实体。如果找到了，缓存中的内容会立即返回给调用方，并且不会调用这个方法。否则这个方法会被调用并且在返回值之前会更新缓存。</p>
<blockquote>
<p>也可以明确地使用标准的JSR-107（JCache）注解（比如<code>@CacheResult</code>）。我们强烈建议你不要把它们混在一起。</p>
</blockquote>
<p>如果没有添加具体的缓存库，Spring Boot将会自动配置一个简单的实现，它使用内存中的并发Map。当需要缓存时（如上面例子中的<code>piDecimals</code>），这个provider将为你即时创建它。简单的提供者并不推荐用于生产，但是对于入门并确保您了解这些特性是非常好的。当你已经决定要使用的缓存提供程序时，请一定要阅读它的文档，以确定如何配置你的应用程序使用的缓存。实际上，所有的提供者都要求你显式地配置应用程序中使用的每个缓存。有些提供了自定义spring.cache.cache-names属性定义的默认缓存的方法。</p>
<blockquote>
<p>也可以透明地<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/integration.html#cache-annotations-put">更新</a>或从缓存中<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/integration.html#cache-annotations-evict">删除</a>数据。</p>
</blockquote>
<blockquote>
<p>如果你使用的缓存基础设施不是基于接口的，那么确保启用了<code>@EnableCaching</code>的<code>proxyTargetClass</code>属性。</p>
</blockquote>
<h3 id="支持的缓存实现"><a href="#支持的缓存实现" class="headerlink" title="支持的缓存实现"></a>支持的缓存实现</h3><p>缓存抽象层没有提供实际的存储，依赖于<code>org.springframework.cache.Cache</code>和<code>org.springframework.cache.CacheManager</code>接口实现。</p>
<p>如果你没有定义<code>CacheManager</code>类型的或名为<code>cacheResolver</code>（查看<code>CachingConfigurer</code>）的<code>CacheResolver</code> bean，Spring Boot尝试加载下面的实现（按此顺序）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-generic">Generic</a></li>
<li><a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-jcache">JCache（JSR-107）</a>（EhCache 3，Hazelcast，Infinispan，etc）</li>
<li><a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-ehcache2">EhCache 2.x</a></li>
<li><a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-hazelcast">Hazelcast</a></li>
<li><a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-infinispan">Infinispan</a></li>
<li><a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-couchbase">Couchbase</a></li>
<li><a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-redis">Redis</a></li>
<li><a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-caffeine">Caffeine</a></li>
<li><a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-simple">Simple</a></li>
</ul>
<blockquote>
<p>也可以使用<code>spring.cache.type</code>属性强制使用缓存实现。如果您需要在某些环境中<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-none">完全禁用缓存</a>(例如测试)，那么可以使用该属性。</p>
</blockquote>
<blockquote>
<p>使用<code>spring-boot-starter-cache</code> “Starter”来快速添加基本的缓存依赖，这个starter引入了<code>spring-context-support</code>:如果是手动添加的依赖，为了使用JCache，EhCache 2.x或Guava支持，你必须得包含<code>spring-context-support</code>。</p>
</blockquote>
<p>如果Spring Boot自动配置了<code>CacheManager</code>，可以通过暴露一个实现了<code>CacheManagerCustomizer</code>接口的bean在<code>CacheManager</code>完全初始化之前进一步优化它的配置。下面的代码设置了一个标志，表示null值应该被传递到底层的map。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt; <span class="title">cacheManagerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConcurrentMapCacheManager cacheManager)</span> </span>&#123;</span><br><span class="line">            cacheManager.setAllowNullValues(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面的例子中，预计会自动配置一个<code>ConcurrentMapCacheManager</code>。如果不是这种情况(你提供了自己的配置，或者是自动配置了不同的缓存实现)，则不会调用customizer了。你可以提供很多个customizer并且可以使用常规的<code>@Order</code>或者<code>Ordered</code>来排序。</p>
</blockquote>
<h4 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h4><p>如果上下文中定义了不止一个<code>org.springframework.cache.Cache</code> bean，则使用通用缓存。<code>CacheManager</code>包装所有创建的这个类型的bean。</p>
<h4 id="JCache（JSR-107）"><a href="#JCache（JSR-107）" class="headerlink" title="JCache（JSR-107）"></a>JCache（JSR-107）</h4><p>JCache是通过类路径中存在<code>javax.cache.spi.CachingProvider</code>来加载的，<code>spring-boot-starter-cache</code> “starter” 提供了<code>JCacheCacheManager</code>。有很多兼容的库并且Spring Boot 提供了对Ehcache 3、Hazelcast和Infinispan的依赖管理。还可以添加任何其他兼容的库。</p>
<p>有可能会出现有多个提供者的情况，在这种情况下必须明确指定提供者。即使JSR-107标准没有强制定义配置文件的位置，但是Spring Boot尽最大可能来适应具体实现。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Only necessary if more than one provider is present</span></span><br><span class="line"><span class="meta">spring.cache.jcache.provider</span>=<span class="string">com.acme.MyCachingProvider</span></span><br><span class="line"><span class="meta">spring.cache.jcache.config</span>=<span class="string">classpath:acme.xml</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于缓存库有可能提供本地实现和JSR-107支持，Spring Boot将会优先选择JSR-107支持，因此如果你切换到不同的JSR-107实现，Spring Boot还是可以支持相同的功能。</p>
</blockquote>
<blockquote>
<p>Spring Boot 对<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-hazelcast">Hazelcast有一个通用的实现</a>。如果有一个单独的<code>HazelcastInstance</code>可用，它会自动地为<code>CacheManager</code>重用，除非指定<code>spring.cache.jcache.config</code>属性。</p>
</blockquote>
<p>还有一些方式来自定义底层的<code>javax.cache.cacheManager</code>:</p>
<ul>
<li>缓存可以在启动的时候通过<code>spring.cache.cache-names</code>属性来创建。如果定义了自已的<code>javax.cache.configuration.Configuration</code> bean ，将会用它来自定义它们。</li>
<li>CacheManager引用调用<code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code> bean 来进行完全定制。</li>
</ul>
<blockquote>
<p>如果定义了一个标准的<code>javax.cache.CacheManager</code> bean，它会自动被抽象层期望的<code>org.springframework.cache.CacheManager</code>实现包装。不进行进一步的定制。</p>
</blockquote>
<h4 id="EhCache-2-x"><a href="#EhCache-2-x" class="headerlink" title="EhCache 2.x"></a>EhCache 2.x</h4><p>如果在classpath的根目录上找到了<code>ehcache.xml</code>文件，那么将会使用EhCache 2.x。如果是EhCache 2.x，<code>spring-boot-starter-cache</code> “Starter”提供的<code>EhCacheCacheManager</code>和它提供的这个文件用来启动缓存管理器。也可以使用这种方式来提供可选的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.ehcache.config&#x3D;classpath:config&#x2F;another-config.xml</span><br></pre></td></tr></table></figure>

<h4 id="Hazelcast"><a href="#Hazelcast" class="headerlink" title="Hazelcast"></a>Hazelcast</h4><h4 id="Infinispan"><a href="#Infinispan" class="headerlink" title="Infinispan"></a>Infinispan</h4><h4 id="Couchbase-1"><a href="#Couchbase-1" class="headerlink" title="Couchbase"></a>Couchbase</h4><h4 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h4><p>如果Redis可用并且配置了，<code>RedisCacheManager</code>将会自动配置。还可以使用<code>spring.cache.cache-names</code>属性在启动时创建额外的缓存。</p>
<blockquote>
<p>在缺省情况下，添加了一个key的前缀，以防止如果两个单独的缓存使用相同的密钥，Redis将会有重叠的key，并可能会返回无效值的情况。如果你创建了自己的<code>RedisCacheManager</code>，我们强烈建议保持开启这个设置。</p>
</blockquote>
<h4 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h4><h4 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h4><p>如果没有发现其他的提供者，将会配置一个使用<code>ConcurrentHashMap</code>作为缓存存储的简单实现。如果应用没有提供缓存库，这将是默认配置。缓存默认是实时创建的，但是你可以使用<code>cache-names</code>属性限制可用的缓存列表。例如，如果你只想要<code>foo</code>和<code>bar</code>缓存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names&#x3D;foo,bar</span><br></pre></td></tr></table></figure>
<p>如果你这样做，你的应用程序使用一个未列出的缓存那么当需要缓存时，它会在运行时失败，但在启动时不会。如果你使用未声明的缓存，这与“真实”缓存提供者的行为方式类似。</p>
<h4 id="None"><a href="#None" class="headerlink" title="None"></a>None</h4><p>当你的配置中出现了@EnableCache时，也可以预期适当的缓存配置。如果在某些环境中需要禁用缓存，那么强制缓存类型为<code>none</code>，以使用无操作实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.type&#x3D;none</span><br></pre></td></tr></table></figure>

<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>Spring Framework 提供了集成消息系统的扩展支持：从简单地使用JMS API <code>JmsTemplate</code> 到完整的接收异步消息的架构。Spring AMQP为“Advanced Message Queuing Protocol”提供了一个类似的特性集并且Spring Boot也为<code>RabbitTemplate</code>和RabbitMQ提供配置自动配置选项。在Spring WebSocket中还原生支持STOMP的消息传递，Spring Boot通过starter和少量的自动配置支持这一点。Spring Boot 也支持Apache Kafka。</p>
<h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p><code>javax.jms.ConnectionFactory</code>接口提供了创建与JMS代理进行交互的<code>javax.jms.Connection</code>的标准方法。尽管Spring需要一个<code>ConnectionFactory</code>来与JMS一起工作，但是你通常不需要直接使用它并且可以依赖更高层次的消息抽象层（查看<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/integration.html#jms">Spring Framework的文档</a>获取更多细节）。Spring Boot 也自动配置必要的组件来发送与接收消息。</p>
<h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4><p>当Spring Boot在classpath中发现ActiveMQ时，也会配置一个<code>ConnectionFactory</code>。如果提供了代理，将启动一个嵌入式代理并且自动配置它（只要没有通过配置指定代理URL）。</p>
<blockquote>
<p>如果你使用了<code>spring-boot-starter-activemq</code>，则提供连接或嵌入ActiveMQ实例的必要依赖项，以及与JMS集成的Spring基础设施。</p>
</blockquote>
<p>ActiveMQ配置由<code>spring.activemq.*</code>中的外部配置属性控制。例如，你可以在<code>application.properties</code>中声明下面的语句：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.activemq.broker-url</span>=<span class="string">tcp://192.168.1.210:9876</span></span><br><span class="line"><span class="meta">spring.activemq.user</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.activemq.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
<p>你还可以通过添加<code>org.apache.activemq:activemq-pool</code>的依赖来使用JMS资源池，并相应地配置<code>PooledConnectionFactory</code>：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.activemq.pool.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.activemq.pool.max-connections</span>=<span class="string">50</span></span><br></pre></td></tr></table></figure>

<p>查看<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.java"><code>ActiveMQProperties</code></a>获取更多地的支持属性。</p>
<p>默认情况下，如果不存在destination ，ActiveMQ会创建一个，因此，destination 是根据它们提供的名称来解析的。</p>
<h4 id="Artemis"><a href="#Artemis" class="headerlink" title="Artemis"></a>Artemis</h4><p>如果Spring Boot 在classpath中发现了Artemis，则会自动配置<code>ConnectionFactory</code>。如果代理存在，则将自动启动并配置嵌入式代理(除非模式属性已显式设置)。支持的模式有:<code>embedded</code>（显式地指出需要使用嵌入式代理，并且在代理在类路径中不可用时导致错误）和<code>native</code>使用<code>netty</code>传输协议来连接代理。当配置后者时，Spring Boot 配置一个<code>ConnectionFactory</code>，使用默认设置连接到在本地机器上运行的代理。</p>
<blockquote>
<p>如果你使用了<code>spring-boot-starter-artemis</code>，将会提供连接已经存在的Artemis实例的必要依赖，以及与JMS集成的Spring基础组件。添加<code>org.apache.activemq:artemis-jms-server</code>到你的应用中允许你使用<code>embedded</code>模式。</p>
</blockquote>
<p>Artemis的配置是由在spring.artemis.*的外部配置属性控制的。例如，你可以在<code>application.properties</code>中声明以下代码：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.artemis.mode</span>=<span class="string">native</span></span><br><span class="line"><span class="meta">spring.artemis.host</span>=<span class="string">192.168.1.210</span></span><br><span class="line"><span class="meta">spring.artemis.port</span>=<span class="string">9876</span></span><br><span class="line"><span class="meta">spring.artemis.user</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.artemis.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>

<p>在嵌入代理时，你可以选择是否启用持久性，以及应该提供的destination列表。可以将它们指定为以逗号分隔的列表，以使用默认选项创建它们；或者你可以定义<code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code>或<code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code>类型的bean(s)，分别用于高级队列和主题配置。</p>
<p>查看<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.java"><code>ArtemisProperties</code></a> 获取更多支持的属性。</p>
<p>任何JNDI查找都不涉及到，destination都是根据它们的名称来解析的，或者在”Artemis “的配置中使用“name”属性，或者通过配置提供的名称。</p>
<h4 id="使用JNDI-ConnectionFactory"><a href="#使用JNDI-ConnectionFactory" class="headerlink" title="使用JNDI ConnectionFactory"></a>使用JNDI ConnectionFactory</h4><p>如果你在应用程序服务器中运行你的应用程序，Spring Boot将尝试使用JNDI来定位一个JMS <code>ConnectionFactory</code>。默认会检查<code>java:/JmsXA</code>和<code>java:/XAConnectionFactory</code>。你可以使用<code>spring.jms.jndi-name</code>属性来指定其他的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jms.jndi-name&#x3D;java:&#x2F;MyConnectionFactory</span><br></pre></td></tr></table></figure>

<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>Spring的<code>JmsTemplate</code>是自动配置的并且你可以直接注入到你的bean中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JmsTemplate jmsTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jmsTemplate = jmsTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>JmsMessagingTemplate</code>也可以以类似的方式注入。如果定义了<code>DestinationResolver</code>或<code>MessageConverter</code> bean，它们将自动关联到自动配置的<code>JmsTemplate</code>。</p>
</blockquote>
<h4 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h4><p>当JMS 基础组件存在时，任何bean都可以用 @JmsListener 注解来创建监听器端点。如果没有定义<code>JmsListenerContainerFactory</code> bean，会自动配置一个默认的。如果定义了<code>DestinationResolver</code>或<code>MessageConverter</code> bean，那么它们将自动与缺省工厂相关联。</p>
<p>默认的工厂默认是事务性的。如果你在一个<code>JtaTransactionManager</code>存在的基础结构中运行，那么默认情况下，它将与监听器容器相关联。如果不是的话，<code>sessionTransacted</code>标志将会启用。在后一种情况下，你可以将本地数据存储事务与传入消息的处理关联起来，方法是在listener方法(或其委托方法)上添加<code>@Transactional</code>。这将确保在本地事务完成后传入消息被确认。这还包括在相同JMS会话中执行的响应消息发送。</p>
<p>下面的组件在<code>someQueue</code>上创建了一个监听端点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;someQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/javadoc-api/org/springframework/jms/annotation/EnableJms.html"><code>@EnableJms</code>文档</a>查看更多细节。</p>
</blockquote>
<p>如果你需要创建更多的<code>JmsListenerContainerFactory</code>实例或者你想要覆盖默认的，Spring Boot提供了<code>DefaultJmsListenerContainerFactoryConfigurer</code>来实例化<code>DefaultJmsListenerContainerFactory</code>并且与自动配置的使用相同的设置。</p>
<p>例如，下面的内容展示了另一个使用特定<code>MessageConverter</code>的工厂:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactory <span class="title">myFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            DefaultJmsListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        DefaultJmsListenerContainerFactory factory =</span><br><span class="line">                <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">        configurer.configure(factory, connectionFactory());</span><br><span class="line">        factory.setMessageConverter(myMessageConverter());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以在任何<code>@JmsListener</code>注解的方法中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;someQueue&quot;, containerFactory=&quot;myFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>高级消息队列协议(AMQP)是面向消息中间件的一种平台无关的、线级协议(?)。Spring AMQP 项目Spring的核心概念应用到基于AMQP的消息解决方案的开发。Spring Boot提供了多种便利，可以通过RabbitMQ与AMQP进行合作，包括<code>spring-boot-starter-amqp</code> “Starter”。</p>
<h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>RabbitMQ是一种基于AMQP协议的轻量级的、可靠的、可伸缩的、可移植的消息代理。Spring使用RabbitMQ来使用AMQP协议进行通信。<br>RabbitMQ配置由<code>spring.rabbitmq.*</code>中的外部配置属性控制。例如，可以在<code>application.properties</code>中声明以下代码：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
<p>请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java"><code>RabbitProperties</code></a>获得更多受支持的选项。</p>
<blockquote>
<p>查看<a target="_blank" rel="noopener" href="http://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/">理解AMQP，RabbitMQ使用的协议</a>了解更多细节</p>
</blockquote>
<h4 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h4><p>Spring的 <code>AmqpTemplate</code> 和 <code>AmqpAdmin</code> 是自动配置的,你可以自动装配他们到自己的 bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpAdmin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AmqpAdmin amqpAdmin;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amqpAdmin = amqpAdmin;</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate = amqpTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>RabbitMessagingTemplate</code>可以以类似的方式注入。如果定义了<code>MessageConverter</code>  bean，那么它将自动与自动配置的<code>AmqpTemplate</code>相关联。</p>
</blockquote>
<p>任何<code>org.springframework.amqp.core.Queue</code>定义为bean的队列将在必要时自动用于在RabbitMQ实例上声明一个对应的队列。</p>
<p>你可以启用<code>AmqpTemplate</code>上的重试来重试操作，例如在丢失代理连接的事件中。默认情况下，重试是禁用的。</p>
<h4 id="接收消息-1"><a href="#接收消息-1" class="headerlink" title="接收消息"></a>接收消息</h4><p>当Rabbit组件存在时，任何bean都可以用<code>@RabbitListener</code>注解来创建一个监听器端点。如果没有定义<code>RabbitListenerContainerFactory</code>,默认自动配置<code>SimpleRabbitListenerContainerFactory</code>,并且你可以使用<code>spring.rabbitmq.listener.type</code>属性切换到一个直接的容器。如果定义了<code>MessageConverter</code>或<code>MessageRecoverer</code> bean，那么它们将自动与缺省工厂相关联。</p>
<p>下面的组件在<code>someQueue</code>队列上创建一个监听器端点:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;someQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请查看<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-amqp/docs/current/api/org/springframework/amqp/rabbit/annotation/EnableRabbit.html"><code>@EnableRabbit</code>的Javadoc</a>以获得更多详细信息。</p>
</blockquote>
<p>如果你需要创建多个<code>RabbitListenerContainerFactory</code>实例或者你想覆盖默认的,Spring Boot提供了<code>SimpleRabbitListenerContainerFactoryConfigurer</code>和<code>DirectRabbitListenerContainerFactoryConfigurer</code>,你可以用它来初始化一个<code>SimpleRabbitListenerContainerFactory</code>和<code>DirectRabbitListenerContainerFactory</code>,并且与自动配置的使用相同的设置。</p>
<blockquote>
<p>不管选择哪种容器类型，这两个bean都是由自动配置公开的。</p>
</blockquote>
<p>例如，下面的内容展示了另一个使用特定<code>MessageConverter</code>的工厂:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">myFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            SimpleRabbitListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory =</span><br><span class="line">                <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        configurer.configure(factory, connectionFactory);</span><br><span class="line">        factory.setMessageConverter(myMessageConverter());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你可以在任何 @RabbitListener 注解的方法中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;someQueue&quot;, containerFactory=&quot;myFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以启用重试来处理监听器抛出异常的情况。默认情况下使用<code>RejectAndDontRequeueRecoverer</code>但是你可以定义一个自己的<code>MessageRecoverer</code>。当重试耗尽时，消息将被拒绝，并且被丢弃或者如果代理配置了交换，则消息将路由到死信交换。默认情况下，重试是禁用的。</p>
<blockquote>
<p><strong>如果没启用重试，侦听器抛出异常，默认情况下，将为无限重试分发。你可以通过两种方式来修改该行为;将<code>defaultRequeueRejected</code>属性设置为<code>false</code>，并尝试零重新交付;或者,抛出<code>AmqpRejectAndDontRequeueException</code>表示该消息应该被拒绝。这是在启用重试并且达到了最大的交付尝试时所使用的机制</strong></p>
</blockquote>
<h3 id="Apache-Kafka"><a href="#Apache-Kafka" class="headerlink" title="Apache Kafka"></a>Apache Kafka</h3><p>通过提供<code>spring-kafka</code>项目的自动配置来支持<a target="_blank" rel="noopener" href="http://kafka.apache.org/"><code>Apache Kafka</code></a>。</p>
<p>Kafka 的配置由<code>spring.kafka.*</code>的外部配置属性控制。例如，你可以在<code>application.properties</code>中声明以下部分:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.bootstrap-servers</span>=<span class="string">localhost:9092</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.group-id</span>=<span class="string">myGroup</span></span><br></pre></td></tr></table></figure>
<p>更多受支持的选项，请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.java"><code>KafkaProperties</code></a>。</p>
<h4 id="发送消息-2"><a href="#发送消息-2" class="headerlink" title="发送消息"></a>发送消息</h4><p>Spring的<code>KafkaTemplate</code>是自动配置的，你可以直接在你自己的bean中注入它们:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(KafkaTemplate kafkaTemplate)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.kafkaTemplate = kafkaTemplate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="接收消息-2"><a href="#接收消息-2" class="headerlink" title="接收消息"></a>接收消息</h4><p>当Apache Kafka基础组件存在时，任何bean都可以用@卡夫卡式的注解来创建一个监听器端点。如果没有定义<code>KafkaListenerContainerFactory</code>,会自动配置一个默认的，并且key定义在<code>spring.kafka.listener.*</code>中。</p>
<p>以下组件在<code>someTopic</code>主题上创建一个监听器端点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;someTopic&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="额外的Kafka属性"><a href="#额外的Kafka属性" class="headerlink" title="额外的Kafka属性"></a>额外的Kafka属性</h4><p>自动配置支持的属性在<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#common-application-properties">附录A，通用应用程序属性</a>中可以查看。请注意，这些属性大部分(连字符或驼峰形式)都直接映射到Apache Kafka的点状属性，请参阅Apache Kafka文档以获得详细信息。</p>
<p>这些属性的前几项都适用于生产者和消费者，但如果希望使用不同的值，则可以在生产者或消费者级别指定。Apache Kafka指定了具有重要性的属性：HIGH，MEDIUM和LOW。Spring Boot自动配置支持所有HIGH重要性的属性，一些选择的MEDIUM和LOW，以及任何没有默认值的属性。</p>
<p>Kafka 所支持的属性中只有一个子集可以通过<code>KafkaProperties</code>类来获得。如果你希望配置没有直接支持的生产者或消费者的附加属性，请使用以下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.properties.foo.bar&#x3D;baz</span><br><span class="line">spring.kafka.consumer.properties.fiz.buz&#x3D;qux</span><br><span class="line"># 这里应该是.吧？</span><br><span class="line">spring,kafka.producer.properties.baz.qux&#x3D;fiz </span><br></pre></td></tr></table></figure>

<p>这设置了普通的<code>foo.bar</code> Kafka 属性为<code>baz</code>(适用于生产者和消费者)，消费者<code>fiz.buz</code>属性为<code>qux</code>和生产者<code>baz.qux</code>属性为<code>fiz</code>。</p>
<blockquote>
<p><strong>以这种方式设置的属性将覆盖Spring Boot 显式支持的任何配置项。</strong></p>
</blockquote>
<h2 id="使用“RestTemplate”-调用REST-服务"><a href="#使用“RestTemplate”-调用REST-服务" class="headerlink" title="使用“RestTemplate” 调用REST 服务"></a>使用“RestTemplate” 调用REST 服务</h2><p>如果需要在应用程序中调用远程REST服务，那么可以使用Spring Framework的<code>RestTemplate</code>类。由于<code>RestTemplate</code>实例通常需要在被使用之前进行定制，所以Spring Boot 不提供任何单独的自动配置的<code>RestTemplate</code> bean。但是，它可以自动配置一个<code>RestTemplateBuilder</code>，当需要时可以使用它创建<code>RestTemplate</code>实例。自动配置的<code>RestTemplateBuilder</code>将确保将合理的<code>HttpMessageConverters</code>应用于<code>RestTemplate</code>实例。</p>
<p>下面是一个典型的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(RestTemplateBuilder restTemplateBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplateBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Details <span class="title">someRestCall</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">&quot;/&#123;name&#125;/details&quot;</span>, Details.class, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>RestTemplateBuilder</code>包含许多有用的方法，这些方法可用于快速配置<code>RestTemplate</code>。例如，要添加基本的身份验证支持，你可以使用<code>builder.basicAuthorization(&quot;user&quot;, &quot;password&quot;).build()</code>。</p>
</blockquote>
<h3 id="定制RestTemplate"><a href="#定制RestTemplate" class="headerlink" title="定制RestTemplate"></a>定制RestTemplate</h3><p><code>RestTemplate</code>定制主要有三种方法，这取决于你希望定制的范围有多大。</p>
<p>要使任何定制的范围尽可能窄，只需插入自动配置的<code>RestTemplateBuilder</code>，然后根据需要调用它的方法就行了。每个方法调用都返回一个新的<code>RestTemplateBuilder</code>实例，因此定制只会影响该构建器的使用。为了在应用层面定制，可以使用额外的定制化定制一个<code>RestTemplateCustomizer</code> bean。所有这些bean都将自动注册到自动配置的<code>RestTemplateBuilder</code>中，并将应用于使用它构建的任何模板。</p>
<p>下面是一个定制化器的例子，它配置了除192.168.0.5之外的所有主机使用代理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCustomizer</span> <span class="keyword">implements</span> <span class="title">RestTemplateCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        HttpHost proxy = <span class="keyword">new</span> HttpHost(<span class="string">&quot;proxy.example.com&quot;</span>);</span><br><span class="line">        HttpClient httpClient = HttpClientBuilder.create()</span><br><span class="line">                .setRoutePlanner(<span class="keyword">new</span> DefaultProxyRoutePlanner(proxy) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> HttpHost <span class="title">determineProxy</span><span class="params">(HttpHost target,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HttpRequest request, HttpContext context)</span></span></span><br><span class="line"><span class="function">                                    <span class="keyword">throws</span> HttpException </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (target.getHostName().equals(<span class="string">&quot;192.168.0.5&quot;</span>)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.determineProxy(target, request, context);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;).build();</span><br><span class="line">        restTemplate.setRequestFactory(</span><br><span class="line">                <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，最极端的(也是很少使用的)选择是创建你自己的<code>RestTemplateBuilder</code> bean。这将关闭<code>RestTemplateBuilder</code>的自动配置，并防止使用任何<code>RestTemplateCustomizer</code> bean。</p>
<h2 id="使用“WebClient”-调用REST-服务"><a href="#使用“WebClient”-调用REST-服务" class="headerlink" title="使用“WebClient” 调用REST 服务"></a>使用“WebClient” 调用REST 服务</h2><h3 id="定制WebClient"><a href="#定制WebClient" class="headerlink" title="定制WebClient"></a>定制WebClient</h3><h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><p>只要在类路径上发现JSR-303的实现(例如Hibernate validator)就会自动启用Bean校验1.1支持的方法校验特性。这允许在bean方法的参数和/或返回值上使用<code>javax.valication</code>约束注解。有这些注解的方法的目标类需要在类级别上用<code>@Validated</code>注解进行注解，因为内联约束注解需要搜索它们的方法。</p>
<p>例如，以下服务触发第一个参数的验证，确保它的大小在8到10之间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Archive <span class="title">findByCodeAndAuthor</span><span class="params">(<span class="meta">@Size(min = 8, max = 10)</span> String code,</span></span></span><br><span class="line"><span class="function"><span class="params">            Author author)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="邮件发送"><a href="#邮件发送" class="headerlink" title="邮件发送"></a>邮件发送</h2><p>Spring框架为使用<code>JavaMailSender</code>接口发送电子邮件提供了一种简单的抽象，Spring Boot 为它提供了自动配置以及启动模块。</p>
<blockquote>
<p>查看<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/integration.html#mail">参考文档</a>以了解如何使用<code>JavaMailSender</code>的详细说明</p>
</blockquote>
<p>如果spring.mail.host和相关的库(如spring-boot-starter-mail所定义的)可用，如果不存在，就会创建一个默认的JavaMailSender。sender可以通过<code>spring.mail</code>命名空间中的配置项进一步定制，查看<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java"><code>MailProperties</code></a>以获得更多细节。</p>
<p>特别是，某些默认的超时值是无限的，你可能想要更改它，以避免被无响应的邮件服务器阻塞线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.properties.mail.smtp.connectiontimeout&#x3D;5000</span><br><span class="line">spring.mail.properties.mail.smtp.timeout&#x3D;3000</span><br><span class="line">spring.mail.properties.mail.smtp.writetimeout&#x3D;5000</span><br></pre></td></tr></table></figure>

<h2 id="JTA-分布式事务"><a href="#JTA-分布式事务" class="headerlink" title="JTA 分布式事务"></a>JTA 分布式事务</h2><p>Spring Boot通过使用Atomikos或Bitronix嵌入式事务管理器来支持跨多个XA资源的分布式JTA事务。在部署到合适的Java EE应用服务器时，JTA事务也得到了支持。当检测到JTA环境时，将使用Spring的<code>JtaTransactionManager</code>来管理事务。将对自动配置的JMS、数据源和JPA bean进行升级，以支持XA事务。你可以使用诸如<code>@Transactional</code>之类的标准Spring 方式来参与分布式事务。如果你在一个JTA环境中，并且仍然希望使用本地事务，那么你可以设置<code>spring.jta.enabled</code>属性设置为<code>false</code>来禁用JTA自动配置。</p>
<h3 id="使用Atomikos-事务管理器"><a href="#使用Atomikos-事务管理器" class="headerlink" title="使用Atomikos 事务管理器"></a>使用Atomikos 事务管理器</h3><p>Atomikos是一个流行的开源事务管理器，可以嵌入到Spring Boot应用程序中。你可以使用<code>spring-boot-starter-jta-atomikos</code> Starter来获取适当的Atomikos库。Spring Boot将自动配置Atomikos，并确保将适当的<code>depends-on</code>设置应用到你的Spring bean上，以正确的启动和关闭顺序。</p>
<p>在缺省情况下，Atomikos事务日志将被写入到应用程序主目录(应用程序jar文件所在的目录)的<code>transaction-logs</code>目录中。你可以通过在<code>application.properties</code>文件中设置一个<code>spring.jta.log-dir</code>属性来定制这个目录。<code>spring.jta.atomikos.properties</code>开始的属性也可以用来定制于Atomikos <code>UserTransactionServiceImp</code>。请参阅<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/jta/atomikos/AtomikosProperties.html"><code>AtomikosProperties</code> Javadoc</a>以获得完整的详细信息。</p>
<blockquote>
<p>为了确保多个事务管理器能够安全地协调相同的资源管理器，每个Atomikos实例必须配置一个惟一的ID，默认情况下，这个ID是Atomikos正在运行的机器的IP地址。为了确保产品的唯一性，你应该为应用程序的每个实例配置<code>spring.jta.transaction-manager-id</code>属性使用不同的值。</p>
</blockquote>
<h3 id="使用Bitronix-事务管理器"><a href="#使用Bitronix-事务管理器" class="headerlink" title="使用Bitronix 事务管理器"></a>使用Bitronix 事务管理器</h3><h3 id="使用Narayana-事务管理器"><a href="#使用Narayana-事务管理器" class="headerlink" title="使用Narayana 事务管理器"></a>使用Narayana 事务管理器</h3><h3 id="使用Java-EE管理的事务管理器"><a href="#使用Java-EE管理的事务管理器" class="headerlink" title="使用Java EE管理的事务管理器"></a>使用Java EE管理的事务管理器</h3><h3 id="混合XA和非XA-JMS连接"><a href="#混合XA和非XA-JMS连接" class="headerlink" title="混合XA和非XA JMS连接"></a>混合XA和非XA JMS连接</h3><h3 id="支持另一个嵌入式事务管理器"><a href="#支持另一个嵌入式事务管理器" class="headerlink" title="支持另一个嵌入式事务管理器"></a>支持另一个嵌入式事务管理器</h3><h2 id="Hazelcast-1"><a href="#Hazelcast-1" class="headerlink" title="Hazelcast"></a>Hazelcast</h2><h2 id="Quartz-Scheduler"><a href="#Quartz-Scheduler" class="headerlink" title="Quartz Scheduler"></a>Quartz Scheduler</h2><p>Spring引导为使用Quartz调度器提供了几项便利，包括<code>spring-boot-starter-quartz</code> ‘Starter’。如果可以使用Quartz，则将自动配置一个<code>Scheduler</code>(通过<code>SchedulerFactoryBean</code>抽象层)。</p>
<p>以下类型的bean将被自动获取并与<code>Scheduler</code>关联:</p>
<ul>
<li><code>JobDetail</code>:定义了一个特定的Job。<code>JobDetail</code>实例可以通过<code>JobBuilder </code>API轻松构建。</li>
<li><code>Calendar</code></li>
<li><code>Trigger</code>:定义特定job何时触发。</li>
</ul>
<p>默认情况下，将使用一个内存中的<code>JobStore</code>。但是，如果你的应用程序中有<code>DataSource </code> bean和配置了<code>spring.quartz.job-store-type</code>属性，则可以配置一个基于jdbc的存储:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.quartz.job-store-type&#x3D;jdbc</span><br></pre></td></tr></table></figure>
<p>当使用jdbc存储时,可以在启动时初始化相关表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.quartz.jdbc.initialize-schema &#x3D; true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>默认情况下会检测到数据库，并使用Quartz库提供的标准脚本进行初始化。还可以使用<code>spring.quartz.jdbc.schema</code>属性提供自定义脚本。</p>
</blockquote>
<p>Quartz调度器的配置可以使用Quartz 配置属性(参见<code>spring.quartz.properties.*</code>)和允许编程式定制<code>SchedulerFactoryBean</code>的<code>SchedulerFactoryBeanCustomizer</code> bean。</p>
<p>Job可以定义set方法来注入数据映射属性。常规bean也可以以类似的方式注入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject &quot;MyService&quot; bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyService</span><span class="params">(MyService myService)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject the &quot;name&quot; job data property</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Integration"><a href="#Spring-Integration" class="headerlink" title="Spring Integration"></a>Spring Integration</h2><p>Spring Boot为使用Spring Integration提供了一些方便，包括<code>spring-boot-starter-integration</code>‘Starter’。Spring Integration为消息传递提供了抽象，还提供了HTTP、TCP等其他传输协议。如果你的类路径上有Spring Integration，它将通过<code>@EnableIntegration</code>注解进行初始化。</p>
<p>Spring Boot还将配置一些由附加的Spring Integration模块所触发的特性。如果“spring-integration-jmx”也在类路径上，消息处理统计信息将在JMX上发布。如果“spring-integration-jdbc”可用，则可以在启动时创建默认的数据库表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.integration.jdbc.initializer.enabled&#x3D;true</span><br></pre></td></tr></table></figure>
<p>查看<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationAutoConfiguration.java"><code>IntegrationAutoConfiguration</code></a> 和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationProperties.java"><code>IntegrationProperties</code></a>类了解更多的细节。</p>
<h2 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h2><p>Spring Boot为许多存储提供了Spring Session 自动配置:</p>
<ul>
<li>JDBC</li>
<li>Redis</li>
<li>Hazelcast</li>
<li>HashMap</li>
</ul>
<p>如果可以使用Spring Session ，那么你必须选择你希望使用的<code>StoreType</code>来存储会话。例如，使用JDBC作为后端存储，您可以将应用程序配置为如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.session.store-type&#x3D;jdbc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你可以通过将<code>store-type</code>设置为<code>none</code>来禁用Spring Session。</p>
</blockquote>
<p>每种存储都有特定的附加设置。例如，可以为jdbc存储定制表的名称:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.session.jdbc.table-name&#x3D;SESSIONS</span><br></pre></td></tr></table></figure>

<h2 id="JMX监视和管理"><a href="#JMX监视和管理" class="headerlink" title="JMX监视和管理"></a>JMX监视和管理</h2><p>Java管理扩展(JMX)提供了一种监视和管理应用程序的标准机制。在默认情况下，Spring Boot将创建一个bean id为‘mbeanServer’的<code>MBeanServer</code>，并公开任何使用Spring JMX注解注解的bean(<code>@ManagedResource</code>、<code>@ManagedAttribute</code>、<code>@ManagedOperation</code>)。</p>
<p>有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java"><code>JmxAutoConfiguration</code></a>类。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Spring Boot提供了许多实用程序和注释，以便在测试应用程序时提供帮助。测试支持由两个模块提供;<code>spring-boot-test</code>包含核心项目，<code>spring-boot-test-autoconfigure</code>支持测试的自动配置。</p>
<p>大多数开发人员只会使用<code>spring-boot-starter-test</code> “Starter”，它既引入了Spring Boot测试模块，也引用了JUnit、AssertJ、Hamcrest和其他一些有用的库。</p>
<h3 id="测试范围的依赖"><a href="#测试范围的依赖" class="headerlink" title="测试范围的依赖"></a>测试范围的依赖</h3><p>如果你使用<code>spring-boot-starter-test</code>‘Starter(在<code>test``scope</code>)，你将会找到以下所提供的库：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://junit.org/">JUnit</a> - Java应用程序单元测试的实际标准</li>
<li><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/testing.html#integration-testing">Spring Test</a>和Spring Boot Test - Spring Boot应用程序的实用工具和集成测试支持</li>
<li><a target="_blank" rel="noopener" href="http://joel-costigliola.github.io/assertj/">AssertJ</a> - 流式的断言库</li>
<li><a target="_blank" rel="noopener" href="http://hamcrest.org/JavaHamcrest/">Hamcrest</a> - 一个对象匹配库(也称为约束或谓词)。</li>
<li><a target="_blank" rel="noopener" href="http://mockito.org/">Mockito</a> - 一个Java mocking框架。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/skyscreamer/JSONassert">JSONassert</a> - 一个用于JSON的断言库。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/jayway/JsonPath">JsonPath</a> - JSON的XPath库</li>
</ul>
<h3 id="测试Spring应用"><a href="#测试Spring应用" class="headerlink" title="测试Spring应用"></a>测试Spring应用</h3><p>依赖注入的一个主要优点是，它应该使你的代码更容易进行单元测试。你可以使用<code>new</code>操作符简单地实例化对象，而不需要涉及Spring。还可以使用<em>模拟对象</em>而不是实际依赖项。</p>
<p>通常，你需要跨过“单元测试”，并开始“集成测试”(Spring ApplicationContext实际上涉及到了这个过程)。在不需要部署应用程序或需要连接到其他组件的情况下，能够执行集成测试是很有用的。</p>
<p>Spring Framework包含一个专用的测试模块，用于进行这样的集成测试。你可以直接声明依赖项<code>org.springframework:spring-test</code>或使用<code>spring-boot-starter-test</code> “Starter”来传递依赖。</p>
<p>如果你之前没有使用过<code>Spring-test</code>模块，你应该阅读<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/testing.html#testing">Spring Framework参考文档</a>的相关部分。</p>
<h3 id="测试Spring-Boot应用"><a href="#测试Spring-Boot应用" class="headerlink" title="测试Spring Boot应用"></a>测试Spring Boot应用</h3><p>Spring Boot 应用程序只是一个Spring ApplicationContext，所以没有什么特别的事情需要做来测试超出了你通常使用的Spring上下文的范围的部分。需要注意的一件事是，如果你使用<code>SpringApplication</code>来创建它，那么Spring Boot的外部属性、日志记录和其他特性在默认情况下是默认安装的。</p>
<p>Spring Boot提供了一个<code>@SpringBootTest</code>注解 ，当你需要Spring Boot特性时，它可以作为标准<code>spring-test``@ContextConfiguration</code>注释的替代品。该注解通过在<code>SpringApplication</code>中创建<code>ApplicationContext </code>来工作。</p>
<p>你可以使用<code>@SpringBootTest</code>的 <code>webEnvironment</code>属性来进一步细化你的测试将如何运行:</p>
<ul>
<li><code>MOCK</code> - 加载一个<code>WebApplicationContext</code>并提供一个模拟servlet环境。在使用该注解时，不会启动嵌入式servlet容器。如果在你的类路径中不存在servlet api，该模式将透明地返回创建常规的非web <code>ApplicationContext</code>。可以与<code>@AutoConfigureMockMvc</code> 一起使用基于<code>MockMvc</code>的应用程序测试。</li>
<li><code>RANDOM_PORT</code> - 加载一个<code>ServletWebServerApplicationContext</code>和提供了一个真正的servlet环境。嵌入式的servlet容器将被启动并在一个随机的端口上监听。</li>
<li><code>DEFINED_PORT</code> - 加载一个<code>ServletWebServerApplicationContext</code>和提供了一个真正的servlet环境。嵌入的servlet容器将被启动并监听一个已定义的端口(例如在你的<code>application.properties</code>或默认端口<code>8080</code>)。</li>
<li><code>NONE</code> - 使用<code>SpringApplication</code>加载一个<code>ApplicationContext</code>，但是不提供<em>任何</em>servlet环境(模拟或其他)。</li>
</ul>
<blockquote>
<p>如果你的测试是<code>@Transactional</code>，它将在默认情况下在每个测试方法结束时回滚事务。如果你将此设置与<code>RANDOM_PORT </code>或<code>DEFINED_PORT</code>结合使用，那么在服务器上启动的任何事务都不会回滚，因为测试运行在不同的线程中，而不是服务器处理。</p>
</blockquote>
<blockquote>
<p>除了<code>@SpringBootTest</code> 而外，还提供了一些其他的注解，用于测试应用程序的特定部分。详情见下文。</p>
</blockquote>
<blockquote>
<p>不要忘记将@RunWith(SpringRunner.class)添加到你的测试中，否则注解将被忽略。</p>
</blockquote>
<h4 id="检测测试配置"><a href="#检测测试配置" class="headerlink" title="检测测试配置"></a>检测测试配置</h4><p>如果你熟悉Spring Test Framework，则可以使用<code>@ContextConfiguration(classes=...)</code>来指定要加载哪个Spring <code>@Configuration</code>。或者，你可能经常在测试中使用嵌套的<code>@Configuration</code>类。</p>
<p>在测试Spring Boot应用程序时，通常不需要这样做。Spring Boot的<code>@*Test</code>注解将自动搜索你的主配置，只要您不显式地定义一个配置。</p>
<p>搜索算法在包含测试的包中起作用，直到找到一个<code>@SpringBootApplication</code>或<code>@SpringBootConfiguration </code>注解的类。只要你以一种合理的方式构造你的代码，你的主配置通常就会被发现。如果你想要定制主配置，你可以使用一个嵌套的<code>@TestConfiguration </code>类。不像一个嵌套的<code>@Configuration </code>类，它将代替应用程序的主要配置，一个嵌套的<code>@TestConfiguration </code>类将被用于应用程序的主要配置。</p>
<blockquote>
<p>Spring的测试框架将在测试之间缓存应用程序上下文。因此，只要你的测试共享相同的配置(不管它是如何被发现的)，加载上下文的潜在时间消耗过程只会发生一次。</p>
</blockquote>
<h4 id="排除测试配置"><a href="#排除测试配置" class="headerlink" title="排除测试配置"></a>排除测试配置</h4><p>如果你的应用程序使用组件扫描，例如，如果您使用<code>@SpringBootApplication </code>或<code>@ComponentScan</code>，那么你可能会发现仅为特定测试而创建的顶级配置类意外地在各处被发现。</p>
<p>正如我们已经看到的，<code>@TestConfiguration </code>可以用于测试的内部类以定制主配置。当被放置在顶级类上时，<code>@TestConfiguration </code>表示<code>src/test/java</code>中的类不应该通过扫描来获取。然后，可以显式地导入该类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Import(MyTestsConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你直接使用<code>@ComponentScan</code>(即不是通过<code>@SpringBootApplication</code>)，你将需要使用它注册<code>TypeExcludeFilter</code>。请参阅<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/context/TypeExcludeFilter.html">Javadoc</a>以获得详细信息。</p>
</blockquote>
<h4 id="使用随机端口"><a href="#使用随机端口" class="headerlink" title="使用随机端口"></a>使用随机端口</h4><p>如果你需要为测试启动一个完整的运行服务器，我们建议你使用随机端口。如果你使用的是<code>@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)</code>，你的测试运行时将随机选择一个可用的端口。</p>
<p>可以使用<code>@LocalServerPort</code>注解来将实际的<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-discover-the-http-port-at-runtime">端口注入</a>到你的测试中。为方便起见，需要对启动服务器进行REST调用的测试可以另外使用<code>@Autowire</code>一个<code>TestRestTemplate</code>，它将解析与运行的服务器的相对链接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.web.client.TestRestTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomPortExampleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TestRestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String body = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">&quot;/&quot;</span>, String.class);</span><br><span class="line">		assertThat(body).isEqualTo(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模拟和监视-bean"><a href="#模拟和监视-bean" class="headerlink" title="模拟和监视 bean"></a>模拟和监视 bean</h4><p>在运行测试时，有时需要模拟应用程序上下文中的某些组件。例如，在开发期间，你可能会对一些不可用的远程服务有一个facade。当你想要模拟在真实环境中可能很难触发的故障时，mock也会很有用。</p>
<p>Spring Boot包含一个<code>@MockBean </code>注解，它可用于在<code>ApplicationContext</code>中定义一个bean的Mockito 模拟。你可以使用注解来添加新的bean，或者替换一个现有的bean定义。注解可以直接用于测试类、测试中的字段或`@Configuration``类和字段。当在一个字段中使用时，也将对创建的模拟实例进行注入。模拟bean在每个测试方法之后自动重置。</p>
<blockquote>
<p>只要你的测试使用了Spring Boot的一个测试注解(也就是<code>@SpringBootTest</code>)，这个特性就会自动启用。为了使用不同的配置，需要显式地添加监听器:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@TestExecutionListeners(MockitoTestExecutionListener.class)</span><br></pre></td></tr></table></figure>

<p>这里有一个典型的例子，我们用一个模拟实现来替换一个现有的<code>RemoteService</code> bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> RemoteService remoteService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Reverser reverser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// RemoteService has been injected into the reverser bean</span></span><br><span class="line">        given(<span class="keyword">this</span>.remoteService.someCall()).willReturn(<span class="string">&quot;mock&quot;</span>);</span><br><span class="line">        String reverse = reverser.reverseSomeCall();</span><br><span class="line">        assertThat(reverse).isEqualTo(<span class="string">&quot;kcom&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，你还可以使用<code>@SpyBean </code>将任何现有的bean包装成一个Mockito <code>spy</code>。请参阅Javadoc以获得完整的详细信息。</p>
<h4 id="自动配置测试"><a href="#自动配置测试" class="headerlink" title="自动配置测试"></a>自动配置测试</h4><p>Spring Boot的自动配置系统适用于应用程序，但有时对测试来说有点太大了。只加载需要测试应用程序“切片”的配置部分通常是有帮助的。例如，你可能想要测试Spring MVC控制器是否正确地映射到url，并且你不希望在这些测试中涉及到数据库调用;或者你<em>可能想要</em>测试JPA实体，并且当这些测试运行时，你对web层不感兴趣。</p>
<p><code>spring-boot-test-autoconfigure</code>模块包含许多注解，可用于自动配置这些“切片”。它们中的每一个都以类似的方式工作，提供了一个<code>@…Test</code>注解，它加载了<code>ApplicationContext</code>和一个或多个可用于定制自动配置设置的<code>@AutoConfigure...</code>注解。</p>
<blockquote>
<p>每个切片都加装一组非常受限制的自动配置类。如果你需要排除其中的一个，那么大多数<code>@…Test</code>注解提供了一个<code>excludeAutoConfiguration </code>属性。或者,你可以使用<code>@ImportAutoConfiguration#exclude</code>。</p>
</blockquote>
<blockquote>
<p>还可以使用<code>@AutoConfigure..</code>注解和标准的<code>@SpringBootTest</code>注解。如果你对“切片”应用程序不感兴趣但是你需要一些自动配置的测试bean，你可以使用这种组合。</p>
</blockquote>
<h4 id="自动配置JSON测试"><a href="#自动配置JSON测试" class="headerlink" title="自动配置JSON测试"></a>自动配置JSON测试</h4><p>要测试对象JSON序列化和反序列化，你可以使用<code>@JsonTest</code>注释。<code>@JsonTest</code>将自动配置Jackson <code>ObjectMapper</code>、任何<code>@JsonComponent</code> bean和任何Jackson <code>Modules</code>。它也会对<code>Gson</code>进行配置，如果你碰巧用的不是杰克逊。如果你需要配置自动配置的元素，你可以使用<code>@AutoConfigureJsonTesters</code>注解。</p>
<p>Spring Boot包括基于AssertJ 的Helper，与JSONassert和JsonPath库一起工作，以检查JSON是否符合预期。<code>JacksonTester</code>、<code>GsonTester</code>和<code>BasicJsonTester</code>类可以分别用于Jackson、Gson和字符串。在使用<code>@JsonTest</code>时，测试类上的任何helper字段都可以<code>@Autowired</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.json.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.json.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@JsonTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJsonTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JacksonTester&lt;VehicleDetails&gt; json;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSerialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        VehicleDetails details = <span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Civic&quot;</span>);</span><br><span class="line">        <span class="comment">// Assert against a `.json` file in the same package as the test</span></span><br><span class="line">        assertThat(<span class="keyword">this</span>.json.write(details)).isEqualToJson(<span class="string">&quot;expected.json&quot;</span>);</span><br><span class="line">        <span class="comment">// Or use JSON path based assertions</span></span><br><span class="line">        assertThat(<span class="keyword">this</span>.json.write(details)).hasJsonPathStringValue(<span class="string">&quot;@.make&quot;</span>);</span><br><span class="line">        assertThat(<span class="keyword">this</span>.json.write(details)).extractingJsonPathStringValue(<span class="string">&quot;@.make&quot;</span>)</span><br><span class="line">                .isEqualTo(<span class="string">&quot;Honda&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeserialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;&#123;\&quot;make\&quot;:\&quot;Ford\&quot;,\&quot;model\&quot;:\&quot;Focus\&quot;&#125;&quot;</span>;</span><br><span class="line">        assertThat(<span class="keyword">this</span>.json.parse(content))</span><br><span class="line">                .isEqualTo(<span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Ford&quot;</span>, <span class="string">&quot;Focus&quot;</span>));</span><br><span class="line">        assertThat(<span class="keyword">this</span>.json.parseObject(content).getMake()).isEqualTo(<span class="string">&quot;Ford&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JSON helper类也可以直接在标准单元测试中使用。如果没有使用<code>@JsonTest</code>，只需在<code>@Before</code>方法中调用helper的<code>initFields</code>方法。</p>
</blockquote>
<p><code>@JsonTest</code>启用的自动配置列表可以在<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#test-auto-configuration">附录中</a>找到。</p>
<h4 id="自动配置Spring-MVC测试"><a href="#自动配置Spring-MVC测试" class="headerlink" title="自动配置Spring MVC测试"></a>自动配置Spring MVC测试</h4><p>为了测试Spring MVC控制器如你预期的工作，你可以使用<code>@WebMvcTest</code>注解。<code>@WebMvcTest</code>将自动配置Spring MVC基础组件和限制扫描<code>@ Controller</code>,<code>@ControllerAdvice</code>,<code>@JsonComponent</code>,<code>Filter</code>,<code>WebMvcConfigurer</code> <code>HandlerMethodArgumentResolver</code> bean。在使用该注解时，不会对常规的<code>@Component</code> bean进行扫描。</p>
<p>通常，<code>@WebMvcTest</code>将局限于单个控制器，并与<code>@MockBean</code>结合使用，为需要的协作者提供模拟实现。<code>@WebMvcTest</code>也自动配置<code>MockMvc</code>。Mock MVC提供了一种强大的方法来快速测试MVC控制器，而不需要启动一个完整的HTTP服务器。</p>
<blockquote>
<p>你还可以使用<code>@AutoConfigureMockMvc</code>注解在非<code>@WebMvcTest</code>(如<code>SpringBootTest</code>)中自动配置<code>MockMvc</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(UserVehicleController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> UserVehicleService userVehicleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">&quot;sboot&quot;</span>))</span><br><span class="line">                .willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Civic&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.mvc.perform(get(<span class="string">&quot;/sboot/vehicle&quot;</span>).accept(MediaType.TEXT_PLAIN))</span><br><span class="line">                .andExpect(status().isOk()).andExpect(content().string(<span class="string">&quot;Honda Civic&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你需要配置自动配置的元素(例如，servlet过滤器何时生效)，你可以在<code>@AutoConfigureMockMvc</code>注解中使用属性。</p>
</blockquote>
<p>如果使用HtmlUnit或Selenium，自动配置还将提供一个HtmlUnit <code>WebClient</code> bean和/或一个<code>WebDriver</code> bean。下面是一个使用HtmlUnit的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.gargoylesoftware.htmlunit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(UserVehicleController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHtmlUnitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> UserVehicleService userVehicleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">&quot;sboot&quot;</span>))</span><br><span class="line">                .willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Civic&quot;</span>));</span><br><span class="line">        HtmlPage page = <span class="keyword">this</span>.webClient.getPage(<span class="string">&quot;/sboot/vehicle.html&quot;</span>);</span><br><span class="line">        assertThat(page.getBody().getTextContent()).isEqualTo(<span class="string">&quot;Honda Civic&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在默认情况下，Spring Boot将把<code>WebDriver</code> bean放入一个特殊的“范围”中，以确保在每次测试之后driver都会结束，并注入一个新的实例。如果你不想要这种行为，您可以将<code>@Scope(&quot;singleton&quot;)</code>添加到你的<code>WebDriver``@bean</code>定义中。</p>
</blockquote>
<p><code>@WebMvcTest</code>启用的自动配置列表可以在<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#test-auto-configuration">附录中找到</a>。</p>
<h4 id="自动配置Spring-WebFlux测试"><a href="#自动配置Spring-WebFlux测试" class="headerlink" title="自动配置Spring WebFlux测试"></a>自动配置Spring WebFlux测试</h4><h4 id="自动配置JPA-Data测试"><a href="#自动配置JPA-Data测试" class="headerlink" title="自动配置JPA Data测试"></a>自动配置JPA Data测试</h4><p>如果你想要测试JPA应用程序，可以使用<code>@DataJpaTest</code>。默认情况下，它将配置一个内存中的嵌入式数据库，扫描<code>@Entity</code>类并配置Spring Data JPA存储库。常规的<code>@Component</code> bean不会被加载到<code>ApplicationContext</code>中。</p>
<p>JPA测试都是事务性的并且在每个测试结束的时候都将回滚，请参阅<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions">Spring参考文档</a>中的相关部分了解更多细节。如果这不是你想要的，您可以禁用一个测试或整个类的事务管理，就像下面这样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleNonTransactionalTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JPA测试还可以注入一个<code>TestEntityManager</code> bean，它为专门为测试设计的标准JPA <code>EntityManager</code>提供了另一种选择。如果你想在<code>@DataJpaTests</code>外使用<code>TestEntityManager</code> 还可以使用<code>@AutoConfigureTestEntityManager</code>注解。如果需要的话，还可以使用<code>JdbcTemplate</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRepositoryTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestEntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.entityManager.persist(<span class="keyword">new</span> User(<span class="string">&quot;sboot&quot;</span>, <span class="string">&quot;1234&quot;</span>));</span><br><span class="line">        User user = <span class="keyword">this</span>.repository.findByUsername(<span class="string">&quot;sboot&quot;</span>);</span><br><span class="line">        assertThat(user.getUsername()).isEqualTo(<span class="string">&quot;sboot&quot;</span>);</span><br><span class="line">        assertThat(user.getVin()).isEqualTo(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存中嵌入式数据库通常适用于测试，因为它们是快速的，不需要任何开发人员安装。然而,如果你喜欢在一个真正的数据库上运行测试可以使用<code>@AutoConfigureTestDatabase</code>注解:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@AutoConfigureTestDatabase(replace=Replace.NONE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRepositoryTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#test-auto-configuration">附录中</a>可以找到由<code>@DataJpaTest</code>启用的自动配置列表。</p>
<h4 id="自动配置JDBC测试"><a href="#自动配置JDBC测试" class="headerlink" title="自动配置JDBC测试"></a>自动配置JDBC测试</h4><p><code>@JdbcTest </code>类似于<code>@DataJpaTest</code>，但对于纯jdbc相关的测试来说是类似的。默认情况下，它还将配置一个内存中的嵌入式数据库和一个<code>JdbcTemplate</code>。常规的<code>@Component</code> bean不会被加载到<code>ApplicationContext</code>中。</p>
<p>JDBC测试在缺省情况下是事务性的，并且在每个测试结束时回滚，请参阅Spring参考文档中的<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions">相关部分</a>以获得更多详细信息。如果这不是你想要的，你可以禁用一个测试或整个类的事务管理，就像下面这样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@JdbcTest</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleNonTransactionalTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你喜欢你的测试运行在一个真正的数据库,你可以你<code>DataJpaTest</code>一样使用<code>@AutoConfigureTestDatabase</code> 注解。</p>
<p>在<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#test-auto-configuration">附录</a>中可以找到由<code>@JdbcTest</code>启用的自动配置列表。</p>
<h4 id="自动配置jOOQ测试"><a href="#自动配置jOOQ测试" class="headerlink" title="自动配置jOOQ测试"></a>自动配置jOOQ测试</h4><h4 id="自动配置MongoDB-Data测试"><a href="#自动配置MongoDB-Data测试" class="headerlink" title="自动配置MongoDB Data测试"></a>自动配置MongoDB Data测试</h4><h4 id="自动配置Neo4j-Data测试"><a href="#自动配置Neo4j-Data测试" class="headerlink" title="自动配置Neo4j Data测试"></a>自动配置Neo4j Data测试</h4><h4 id="自动配置Redis-Data测试"><a href="#自动配置Redis-Data测试" class="headerlink" title="自动配置Redis Data测试"></a>自动配置Redis Data测试</h4><p>如果您想测试Redis应用程序，可以使用<code>@DataRedisTest</code>。默认情况下，它将扫描<code>@RedisHash</code>类，并配置Spring Data Redis存储库。常规的<code>@Component</code> bean不会被加载到<code>ApplicationContext</code>中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataRedisTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataRedisTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> YourRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@DataRedisTest</code>启用的自动配置列表可以在<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#test-auto-configuration">附录</a>中找到。</p>
<h4 id="自动配置LDAP-Data测试"><a href="#自动配置LDAP-Data测试" class="headerlink" title="自动配置LDAP Data测试"></a>自动配置LDAP Data测试</h4><h4 id="自动配置REST客户端"><a href="#自动配置REST客户端" class="headerlink" title="自动配置REST客户端"></a>自动配置REST客户端</h4><p>如果你想测试REST客户端，可以使用<code>@RestClientTest</code>注释。默认情况下，它将自动配置Jackson和GSON支持，配置<code>RestTemplateBuilder</code>，并添加对<code>MockRestServiceServer</code>的支持。你想要测试的特定bean应该使用<code>@RestClientTest</code>的<code>value</code>或<code>components</code>属性指定:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@RestClientTest(RemoteVehicleDetailsService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRestClientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RemoteVehicleDetailsService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockRestServiceServer server;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getVehicleDetailsWhenResultIsSuccessShouldReturnDetails</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.server.expect(requestTo(<span class="string">&quot;/greet/details&quot;</span>))</span><br><span class="line">                .andRespond(withSuccess(<span class="string">&quot;hello&quot;</span>, MediaType.TEXT_PLAIN));</span><br><span class="line">        String greeting = <span class="keyword">this</span>.service.callRestService();</span><br><span class="line">        assertThat(greeting).isEqualTo(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#test-auto-configuration">附录</a>中可以找到由<code>@RestClientTest</code>启用的自动配置列表。</p>
<h4 id="自动配置的Spring-REST-Doc测试"><a href="#自动配置的Spring-REST-Doc测试" class="headerlink" title="自动配置的Spring REST Doc测试"></a>自动配置的Spring REST Doc测试</h4><p>如果您想在测试中使用Spring REST Doc，可以使用<code>@AutoConfigureRestDocs</code>注释。它将自动配置<code>MockMvc</code>，以使用Spring REST Doc，并消除Spring REST Doc的JUnit规则的需求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(UserController.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDocumentationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvc.perform(get(<span class="string">&quot;/users&quot;</span>).accept(MediaType.TEXT_PLAIN))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andDo(document(<span class="string">&quot;list-users&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@AutoConfigureRestDocs</code>可以用来覆盖默认的输出目录(如果你使用的是Maven则为<code>target/generated-snippets</code>或如果你使用的是Gradle则为<code>build/generated-snippets</code>)。它还可以用于配置在任何文档化的URI中出现的主机、scheme和端口。如果你需要控制更多的Spring REST Doc配置可以使用<code>RestDocsMockMvcConfigurationCustomizer</code> bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationConfiguration</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RestDocsMockMvcConfigurationCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(MockMvcRestDocumentationConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.snippets().withTemplateFormat(TemplateFormats.markdown());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想利用Spring REST Doc的参数化输出目录支持,你可以创建一个<code>RestDocumentationResultHandler</code> bean。自动配置将调用这个结果处理器的<code>alwaysDo</code>，从而导致每个<code>MockMvc</code>调用来自动生成默认的代码片段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultHandlerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestDocumentationResultHandler <span class="title">restDocumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MockMvcRestDocumentation.document(<span class="string">&quot;&#123;method-name&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用Spock来测试Spring-Boot应用程序"><a href="#使用Spock来测试Spring-Boot应用程序" class="headerlink" title="使用Spock来测试Spring Boot应用程序"></a>使用Spock来测试Spring Boot应用程序</h4><p>如果你想用Spock来测试一个Spring Boot应用程序，你应该增加Spock的<code>spock-spring</code>模块的依赖到你的应用程序构建中。<code>spock-spring</code>将Spring的测试框架集成到Spock中。建议你使用Spock 1.1或更高版本，以便从最近对Spock Spring框架和Spring Boot集成的一些改进中获益。请参考<a target="_blank" rel="noopener" href="http://spockframework.org/spock/docs/1.1/modules.html">Spock的Spring模块的文档</a>，以了解更多细节。</p>
<h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><p>一些测试工具类被打包为<code>spring-oot</code>的一部分，这在测试应用程序时通常是有用的。</p>
<h4 id="ConfigFileApplicationContextInitializer"><a href="#ConfigFileApplicationContextInitializer" class="headerlink" title="ConfigFileApplicationContextInitializer"></a>ConfigFileApplicationContextInitializer</h4><p><code>ConfigFileApplicationContextInitializer</code>是一个 <code>ApplicationContextInitializer</code>,适用于测试加载Spring Boot <code>application.properties</code>文件。当你不需要<code>@SpringBootTest</code>提供的全部功能时，你可以使用它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(classes = Config.class,</span></span><br><span class="line"><span class="meta">    initializers = ConfigFileApplicationContextInitializer.class)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>单独使用<code>ConfigFileApplicationContextInitializer</code>不会提供支持<code>@Value(&quot;$&#123;…&#125;&quot;)</code>注入。它的唯一工作就是确保应用<code>application.properties</code>文件被加载到Spring的环境中。对于<code>@Value</code>支持你需要另外配置一个<code>PropertySourcesPlaceholderConfigurer</code>或使用会自动配置的<code>@SpringBootTest</code>。</p>
</blockquote>
<h4 id="EnvironmentTestUtils"><a href="#EnvironmentTestUtils" class="headerlink" title="EnvironmentTestUtils"></a>EnvironmentTestUtils</h4><p><code>EnvironmentTestUtils</code>允许你快速为<code>ConfigurableEnvironment</code>或<code>ConfigurableApplicationContext</code>添加属性。只需用使用<code>key=value</code>字符串来调用它:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EnvironmentTestUtils.addEnvironment(env, <span class="string">&quot;org=Spring&quot;</span>, <span class="string">&quot;name=Boot&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="OutputCapture"><a href="#OutputCapture" class="headerlink" title="OutputCapture"></a>OutputCapture</h4><p><code>OutputCapture</code>是一个JUnit <code>Rule</code>，你可以使用它来捕获<code>System.out</code>和<code>System.err</code>输出。只需将捕获声明为一个<code>@Rule</code>，然后使用<code>toString()</code>断言:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.rule.OutputCapture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> OutputCapture capture = <span class="keyword">new</span> OutputCapture();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testName</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        assertThat(capture.toString(), containsString(<span class="string">&quot;World&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TestRestTemplate"><a href="#TestRestTemplate" class="headerlink" title="TestRestTemplate"></a>TestRestTemplate</h4><p><code>TestRestTemplate</code>是一个方便的Spring <code>RestTemplate</code>替代品，它在集成测试中很有用。你可以获得一个普通的模板，或者一个发送基本HTTP身份验证的模板(带有用户名和密码)。在任何一种情况下，模板都将以一种测试友好的方式运行，不会向服务器端错误抛出异常。建议使用Apache HTTP客户端(版本4.3.2或更高的)，这不是强制的，如果在你有类路径中有这个库，那么<code>TestRestTemplate</code>将通过适当地配置客户端来响应。如果你确实使用了Apache的HTTP客户端，将启用一些额外的测试友好特性：</p>
<ul>
<li>重定向将不会被执行(因此你可以断言响应位置)</li>
<li>cookie将被忽略(因此模板是无状态的)</li>
</ul>
<p>可以在你的集成测试中直接实例化<code>TestRestTemplate</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestRestTemplate template = <span class="keyword">new</span> TestRestTemplate();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpHeaders headers = template.getForEntity(<span class="string">&quot;http://myhost.com/example&quot;</span>, String.class).getHeaders();</span><br><span class="line">        assertThat(headers.getLocation().toString(), containsString(<span class="string">&quot;myotherhost&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，如果你正在使用<code>@SpringBootTest</code>注解的<code>WebEnvironment.RANDOM_PORT</code>或<code>WebEnvironment.DEFINED_PORT</code>，你只需注入一个完全配置的<code>TestRestTemplate</code>并开始使用它。如果需要，可以通过<code>RestTemplateBuilder</code>来应用额外的定制。任何不指定主机和端口的URL都将自动连接到嵌入式服务器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestRestTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpHeaders headers = template.getForEntity(<span class="string">&quot;/example&quot;</span>, String.class).getHeaders();</span><br><span class="line">        assertThat(headers.getLocation().toString(), containsString(<span class="string">&quot;myotherhost&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestConfiguration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RestTemplateBuilder <span class="title">restTemplateBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RestTemplateBuilder()</span><br><span class="line">                .additionalMessageConverters(...)</span><br><span class="line">                .customizers(...);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h2><p>Spring Boot 为嵌入式Tomcat(8和7)、Jetty 9和Undertow提供WebSockets 自动配置。如果你正在将一个war文件部署到一个独立的容器中，Spring Boot假设容器将负责它的WebSocket支持的配置。</p>
<p>Spring框架提供了丰富的WebSocket支持，可以通过<code>spring-boot-starter-websocket</code>模块轻松访问。</p>
<h2 id="Web-Services"><a href="#Web-Services" class="headerlink" title="Web Services"></a>Web Services</h2><p>Spring Boot提供了Web服务的自动配置，因此所有需要的都是定义你的端点。</p>
<p><a target="_blank" rel="noopener" href="http://docs.spring.io/spring-ws/docs/2.4.0.RELEASE/reference/htmlsingle">Spring Web服务的特性</a>可以通过<code>spring-boot-starter-webservices</code>模块轻松地访问。</p>
<h2 id="创建自己的自动配置"><a href="#创建自己的自动配置" class="headerlink" title="创建自己的自动配置"></a>创建自己的自动配置</h2><p>如果你在一家开发共享库的公司工作，或者你在一个开源或商业库公司工作，你可能想要开发你自己的自动配置。自动配置类可以捆绑在外部jar中，还可以被Spring Boot获取。</p>
<p>自动配置可以与一个“starter”相关联，它提供了自动配置代码以及你将使用的典型库。我们将首先介绍你需要了解关于构建你自己的自动配置的内容，然后我们将继续介绍<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-custom-starter">创建自定义starter所需的典型步骤</a>。</p>
<p>这里有一个<a target="_blank" rel="noopener" href="https://github.com/snicoll-demos/spring-boot-master-auto-configuration">演示项目</a>可以展示如何一步一步地创建一个starter。</p>
<h3 id="理解自动配置bean"><a href="#理解自动配置bean" class="headerlink" title="理解自动配置bean"></a>理解自动配置bean</h3><p>在外壳之下，自动配置是用标准的<code>@Configuration</code>类实现的。当自动配置应该应用时，还会使用附加的<code>@Conditional</code>注解来约束。通常，自动配置类使用<code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingBean</code>注解。这确保了只有在找到相关类和没有声明自己的<code>@Configuration</code>时才会自动配置。</p>
<p>你可以浏览<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure"><code>spring-boot-autoconfigure</code></a>的源代码，以查看我们提供的<code>@Configuration</code>类(参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories"><code>META-INF/spring.factories</code></a>文件)。</p>
<h3 id="定位自动配置候选者"><a href="#定位自动配置候选者" class="headerlink" title="定位自动配置候选者"></a>定位自动配置候选者</h3><p>Spring Boot检查在你发布的jar中是否存在<code>META-INF/spring.factories</code>文件。应该在该文件以<code>EnableAutoConfiguration</code> key列出你的配置类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\</span><br><span class="line">com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>如果你的配置需要按照特定的顺序使用，那么你可以使用<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureAfter.java"><code>@AutoConfigureAfter</code></a>或<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureBefore.java"><code>@AutoConfigureBefore</code></a>注解。例如，如果你提供了web专用的配置，那么你的类可能需要在<code>WebMvcAutoConfiguration</code>之后应用。</p>
<p>如果你想要排序某些自动配置并且它们不应该对彼此有任何直接的了解，那么你也可以使用<code>@AutoconfigureOrder</code>。该注解与常规的<code>@Order</code>注解具有相同的语义，但提供了自动配置类的专用顺序。</p>
<blockquote>
<p>自动配置<em>只能</em>以这种方式加载。确保它们是在特定的包空间中定义的，并且不要对它们使用组件扫描。</p>
</blockquote>
<h3 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h3><p>你几乎总是希望在自动配置类中包含一个或多个<code>@Conditional</code>注解。<code>@ConditionalOnMissingBean</code>是一个常见的例子，它允许开发人员在不满意你的默认设置的情况下“覆盖”自动配置。</p>
<p>Spring Boot包含许多<code>@Conditional</code>注解，可以通过注解<code>@Configuration</code>类或单独的<code>@Bean</code>方法在自己的代码中重用。</p>
<h4 id="类条件"><a href="#类条件" class="headerlink" title="类条件"></a>类条件</h4><p><code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingClass</code>注解允许基于特定类的存在与否来是否包含该配置。由于使用<a target="_blank" rel="noopener" href="http://asm.ow2.org/">ASM</a>解析注解元数据，所以实际上可以使用<code>value</code>属性引用真正的类，即使这个类可能不会出现在正在运行的应用程序类路径中。如果你喜欢使用<code>String</code>值指定类名，那么也可以使用<code>name</code>属性。</p>
<blockquote>
<p>如果你使用<code>@ConditionalOnClass</code>或<code>@ConditionalOnMissingClass</code>作为元注解的一部分来组成你自己的组合注解，你必须使用<code>name</code>来指定类在这种情况下不处理。</p>
</blockquote>
<h4 id="Bean条件"><a href="#Bean条件" class="headerlink" title="Bean条件"></a>Bean条件</h4><p><code>@ConditionalOnBean</code> 和<code>@ConditionalOnMissingBean</code>注解允许根据特定bean的存在或不存在来是否包含bean。你可以使用<code>value</code>属性来按类型指定bean，也可以通过<code>name</code>指定bean。<code>search</code>属性允许你在搜索bean时限制应该考虑的<code>ApplicationContext</code>层次结构。</p>
<p>当被放置在<code>@Bean</code>方法上时，目标类型默认为该方法的返回类型，例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，如果在<code>ApplicationContext</code>中没有包含类型<code>MyService</code>的bean，那么将创建<code>myService</code> bean。</p>
<blockquote>
<p>你需要非常谨慎地处理bean定义的顺序，因为这些条件是根据目前处理的内容进行计算的。出于这个原因，我们建议只在自动配置类上使用<code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>注解(因为在添加了任何用户定义的bean定义之后，这些注解就会被加载)。</p>
</blockquote>
<blockquote>
<p><code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>不会阻止<code>@Configuration</code>类的创建。在类级别上使用这些条件相当于用注解标记每个包含的<code>@Bean</code>方法。</p>
</blockquote>
<h4 id="属性条件"><a href="#属性条件" class="headerlink" title="属性条件"></a>属性条件</h4><p><code>@ConditionalOnProperty</code>注解允许基于Spring Environment属性来是否包含配置。使用<code>prefix</code>和<code>name</code>属性来指定应该检查的属性。默认情况下，任何存在且不等于<code>false</code>的属性将被匹配。你还可以使用<code>havingValue</code>和<code>matchIfMissing</code>属性创建更高级的检查。</p>
<h4 id="资源条件"><a href="#资源条件" class="headerlink" title="资源条件"></a>资源条件</h4><p><code>@ConditionalOnResource</code>注解只允许在特定的资源出现时才包含配置。资源可以指定使用通常的Spring 的约定,例如,<code>file:/home/user/test.dat</code>。</p>
<h4 id="Web应用条件"><a href="#Web应用条件" class="headerlink" title="Web应用条件"></a>Web应用条件</h4><p><code>@@ConditionalOnWebApplication</code>和<code>@ConditionalOnNotWebApplication</code>注解允许取决于应用是一个“web应用”来是否包含配置。一个web应用是使用Spring <code>WebApplicationContext</code>,定义了一个<code>session</code> scope或拥有<code>StandardServletEnvironment</code>的任何应用。</p>
<h4 id="SpEL表达式条件"><a href="#SpEL表达式条件" class="headerlink" title="SpEL表达式条件"></a>SpEL表达式条件</h4><p><code>@ConditionalOnExpression</code>注解允许基于<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/core.html#expressions">SpEL表达式</a>的结果包含配置。</p>
<h3 id="创建自己的starter"><a href="#创建自己的starter" class="headerlink" title="创建自己的starter"></a>创建自己的starter</h3><p>对于一个库，一个完整的Spring Boot starter可能包含以下组件:</p>
<ul>
<li>包含自动配置代码的<code>autoconfigure</code>模块</li>
<li>启动器模块提供对 autoconfigure 模块的依赖，以及库和其他通常有用的附加依赖项。简而言之，添加这个starter应该足以开始使用该库。</li>
</ul>
<blockquote>
<p>如果你不需要将这两个关注点分开，你可以将自动配置代码和依赖项管理合并在一个模块中。</p>
</blockquote>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>请确保为你的starter提供适当的命名空间。不要以<code>spring-boot</code> 开头，即使你使用的是不同的Maven  groupId。我们可能会在将来为你自动配置的东西提供官方支持。</p>
<p>这是一个经验法则。让我们假设你正在为“acme”创建一个starter，请将自动配置模块命名为<code>acme-spring-boot-autoconfigure</code>和starter命名为<code>acme-spring-boot-starter</code>。如果你只有一个组合了这两个模块的模块，那就使用<code>acme-spring-boot-starter</code>。</p>
<p>此外，如果你的启动器提供了配置  key，那么为它们使用适当的命名空间。特别是，不要将你的key包含在Spring Boot 使用的命名空间中(例如<code>server</code>, <code>management</code>, <code>spring</code>等)。这些都是“我们的”，我们可以在将来改进/修改它们，这样可能破坏你的东西。</p>
<p>确保<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#configuration-metadata-annotation-processor">触发元数据生成</a>，以便你的key也可以使用IDE辅助功能。你可能需要检查生成的元数据(<code>META-INF/spring-configuration-metadata.json</code>)，以确保你的key被正确地记录。</p>
<h4 id="自动配置模块"><a href="#自动配置模块" class="headerlink" title="自动配置模块"></a>自动配置模块</h4><p>autoconfigure 模块包含了从这个库启动的所有必要的内容。它还可能包含配置key定义(<code>@ConfigurationProperties</code>)和任何可用于进一步定制组件如何初始化的回调接口。</p>
<blockquote>
<p>你应该将对库的依赖项标记为可选的，这样你就可以更容易地在你的项目中包含autoconfigure模块。如果你这样做，将不会提供这些库，而且Spring Boot将默认关闭。</p>
</blockquote>
<h4 id="starter模块"><a href="#starter模块" class="headerlink" title="starter模块"></a>starter模块</h4><p>starter是一个空jar。它的唯一目的是提供必要的依赖项来与库一起工作;把它看作需要什么上手的自以为是的观点（不懂）。</p>
<p>不要对starter添加的项目做出假设。 如果你自动配置的库通常需要其他starter，请提及它们。 如果可选依赖关系的数量高，则提供一组适当的<em>默认依赖</em>关系可能会很困难，因为你应避免为库的典型用法带来不必要的依赖关系。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://qzztf.com">水娃</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://qzztf.com/post/29b6/">http://qzztf.com/post/29b6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://qzztf.com" target="_blank">水娃火娃石榴娃</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring-Boot/">Spring Boot</a><a class="post-meta__tags" href="/tags/%E7%89%B9%E6%80%A7/">特性</a></div><div class="post_share"><div class="social-share" data-image="/image/avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/60cf/" title="Spring Boot 五-Spring Boot执行器 - 生产就绪特性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring Boot 五-Spring Boot执行器 - 生产就绪特性</div></div></a></div><div class="next-post pull-right"><a href="/post/beda/" title="dubbo学习7-只订阅服务不注册"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">dubbo学习7-只订阅服务不注册</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/361c/" title="Idea 创建 Spring boot应用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-04-22</div><div class="title">Idea 创建 Spring boot应用</div></div></a></div><div><a href="/post/29bc/" title="Spring Boot 七 - Spring Boot CLI"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-13</div><div class="title">Spring Boot 七 - Spring Boot CLI</div></div></a></div><div><a href="/post/4406/" title="Spring Boot 八- 构建工具插件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-16</div><div class="title">Spring Boot 八- 构建工具插件</div></div></a></div><div><a href="/post/64fe/" title="Spring Boot 六 - 部署Spring Boot应用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-09</div><div class="title">Spring Boot 六 - 部署Spring Boot应用</div></div></a></div><div><a href="/post/60cf/" title="Spring Boot 五-Spring Boot执行器 - 生产就绪特性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-09-13</div><div class="title">Spring Boot 五-Spring Boot执行器 - 生产就绪特性</div></div></a></div><div><a href="/post/6b4e/" title="Spring Boot 九 - “How-to” 指南"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-18</div><div class="title">Spring Boot 九 - “How-to” 指南</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">水娃</div><div class="author-info__description">水娃的博客 | java</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qzztf"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringApplication"><span class="toc-number">1.</span> <span class="toc-text">SpringApplication</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5"><span class="toc-number">1.1.</span> <span class="toc-text">启动失败</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Banner"><span class="toc-number">1.2.</span> <span class="toc-text">自定义Banner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89SpringApplication"><span class="toc-number">1.3.</span> <span class="toc-text">自定义SpringApplication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%BC%8Fbuilder-API"><span class="toc-number">1.4.</span> <span class="toc-text">流式builder API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">事件和监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-%E7%8E%AF%E5%A2%83"><span class="toc-number">1.6.</span> <span class="toc-text">Web 环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%BA%94%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">访问应用参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ApplicationRunner%EF%BC%8CCommandLineRunner"><span class="toc-number">1.8.</span> <span class="toc-text">使用ApplicationRunner，CommandLineRunner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E9%80%80%E5%87%BA"><span class="toc-number">1.9.</span> <span class="toc-text">应用退出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%91%98%E5%8A%9F%E8%83%BD"><span class="toc-number">1.10.</span> <span class="toc-text">管理员功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%85%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">扩展配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%9A%8F%E6%9C%BA%E5%80%BC"><span class="toc-number">2.1.</span> <span class="toc-text">配置随机值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">访问控制台参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">应用属性文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Profile-specific%E5%B1%9E%E6%80%A7"><span class="toc-number">2.4.</span> <span class="toc-text">Profile-specific属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84Placeholders"><span class="toc-number">2.5.</span> <span class="toc-text">属性文件中的Placeholders</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YAML-%E4%BB%A3%E6%9B%BF%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6"><span class="toc-number">2.6.</span> <span class="toc-text">YAML 代替属性文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BDYAML"><span class="toc-number">2.6.1.</span> <span class="toc-text">加载YAML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86YMAL%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E6%9A%B4%E9%9C%B2%E5%88%B0Spring-%E7%8E%AF%E5%A2%83%E4%B8%AD"><span class="toc-number">2.6.2.</span> <span class="toc-text">将YMAL作为属性暴露到Spring 环境中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AAprofile-%E7%9A%84YAML%E6%96%87%E4%BB%B6"><span class="toc-number">2.6.3.</span> <span class="toc-text">多个profile 的YAML文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#YAML-%E7%BC%BA%E9%99%B7"><span class="toc-number">2.6.4.</span> <span class="toc-text">YAML 缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6YAML%E5%88%97%E8%A1%A8"><span class="toc-number">2.6.5.</span> <span class="toc-text">合并YAML列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">2.7.</span> <span class="toc-text">类型安全的配置属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E9%85%8D%E7%BD%AE"><span class="toc-number">2.7.1.</span> <span class="toc-text">第三方配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%BE%E6%95%A3%E7%BB%91%E5%AE%9A"><span class="toc-number">2.7.2.</span> <span class="toc-text">松散绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.7.2.0.1.</span> <span class="toc-text">松散绑定规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.7.3.</span> <span class="toc-text">属性转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConfigurationProperties-%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.7.4.</span> <span class="toc-text">@ConfigurationProperties 校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConfigurationProperties-%E4%B8%8E-Value%E5%AF%B9%E6%AF%94"><span class="toc-number">2.7.5.</span> <span class="toc-text">@ConfigurationProperties 与 @Value对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Profiles"><span class="toc-number">3.</span> <span class="toc-text">Profiles</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%BF%80%E6%B4%BB%E7%9A%84profile"><span class="toc-number">3.1.</span> <span class="toc-text">增加激活的profile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E8%AE%BE%E7%BD%AEprofile"><span class="toc-number">3.2.</span> <span class="toc-text">以编程方式设置profile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%AE%9AProfile%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">特定Profile配置文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">4.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">日志格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA"><span class="toc-number">4.2.</span> <span class="toc-text">控制台输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A9%E8%89%B2%E7%BC%96%E7%A0%81%E8%BE%93%E5%87%BA"><span class="toc-number">4.2.1.</span> <span class="toc-text">彩色编码输出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA"><span class="toc-number">4.3.</span> <span class="toc-text">文件输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="toc-number">4.4.</span> <span class="toc-text">日志级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE"><span class="toc-number">4.5.</span> <span class="toc-text">自定义日志配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Logback%E6%89%A9%E5%B1%95"><span class="toc-number">4.6.</span> <span class="toc-text">Logback扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%AE%9AProfile%E9%85%8D%E7%BD%AE"><span class="toc-number">4.6.1.</span> <span class="toc-text">特定Profile配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%B1%9E%E6%80%A7"><span class="toc-number">4.6.2.</span> <span class="toc-text">环境属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91web%E5%BA%94%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">开发web应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Web-MVC-%E6%A1%86%E6%9E%B6"><span class="toc-number">5.1.</span> <span class="toc-text">Spring Web MVC 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-MVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">5.1.1.</span> <span class="toc-text">Spring MVC自动配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HttpMessageConverter"><span class="toc-number">5.1.2.</span> <span class="toc-text">HttpMessageConverter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89JSON%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">5.1.3.</span> <span class="toc-text">自定义JSON序列化和反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MessageCodesResolver"><span class="toc-number">5.1.4.</span> <span class="toc-text">MessageCodesResolver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E5%AE%B9"><span class="toc-number">5.1.5.</span> <span class="toc-text">静态内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Favicon"><span class="toc-number">5.1.6.</span> <span class="toc-text">自定义Favicon</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConfigurableWebBindingInitializer"><span class="toc-number">5.1.7.</span> <span class="toc-text">ConfigurableWebBindingInitializer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E"><span class="toc-number">5.1.8.</span> <span class="toc-text">模板引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">5.1.9.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">5.1.9.1.</span> <span class="toc-text">自定义错误页面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8Spring-MVC%E4%B9%8B%E5%A4%96%E6%98%A0%E5%B0%84%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">5.1.9.2.</span> <span class="toc-text">在Spring MVC之外映射错误页面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WebSphere-%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">5.1.9.3.</span> <span class="toc-text">WebSphere 应用服务器中错误处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-HATEOAS"><span class="toc-number">5.1.10.</span> <span class="toc-text">Spring HATEOAS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS%E6%94%AF%E6%8C%81"><span class="toc-number">5.1.11.</span> <span class="toc-text">CORS支持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-WebFlux%E6%A1%86%E6%9E%B6"><span class="toc-number">5.2.</span> <span class="toc-text">Spring WebFlux框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-WebFlux%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">5.2.1.</span> <span class="toc-text">Spring WebFlux自动配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HttpMessageReaders-%E5%92%8C-HttpMessageWriters-HTTP%E7%BC%96%E7%A0%81"><span class="toc-number">5.2.2.</span> <span class="toc-text">HttpMessageReaders 和 HttpMessageWriters HTTP编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E5%AE%B9-1"><span class="toc-number">5.2.3.</span> <span class="toc-text">静态内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E-1"><span class="toc-number">5.2.4.</span> <span class="toc-text">模板引擎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAX-RS-%E5%92%8CJersey"><span class="toc-number">5.3.</span> <span class="toc-text">JAX-RS 和Jersey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8Fservlet%E5%AE%B9%E5%99%A8%E6%94%AF%E6%8C%81"><span class="toc-number">5.4.</span> <span class="toc-text">嵌入式servlet容器支持</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet%EF%BC%8CFilter%E5%92%8Clisterner"><span class="toc-number">5.4.1.</span> <span class="toc-text">Servlet，Filter和listerner</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.4.2.</span> <span class="toc-text">Servlet上下文初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServletWebServerApplicationContext"><span class="toc-number">5.4.3.</span> <span class="toc-text">ServletWebServerApplicationContext</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%AB%E6%8F%8FServlet%EF%BC%8CFilter%E5%92%8Clisenter"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">扫描Servlet，Filter和lisenter</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServletWebServerApplicatonContext"><span class="toc-number">5.4.4.</span> <span class="toc-text">ServletWebServerApplicatonContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B5%8C%E5%85%A5%E5%BC%8Fservlet%E5%AE%B9%E5%99%A8"><span class="toc-number">5.4.5.</span> <span class="toc-text">自定义嵌入式servlet容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">5.4.5.1.</span> <span class="toc-text">编程式自定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E8%87%AA%E5%AE%9A%E4%B9%89ConfigurableServletWebServerFactory"><span class="toc-number">5.4.5.2.</span> <span class="toc-text">直接自定义ConfigurableServletWebServerFactory</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSP%E9%99%90%E5%88%B6"><span class="toc-number">5.4.6.</span> <span class="toc-text">JSP限制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8"><span class="toc-number">6.</span> <span class="toc-text">安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OAuth2"><span class="toc-number">6.1.</span> <span class="toc-text">OAuth2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">6.1.1.</span> <span class="toc-text">授权服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">6.1.2.</span> <span class="toc-text">资源服务器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#User%E4%BF%A1%E6%81%AF%E4%B8%AD%E7%9A%84Token%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">User信息中的Token类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89User%E4%BF%A1%E6%81%AF-RestTemplate"><span class="toc-number">6.3.</span> <span class="toc-text">自定义User信息 RestTemplate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Client"><span class="toc-number">6.3.1.</span> <span class="toc-text">Client</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="toc-number">6.3.2.</span> <span class="toc-text">单点登录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Actuator-%E5%AE%89%E5%85%A8"><span class="toc-number">6.4.</span> <span class="toc-text">Actuator 安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">7.</span> <span class="toc-text">SQL数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">7.1.</span> <span class="toc-text">配置数据源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%AF%E6%8C%81"><span class="toc-number">7.1.1.</span> <span class="toc-text">嵌入式数据库支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%94%9F%E4%BA%A7%E5%BA%93"><span class="toc-number">7.1.2.</span> <span class="toc-text">连接生产库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5JNDI%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">7.1.3.</span> <span class="toc-text">连接JNDI数据库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JdbcTemplate"><span class="toc-number">7.2.</span> <span class="toc-text">使用JdbcTemplate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JPA%E5%92%8CSpring-Data"><span class="toc-number">7.3.</span> <span class="toc-text">JPA和Spring Data</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">7.3.1.</span> <span class="toc-text">实体类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Data-JPA%E4%BB%93%E5%BA%93"><span class="toc-number">7.3.2.</span> <span class="toc-text">Spring Data JPA仓库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4JPA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">7.3.3.</span> <span class="toc-text">创建和删除JPA数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8View%E4%B8%AD%E6%89%93%E5%BC%80EntityManager"><span class="toc-number">7.3.4.</span> <span class="toc-text">在View中打开EntityManager</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8H2%E7%9A%84web%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">7.4.</span> <span class="toc-text">使用H2的web控制台</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9H2%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">7.4.1.</span> <span class="toc-text">修改H2控制台的路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86H2%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">7.4.2.</span> <span class="toc-text">加密H2的控制台</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8jOOQ"><span class="toc-number">7.5.</span> <span class="toc-text">使用jOOQ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">7.5.1.</span> <span class="toc-text">代码生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8DSLContext"><span class="toc-number">7.5.2.</span> <span class="toc-text">使用DSLContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jOOQ-SQL%E6%96%B9%E8%A8%80"><span class="toc-number">7.5.3.</span> <span class="toc-text">jOOQ SQL方言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89jOOQ"><span class="toc-number">7.5.4.</span> <span class="toc-text">自定义jOOQ</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NoSQL"><span class="toc-number">8.</span> <span class="toc-text">NoSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis"><span class="toc-number">8.1.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0Redis"><span class="toc-number">8.1.1.</span> <span class="toc-text">连接到Redis</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MongoDB"><span class="toc-number">8.2.</span> <span class="toc-text">MongoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">8.2.1.</span> <span class="toc-text">连接到MongoDB数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MongoTemplate"><span class="toc-number">8.2.2.</span> <span class="toc-text">MongoTemplate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Data-MongoDB%E4%BB%93%E5%BA%93"><span class="toc-number">8.2.3.</span> <span class="toc-text">Spring Data MongoDB仓库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8FMongo"><span class="toc-number">8.2.4.</span> <span class="toc-text">嵌入式Mongo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Neo4j"><span class="toc-number">8.3.</span> <span class="toc-text">Neo4j</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0Neo4j%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">8.3.1.</span> <span class="toc-text">连接到Neo4j数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.3.2.</span> <span class="toc-text">使用嵌入式模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Neo4jSession"><span class="toc-number">8.3.3.</span> <span class="toc-text">Neo4jSession</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Data-Neo4j%E4%BB%93%E5%BA%93"><span class="toc-number">8.3.4.</span> <span class="toc-text">Spring Data Neo4j仓库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%93%E5%BA%93%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.3.5.</span> <span class="toc-text">仓库示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gemfire"><span class="toc-number">8.4.</span> <span class="toc-text">Gemfire</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solr"><span class="toc-number">8.5.</span> <span class="toc-text">Solr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0Solr"><span class="toc-number">8.5.1.</span> <span class="toc-text">连接到Solr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Data-Solr%E4%BB%93%E5%BA%93"><span class="toc-number">8.5.2.</span> <span class="toc-text">Spring Data Solr仓库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Elasticsearch"><span class="toc-number">8.6.</span> <span class="toc-text">Elasticsearch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Jest%E8%BF%9E%E6%8E%A5Elasticsearch"><span class="toc-number">8.6.1.</span> <span class="toc-text">使用Jest连接Elasticsearch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Spring-Data%E8%BF%9E%E6%8E%A5Elasticsearch"><span class="toc-number">8.6.2.</span> <span class="toc-text">使用Spring Data连接Elasticsearch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Data-Elasticsearch-%E4%BB%93%E5%BA%93"><span class="toc-number">8.6.3.</span> <span class="toc-text">Spring Data Elasticsearch 仓库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cassandra"><span class="toc-number">8.7.</span> <span class="toc-text">Cassandra</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0Cassandra"><span class="toc-number">8.7.1.</span> <span class="toc-text">连接到Cassandra</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Data-Cassandra%E4%BB%93%E5%BA%93"><span class="toc-number">8.7.2.</span> <span class="toc-text">Spring Data Cassandra仓库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Couchbase"><span class="toc-number">8.8.</span> <span class="toc-text">Couchbase</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0Couchbase"><span class="toc-number">8.8.1.</span> <span class="toc-text">连接到Couchbase</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Data-Couchbase%E4%BB%93%E5%BA%93"><span class="toc-number">8.8.2.</span> <span class="toc-text">Spring Data Couchbase仓库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LDAP"><span class="toc-number">8.9.</span> <span class="toc-text">LDAP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0LDAP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">8.9.1.</span> <span class="toc-text">连接到LDAP服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Data-LDAP%E4%BB%93%E5%BA%93"><span class="toc-number">8.9.2.</span> <span class="toc-text">Spring Data LDAP仓库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%86%85%E5%AD%98LDAP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">8.9.3.</span> <span class="toc-text">嵌入式内存LDAP服务器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InfluxDB"><span class="toc-number">8.10.</span> <span class="toc-text">InfluxDB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0InfluxDB"><span class="toc-number">8.10.1.</span> <span class="toc-text">连接到InfluxDB</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">9.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.1.</span> <span class="toc-text">支持的缓存实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8"><span class="toc-number">9.1.1.</span> <span class="toc-text">通用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JCache%EF%BC%88JSR-107%EF%BC%89"><span class="toc-number">9.1.2.</span> <span class="toc-text">JCache（JSR-107）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EhCache-2-x"><span class="toc-number">9.1.3.</span> <span class="toc-text">EhCache 2.x</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hazelcast"><span class="toc-number">9.1.4.</span> <span class="toc-text">Hazelcast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Infinispan"><span class="toc-number">9.1.5.</span> <span class="toc-text">Infinispan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Couchbase-1"><span class="toc-number">9.1.6.</span> <span class="toc-text">Couchbase</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-1"><span class="toc-number">9.1.7.</span> <span class="toc-text">Redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Caffeine"><span class="toc-number">9.1.8.</span> <span class="toc-text">Caffeine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Simple"><span class="toc-number">9.1.9.</span> <span class="toc-text">Simple</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#None"><span class="toc-number">9.1.10.</span> <span class="toc-text">None</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF"><span class="toc-number">10.</span> <span class="toc-text">消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JMS"><span class="toc-number">10.1.</span> <span class="toc-text">JMS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ActiveMQ"><span class="toc-number">10.1.1.</span> <span class="toc-text">ActiveMQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Artemis"><span class="toc-number">10.1.2.</span> <span class="toc-text">Artemis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JNDI-ConnectionFactory"><span class="toc-number">10.1.3.</span> <span class="toc-text">使用JNDI ConnectionFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">10.1.4.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="toc-number">10.1.5.</span> <span class="toc-text">接收消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMQP"><span class="toc-number">10.2.</span> <span class="toc-text">AMQP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RabbitMQ"><span class="toc-number">10.2.1.</span> <span class="toc-text">RabbitMQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF-1"><span class="toc-number">10.2.2.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF-1"><span class="toc-number">10.2.3.</span> <span class="toc-text">接收消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Apache-Kafka"><span class="toc-number">10.3.</span> <span class="toc-text">Apache Kafka</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF-2"><span class="toc-number">10.3.1.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF-2"><span class="toc-number">10.3.2.</span> <span class="toc-text">接收消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84Kafka%E5%B1%9E%E6%80%A7"><span class="toc-number">10.3.3.</span> <span class="toc-text">额外的Kafka属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E2%80%9CRestTemplate%E2%80%9D-%E8%B0%83%E7%94%A8REST-%E6%9C%8D%E5%8A%A1"><span class="toc-number">11.</span> <span class="toc-text">使用“RestTemplate” 调用REST 服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6RestTemplate"><span class="toc-number">11.1.</span> <span class="toc-text">定制RestTemplate</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E2%80%9CWebClient%E2%80%9D-%E8%B0%83%E7%94%A8REST-%E6%9C%8D%E5%8A%A1"><span class="toc-number">12.</span> <span class="toc-text">使用“WebClient” 调用REST 服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6WebClient"><span class="toc-number">12.1.</span> <span class="toc-text">定制WebClient</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C"><span class="toc-number">13.</span> <span class="toc-text">校验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81"><span class="toc-number">14.</span> <span class="toc-text">邮件发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JTA-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">15.</span> <span class="toc-text">JTA 分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Atomikos-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">15.1.</span> <span class="toc-text">使用Atomikos 事务管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Bitronix-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">15.2.</span> <span class="toc-text">使用Bitronix 事务管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Narayana-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">15.3.</span> <span class="toc-text">使用Narayana 事务管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Java-EE%E7%AE%A1%E7%90%86%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">15.4.</span> <span class="toc-text">使用Java EE管理的事务管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88XA%E5%92%8C%E9%9D%9EXA-JMS%E8%BF%9E%E6%8E%A5"><span class="toc-number">15.5.</span> <span class="toc-text">混合XA和非XA JMS连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">15.6.</span> <span class="toc-text">支持另一个嵌入式事务管理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hazelcast-1"><span class="toc-number">16.</span> <span class="toc-text">Hazelcast</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Quartz-Scheduler"><span class="toc-number">17.</span> <span class="toc-text">Quartz Scheduler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Integration"><span class="toc-number">18.</span> <span class="toc-text">Spring Integration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Session"><span class="toc-number">19.</span> <span class="toc-text">Spring Session</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMX%E7%9B%91%E8%A7%86%E5%92%8C%E7%AE%A1%E7%90%86"><span class="toc-number">20.</span> <span class="toc-text">JMX监视和管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">21.</span> <span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%8C%83%E5%9B%B4%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="toc-number">21.1.</span> <span class="toc-text">测试范围的依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95Spring%E5%BA%94%E7%94%A8"><span class="toc-number">21.2.</span> <span class="toc-text">测试Spring应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95Spring-Boot%E5%BA%94%E7%94%A8"><span class="toc-number">21.3.</span> <span class="toc-text">测试Spring Boot应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE"><span class="toc-number">21.3.1.</span> <span class="toc-text">检测测试配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E9%99%A4%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE"><span class="toc-number">21.3.2.</span> <span class="toc-text">排除测试配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E7%AB%AF%E5%8F%A3"><span class="toc-number">21.3.3.</span> <span class="toc-text">使用随机端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%92%8C%E7%9B%91%E8%A7%86-bean"><span class="toc-number">21.3.4.</span> <span class="toc-text">模拟和监视 bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95"><span class="toc-number">21.3.5.</span> <span class="toc-text">自动配置测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEJSON%E6%B5%8B%E8%AF%95"><span class="toc-number">21.3.6.</span> <span class="toc-text">自动配置JSON测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AESpring-MVC%E6%B5%8B%E8%AF%95"><span class="toc-number">21.3.7.</span> <span class="toc-text">自动配置Spring MVC测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AESpring-WebFlux%E6%B5%8B%E8%AF%95"><span class="toc-number">21.3.8.</span> <span class="toc-text">自动配置Spring WebFlux测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEJPA-Data%E6%B5%8B%E8%AF%95"><span class="toc-number">21.3.9.</span> <span class="toc-text">自动配置JPA Data测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEJDBC%E6%B5%8B%E8%AF%95"><span class="toc-number">21.3.10.</span> <span class="toc-text">自动配置JDBC测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEjOOQ%E6%B5%8B%E8%AF%95"><span class="toc-number">21.3.11.</span> <span class="toc-text">自动配置jOOQ测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEMongoDB-Data%E6%B5%8B%E8%AF%95"><span class="toc-number">21.3.12.</span> <span class="toc-text">自动配置MongoDB Data测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AENeo4j-Data%E6%B5%8B%E8%AF%95"><span class="toc-number">21.3.13.</span> <span class="toc-text">自动配置Neo4j Data测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AERedis-Data%E6%B5%8B%E8%AF%95"><span class="toc-number">21.3.14.</span> <span class="toc-text">自动配置Redis Data测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AELDAP-Data%E6%B5%8B%E8%AF%95"><span class="toc-number">21.3.15.</span> <span class="toc-text">自动配置LDAP Data测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEREST%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">21.3.16.</span> <span class="toc-text">自动配置REST客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84Spring-REST-Doc%E6%B5%8B%E8%AF%95"><span class="toc-number">21.3.17.</span> <span class="toc-text">自动配置的Spring REST Doc测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Spock%E6%9D%A5%E6%B5%8B%E8%AF%95Spring-Boot%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">21.3.18.</span> <span class="toc-text">使用Spock来测试Spring Boot应用程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">21.4.</span> <span class="toc-text">测试工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConfigFileApplicationContextInitializer"><span class="toc-number">21.4.1.</span> <span class="toc-text">ConfigFileApplicationContextInitializer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EnvironmentTestUtils"><span class="toc-number">21.4.2.</span> <span class="toc-text">EnvironmentTestUtils</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OutputCapture"><span class="toc-number">21.4.3.</span> <span class="toc-text">OutputCapture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TestRestTemplate"><span class="toc-number">21.4.4.</span> <span class="toc-text">TestRestTemplate</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSockets"><span class="toc-number">22.</span> <span class="toc-text">WebSockets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Services"><span class="toc-number">23.</span> <span class="toc-text">Web Services</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">24.</span> <span class="toc-text">创建自己的自动配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AEbean"><span class="toc-number">24.1.</span> <span class="toc-text">理解自动配置bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%80%99%E9%80%89%E8%80%85"><span class="toc-number">24.2.</span> <span class="toc-text">定位自动配置候选者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B3%A8%E8%A7%A3"><span class="toc-number">24.3.</span> <span class="toc-text">条件注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%9D%A1%E4%BB%B6"><span class="toc-number">24.3.1.</span> <span class="toc-text">类条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E6%9D%A1%E4%BB%B6"><span class="toc-number">24.3.2.</span> <span class="toc-text">Bean条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%9D%A1%E4%BB%B6"><span class="toc-number">24.3.3.</span> <span class="toc-text">属性条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%9D%A1%E4%BB%B6"><span class="toc-number">24.3.4.</span> <span class="toc-text">资源条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Web%E5%BA%94%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">24.3.5.</span> <span class="toc-text">Web应用条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9D%A1%E4%BB%B6"><span class="toc-number">24.3.6.</span> <span class="toc-text">SpEL表达式条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84starter"><span class="toc-number">24.4.</span> <span class="toc-text">创建自己的starter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D"><span class="toc-number">24.4.1.</span> <span class="toc-text">命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97"><span class="toc-number">24.4.2.</span> <span class="toc-text">自动配置模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#starter%E6%A8%A1%E5%9D%97"><span class="toc-number">24.4.3.</span> <span class="toc-text">starter模块</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/5441/" title="Spring Cloud Gateway整合Spring Doc">Spring Cloud Gateway整合Spring Doc</a><time datetime="2023-04-02T12:49:15.000Z" title="发表于 2023-04-02 20:49:15">2023-04-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/f507/" title="处理字典值反显问题.md">处理字典值反显问题.md</a><time datetime="2023-04-02T12:46:42.000Z" title="发表于 2023-04-02 20:46:42">2023-04-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/9fa5/" title="Spring AOP 调用同一个对象的方法">Spring AOP 调用同一个对象的方法</a><time datetime="2020-12-05T14:55:47.000Z" title="发表于 2020-12-05 22:55:47">2020-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/39fc/" title="Spring AOP基本用法3">Spring AOP基本用法3</a><time datetime="2020-09-23T02:26:55.000Z" title="发表于 2020-09-23 10:26:55">2020-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/f93d/" title="Spring AOP基本用法2">Spring AOP基本用法2</a><time datetime="2020-09-23T02:25:58.000Z" title="发表于 2020-09-23 10:25:58">2020-09-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 水娃</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '248e3cebde8537449dbb',
      clientSecret: 'a9c539e71782374d81eb91ad932288cd41809575',
      repo: 'blog-s-gitalk',
      owner: 'qinzaizhen',
      admin: ['qzztf'],
      id: '83e3354f17e798a84bbead6ee3db9df5',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>