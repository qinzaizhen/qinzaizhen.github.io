<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Spring Boot 九 - “How-to” 指南 | 水娃火娃石榴娃</title><meta name="author" content="水娃"><meta name="copyright" content="水娃"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本节提供了一些常见的“如何做…”类型的问题的答案，这些问题在使用Spring Boot时经常出现。 这绝对不是详尽的列表，但它确实涵盖了很多。 如果你有一个我们没在这里介绍的特定问题，你可能需要访问 stackoverflow.com 来查看是否有其他人已经提供了答案; 这也是提出新问题的好地方（请"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://qzztf.com/post/6b4e/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/image/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/image/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/image/pwa/16.png"/><link rel="mask-icon" href="/image/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?86553a0f289bcfb307062507dc247eb2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring Boot 九 - “How-to” 指南',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-16 15:25:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="水娃火娃石榴娃"><span class="site-name">水娃火娃石榴娃</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring Boot 九 - “How-to” 指南</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2017-10-18T13:39:45.000Z" title="发表于 2017-10-18 21:39:45">2017-10-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-16T07:25:26.152Z" title="更新于 2024-06-16 15:25:26">2024-06-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>80分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring Boot 九 - “How-to” 指南"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本节提供了一些常见的“如何做…”类型的问题的答案，这些问题在使用Spring Boot时经常出现。 这绝对不是详尽的列表，但它确实涵盖了很多。</p>
<p>如果你有一个我们没在这里介绍的特定问题，你可能需要访问 <a target="_blank" rel="noopener" href="http://stackoverflow.com/tags/spring-boot">stackoverflow.com</a> 来查看是否有其他人已经提供了答案; 这也是提出新问题的好地方（请使用<code>spring-boot</code>标签）。</p>
<p>我们也很乐意扩展这一节;如果你想添加一个“操作指南”，你可以向我们发送一个<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master">pull request</a>。</p>
<h2 id="Spring-Boot-应用"><a href="#Spring-Boot-应用" class="headerlink" title="Spring Boot 应用"></a>Spring Boot 应用</h2><h3 id="创建自己的FailureAnalyzer"><a href="#创建自己的FailureAnalyzer" class="headerlink" title="创建自己的FailureAnalyzer"></a>创建自己的FailureAnalyzer</h3><p><a target="_blank" rel="noopener" href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/diagnostics/FailureAnalyzer.html">FailureAnalyzer``</a>是在启动时拦截异常的好方法，并将其转换为可读的消息，将其封装到<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/diagnostics/FailureAnalysis.html"><code>FailureAnalysis</code></a>中。Spring Boot为应用程序上下文相关的异常、jsr-303验证等提供了这样的分析器。实际上，也很容易创建自己的分析器。</p>
<p><code>AbstractFailureAnalyzer</code>是<code>FailureAnalyzer</code>的一个方便的扩展，它检查异常中指定的异常类型的存在。你可以从它扩展，以便你的实现只有在实际存在时才有机会处理异常。如果出于某种原因，你无法处理异常，则返回<code>null</code>以给另一个实现一个处理异常的机会。</p>
<p><code>FailureAnalyzer</code>的实现可以注册到<code>META-INF/spring.factories</code>，例如：<code>ProjectConstraintViolationFailureAnalyzer</code>: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.diagnostics.FailureAnalyzer&#x3D;\</span><br><span class="line">com.example.ProjectConstraintViolationFailureAnalyzer</span><br></pre></td></tr></table></figure>

<h3 id="排除自动配置故障"><a href="#排除自动配置故障" class="headerlink" title="排除自动配置故障"></a>排除自动配置故障</h3><p>Spring Boot 自动配置尽可能做“正确的事情”，但是有时候失败了并且很难告知为何失败。</p>
<p>在任何 Spring Boot <code>ApplicationContext</code>中有一个非常有用的<code>ConditionEvaluationReport</code>。如果启用了<code>DEBUG</code>日志输出，你将看到它。如果你使用<code>spring-boot-actuator</code>，也有一个<code>autoconfig</code>端点，该端点以JSON的格式呈现报表。使用它来调试应用程序，并查看Spring Boot 在运行时添加了哪些特性(没有哪些特性)。</p>
<p>可以通过查看源代码和Javadoc来回答更多的问题。下面是一些经验法则:</p>
<ul>
<li>查找名为<code>*AutoConfiguration</code>的类，并读取它们的源代码，特别是<code>@Conditional*</code>，以找出它们启用和何时启用的功能。添加<code>-debug</code>到命令行或系统属性<code>-Ddebug</code>，这样可以在控制台上打印应用程序中所做的所有自动配置决策的日志。在运行的Actuator 应用程序中，可以查看<code>autoconfig</code>端点(<code>/application/autoconfig</code>或类似的JMX的端点)获取相同的信息。</li>
<li>寻找<code>@ConfigurationProperties</code>(例如<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java"><code>ServerProperties</code></a>)类，并从那里读取可用的外部配置选项。<code>@ConfigurationProperties</code>有一个<code>name</code>属性，它充当外部属性的前缀，因此<code>ServerProperties</code>有<code>prefix=&quot;server&quot;</code>，其配置属性是<code>server.port</code>, <code>server.address</code>等。在一个运行的 Actuator 应用程序中，可以查看<code>configprops</code>端点。</li>
<li>查找<code>Binder</code>的<code>bind</code>方法的用法，来以一种轻松的方式从<code>Environment</code>中明确地拉出配置值。它经常被用作前缀。</li>
<li>查找直接绑定到<code>Environment</code>的<code>@Value</code>注解。</li>
<li>查找<code>@ConditionalOnExpression</code>注释，它在SpEL表达式中有开关的功能，通常使用从<code>Environment</code>中解析的占位符来进行计算。</li>
</ul>
<h3 id="在开始之前自定义Environment或ApplicationContext"><a href="#在开始之前自定义Environment或ApplicationContext" class="headerlink" title="在开始之前自定义Environment或ApplicationContext"></a>在开始之前自定义Environment或ApplicationContext</h3><p><code>SpringApplication</code>拥有 <code>ApplicationListeners</code>和<code>ApplicationContextInitializers</code>，用于定制上下文或环境。Spring Boot 从<code>META-INF/spring.factories</code>加载了许多这样的内部使用的自定义。有不止一种方法可以注册额外的:</p>
<ul>
<li>在运行之前，通过在<code>SpringApplication</code>上以编程的方式调用<code>addListeners</code>和<code>addInitializers</code>方法。</li>
<li>通过设置<code>context.initializer.classes</code>或<code>context.listener.classes</code>来声明。</li>
<li>通过添加<code>META-INF/spring.factories</code>来声明并打包成一个jar文件，所有应用程序都将其作为一个库使用。</li>
</ul>
<p><code>SpringApplication</code>向监听器发送一些特殊的<code>ApplicationEvents</code>(有些甚至在创建上下文之前)，然后注册<code>ApplicationContext</code>所发布的事件的监听器。请参阅“Spring Boot特性”小节中的“<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-application-events-and-listeners">应用程序事件和监听器</a>”部分以获得完整的列表。</p>
<p>也可以在使用<code>EnvironmentPostProcessor</code>刷新应用程序上下文之前自定义<code>Environment</code>。每个实现都应该在<code>META-INF/spring.factories</code>中注册:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.env.EnvironmentPostProcessor&#x3D;com.example.YourEnvironmentPostProcessor</span><br></pre></td></tr></table></figure>
<p>该实现可以加载任意文件并将其添加到<code>Environment</code>中。例如，下面这个例子从类路径加载一个YAML配置文件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvironmentPostProcessorExample</span> <span class="keyword">implements</span> <span class="title">EnvironmentPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> YamlPropertySourceLoader loader = <span class="keyword">new</span> YamlPropertySourceLoader();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessEnvironment</span><span class="params">(ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="function"><span class="params">			SpringApplication application)</span> </span>&#123;</span><br><span class="line">		Resource path = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;com/example/myapp/config.yml&quot;</span>);</span><br><span class="line">		PropertySource&lt;?&gt; propertySource = loadYaml(path);</span><br><span class="line">		environment.getPropertySources().addLast(propertySource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> PropertySource&lt;?&gt; loadYaml(Resource path) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!path.exists()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Resource &quot;</span> + path + <span class="string">&quot; does not exist&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.loader.load(<span class="string">&quot;custom-resource&quot;</span>, path, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">					<span class="string">&quot;Failed to load yaml configuration from &quot;</span> + path, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在默认情况下，<code>Environment</code>已经准备好了所有常见的Spring Boot 加载的属性。因此，可以从环境中获取文件的位置。这个例子在列表的末尾添加了<code>custom-resource</code>属性源，因此在其他任何位置中定义的键都是有优先级的。自定义的实现可以明确地定义其他顺序。</p>
</blockquote>
<blockquote>
<p>虽然在你的<code>@SpringBootApplication</code>上使用<code>@PropertySource</code>似乎很方便，而且很容易在<code>Environment</code>中加载自定义资源，但是我们并不推荐它，因为Spring Boot 会在<code>ApplicationContext</code>刷新之前准备好<code>Environment</code>。通过<code>@PropertySource</code>定义的任何key 都将被加载得太晚以至于不会对自动配置产生任何影响。</p>
</blockquote>
<h3 id="构建ApplicationContext层次结构（添加父或上下文）"><a href="#构建ApplicationContext层次结构（添加父或上下文）" class="headerlink" title="构建ApplicationContext层次结构（添加父或上下文）"></a>构建ApplicationContext层次结构（添加父或上下文）</h3><p>你可以使用<code>ApplicationBuilder</code>类来创建父/子<code>ApplicationContext</code>层次结构。参见“Spring Boot 功能”部分的“<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-fluent-builder-api">流式构建器API</a>”部分，了解更多信息。</p>
<h3 id="创建非web应用"><a href="#创建非web应用" class="headerlink" title="创建非web应用"></a>创建非web应用</h3><p>并非所有Spring 应用程序都必须是web应用程序(或web服务)。如果你想要在<code>main</code>方法中执行一些代码，但是也要启动一个Spring应用程序来设置要使用的基础组件，那么使用Spring Boot的<code>SpringSpringApplication</code>特性这事就很容易了。一个<code>SpringApplication</code>根据它是否需要一个web应用程序来更改它的<code>ApplicationContext</code>类。你可以做的第一件事就是将servlet API依赖从类路径中去除。如果你不能这样做(例如，你从相同的代码库运行两个应用程序)，那么你可以在你的<code>SpringApplication</code>实例上显式地调用<code>setWebEnvironment(false)</code>方法，或者设置<code>applicationContextClass</code>属性(通过Java API或外部属性)。你希望作为业务逻辑运行的应用程序代码可以作为<code>CommandLineRunner</code>实现，并作为一个<code>@Bean</code>定义注入上下文中。</p>
<h2 id="属性和配置"><a href="#属性和配置" class="headerlink" title="属性和配置"></a>属性和配置</h2><h3 id="在构建时自动展开属性"><a href="#在构建时自动展开属性" class="headerlink" title="在构建时自动展开属性"></a>在构建时自动展开属性</h3><p>你可以使用现有的构建配置自动地扩展它们，而不是在你的项目的构建配置中硬编码指定的一些属性。这在Maven和Gradle中都是可能的。</p>
<h4 id="使用Maven自动展开属性"><a href="#使用Maven自动展开属性" class="headerlink" title="使用Maven自动展开属性"></a>使用Maven自动展开属性</h4><p>你可以使用资源过滤来自动展开Maven项目中的属性。如果你使用了<code>spring-boot-starter-parent</code>，那么你可以通过<code>@..@</code>占位符访问Maven项目属性。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.encoding&#x3D;@project.build.sourceEncoding@</span><br><span class="line">app.java.version&#x3D;@java.version@</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有生产配置才能通过这种方式过滤（比如<code>src/test/resources</code>中不会过滤）。</p>
</blockquote>
<blockquote>
<p>如果你启用了<code>addResources</code>标志，<code>spring-boot:run</code>可以将<code>src/main/resources</code>直接添加到classpath中(出去热加载的目的)。这将绕过资源过滤和这个功能。你可以使用<code>exec:java</code> goal或者自定义这个插件的配置，查看<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/maven-plugin//usage.html">插件使用页面</a>获取更多细节。</p>
</blockquote>
<p>如果你没有使用starter parent，你需要在<code>pom.xml</code>(在<code>&lt;build/&gt;元素中</code>)加入以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">	&lt;resource&gt;</span><br><span class="line">		&lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;</span><br><span class="line">		&lt;filtering&gt;true&lt;&#x2F;filtering&gt;</span><br><span class="line">	&lt;&#x2F;resource&gt;</span><br><span class="line">&lt;&#x2F;resources&gt;</span><br></pre></td></tr></table></figure>
<p>和(<code>&lt;plugins/&gt;</code>中)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;maven-resources-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.7&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;configuration&gt;</span><br><span class="line">		&lt;delimiters&gt;</span><br><span class="line">			&lt;delimiter&gt;@&lt;&#x2F;delimiter&gt;</span><br><span class="line">		&lt;&#x2F;delimiters&gt;</span><br><span class="line">		&lt;useDefaultDelimiters&gt;false&lt;&#x2F;useDefaultDelimiters&gt;</span><br><span class="line">	&lt;&#x2F;configuration&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你在配置中使用了标准的Spring占位符(例如：<code>$&#123;foo&#125;</code>)，<code>useDefaultDelimiters</code>属性非常重要。如果没有设置为<code>false</code>，这些也将会被展开。</p>
</blockquote>
<h4 id="使用Gradle自动展开属性"><a href="#使用Gradle自动展开属性" class="headerlink" title="使用Gradle自动展开属性"></a>使用Gradle自动展开属性</h4><p>你可以通过配置Java插件的<code>processResources</code>任务来自动展开Gradle项目的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">processResources &#123;</span><br><span class="line">	expand(project.properties)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你可以通过占位符引用Gradle项目属性，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.name&#x3D;$&#123;name&#125;</span><br><span class="line">app.description&#x3D;$&#123;description&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Gradle的<code>expand</code>方法使用Groovy的<code>SimpleTemplateEngine</code>,它将转换<code>$&#123;...&#125;</code>标志。<code>$&#123;..&#125;</code>样式与Spring自己的属性占位符技术有冲突。为了一起使用Spring的属性占位符和自动展开，你需要转义<code>\$&#123;..&#125;</code>Spring 的属性占位符。</p>
</blockquote>
<h3 id="外部化SpringApplication的配置"><a href="#外部化SpringApplication的配置" class="headerlink" title="外部化SpringApplication的配置"></a>外部化SpringApplication的配置</h3><p>一个<code>SpringApplication</code>具有bean属性(主要是setter方法)，因此当你创建应用程序时你可以使用它的Java API来修改其行为。或者你可以使用<code>spring.main.*</code>中的属性对配置进行外部化。例如,在<code>application.properties</code>中你可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.main.web-environment&#x3D;false</span><br><span class="line">spring.main.banner-mode&#x3D;off</span><br></pre></td></tr></table></figure>
<p>然后Spring Boot banner 将不会在启动时打印出来，并且这个应用将不会是web应用。</p>
<blockquote>
<p>上面的例子还演示了允许在属性名中使用下划线(_)和斜杠(-)是多么的灵活。</p>
</blockquote>
<p>定义在外部配置的属性将会覆盖通过Java API指定的值，除了用来创建<code>ApplicationContext</code>的sources。让我们看下面的应用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new SpringApplicationBuilder()</span><br><span class="line">	.bannerMode(Banner.Mode.OFF)</span><br><span class="line">	.sources(demo.MyApp.class)</span><br><span class="line">	.run(args);</span><br></pre></td></tr></table></figure>
<p>使用了下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.main.sources&#x3D;com.acme.Config,com.acme.ExtraConfig</span><br><span class="line">spring.main.banner-mode&#x3D;console</span><br></pre></td></tr></table></figure>
<p>实际的应用将会显示出banner（因为被配置覆盖了）并且·<code>ApplicationContext</code>使用3个source(以下面的顺序)：<code>demo.MyApp</code>, <code>com.acme.Config</code>, <code>com.acme.ExtraConfig</code>。</p>
<h3 id="更改应用程序的外部属性的位置"><a href="#更改应用程序的外部属性的位置" class="headerlink" title="更改应用程序的外部属性的位置"></a>更改应用程序的外部属性的位置</h3><p>默认情况下不同的source是以定义好的顺序（查看“Spring Boot特性”一节中<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-external-config">外部配置</a>了解确切的顺序）添加到Spring<code>Environment</code>的。</p>
<p>增强和修改这一功能的一个很好的方法是将@propertysource注解添加到你的应用程序sources。传递给<code>SpringApplication</code>静态方法，并使用<code>setSources()</code>添加的这些类将被检查是否有<code>PropertySources</code>，如果它们有，那么这些属性将被尽早添加到<code>Environment</code>中，以便在<code>ApplicationContext</code>生命周期的所有阶段中使用。以这种方式添加的属性比使用默认位置(如application.Properties)、系统属性、环境变量或命令行添加的任何属性优先级都要低。</p>
<p>你也可以提供系统属性（或环境变量）来改变这一行为：</p>
<ul>
<li><code>spring.config.name</code> (<code>SPRING_CONFIG_NAME</code>),默认<code>application</code>为这个文件名的根。</li>
<li><code>spring.config.location</code> (<code>SPRING_CONFIG_LOCATION</code>) 是要加载的文件（例如classpath资源或URL）。为这个文档设置了一个单独的<code>Environment</code>属性并且它可以被系统属性，环境变量或者命令行参数覆盖。</li>
</ul>
<p>无论你设置了什么环境变量，Spring Boot都会加载<code>application.properties</code>。如果使用了YAML那么以“.yml”结尾的文件默认也会被添加到列表中去。</p>
<p>Spring Boot 在<code>DEBUG</code>级别将会打印出加载的配置文件，并在<code>TRACE</code>级别打印出没有找到的备选文件。</p>
<p>查看<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/config/ConfigFileApplicationListener.java">ConfigFileApplicationListener</a>了解更多细节。</p>
<h3 id="使用’短’命令行参数"><a href="#使用’短’命令行参数" class="headerlink" title="使用’短’命令行参数"></a>使用’短’命令行参数</h3><p>有些人喜欢用（例如）<code>--port=9000</code>而不用<code>--server.port=9000</code>在命令行设置配置属性。你可以很容易地通过在<code>application.properties</code>中使用占位符来启用这个功能，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port &#x3D; $&#123;port:8080&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你从<code>spring-boot-starter-parent</code>POM继承而来，<code>maven-resources-plugins</code>默认的过滤标记从<code>$&#123;*&#125;</code>修改为<code>@</code>(例如<code>@maven.token@</code>代替<code>$&#123;maven.token&#125;</code>)来避免与Spring风格的占位符冲突。如果你直接为<code>application.properties</code>启用了maven的过滤，你可能也需要修改默认的过滤符为其他的分隔符。</p>
</blockquote>
<blockquote>
<p>在这种特定情况下端口绑定可以在Heroku和Clound Foundry这样的PaaS环境中生效，因为这两个平台<code>PORT</code>环境变量是自动设置的，并且Spring 可以绑定到<code>Environment</code>属性的大写的同义词属性。</p>
</blockquote>
<h3 id="使用YAML外部属性"><a href="#使用YAML外部属性" class="headerlink" title="使用YAML外部属性"></a>使用YAML外部属性</h3><p>YAML是JSON的一个超集，并且方便以层次格式存储外部属性。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">	application:</span><br><span class="line">		name: cruncher</span><br><span class="line">	datasource:</span><br><span class="line">		driverClassName: com.mysql.jdbc.Driver</span><br><span class="line">		url: jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;test</span><br><span class="line">server:</span><br><span class="line">	port: 9000</span><br></pre></td></tr></table></figure>
<p>创建一个名为<code>application.yml</code>的文件并放在classpath根目录，也需要将<code>snakeyaml</code>添加到依赖中(maven坐标为<code>org.yaml:snakeyaml</code>,如果你使用<code>spring-boot-starter</code>将会自动包含进来)。YAML文件将会解析为Java <code>Map&lt;String,Object&gt;</code>(就像一个JSON对象)，并且Spring Boot使这个map变扁平，这样它具有一层深度并且拥有句号分隔的key，有点儿像java中常常使用的<code>Properties</code>文件。</p>
<p>上面的YAML例子对应到<code>applicatoin.properties</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name&#x3D;cruncher</span><br><span class="line">spring.datasource.driverClassName&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;test</span><br><span class="line">server.port&#x3D;9000</span><br></pre></td></tr></table></figure>
<p>在“Spring Boot特性”一节中查看“<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-external-config-yaml">使用YAML代替Properties</a>”了解更多细节。</p>
<h3 id="设置激活的Spring-profile"><a href="#设置激活的Spring-profile" class="headerlink" title="设置激活的Spring profile"></a>设置激活的Spring profile</h3><p>Spring <code>Environment</code> 有一个针对此的API，但是通常你应该设置一个系统属性(<code>spring.profiles.active</code>)或者一个OS环境变量(<code>SPRING_PROFILES_ACTIVE</code>)。例如通过一个<code>-D</code>参数（记住把它放在main 类或者jar包前）来启动你的应用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar -Dspring.profiles.active&#x3D;production demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>在Spring Boot中你也可以在<code>application.properties</code>中设置激活的profile。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active&#x3D;production</span><br></pre></td></tr></table></figure>
<p>通过这种方式设置的值可以被系统属性或者环境变量设置替代，但是<code>SpringApplicationBuilder.profiles()</code>方法不会。因此后面的Java API 可以用来参数化profile而不改变默认的。</p>
<p>查看“Spring Boot特性”一节中<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-profiles">Profiles</a>了解更多细节。</p>
<h3 id="根据环境改变配置"><a href="#根据环境改变配置" class="headerlink" title="根据环境改变配置"></a>根据环境改变配置</h3><p>YAML文件实际上是一系列以<code>---</code>线分隔的文档，并且每个文档都被解析成独立的扁平map。</p>
<p>如果一个YAML文档包含了<code>spring.profiles</code> key, 那么这个profiles的值（逗号隔开的列表）将会传入Spring <code>Environment.acceptsProfiles()</code> 并且如果其中的任何profile激活了，那么这个文档将会包含到最终的合并结果中（否则不会）。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">	port: 9000</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">	profiles: development</span><br><span class="line">server:</span><br><span class="line">	port: 9001</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">	profiles: production</span><br><span class="line">server:</span><br><span class="line">	port: 0</span><br></pre></td></tr></table></figure>
<p>在这个例子中，默认的端口号是9000，但是如果Spring “development” profile激活了，那么端口号会是9001，如果”production” 激活了，那么它将是0。</p>
<h3 id="发现外部属性的内置选项"><a href="#发现外部属性的内置选项" class="headerlink" title="发现外部属性的内置选项"></a>发现外部属性的内置选项</h3><p>Spring Boot 在运行时从<code>application.properties</code>(或<code>.yml</code>)(和其他位置)绑定外部属性到应用程序中。在一个位置上没有(而且技术上不可能是)所有受支持的属性的详尽列表，因为属性可以来自类路径上的附加jar文件。</p>
<p>具有Actuator 功能的运行中的应用程序有一个<code>configprops</code>端点，它显示了通过<code>@ConfigurationProperties</code>可获得的所有绑定和可绑定属性。</p>
<p>附录包括一个<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#common-application-properties"><code>application.properties</code></a>示例,包含了Spring Boot所支持的最常见属性的列表。最终的列表来自搜索<code>@ConfigurationProperties</code>和<code>@Value</code>注解，以及偶尔使用<code>Binder</code>的源代码。</p>
<h2 id="嵌入式Web服务器"><a href="#嵌入式Web服务器" class="headerlink" title="嵌入式Web服务器"></a>嵌入式Web服务器</h2><h3 id="使用其它Web服务器"><a href="#使用其它Web服务器" class="headerlink" title="使用其它Web服务器"></a>使用其它Web服务器</h3><p>下面的Spring Boot starters 为我们带来了一个默认的容器：</p>
<ul>
<li><code>spring-boot-starter-web</code>和<code>spring-boot-starter-tomcat</code>一起带来了tomcat，<br>但可以使用<code>spring-boot-starter-jetty</code> 和 <code>spring-boot-starter-undertow</code>替代。</li>
<li><code>spring-boot-starter-webflux</code>和<code>spring-boot-starter-reactor-netty</code>带来了Reactor Netty，但是可以使用<code>spring-boot-starter-tomcat, spring-boot-starter-jetty</code> 和 <code>spring-boot-starter-undertow</code>替代。</li>
</ul>
<blockquote>
<p>许多starter 只支持Spring MVC,因此它们传递地带来了<code>spring-boot-starter-web</code>。</p>
</blockquote>
<p>如果你选择使用不同的HTTP服务器，你需要排除那些依赖并且引入你选择的。Spring Boot为HTTP 服务器提供了独立的starter来使这个过程尽可能简单。</p>
<p>下面是一个Maven 的例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Exclude the Tomcat dependency --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Use Jetty instead --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Gradle:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">	&#x2F;&#x2F; exclude Reactor Netty</span><br><span class="line">	compile.exclude module: &#39;spring-boot-starter-reactor-netty&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">	compile &#39;org.springframework.boot:spring-boot-starter-webflux&#39;</span><br><span class="line">	&#x2F;&#x2F; Use Undertow instead</span><br><span class="line">	compile &#39;org.springframework.boot:spring-boot-starter-undertow&#39;</span><br><span class="line">	&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>WebClient</code>需要<code>spring-boot-starter-reactor-netty</code>,因此如果你需要使用其他的HTTP服务器，你需要排除它。</p>
</blockquote>
<h3 id="配置Jetty"><a href="#配置Jetty" class="headerlink" title="配置Jetty"></a>配置Jetty</h3><p>一般可以按照<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-discover-build-in-options-for-external-properties">“发现内置外部属性”</a>对<code>@ConfigurationProperties</code>(<code>ServerProperties</code>是主要的一个)的建议,但也看看<code>ServletWebServerFactoryCustomizer</code>。Jetty api非常丰富,所以一旦你可以访问<code>JettyServletWebServerFactory</code>你可以以多种方式修改它。或者是添加自己的<code>JettyServletWebServerFactory</code>。</p>
<h3 id="添加Servlet-Filter-或-Listener"><a href="#添加Servlet-Filter-或-Listener" class="headerlink" title="添加Servlet, Filter 或 Listener"></a>添加Servlet, Filter 或 Listener</h3><p>有两种方法可以添加<code>Servlet</code>、<code>Filter</code>、<code>ServletContextListener</code>和其他受Servlet规范支持的<code>Listener</code>。你可以为它们提供Spring bean，也可以启用Servlet组件扫描。</p>
<h4 id="使用Spring-Bean添加Servlet，Filter和Listener"><a href="#使用Spring-Bean添加Servlet，Filter和Listener" class="headerlink" title="使用Spring Bean添加Servlet，Filter和Listener"></a>使用Spring Bean添加Servlet，Filter和Listener</h4><p>要添加Servlet、Filter或Servlet<code>*Listener</code>，可以为其提供一个<code>@Bean</code>定义。当你想要注入配置或依赖项时，这可能非常有用。但是，你必须非常小心，它们不会引起太多其他bean的热切初始化，因为它们必须在应用程序生命周期的早期就被安装在容器中(例如，让它们依赖于你的<code>DataSource</code>或JPA配置不是一个好主意)。你可以通过在第一次使用时懒加载而不是初始化时来解决这些限制。</p>
<p>对于<code>Filters</code>和<code>Servlet</code>，你还可以通过添加<code>FilterRegistrationBean</code>或<code>ServletRegistrationBean</code>来添加映射和初始化参数而不是使用底层组件。</p>
<blockquote>
<p>如果在过滤器注册中没有指定<code>dispatcherType</code>，它将匹配<code>FORWARD</code>，<code>INCLUDE</code>和<code>REQUEST</code>。 如果已启用异步，则它也将匹配<code>ASYNC</code>。<br>如果要迁移<code>web.xml</code>中没有<code>dispatcher</code>元素的过滤器，则需要自行指定<code>dispatcherType</code>：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public  FilterRegistrationBean myFilterRegistration() &#123;</span><br><span class="line">	FilterRegistrationBean registration &#x3D; new FilterRegistrationBean();</span><br><span class="line">	registration.setDispatcherTypes(DispatcherType.REQUEST);</span><br><span class="line">	....</span><br><span class="line">	return registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="禁止注册Servlet-或-Filter"><a href="#禁止注册Servlet-或-Filter" class="headerlink" title="禁止注册Servlet 或 Filter"></a>禁止注册Servlet 或 Filter</h5><p>如上所述，任何<code>Servlet</code>或<code>Filter</code> bean将自动注册到servlet容器。 要禁用特定的<code>Filter</code>或<code>Servlet</code> bean的注册，请为其创建一个注册 bean并将其标记为禁用。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">registration</span><span class="params">(MyFilter filter)</span> </span>&#123;</span><br><span class="line">	FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean(filter);</span><br><span class="line">	registration.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用类路径扫描添加Servlet，Filter和Listener"><a href="#使用类路径扫描添加Servlet，Filter和Listener" class="headerlink" title="使用类路径扫描添加Servlet，Filter和Listener"></a>使用类路径扫描添加Servlet，Filter和Listener</h4><p><code>@WebServlet</code>、<code>@WebFilter</code>和<code>@WebListener</code>注解类可以自动注册一个嵌入的servlet容器，通过使用<code>@ServletComponentScan</code>注解<code>@Configuration</code>类，并指定包含你想要注册的组件的包(s)。默认情况下，<code>@ServletComponentScan</code>将从带注解的类的包中进行扫描。</p>
<h3 id="修改HTTP端口"><a href="#修改HTTP端口" class="headerlink" title="修改HTTP端口"></a>修改HTTP端口</h3><p>在独立应用程序中，主HTTP端口默认为<code>8080</code>，但可以使用<code>server.port</code>（例如在<code>application.properties</code>或系统属性中）进行设置。 由于<code>Environment</code>值的松散绑定，你还可以使用<code>SERVER_PORT</code>（例如作为OS环境变量）。</p>
<p>要完全关闭HTTP端点，但仍然创建<code>WebApplicationContext</code>，请使用<code>server.port = -1</code>（这对于测试有时很有用）。</p>
<p>有关更多详细信息，请参阅“Spring Boot功能”部分中的<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-customizing-embedded-containers">“定制嵌入式Servlet容器”</a>或<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java"><code>ServerProperties</code></a>源代码。</p>
<h3 id="使用随机未分配的HTTP端口"><a href="#使用随机未分配的HTTP端口" class="headerlink" title="使用随机未分配的HTTP端口"></a>使用随机未分配的HTTP端口</h3><p>要扫描一个空闲端口（使用OS本机来防止冲突），请使用<code>server.port = 0</code>。</p>
<h3 id="在运行时发现HTTP端口"><a href="#在运行时发现HTTP端口" class="headerlink" title="在运行时发现HTTP端口"></a>在运行时发现HTTP端口</h3><p>你可以从日志输出中访问运行服务器的端口，也可以通过<code>ServletWebServerApplicationContext</code>的<code>EmbeddedWebServer</code>访问。最好的办法来获取和确保它已经初始化了，就是添加一个<code>ApplicationListener&lt;ServletWebServerInitializedEvent&gt;</code>类型的<code>@Bean</code>，并在容器发布的时候将其从容器中取出。</p>
<p>使用<code>@SpringBootTest（webEnvironment = WebEnvironment.RANDOM_PORT）</code>的测试用例也可以使用<code>@LocalServerPort</code>注解将实际的端口注入到字段中。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringBootTest(webEnvironment&#x3D;WebEnvironment.RANDOM_PORT)</span><br><span class="line">public class MyWebIntegrationTests &#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	ServletWebServerApplicationContext server;</span><br><span class="line"></span><br><span class="line">	@LocalServerPort</span><br><span class="line">	int port;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@LocalServerPort</code>是<code>@Value（“$ &#123;local.server.port&#125;”）</code>的元注解。不要试图在普通应用程序中注入端口。 正如我们刚刚看到的，只有在容器初始化后才会设置该值。 与测试相反，应用程序代码回调会被提前处理（即在值实际可用之前）。</p>
</blockquote>
<h3 id="配置SSL"><a href="#配置SSL" class="headerlink" title="配置SSL"></a>配置SSL</h3><p>可以通过设置各种<code>server.ssl.*</code>属性（通常在<code>application.properties</code>或<code>application.yml</code>中）声明性地配置SSL。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.port&#x3D;8443</span><br><span class="line">server.ssl.key-store&#x3D;classpath:keystore.jks</span><br><span class="line">server.ssl.key-store-password&#x3D;secret</span><br><span class="line">server.ssl.key-password&#x3D;another-secret</span><br></pre></td></tr></table></figure>
<p>请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/web/server/Ssl.java"><code>Ssl</code></a>了解所有支持的属性的详细信息。</p>
<p>使用类似上例的配置意味着应用程序将不再支持8080端口上的普通HTTP连接器。Spring Boot不支持通过<code>application.properties</code>配置HTTP和HTTPS两个连接器。如果你想有两个，那么你需要以编程方式配置其中之一。建议使用<code>application.properties</code>配置HTTPS，因为HTTP连接器以编程方式更容易配置。有关示例，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-tomcat-multi-connectors"><code>spring-boot-sample-tomcat-multi-connectors</code></a>示例项目。</p>
<h3 id="配置访问日志"><a href="#配置访问日志" class="headerlink" title="配置访问日志"></a>配置访问日志</h3><p>可以通过各自的命名空间为Tomcat，Undertow和Jetty配置访问日志。</p>
<p>例如，以下以<a target="_blank" rel="noopener" href="https://tomcat.apache.org/tomcat-8.5-doc/config/valve.html#Access_Logging">自定义模式</a>配置Tomcat访问日志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.basedir&#x3D;my-tomcat</span><br><span class="line">server.tomcat.accesslog.enabled&#x3D;true</span><br><span class="line">server.tomcat.accesslog.pattern&#x3D;%t %a &quot;%r&quot; %s (%D ms)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>日志的默认位置是相对于tomcat基本目录的<code>logs</code>目录，默认情况下该目录是临时目录，因此你可能需要修复Tomcat的基本目录或使用日志的绝对路径。在上面的示例中，日志将在相对于应用程序的工作目录的<code>my-tomcat/logs</code>目录中。</p>
</blockquote>
<p>undertow 访问日志可以用类似的方式进行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.undertow.accesslog.enabled&#x3D;true</span><br><span class="line">server.undertow.accesslog.pattern&#x3D;%t %a &quot;%r&quot; %s (%D ms)</span><br></pre></td></tr></table></figure>
<p>日志存储在相对于应用程序的工作目录的<code>logs</code>目录中。这可以通过<code>server.undertow.accesslog.directory</code>进行自定义。</p>
<p>最后，jetty的访问日志也可以这样配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.jetty.accesslog.enabled&#x3D;true</span><br><span class="line">server.jetty.accesslog.filename&#x3D;&#x2F;var&#x2F;log&#x2F;jetty-access.log</span><br></pre></td></tr></table></figure>
<p>默认情况下，日志将被重定向到<code>System.err</code>。 有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.eclipse.org/jetty/documentation/9.4.x/configuring-jetty-request-logs.html">文档</a>。</p>
<h3 id="使用前端代理服务器"><a href="#使用前端代理服务器" class="headerlink" title="使用前端代理服务器"></a>使用前端代理服务器</h3><p>你的应用程序可能需要发送<code>302</code>重定向或使用绝对链接呈现内容。在代理之后运行时，调用者需要链接到代理，而不是托管应用的机器的物理地址。通常情况下，这种情况是通过与代理的约定来处理的，代理将添加头来告诉后端如何构建到自己的链接。</p>
<p>如果代理添加了常规的<code>X-Forwarded-For</code>和<code>X-Forwarded-Proto</code>头（大部分是开箱即用的），只要在你的<code>application.properties</code>中设置<code>server.use-forward-headers</code>为<code>true</code>的,那么服务器就可以正确地呈现绝对链接。</p>
<blockquote>
<p>如果你的应用程序正在Cloud Foundry 或 Heroku 中运行，那么<code>server.use-forward-headers</code>属性将默认为<code>true</code>（如果未指定）。 在所有其他情况下，它默认为<code>false</code>。</p>
</blockquote>
<h4 id="自定义Tomcat的代理配置"><a href="#自定义Tomcat的代理配置" class="headerlink" title="自定义Tomcat的代理配置"></a>自定义Tomcat的代理配置</h4><p>如果你正在使用Tomcat，则可以另外配置用于携带“转发”信息的头的名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.remote-ip-header&#x3D;x-your-remote-ip-header</span><br><span class="line">server.tomcat.protocol-header&#x3D;x-your-protocol-header</span><br></pre></td></tr></table></figure>
<p>Tomcat也配置了一个默认的正则表达式来匹配要被信任的内部代理。默认情况下，<code>10/8</code>, <code>192.168/16</code>, <code>169.254/16</code> 和 <code>127/8</code>中的IP地址是可信的。你可以通过向<code>application.properties</code>添加条目来自定义阀的配置。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.internal-proxies&#x3D;192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有在使用属性文件进行配置时才需要双反斜杠。如果你使用的是YAML，则单个反斜杠就足够了，并且与上面显示的相同的值将是<code>192\.168\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;</code>。</p>
</blockquote>
<blockquote>
<p>你可以通过将<code>internal-proxies</code>设置为空来信任所有代理（但不要在生产中这样做）。</p>
</blockquote>
<p>通过切换自动关闭（即设置 <code>server.use-forward-headers = false</code>）并在<code>TomcatServletWebServerFactory</code> bean中添加一个新的阀实例，可以完全控制Tomcat的<code>RemoteIpValve</code>配置。</p>
<h3 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h3><p>通常，你可以按照<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-discover-build-in-options-for-external-properties">“发现外部属性的内置选项”</a>中有关<code>@ConfigurationProperties</code>（<code>ServerProperties</code>是此处的主要内容）的建议，还可以查看<code>ServletWebServerFactoryCustomizer</code>和各种可以添加到Tomcat特定的<code>*Customizers</code>。 Tomcat的API相当丰富，所以一旦你可以访问<code>TomcatServletWebServerFactory</code>，你可以通过多种方式对其进行修改。或者是添加自己的<code>TomcatServletWebServerFactory</code>。</p>
<h3 id="启用Tomcat多Connector功能"><a href="#启用Tomcat多Connector功能" class="headerlink" title="启用Tomcat多Connector功能"></a>启用Tomcat多Connector功能</h3><p>将<code>org.apache.catalina.connector.Connector</code>添加到<code>TomcatServletWebServerFactory</code>，该<code>TomcatServletWebServerFactory</code>可以允许多个连接器，例如， HTTP和HTTPS连接器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ServletWebServerFactory servletContainer() &#123;</span><br><span class="line">	TomcatServletWebServerFactory tomcat &#x3D; new TomcatServletWebServerFactory();</span><br><span class="line">	tomcat.addAdditionalTomcatConnectors(createSslConnector());</span><br><span class="line">	return tomcat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Connector createSslConnector() &#123;</span><br><span class="line">	Connector connector &#x3D; new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);</span><br><span class="line">	Http11NioProtocol protocol &#x3D; (Http11NioProtocol) connector.getProtocolHandler();</span><br><span class="line">	try &#123;</span><br><span class="line">		File keystore &#x3D; new ClassPathResource(&quot;keystore&quot;).getFile();</span><br><span class="line">		File truststore &#x3D; new ClassPathResource(&quot;keystore&quot;).getFile();</span><br><span class="line">		connector.setScheme(&quot;https&quot;);</span><br><span class="line">		connector.setSecure(true);</span><br><span class="line">		connector.setPort(8443);</span><br><span class="line">		protocol.setSSLEnabled(true);</span><br><span class="line">		protocol.setKeystoreFile(keystore.getAbsolutePath());</span><br><span class="line">		protocol.setKeystorePass(&quot;changeit&quot;);</span><br><span class="line">		protocol.setTruststoreFile(truststore.getAbsolutePath());</span><br><span class="line">		protocol.setTruststorePass(&quot;changeit&quot;);</span><br><span class="line">		protocol.setKeyAlias(&quot;apitester&quot;);</span><br><span class="line">		return connector;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new IllegalStateException(&quot;can&#39;t access keystore: [&quot; + &quot;keystore&quot;</span><br><span class="line">				+ &quot;] or truststore: [&quot; + &quot;keystore&quot; + &quot;]&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-Tomcat的-LegacyCookieProcessor"><a href="#使用-Tomcat的-LegacyCookieProcessor" class="headerlink" title="使用 Tomcat的 LegacyCookieProcessor"></a>使用 Tomcat的 LegacyCookieProcessor</h3><p>Spring Boot使用的嵌入式Tomcat不支持开箱即用的Cookie格式的“Version 0”，你可能会看到以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: An invalid character [32] was present in the Cookie value</span><br></pre></td></tr></table></figure>
<p>如果可能的话，你应该考虑更新你的代码，只存储符合新Cookie规范的值。但是，如果你无法更改cookie的写入方式，则可以将Tomcat配置为使用<code>LegacyCookieProcessor</code>。 要切换到<code>LegacyCookieProcessor</code>，请使用添加<code>TomcatContextCustomizer</code>的<code>ServletWebServerFactoryCustomizer</code> bean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; cookieProcessorCustomizer() &#123;</span><br><span class="line">	return (serverFactory) -&gt; serverFactory.addContextCustomizers(</span><br><span class="line">			(context) -&gt; context.setCookieProcessor(new LegacyCookieProcessor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置Undertow"><a href="#配置Undertow" class="headerlink" title="配置Undertow"></a>配置Undertow</h3><h3 id="启用-Undertow-多Listener功能"><a href="#启用-Undertow-多Listener功能" class="headerlink" title="启用 Undertow 多Listener功能"></a>启用 Undertow 多Listener功能</h3><h3 id="使用-ServerEndpoint创建WebSocket端点"><a href="#使用-ServerEndpoint创建WebSocket端点" class="headerlink" title="使用@ServerEndpoint创建WebSocket端点"></a>使用@ServerEndpoint创建WebSocket端点</h3><p>如果要在使用嵌入式容器的Spring Boot应用程序中使用<code>@ServerEndpoint</code>，则必须声明一个<code>ServerEndpointExporter </code> <code>@Bean</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ServerEndpointExporter serverEndpointExporter() &#123;</span><br><span class="line">	return new ServerEndpointExporter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个bean将用底层的WebSocket容器注册任何<code>ServerEndpoint</code>注解的bean。当部署到一个独立的servlet容器时，这个角色由servlet容器初始化器执行，而<code>ServerEndpointExporter</code> bean是不需要的。</p>
<h3 id="启用HTTP响应压缩"><a href="#启用HTTP响应压缩" class="headerlink" title="启用HTTP响应压缩"></a>启用HTTP响应压缩</h3><p>Jetty,Tomcat和Undertow都支持HTTP响应压缩。可以通过<code>application.properties</code>启用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.compression.enabled&#x3D;true</span><br></pre></td></tr></table></figure>
<p>默认情况下，响应的长度必须至少达到2048个字节，以便进行压缩。可以使用<code>server.compression.min-response-size</code>属性进行配置。</p>
<p>默认情况下，只有当内容类型为以下内容时，响应才会被压缩:</p>
<ul>
<li>text/html</li>
<li>text/xml</li>
<li>text/plain</li>
<li>text/css</li>
</ul>
<p>可以使用<code>server.compression.mime-types</code>属性进行配置。</p>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="编写JSON-REST-服务"><a href="#编写JSON-REST-服务" class="headerlink" title="编写JSON REST 服务"></a>编写JSON REST 服务</h3><p>在Spring Boot应用程序中，只要Jackson2位于类路径上, 任何Spring <code>@RestController</code>都应该在默认情况下呈现JSON响应。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class MyController &#123;</span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;&#x2F;thing&quot;)</span><br><span class="line">	public MyThing thing() &#123;</span><br><span class="line">			return new MyThing();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要<code>MyThing</code>可以由Jackson2(例如普通的POJO或Groovy对象)序列化，那么<code>localhost:8080/thing</code>将默认返回JSON。有时在浏览器中，你可能会看到XML响应，因为浏览器倾向于发送XML优先的accept头。</p>
<h3 id="编写XML-REST-服务"><a href="#编写XML-REST-服务" class="headerlink" title="编写XML REST 服务"></a>编写XML REST 服务</h3><p>如果在类路径中有Jackson XML扩展(<code>jackson-dataformat-xml</code>)，它将被用于呈现XML响应，而与我们使用的JSON相同的示例也会起作用。要使用它，请在你的项目中添加以下依赖项:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可能还想添加对Woodstox的依赖。它比JDK提供的默认StAX实现快得多，而且还增加了美化的打印支持和改进的命名空间处理:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.woodstox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>woodstox-core-asl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不能使用杰克逊的XML扩展，那么将使用JAXB(默认为JDK提供)，并附加要求将<code>MyThing</code>注解<code>@XmlRootElement</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThing</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="comment">// .. getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让服务器呈现XML而不是JSON，你可能需要发送一个<code>Accept:text/XML</code>头(或使用浏览器)。</p>
<h3 id="自定义Jackson-ObjectMapper"><a href="#自定义Jackson-ObjectMapper" class="headerlink" title="自定义Jackson ObjectMapper"></a>自定义Jackson ObjectMapper</h3><p>Spring MVC(客户端和服务器端)使用<code>HttpMessageConverters</code>在HTTP交互中协商内容转换。如果Jackson 在类路径中,你已经得到了<code>Jackson2ObjectMapperBuilder</code>提供的默认的转换器(s),这是自动配置的一个实例。</p>
<p>默认创建的<code>ObjectMapper</code>(或用于JacksonXML转换器的<code>XmlMapper</code>)实例具有以下自定义属性:</p>
<ul>
<li><code>MapperFeature.DEFAULT_VIEW_INCLUSION</code>是禁用的</li>
<li><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>是禁用的</li>
</ul>
<p>Spring Boot也有一些特性，可以使定制这个行为变得更加容易。</p>
<p>你可以使用环境配置<code>ObjectMapper</code>和<code>XmlMapper</code>实例。Jackson提供了一套广泛的简单的开关特性，可用于配置其处理的各个方面。这些特性是在Jackson的六个枚举中描述的，这些枚举映射到环境中的属性:</p>
<table>
<thead>
<tr>
<th>Jackson 枚举</th>
<th>环境属性</th>
</tr>
</thead>
<tbody><tr>
<td><code>com.fasterxml.jackson.databind.DeserializationFeature</code></td>
<td>`spring.jackson.deserialization.<feature_name>=true</feature_name></td>
</tr>
<tr>
<td><code>com.fasterxml.jackson.core.JsonGenerator.Feature</code></td>
<td>`spring.jackson.generator.<feature_name>=true</feature_name></td>
</tr>
<tr>
<td><code>com.fasterxml.jackson.databind.MapperFeature</code></td>
<td>`spring.jackson.mapper.<feature_name>=true</feature_name></td>
</tr>
<tr>
<td><code>com.fasterxml.jackson.core.JsonParser.Feature</code></td>
<td>`spring.jackson.parser.<feature_name>=true</feature_name></td>
</tr>
<tr>
<td><code>com.fasterxml.jackson.databind.SerializationFeature</code></td>
<td>`spring.jackson.serialization.<feature_name>=true</feature_name></td>
</tr>
<tr>
<td><code>com.fasterxml.jackson.annotation.JsonInclude.Include</code></td>
<td>`spring.jackson.default-property-inclusion=always</td>
</tr>
</tbody></table>
<p>例如,设置<code>spring.jackson.serialization.indent_output = true</code>启用美化打印。注意，由于使用了<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/html/boot-features-external-config.html#boot-features-external-config-relaxed-binding">松散绑定</a>，<code>indent_output</code>的情况不必与对应的枚举常量相匹配，后者是<code>INDENT_OUTPUT</code>。</p>
<p>这种基于环境的配置应用于自动配置<code>Jackson2ObjectMapperBuilder</code> bean,并将适用于任何使用这个builder创建的mappers ,包括自动配置<code>ObjectMapper</code> bean。</p>
<p>上下文的<code>Jackson2ObjectMapperBuilder</code>可以由一个或多个<code>Jackson2ObjectMapperBuilderCustomizer</code> bean定制。这种定制的bean可以被排序，而Boot自己的定制器的顺序是0，允许在Boot的定制之前和之后进行额外的定制。</p>
<p>任何<code>com.fasterxml.jackson.databind.Module</code>类型的bean将自动注册自动配置的<code>Jackson2ObjectMapperBuilder</code>和应用于任何它创建的<code>ObjectMapper</code>实例。当向你的应用程序添加新特性时，这提供了一种用于定制模块的全局机制。</p>
<p>如果你想完全替换默认<code>ObjectMapper</code>,要么定义一个这种类型的<code>@ bean</code>并将其标记为<code>@Primary</code>,或者,如果你喜欢builder方式,可以定义一个<code>Jackson2ObjectMapperBuilder</code>  的<code>@Bean</code>。注意，在这两种情况下，这将禁用<code>ObjectMapper</code>的所有自动配置。</p>
<p>如果你提供任何<code>MappingJackson2HttpMessageConverter</code>类型的<code>@ Beans</code>然后他们将取代MVC的默认配置。另外，还提供了一种<code>HttpMessageConverters</code>类型的bean(如果使用默认的MVC配置的话，总是可用的)，它提供了一些有用的方法来访问默认的和用户增强的消息转换器。</p>
<p>请参阅<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/html/howto-spring-mvc.html#howto-customize-the-responsebody-rendering">“定制<code>@ResponseBody</code>渲染”</a>部分和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java"><code>WebMvcAutoConfiguration</code></a>源代码以获得更多详细信息。</p>
<h3 id="自定义-ResponseBody渲染"><a href="#自定义-ResponseBody渲染" class="headerlink" title="自定义@ResponseBody渲染"></a>自定义@ResponseBody渲染</h3><p>Spring使用<code>HttpMessageConverters</code>来渲染<code>@ResponseBody</code>(或来自<code>@RestController</code>的响应)。只需在Spring Boot 上下文中添加这种类型的bean，就可以提供额外的转换器。如果添加的bean是默认包含的类型(例如<code>MappingJackson2HttpMessageConverter</code> JSON转换),那么它将取代默认值。提供了一种<code>HttpMessageConverters</code>类型的bean(如果使用默认的MVC配置的话，总是可用的)，它提供了一些有用的方法来访问默认的和用户增强的消息转换器(例如，如果你想手动将它们注入到一个定制的<code>RestTemplate</code>中)。</p>
<p>在正常使用MVC时,任何提供的<code>WebMvcConfigurer</code> bean通过重写<code>configureMessageConverters</code>方法也可以贡献转换器,但与正常MVC不一样的是,你只能供应你需要的额外的转换器(因为 Spring Boot 使用相同的机制提供它默认的)。最后,如果你选择通过提供自己的<code>@EnableWebMvc</code>配置退出Spring Boot默认的MVC配置,然后你可以完全控制,并使用<code>WebMvcConfigurationSupport</code> 到<code>getMessageConverters</code>来手动做任何事。</p>
<p>更多细节请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java"><code>WebMvcAutoConfiguration</code></a>源代码。</p>
<h3 id="处理文件上传"><a href="#处理文件上传" class="headerlink" title="处理文件上传"></a>处理文件上传</h3><p>Spring Boot包含Servlet 3 <code>javax.servlet.http.Part</code>API来支持上传文件。在默认情况下，Spring Boot配置Spring MVC，每个文件最大为1MB，在单个请求中最多可达到10MB的文件数据。你可以覆盖这些值，以及存储中间数据的位置(例如，存储到<code>/tmp</code>目录)，以及通过使用在<code>MultipartProperties</code>类中公开的属性将数据刷新到磁盘的阈值。如果你想指定文件是无限的,例如,设置<code>spring.servlet.multipart.max-file-size</code>属性为<code>-1</code>。</p>
<p>当你希望在Spring MVC控制器处理程序方法中作为<code>@RequestParam</code>注解的<code>MultipartFile</code>类型参数来接收multipart编码的文件数据时，multipart的支持是很有帮助的。</p>
<p>查看<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/MultipartAutoConfiguration.java"><code>MultipartAutoConfiguration</code></a>源代码获取更多的细节。</p>
<h3 id="关闭Spring-MVC-DispatcherServlet"><a href="#关闭Spring-MVC-DispatcherServlet" class="headerlink" title="关闭Spring MVC DispatcherServlet"></a>关闭Spring MVC DispatcherServlet</h3><p>Spring Boot希望从应用程序的<code>/</code>提供所有内容。如果你更愿意将自己的servlet映射到该URL，你可以这样做，但是你可能会丢失一些其他的Boot MVC 特性。添加自己的servlet并将其映射到根资源只需声明一个<code>Servlet</code>类型的<code>@ Bean</code>并且给它特殊的bean名称-<code>dispatcherServlet</code>(如果你想关掉它,而不是取代它,你还可以创建一个不同类型同名称的bean)。</p>
<h3 id="关闭默认MVC配置"><a href="#关闭默认MVC配置" class="headerlink" title="关闭默认MVC配置"></a>关闭默认MVC配置</h3><p>对MVC配置进行完全控制的最简单方法是，提供你自己的<code>@Configuration</code>，并使用<code>@EnableWebMvc</code>注解。这将把所有MVC配置掌握在你的手中。</p>
<h3 id="自定义ViewResolver"><a href="#自定义ViewResolver" class="headerlink" title="自定义ViewResolver"></a>自定义ViewResolver</h3><p><code>ViewResolver</code>是Spring MVC的核心组件，将<code>@Controller</code>中的视图名转换为实际的<code>View</code>实现。请注意，<code>ViewResolvers</code>主要用于UI应用程序，而不是REST风格的服务(<code>View</code>不用于渲染<code>@ResponseBody</code>)。有许多<code>ViewResolver</code>的实现可供选择，而Spring本身并不建议你应该使用哪一个。另一方面，Spring Boot根据它在类路径和应用程序上下文中找到的内容，为你安装一个或两个。<code>DispatcherServlet</code>使用它在应用程序上下文中找到的所有解析器，依次尝试每一个解析器，直到得到一个结果，因此，如果你要添加自己的解析器，那么你必须了解该顺序，并在其中添加你的解析器。</p>
<p><code>WebMvcAutoConfiguration</code>为您的上下文添加了以下<code>ViewResolvers</code>:</p>
<ul>
<li>一个<code>InternalResourceViewResolver</code> bean，id 为“defaultViewResolver”。这一项定位了可以使用<code>DefaultServlet</code>来渲染的物理资源(例如，如果你使用的是静态资源和JSP页面)。它在视图名中应用一个前缀和一个后缀，然后在servlet上下文中查找带有该路径的物理资源(默认值都是空的，但是通过<code>spring.mvc.view.prefix</code>和<code>spring.mvc.view.suffix</code>可以访问外部配置)。可以通过提供相同类型的bean来覆盖它。</li>
<li>一个id为“BeanNameViewResolver”的<code>BeanNameViewResolver</code>。这是视图解析器链中的一个有用的成员，它将使用与正在解析的<code>View</code>相同的名称来获取任何bean。不应该重写或替换它。</li>
<li>一个id 为“viewResolver”的<code>ContentNegotiatingViewResolver</code> 实际上只有存在实际的<code>View</code>类型的bean时才会被添加。这是一个“主”解析器，委托给其他解析器，并试图找到一个匹配客户端发送的“Accept”HTTP头的匹配项。有一个<a target="_blank" rel="noopener" href="https://spring.io/blog/2013/06/03/content-negotiation-using-views">关于<code>ContentNegotiatingViewResolver</code>有用的博客</a>,你可能更喜欢研究学习,可以查看源代码了解更多。你可以通过定义一个bean名为“viewResolver”关掉自动配置<code>ContentNegotiatingViewResolver</code>。</li>
<li>如果你用的是Thymeleaf，也会有一个id为“thymeleafViewResolver”的<code>ThymeleafViewResolver</code>。它通过使用前缀和后缀包围视图名来查找资源(<code>spring.thymeleaf.prefix</code>和<code>spring.thymeleaf.suffix</code>，默认分别为”classpath:/templates/“和”.html”的)。可以通过提供相同名称的bean来覆盖它。</li>
<li>如果你使用FreeMarker，也会有一个id为“freeMarkerViewResolver”的<code>FreeMarkerViewResolver</code>。它在围绕视图名称的前缀和后缀(<code>spring.freemarker.prefix</code>和 <code>spring.freemarker.suffix</code>)的加载路径(<code>spring.freemarker.templateLoaderPath</code>,默认分别为“classpath:/templates/”和”.tpl”)中查找资源。可以通过提供相同名称的bean来覆盖它。</li>
<li>如果您使用的是Groovy模板(实际上，如果你的类路径上有Groovy模板)，那么也会有一个id为’groovyMarkupViewResolver’的<code>GroovyMarkupViewResolver</code>。它在围绕视图名称的前缀和后缀(<code>spring.groovy.template.prefix</code>和 <code>spring.groovy.template.suffix</code>)的加载路径(<code>spring.freemarker.templateLoaderPath</code>,默认分另为“classpath:/templates/”和”.tpl”)中查找资源。可以通过提供相同名称的bean来覆盖它。</li>
</ul>
<p>查看<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java"><code>WebMvcAutoConfiguration</code></a>、<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/thymeleaf/ThymeleafAutoConfiguration.java"><code>ThymeleafAutoConfiguration</code></a>，<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/freemarker/FreeMarkerAutoConfiguration.java"><code>FreeMarkerAutoConfiguration</code></a>，<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/groovy/template/GroovyTemplateAutoConfiguration.java"><code>GroovyTemplateAutoConfiguration</code></a>了解更多。</p>
<h2 id="HTTP-客户端"><a href="#HTTP-客户端" class="headerlink" title="HTTP 客户端"></a>HTTP 客户端</h2><h3 id="配置RestTemplate使用代理"><a href="#配置RestTemplate使用代理" class="headerlink" title="配置RestTemplate使用代理"></a>配置RestTemplate使用代理</h3><p>正如<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/html/boot-features-resttemplate.html#boot-features-resttemplate-customization">“RestTemplate定制”</a>中所描述的那样，<code>RestTemplateCustomizer</code>可以使用<code>RestTemplateBuilder</code>来构建一个定制的<code>RestTemplate</code>。这是创建配置使用代理的<code>RestTemplate</code>的推荐方法。</p>
<p>代理配置的具体细节取决于正在使用的底层客户端请求工厂。这里有一个例子配置<code>HttpComponentsClientRequestFactory</code>,包含了一个 <code>HttpClient</code>,除了<code>192.168.0.5</code>以外，它为其他的主机都使用一个代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCustomizer</span> <span class="keyword">implements</span> <span class="title">RestTemplateCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">		HttpHost proxy = <span class="keyword">new</span> HttpHost(<span class="string">&quot;proxy.example.com&quot;</span>);</span><br><span class="line">		HttpClient httpClient = HttpClientBuilder.create()</span><br><span class="line">				.setRoutePlanner(<span class="keyword">new</span> DefaultProxyRoutePlanner(proxy) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> HttpHost <span class="title">determineProxy</span><span class="params">(HttpHost target,</span></span></span><br><span class="line"><span class="function"><span class="params">							HttpRequest request, HttpContext context)</span></span></span><br><span class="line"><span class="function">									<span class="keyword">throws</span> HttpException </span>&#123;</span><br><span class="line">						<span class="keyword">if</span> (target.getHostName().equals(<span class="string">&quot;192.168.0.5&quot;</span>)) &#123;</span><br><span class="line">							<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">super</span>.determineProxy(target, request, context);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;).build();</span><br><span class="line">		restTemplate.setRequestFactory(</span><br><span class="line">				<span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>除了Commons Logging API，Spring Boot没有强制的日志记录依赖，其中有许多实现可供选择。要使用<a target="_blank" rel="noopener" href="http://logback.qos.ch/">Logback</a>，你需要在引入它和<code>jcl-over-slf4j</code>(它实现了公共资源日志API)。最简单的方法是通过starter，这些启动器都依赖于<code>spring-boot-starter-logging</code>。对于一个web应用程序，你只需要<code>spring-boot-starter-web</code>，因为它依赖于日志starter。例如在Maven中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring Boot有一个<code>LoggingSystem</code>抽象，它试图根据类路径的内容来配置日志记录。如果可以使用Logback，这是第一选择。</p>
<p>如果你需要对日志进行的惟一更改是设置不同记录器的级别，那么你可以在<code>application.properties</code>中使用”logging.level” 前缀来执行此操作,,如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.level.org.springframework.web&#x3D;DEBUG</span><br><span class="line">logging.level.org.hibernate&#x3D;ERROR</span><br></pre></td></tr></table></figure>
<p>你还可以使用“logg.file”设置文件的位置(除控制台之外)。</p>
<p>要更细粒度的设置日志系统，你需要使用由<code>LoggingSystem</code>支持的原生配置格式。默认情况下，Spring Boot从系统的默认位置获取原生配置(例如:Logback的<code>classpath:logback.xml</code>)，但是你可以使用”logging.config”属性设置配置文件的位置。</p>
<h3 id="配置Logback进行日志记录"><a href="#配置Logback进行日志记录" class="headerlink" title="配置Logback进行日志记录"></a>配置Logback进行日志记录</h3><p>如果你放了一个<code>logback.xml</code>文件在类路径的根目录中，它将从那里获取(或者是<code>logback-spring.xml</code>以利用Boot 提供的模板特性)。Spring Boot提供了一个默认的基本配置，如果你只想设置级别，你可以包括它。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/base.xml&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework.web&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你看过spring-boot jar中的<code>base.xml</code>，你将看到它使用了一些有用的系统属性，<code>LoggingSystem</code>为你创建了这些属性。它们是:</p>
<ul>
<li><code>$&#123;PID&#125;</code>当前的进程ID。</li>
<li><code>$&#123;LOG_FILE&#125;</code> 如果在Boot的外部配置中设置了<code>logging.file</code>。</li>
<li><code>$&#123;LOG_PATH&#125;</code> 如果设置了<code>logging.path</code>(表示一个用于存放日志文件的目录)。</li>
<li><code>$&#123;LOG_EXCEPTION_CONVERSION_WORD&#125;</code> 如果在Boot 的外部配置中设置了<code>logging.exception-conversion-word</code>。</li>
</ul>
<p>Spring Boot还使用自定义的Logback转换器在控制台(但不是在日志文件中)提供了一些漂亮的ANSI颜色终端输出。查看默认的<code>base.xml</code>配置了解更多细节。</p>
<p>如果Groovy在类路径上，你应该也能够用<code>logback.groovy</code>来配置Logback(如果有的话，它将会被优先考虑)。</p>
<h4 id="配置logback只以文件输出"><a href="#配置logback只以文件输出" class="headerlink" title="配置logback只以文件输出"></a>配置logback只以文件输出</h4><p>如果你想要禁用控制台日志记录，并且只将输出写入文件，那么你需要一个自定义的<code>logback-spring.xml</code>文件,它引入<code>file-appender.xml</code>而不引入<code>console-appender.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_FILE&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;/&#125;spring.log&#125;&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/file-appender.xml&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你还需要在<code>application.properties</code>中加入<code>logging.file</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.file&#x3D;myapplication.log</span><br></pre></td></tr></table></figure>
<h3 id="配置Log4j进行日志记录"><a href="#配置Log4j进行日志记录" class="headerlink" title="配置Log4j进行日志记录"></a>配置Log4j进行日志记录</h3><p>如果在类路径上存在<a target="_blank" rel="noopener" href="http://logging.apache.org/log4j/2.x">Log4j 2</a>，Spring Boot 将支持Log4j 2进行日志配置。如果你正在使用starter来收集依赖关系，这意味着你必须排除Logback，然后将log4j 2包含在内。如果你没有使用starter，那么除了Log4j 2之外，你还需要提供<code>jcl-over-slf4j</code>(至少)。</p>
<p>最简单的方式可能是通过starter，尽管它需要配置一些不包含，例如在Maven中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Log4j starter的使用聚集了对常见日志必要的依赖项(例如，包括Tomcat使用的<code>java.util.logging</code>但是配置使用Log4j 2进行日志记录）。请参阅Actuator Log4j 2的示例以获得更多细节，并在实际操作中查看。</p>
</blockquote>
<h4 id="使用YAML或JSON来配置Log4j-2"><a href="#使用YAML或JSON来配置Log4j-2" class="headerlink" title="使用YAML或JSON来配置Log4j 2"></a>使用YAML或JSON来配置Log4j 2</h4><p>除了默认的XML配置格式之外，Log4j 2还支持YAML和JSON配置文件。要配置Log4j 2以使用另一种配置文件格式，将适当的依赖项添加到类路径，并命名配置文件以匹配你所选择的文件格式:</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>依赖</th>
<th>文件名</th>
</tr>
</thead>
<tbody><tr>
<td>YAML</td>
<td>com.fasterxml.jackson.core:jackson-databind    com.fasterxml.jackson.dataformat:jackson-dataformat-yaml</td>
<td>log4j2.yaml log4j2.yml</td>
</tr>
<tr>
<td>JSON</td>
<td>com.fasterxml.jackson.core:jackson-databind</td>
<td>log4j2.json   log4j2.jsn</td>
</tr>
</tbody></table>
<h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><h3 id="配置自定义数据源"><a href="#配置自定义数据源" class="headerlink" title="配置自定义数据源"></a>配置自定义数据源</h3><p>要配置你自己的<code>DataSource</code>，请在你的配置中定义该类型的<code>@Bean</code>。 Spring Boot会在需要的地方重复使用你的<code>DataSource</code>，包括数据库初始化。 如果你需要将某些设置外部化，则可以轻松地将<code>DataSource</code>绑定到环境（请参阅<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/html/boot-features-external-config.html#boot-features-external-config-3rd-party-configuration">第24.7.1节“第三方配置”</a>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;app.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FancyDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.datasource.url&#x3D;jdbc:h2:mem:mydb</span><br><span class="line">app.datasource.username&#x3D;sa</span><br><span class="line">app.datasource.pool-size&#x3D;30</span><br></pre></td></tr></table></figure>
<p>假设你的<code>FancyDataSource</code>具有常规的JavaBean属性,包括url，用户名和池大小，那么在<code>DataSource</code>可用于其他组件之前，将自动绑定这些设置。 常规的<a target="_blank" rel="noopener" href="http://www.docsh.site/docs/spring-boot/spring-boot-docs/current/en/reference/html/howto-database-initialization.html#howto-initialize-a-database-using-spring-jdbc">数据库初始化</a>也会发生（所以<code>spring.datasource.*</code>的相关子集仍然可以与你的自定义配置一起使用）。</p>
<p>如果你正在配置自定义的JNDI<code>DataSource</code>，则可以应用相同的原则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(destroyMethod=&quot;&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;app.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	JndiDataSourceLookup dataSourceLookup = <span class="keyword">new</span> JndiDataSourceLookup();</span><br><span class="line">	<span class="keyword">return</span> dataSourceLookup.getDataSource(<span class="string">&quot;java:comp/env/jdbc/YourDS&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Boot还提供了一个实用的构造器类<code>DataSourceBuilder</code>，可用于创建其中一个标准数据源（如果它在类路径上）。构造器可以根据类路径上的可用内容来检测要使用的类。 它也会根据JDBC URL自动检测驱动程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要使用该<code>DataSource</code>运行应用程序，所需要的只是连接信息; 还可以提供特定于池的设置，请检查将在运行时使用的具体实现以获取更多详细信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;test</span><br><span class="line">app.datasource.username&#x3D;dbuser</span><br><span class="line">app.datasource.password&#x3D;dbpass</span><br><span class="line">app.datasource.pool-size&#x3D;30</span><br></pre></td></tr></table></figure>
<p>但有一个问题。 由于连接池的实际类型未公开，所以在你的自定义<code>DataSource</code>的元数据中不会生成任何键，并且你的IDE中没有自动提示功能（<code>DataSource</code>接口不公开任何属性）。 另外，如果你碰巧在类路径上有Hikari，这个基本的设置将不起作用，因为Hikari没有<code>url</code>属性（而是一个<code>jdbcUrl</code>属性）。 你将不得不重写你的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.datasource.jdbc-url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;test</span><br><span class="line">app.datasource.username&#x3D;dbuser</span><br><span class="line">app.datasource.password&#x3D;dbpass</span><br><span class="line">app.datasource.maximum-pool-size&#x3D;30</span><br></pre></td></tr></table></figure>
<p>你可以通过强制连接池使用并返回一个专门的实现，而不是<code>DataSource</code>来解决这个问题。 你将无法在运行时更改实现，但选项列表将是显式的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HikariDataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> DataSourceBuilder.create().type(HikariDataSource.class).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你甚至可以进一步利用<code>DataSourceProperties</code>为你做的事情，即如果没有提供一个合理的用户名和密码的URL,则提供一个默认的嵌入式数据库。 你可以很容易地从任何<code>DataSourceProperties</code>的状态初始化一个<code>DataSourceBuilder</code>，所以你可以注入Spring Boot自动创建的那个。 但是，这会将你的配置拆分为两个命名空间：url，用户名，密码，类型和驱动在<code>spring.datasource</code>上，其他的在自定义命名空间（<code>app.datasource</code>）上。为了避免这种情况，你可以在自定义命名空间上重新定义自定义的<code>DataSourceProperties</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">dataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HikariDataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> properties.initializeDataSourceBuilder().type(HikariDataSource.class)</span><br><span class="line">			.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了选择了一个专用的连接池（在代码中）并且它的设置暴露在相同的命名空间，这个设置使你与默认情况下的Spring Boot配合。 由于<code>DataSourceProperties</code>为你处理<code>url</code>/<code>jdbcUrl</code>转义，因此可以像这样配置它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;test</span><br><span class="line">app.datasource.username&#x3D;dbuser</span><br><span class="line">app.datasource.password&#x3D;dbpass</span><br><span class="line">app.datasource.maximum-pool-size&#x3D;30</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于你的自定义配置选择Hikari，<code>app.datasource.type</code>将不起作用。 在实践中，构造器将被初始化为设置的任何可能的值，然后被对<code>.type()</code>的调用覆盖。</p>
</blockquote>
<p>更多详细信息请参见“Spring Boot功能”部分的<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/html/boot-features-sql.html#boot-features-configure-datasource">第29.1节“配置数据源”</a>和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java"><code>DataSourceAutoConfiguration</code></a>类源代码。</p>
<h3 id="配置两个数据源"><a href="#配置两个数据源" class="headerlink" title="配置两个数据源"></a>配置两个数据源</h3><p>如果你需要配置多个数据源，则可以应用上一节中所述的相同技巧。 但是，你必须标记一个<code>DataSource``@Primary</code>，因为各种自动配置都希望能够按类型获得一个。</p>
<p>如果您创建自己的<code>DataSource</code>，则自动配置将退出。在下面的示例中，我们提供了与在主数据源上自动配置提供的完全相同的功能集：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource.foo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">fooDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource.foo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">fooDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fooDataSourceProperties().initializeDataSourceBuilder().build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource.bar&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BasicDataSource <span class="title">barDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> DataSourceBuilder.create().type(BasicDataSource.class).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>必须将<code>fooDataSourceProperties</code>标记为<code>@Primary</code>，以便数据库初始化程序功能使用你的副本（如果使用的话）。</p>
</blockquote>
<p>这两个数据源也都是用于高级自定义的。 例如，你可以如下配置它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.datasource.foo.type&#x3D;com.zaxxer.hikari.HikariDataSource</span><br><span class="line">app.datasource.foo.maximum-pool-size&#x3D;30</span><br><span class="line"></span><br><span class="line">app.datasource.bar.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;test</span><br><span class="line">app.datasource.bar.username&#x3D;dbuser</span><br><span class="line">app.datasource.bar.password&#x3D;dbpass</span><br><span class="line">app.datasource.bar.max-total&#x3D;30</span><br></pre></td></tr></table></figure>
<p>当然，你也可以将相同的概念应用于辅助<code>DataSource</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource.foo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">fooDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource.foo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">fooDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fooDataSourceProperties().initializeDataSourceBuilder().build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource.bar&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">barDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource.bar&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">barDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> barDataSourceProperties().initializeDataSourceBuilder().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的这个例子在自定义命名空间上配置了两个数据源，这与Spring Boot在自动配置中做了相同的逻辑。</p>
<h3 id="使用Spring-Data仓库"><a href="#使用Spring-Data仓库" class="headerlink" title="使用Spring Data仓库"></a>使用Spring Data仓库</h3><p>Spring Data可以为你创建各种风格的<code>@Repository</code>接口。只要这些<code>@Repositories</code>包含在<code>@EnableAutoConfiguration</code>类的相同包（或子包）中，Spring Boot将为你处理所有这些接口。</p>
<p>对于许多应用程序来说，你需要的所有东西是把正确的Spring Data依赖关系放到你的类路径中（JPA有一个<code>spring-boot-starter-data-jpa</code>和一个Mongodb的<code>spring-boot-starter-data-mongodb</code>），创建一些仓库接口来处理你的<code>@Entity</code>对象。 有两个示例<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-data-jpa">JPA示例</a>和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-data-mongodb">Mongodb示例</a>。</p>
<p>Spring Boot尝试根据找到的<code>@EnableAutoConfiguration</code>来猜测<code>@Repository</code>定义的位置。 为了更好的控制，可以使用<code>@EnableJpaRepositories</code>注解（来自Spring Data JPA）。</p>
<h3 id="从Spring配置中分离-Entity定义"><a href="#从Spring配置中分离-Entity定义" class="headerlink" title="从Spring配置中分离@Entity定义"></a>从Spring配置中分离@Entity定义</h3><p>Spring Boot尝试根据找到的<code>@EnableAutoConfiguration</code>来猜测你的<code>@Entity</code>定义的位置。 为了获得更多控制权，你可以使用<code>@EntityScan</code>注解，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@EntityScan(basePackageClasses=City.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置JPA属性"><a href="#配置JPA属性" class="headerlink" title="配置JPA属性"></a>配置JPA属性</h3><p>Spring Data JPA已经提供了一些与供应商无关的配置选项（例如用于SQL日志记录），Spring Boot公开了这些，还有一些作为hibernate的外部配置属性。 其中一些是根据上下文自动检测，所以你不应该设置它们。</p>
<p><code>spring.jpa.hibernate.ddl-auto</code>是一个特殊情况，因为它具有不同的默认值，这取决于运行时的条件。 如果使用嵌入式数据库，并且没有像Liquibase或Flyway这样的schema管理器处理<code>DataSource</code>，那么它将默认使用<code>create-drop</code>。 在其他情况下，它默认为<code>none</code>。</p>
<p>使用的方言也是根据当前的<code>DataSource</code>自动检测的，但是如果你想明确地使用方言，你可以自己设置<code>spring.jpa.database</code>，并绕过启动时的检查。</p>
<blockquote>
<p>指定一个<code>database</code>将导致定义良好的Hibernate方言的配置。一些数据库有不止一个<code>Dialect</code>，这有可能不适合你的需要。在这种情况下，你可以将<code>spring.jpa.database</code>设置为默认值，让Hibernate自己解决，或使用<code>spring.jpa.database-platform</code>属性设置方言。</p>
</blockquote>
<p>最常见的选项是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.hibernate.naming.physical-strategy&#x3D;com.example.MyPhysicalNamingStrategy</span><br><span class="line">spring.jpa.show-sql&#x3D;true</span><br></pre></td></tr></table></figure>
<p>另外，在创建本地<code>EntityManagerFactory</code>时，<code>spring.jpa.properties.*</code>中的所有属性都作为普通的JPA属性（去掉了前缀）传递。</p>
<h3 id="配置Hibernate命名策略"><a href="#配置Hibernate命名策略" class="headerlink" title="配置Hibernate命名策略"></a>配置Hibernate命名策略</h3><p>Hibernate使用<a target="_blank" rel="noopener" href="http://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#naming">两种不同的命名策略</a>来将名称从对象模型映射到相应的数据库名称。物理和隐式策略实现的完全限定类名称可分别使用<code>spring.jpa.hibernate.naming.physical-strategy</code>和<code>spring.jpa.hibernate.naming.implicit-strategy</code>属性进行配置。</p>
<p>Spring Boot默认使用<code>SpringPhysicalNamingStrategy</code>配置物理命名策略。这个实现提供了与Hibernate 4相同的表结构：所有的点都被下划线替换，而且驼峰也被下划线替换。 默认情况下，所有表名都以小写形式生成，但如果你的schema 需要，则可以覆盖该标志。</p>
<p>具体来说，<code>TelephoneNumber</code>实体将被映射到<code>telephone_number</code>表。</p>
<p>如果你更喜欢使用Hibernate 5的默认值，请设置以下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.hibernate.naming.physical-strategy&#x3D;org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</span><br></pre></td></tr></table></figure>
<p>有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaAutoConfiguration.java"><code>HibernateJpaAutoConfiguration</code></a>和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/JpaBaseConfiguration.java"><code>JpaBaseConfiguration</code></a>。</p>
<h3 id="使用自定义EntityManagerFactory"><a href="#使用自定义EntityManagerFactory" class="headerlink" title="使用自定义EntityManagerFactory"></a>使用自定义EntityManagerFactory</h3><p>要完全控制<code>EntityManagerFactory</code>的配置，你需要添加一个名为“entityManagerFactory”的<code>@Bean</code>。 Spring Boot的自动配置基于该类型的bean的存在与否关闭其实体管理器。</p>
<h3 id="使用两个实体管理器"><a href="#使用两个实体管理器" class="headerlink" title="使用两个实体管理器"></a>使用两个实体管理器</h3><p>即使默认的<code>EntityManagerFactory</code>工作正常，你也需要定义一个新的，否则该类型的第二个bean的存在将关闭默认的这个。 为了简化操作，你可以使用Spring Boot提供的方便的<code>EntityManagerBuilder</code>，或者如果你愿意，可以直接使用Spring ORM中的<code>LocalContainerEntityManagerFactoryBean</code>。<br>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add two data sources configured as above</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">customerEntityManagerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> builder</span><br><span class="line">			.dataSource(customerDataSource())</span><br><span class="line">			.packages(Customer.class)</span><br><span class="line">			.persistenceUnit(<span class="string">&quot;customers&quot;</span>)</span><br><span class="line">			.build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">orderEntityManagerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> builder</span><br><span class="line">			.dataSource(orderDataSource())</span><br><span class="line">			.packages(Order.class)</span><br><span class="line">			.persistenceUnit(<span class="string">&quot;orders&quot;</span>)</span><br><span class="line">			.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的配置几乎可以自行完成。要完成整个过程，你还需要为两个<code>EntityManagers</code>配置<code>TransactionManagers</code>。 如果你把其中一个标记为@Primary，它可以被Spring Boot中默认的<code>JpaTransactionManager</code>支持，另一个必须明确地注入一个新的实例。 或者你也可以使用跨越两者的JTA事务管理器。</p>
<p>如果你使用Spring Data，则需要相应地配置<code>@EnableJpaRepositories</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(basePackageClasses = Customer.class,</span></span><br><span class="line"><span class="meta">		entityManagerFactoryRef = &quot;customerEntityManagerFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerConfiguration</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(basePackageClasses = Order.class,</span></span><br><span class="line"><span class="meta">		entityManagerFactoryRef = &quot;orderEntityManagerFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderConfiguration</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用传统的persistence-xml"><a href="#使用传统的persistence-xml" class="headerlink" title="使用传统的persistence.xml"></a>使用传统的persistence.xml</h3><p>Spring不需要使用XML来配置JPA提供程序，并且Spring Boot假定你想要利用该功能。如果你喜欢使用<code>persistence.xml</code>，那么你需要定义自己的<code>LocalEntityManagerFactoryBean</code>（id为’entityManagerFactory’)类型的<code>@Bean</code>，并设置持久化单元名称。</p>
<p>有关默认设置，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/JpaBaseConfiguration.java"><code>JpaBaseConfiguration</code></a>。</p>
<h3 id="使用Spring-Data-JPA和Mongo仓库"><a href="#使用Spring-Data-JPA和Mongo仓库" class="headerlink" title="使用Spring Data JPA和Mongo仓库"></a>使用Spring Data JPA和Mongo仓库</h3><p>Spring Data JPA和Spring Data Mongo可以自动为你创建<code>Repository</code>实现。 如果它们都出现在类路径中，那么可能需要做一些额外的配置来告诉Spring Boot你为哪一个（或两者）创建存储库。 最明显的方法是使用标准的Spring Data <code>@Enable*Repositories</code>，并告诉它你的<code>Repository</code>接口的位置（其中’*’是’Jpa’或’Mongo’或是两者）。</p>
<p>还有一些<code>spring.data.*.repositories.enabled</code>标志，你可以使用它们在外部配置中打开和关闭自动配置的存储库。例如，如果你想要关闭Mongo仓库并且仍然使用自动配置的<code>MongoTemplate</code>，这很有用。</p>
<p>其他自动配置的Spring Data  存储库类型（Elasticsearch，Solr）也存在同样的障碍和相同的功能。只需分别更改注解和标志的名称。</p>
<h3 id="暴露Spring数据仓库为REST端点"><a href="#暴露Spring数据仓库为REST端点" class="headerlink" title="暴露Spring数据仓库为REST端点"></a>暴露Spring数据仓库为REST端点</h3><p>Spring Data REST只要为应用程序启用了Spring MVC，就可以将<code>Repository</code>实现公开为REST端点。</p>
<p>Spring Boot公开了一些自定义<code>RepositoryRestConfiguration</code>的<code>spring.data.rest</code>命名空间的有用属性。如果你需要提供额外的定制，你应该使用<code>RepositoryRestConfigurer</code> bean。</p>
<blockquote>
<p>如果你没有在你自定义的<code>RepositoryRestConfigurer</code>中指定任何顺序，它将在Spring Boot在内部使用的那个后运行。 如果你需要指定顺序，请确保它大于0。</p>
</blockquote>
<h3 id="配置JPA使用的组件"><a href="#配置JPA使用的组件" class="headerlink" title="配置JPA使用的组件"></a>配置JPA使用的组件</h3><p>如果你想配置一个将被JPA使用的组件，那么你需要确保组件在JPA之前被初始化。 如果组件是自动配置的，Spring Boot将为你处理这个问题。例如，当Flyway自动配置时，Hibernate被配置为依赖于Flyway，这样后者有机会在Hibernate尝试使用它之前初始化数据库。</p>
<p>如果你自己配置组件，则可以使用<code>EntityManagerFactoryDependsOnPostProcessor</code>子类作为设置必需依赖项的便捷方式。例如，如果你使用Elasticsearch作为Hibernate Search的索引管理器，那么任何<code>EntityManagerFactory</code> bean都必须配置为依赖于<code>elasticsearchClient</code> bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> EntityManagerFactoryDependsOnPostProcessor&#125; that ensures that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> EntityManagerFactory&#125; beans depend on the &#123;<span class="doctag">@code</span> elasticsearchClient&#125; bean.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchJpaDependencyConfiguration</span></span></span><br><span class="line"><span class="class">		<span class="keyword">extends</span> <span class="title">EntityManagerFactoryDependsOnPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ElasticsearchJpaDependencyConfiguration() &#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="string">&quot;elasticsearchClient&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据库初始化"><a href="#数据库初始化" class="headerlink" title="数据库初始化"></a>数据库初始化</h2><p>SQL数据库可以用不同的方式初始化，这取决于你选择的是什么技术。当然，只要数据库是一个独立的进程，你也可以手动完成。</p>
<h3 id="使用JPA初始化数据库"><a href="#使用JPA初始化数据库" class="headerlink" title="使用JPA初始化数据库"></a>使用JPA初始化数据库</h3><p>JPA具有用于生成DDL的功能，可以将这些功能设置为在启动时运行。 这是通过两个外部属性来控制的：</p>
<ul>
<li><code>spring.jpa.generate-ddl</code>（boolean）打开和关闭该功能，并且独立于供应商。</li>
<li><code>spring.jpa.hibernate.ddl-auto</code>（enum）是一个Hibernate特性，以更细粒度的方式控制该行为。</li>
</ul>
<h3 id="使用Hibernate初始化数据库"><a href="#使用Hibernate初始化数据库" class="headerlink" title="使用Hibernate初始化数据库"></a>使用Hibernate初始化数据库</h3><p>你可以显式设置<code>spring.jpa.hibernate.ddl-auto</code>，标准Hibernate属性值为<code>none</code>，<code>validate</code>，<code>update</code>，<code>create</code>，<code>create-drop</code>。 Spring Boot根据数据库是否为嵌入式的为你选择一个默认值：如果没有检测到schema管理器，则默认为<code>create-drop</code>，在其他所有情况下均设置为<code>none</code>。通过查看<code>Connection</code>类型来检测嵌入式数据库：<code>hsqldb</code>，<code>h2</code>和<code>derby</code>是嵌入式的，其余不是。从内存数据库切换到“真实”数据库时请小心，不要假定新平台中存在表和数据。 你必须显式设置<code>ddl-auto</code>，或使用其他机制来初始化数据库。</p>
<blockquote>
<p>你可以通过启用<code>org.hibernate.SQL</code>日志记录器来输出schema创建的过程。如果启用调试模式，将自动完成。</p>
</blockquote>
<p>另外，如果Hibernate从头开始创建schema（即，如果<code>ddl-auto</code>属性设置为<code>create</code>或<code>create-drop</code>），那么在启动时将执行类路径根目录中名为<code>import.sql</code>的文件。 这对于演示和测试是非常有用的。 这是一个Hibernate功能（与Spring无关）。</p>
<h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><p>Spring Boot可以自动创建<code>DataSource</code>的schema（DDL脚本）并对其进行初始化（DML脚本）：它分别从标准根类路径位置<code>schema.sql</code>和<code>data.sql</code>中加载SQL。 另外，Spring Boot将处理<code>schema-$&#123;platform&#125;.sql</code>和<code>data-$&#123;platform&#125;.sql</code>文件（如果存在），其中<code>platform</code>是<code>spring.datasource.platform</code>的值。这允许你在必要时切换到数据库特定的脚本，例如你可以选择将其设置为数据库的供应商名称（<code>hsqldb</code>，<code>h2</code>，<code>oracle</code>，<code>mysql</code>，<code>postgresql</code>等）。</p>
<p>Spring Boot默认启用Spring JDBC初始化程序的快速失败功能，所以如果脚本导致异常，应用程序将无法启动。 你可以使用<code>spring.datasource.continue-on-error</code>来调整它。</p>
<blockquote>
<p>在基于JPA的应用程序中，可以选择让Hibernate创建schema或使用<code>schema.sql</code>，但不能两者同时使用。如果你选择了后者，请确保禁用<code>spring.jpa.hibernate.ddl-auto</code>。</p>
</blockquote>
<p>你也可以通过将<code>spring.datasource.initialize</code>设置为<code>false</code>来禁用初始化。</p>
<h3 id="初始化一个Spring-Batch数据库"><a href="#初始化一个Spring-Batch数据库" class="headerlink" title="初始化一个Spring Batch数据库"></a>初始化一个Spring Batch数据库</h3><p>如果你使用的是Spring Batch，那么它将为大多数流行的数据库平台预先打包SQL初始化脚本。 Spring Boot可以检测你的数据库类型并在启动时执行这些脚本。如果你使用嵌入式数据库，则默认情况下会发生这种情况。你也可以为任何数据库类型启用这个功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.batch.initialize-schema&#x3D;always</span><br></pre></td></tr></table></figure>
<p>你也可以使用<code>spring.batch.initialize-schema = never</code>显式地关闭初始化功能。</p>
<h3 id="使用更高级别的数据库迁移工具"><a href="#使用更高级别的数据库迁移工具" class="headerlink" title="使用更高级别的数据库迁移工具"></a>使用更高级别的数据库迁移工具</h3><p>Spring Boot支持两种更高级的迁移工具：<a target="_blank" rel="noopener" href="http://flywaydb.org/">Flyway</a>和<a target="_blank" rel="noopener" href="http://www.liquibase.org/">Liquibase</a>。</p>
<h4 id="启动时执行Flyway数据库迁移"><a href="#启动时执行Flyway数据库迁移" class="headerlink" title="启动时执行Flyway数据库迁移"></a>启动时执行Flyway数据库迁移</h4><p>要在启动时自动运行Flyway数据库迁移，请将<code>org.flywaydb:flyway-core</code>添加到类路径中。</p>
<p>迁移是以<code>V&lt;VERSION&gt;__&lt;NAME&gt;.sql</code>格式（带有<code>&lt;VERSION&gt;</code>下划线分隔的版本，例如’1’或’2_1’）的脚本。默认情况下，它们位于文件夹<code>classpath:db/migration</code>中，但是可以使用<code>spring.flyway.locations</code>修改它。你还可以添加特殊的<code>&#123;vendor&#125;</code>占位符来使用供应商特定的脚本。 假设：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.flyway.locations&#x3D;db&#x2F;migration&#x2F;&#123;vendor&#125;</span><br></pre></td></tr></table></figure>
<p>这个配置不是使用<code>db/migration</code>，而是根据数据库的类型（对于Mysql来说即<code>db/migration/mysql</code>）来设置使用的文件夹。可以在<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jdbc/DatabaseDriver.java"><code>DatabaseDriver</code></a>中查看受支持的数据库列表。</p>
<p>另请参阅flyway-core的Flyway类以了解可用设置（如模式等）的详细信息。另外，Spring Boot在<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/flyway/FlywayProperties.java"><code>FlywayProperties</code></a>中提供了一组属性，可用于禁用迁移或关闭位置检查。 Spring Boot将调用<code>Flyway.migrate（）</code>来执行数据库迁移。 如果你想要更多的控制，提供一个实现了<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/flyway/FlywayMigrationStrategy.java"><code>FlywayMigrationStrategy</code></a>的<code>@Bean</code>。</p>
<p>Flyway支持SQL和Java<a target="_blank" rel="noopener" href="http://flywaydb.org/documentation/callbacks.html">回调</a>。 要使用基于SQL的回调，请将回调脚本放在<code>classpath:db/migration</code>文件夹中。 要使用基于Java的回调，创建一个或多个实现了<code>FlywayCallback</code>的Bean，或者最好是继承<code>BaseFlywayCallback</code>。 任何这样的bean将自动注册到<code>Flyway</code>。 他们可以通过使用<code>@Order</code>或实现<code>Ordered</code>来指定顺序。</p>
<p>默认情况下，Flyway将在你的上下文中自动装配（<code>@Primary</code>）<code>DataSource</code>，并将其用于迁移。 如果你喜欢使用不同的<code>DataSource</code>，你可以创建一个<code>@Bean</code>标记为<code>@FlywayDataSource</code> - 如果你这样做，记得创建另一个数据源,如果你需要两个数据源记得把它标记为<code>@Primary</code>。 或者，你可以通过在外部属性中设置<code>spring.flyway.[url，user，password]</code>来使用Flyway的原生<code>DataSource</code>。</p>
<p>这里有一个<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-flyway">Flyway示例</a>，你可以看到如何设置这些东西。</p>
<p>你也可以使用Flyway为特定场景提供数据。例如，你可以将测试专用的迁移脚本放在<code>src/test/resources</code>中，并且只有在你的应用程序开始测试时才会运行它们。 如果你想更复杂一点，可以使用特定profile的配置来自定义<code>spring.flyway.locations</code>，以便某些迁移脚本只在特定profile激活时运行。 例如，在<code>application-dev.properties</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.flyway.locations&#x3D;classpath:&#x2F;db&#x2F;migration,classpath:&#x2F;dev&#x2F;db&#x2F;migration</span><br></pre></td></tr></table></figure>
<p>使用该设置，<code>dev/db/migration</code>中的迁移脚本将仅在<code>dev</code> profile激活时运行。</p>
<h4 id="启动时执行Liquibase数据库迁移"><a href="#启动时执行Liquibase数据库迁移" class="headerlink" title="启动时执行Liquibase数据库迁移"></a>启动时执行Liquibase数据库迁移</h4><p>要在启动时自动运行Liquibase数据库迁移，请将<code>org.liquibase:liquibase-core</code>添加到你的类路径中。</p>
<p>主要的更改日志默认从<code>db/changelog/db.changelog-master.yaml</code>中读取，但可以设置使用<code>spring.liquibase.change-log</code>。除了YAML，Liquibase还支持JSON，XML和SQL更改日志格式。</p>
<p>默认情况下，Liquibase会在你的上下文中自动装载（<code>@Primary</code>）<code>DataSource</code>，并用它来进行迁移。 如果你喜欢使用不同的<code>DataSource</code>，你可以创建一个<code>@Bean</code>标记为<code>@LiquibaseDataSource</code> - 如果你这样做的话，记得创建另一个数据源，如果你想要两个数据源，就把它标记为<code>@Primary</code>。 或者，你可以通过在外部属性中设置<code>spring.liquibase.[url，user，password]</code>来使用Liquibase的原生<code>DataSource</code>。</p>
<p>有关上下文，默认模式等可用设置的详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/liquibase/LiquibaseProperties.java"><code>LiquibaseProperties</code></a>。</p>
<p>有一个<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-liquibase">Liquibase示例</a>，你可以看到如何设置。</p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><h3 id="禁用事务的JMS会话"><a href="#禁用事务的JMS会话" class="headerlink" title="禁用事务的JMS会话"></a>禁用事务的JMS会话</h3><p>如果你的JMS代理不支持事务会话，则必须完全禁用事务支持。如果你创建自己的<code>JmsListenerContainerFactory</code>，则无需执行任何操作，因为默认情况下不会进行事务处理。 如果你想使用<code>DefaultJmsListenerContainerFactoryConfigurer</code>来重用Spring Boot的默认设置，可以按如下所示禁用事务性会话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactory <span class="title">jmsListenerContainerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		ConnectionFactory connectionFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">		DefaultJmsListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">	DefaultJmsListenerContainerFactory listenerFactory =</span><br><span class="line">			<span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">	configurer.configure(listenerFactory, connectionFactory);</span><br><span class="line">	listenerFactory.setTransactionManager(<span class="keyword">null</span>);</span><br><span class="line">	listenerFactory.setSessionTransacted(<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">return</span> listenerFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里覆盖了默认的工厂，并且它应该被应用到你的应用程序定义的任何其他工厂（如果有的话）。</p>
<h2 id="批处理应用"><a href="#批处理应用" class="headerlink" title="批处理应用"></a>批处理应用</h2><blockquote>
<p>默认情况下，批处理应用程序需要一个<code>DataSource</code>来存储作业详细信息。如果你不要这么做，你需要实现<code>BatchConfigurer</code>，请参阅<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-batch/apidocs/org/springframework/batch/core/configuration/annotation/EnableBatchProcessing.html"><code>@EnableBatchProcessing</code>的Javadoc</a>获取更多细节。</p>
</blockquote>
<h3 id="启动时执行Spring-Batch作业"><a href="#启动时执行Spring-Batch作业" class="headerlink" title="启动时执行Spring Batch作业"></a>启动时执行Spring Batch作业</h3><p>Spring Batch自动配置是通过在你的上下文中添加<code>@EnableBatchProcessing</code>（从Spring Batch）来实现的。</p>
<p>默认情况下，它会在启动时执行应用程序上下文中的<strong>所有</strong><code>Jobs</code>（有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/JobLauncherCommandLineRunner.java">JobLauncherCommandLineRunner</a>）。 你可以通过指定<code>spring.batch.job.names</code>（逗号分隔的作业名称模式）来限制到特定作业或作业的范围。</p>
<p>如果应用程序上下文包含<code>JobRegistry</code>，则在注册信息中查找<code>spring.batch.job.names</code>中的作业，而不是从上下文自动装配。 这是一个常见的模式，其中有更复杂的系统，在这个系统中多个作业在子环境中定义并集中注册。</p>
<p>有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/BatchAutoConfiguration.java">BatchAutoConfiguration</a>和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-batch/blob/master/spring-batch-core/src/main/java/org/springframework/batch/core/configuration/annotation/EnableBatchProcessing.java">@EnableBatchProcessing</a>。</p>
<h2 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h2><h3 id="更改actuator端点的HTTP端口或地址"><a href="#更改actuator端点的HTTP端口或地址" class="headerlink" title="更改actuator端点的HTTP端口或地址"></a>更改actuator端点的HTTP端口或地址</h3><p>在独立应用程序中，Actuator HTTP端口默认与主HTTP端口相同。为了让应用程序在不同的端口上监听，可以设置外部属性<code>management.port</code>。要监听一个完全不同的网络地址（例如，如果你有一个用于管理的内部网络和一个用于外部用户应用的网络），你还可以将<code>management.address</code>设置为服务器能够绑定的有效IP地址。</p>
<p>有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/web/ManagementServerProperties.java"><code>ManagementServerProperties</code></a>源代码以及“Production-ready功能”部分中的<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#production-ready-customizing-management-server-port">第50.2节“自定义管理服务器端口”</a>。</p>
<h3 id="自定义“whitelabel”错误页面"><a href="#自定义“whitelabel”错误页面" class="headerlink" title="自定义“whitelabel”错误页面"></a>自定义“whitelabel”错误页面</h3><p>如果你遇到服务器错误（使用JSON和其他媒体类型的计算机客户端应该看到具有正确错误代码的合理响应），Spring Boot将安装一个“whitelabel”错误页面。</p>
<blockquote>
<p>设置<code>server.error.whitelabel.enabled = false</code>将关闭默认错误页面并恢复为你正在使用的servlet容器的默认值。请注意，Spring Boot仍然会尝试解决错误视图，所以你可能会添加你自己的错误页面，而不是完全禁用它。</p>
</blockquote>
<p>用你自己的覆盖错误页面取决于你正在使用的模板技术。例如，如果你使用的是Thymeleaf，则可以添加一个<code>error.html</code>模板，如果你使用的是FreeMarker，则可以添加一个<code>error.ftl</code>模板。一般来说，你需要的是一个用错误名称解析的<code>View</code>，和/或处理<code>/error</code>路径的<code>@Controller</code>。除非你替换了一些默认配置，否则你应该在你的<code>ApplicationContext</code>中找到一个<code>BeanNameViewResolver</code>，所以带有id<code>error</code>的<code>@Bean</code>将是一个简单的方法。查看<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/error/ErrorMvcAutoConfiguration.java"><code>ErrorMvcAutoConfiguration</code></a>以获取更多详情。</p>
<p>有关如何在servlet容器中注册处理程序的详细信息，另请参阅<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-error-handling">错误处理</a>一节。</p>
<h3 id="Actuator-和-Jersey"><a href="#Actuator-和-Jersey" class="headerlink" title="Actuator 和 Jersey"></a>Actuator 和 Jersey</h3><p>Actuator HTTP端点仅适用于基于Spring MVC的应用程序。如果你想使用Jersey并仍然使用Actuator，则需要启用Spring MVC（例如，依赖于<code>spring-boot-starter-web</code>）。默认情况下，Jersey和Spring MVC调度程序servlet都映射到相同的路径（<code>/</code>）。你将需要更改其中一个的路径（通过为Spring MVC配置<code>server.servlet.path</code>或为Jersey配置<code>spring.jersey.application-path</code>）。 例如，如果将<code>server.servlet.path = / system</code>添加到<code>application.properties</code>中，则actuator HTTP端点将可以在<code>/ system</code>下使用。</p>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><h3 id="关闭Spring-Boot-安全配置"><a href="#关闭Spring-Boot-安全配置" class="headerlink" title="关闭Spring Boot 安全配置"></a>关闭Spring Boot 安全配置</h3><p>如果你在应用程序中的任何位置使用<code>@EnableWebSecurity</code>定义<code>@Configuration</code>，它将关闭Spring Boot中的默认Web应用程序安全设置（但保留Actuator的安全配置）。 要调整默认值，请尝试设置<code>security.*</code>（请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/SecurityProperties.java"><code>SecurityProperties</code></a>以获取可用设置的详细信息）以及<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#common-application-properties-security">Common应用程序属性</a>的<code>SECURITY</code>部分。</p>
<h3 id="更改AuthenticationManager并添加用户帐户"><a href="#更改AuthenticationManager并添加用户帐户" class="headerlink" title="更改AuthenticationManager并添加用户帐户"></a>更改AuthenticationManager并添加用户帐户</h3><p>如果你提供了一个类型为<code>AuthenticationManager</code>的<code>@Bean</code>，那么将不会创建默认的，所以你可以使用Spring Security的全部功能（例如<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#jc-authentication">各种认证选项</a>）。</p>
<p>Spring Security还提供了一个方便的<code>AuthenticationManagerBuilder</code>，它可以用来构建一个带有通用选项的<code>AuthenticationManager</code>。在webapp中使用这种方法的推荐方法是将其注入<code>WebSecurityConfigurerAdapter</code>中的void方法，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfiguration</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureGlobal</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			auth.inMemoryAuthentication()</span><br><span class="line">				.withUser(<span class="string">&quot;barry&quot;</span>).password(<span class="string">&quot;password&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>); <span class="comment">// ... etc.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... other stuff for application security</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果将其放在嵌套类或独立类中（即不会混入大量可能影响实例化顺序的其他<code>@Beans</code>），你将获得最佳结果。 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-web-secure">安全的Web示例</a>是一个有用的模板。</p>
<p>如果遇到实例化问题（例如，对用户详细信息存储使用JDBC或JPA），将<code>AuthenticationManagerBuilder</code>回调提取到<code>GlobalAuthenticationConfigurerAdapter</code>中（在<code>init()</code>方法中，以便在其他地方需要身份验证管理器之前进行）有可能是值得。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationManagerConfiguration</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">		<span class="title">GlobalAuthenticationConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(AuthenticationManagerBuilder auth)</span> </span>&#123;</span><br><span class="line">		auth.inMemoryAuthentication() <span class="comment">// ... etc.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用代理服务器时启用HTTPS"><a href="#使用代理服务器时启用HTTPS" class="headerlink" title="使用代理服务器时启用HTTPS"></a>使用代理服务器时启用HTTPS</h3><p>确保你的所有主要端点只能通过HTTPS使用，这对于任何应用程序来说都是非常重要的任务。 如果你使用Tomcat作为servlet容器，那么Spring Boot会在检测到某些环境设置时自动添加Tomcat自己的<code>RemoteIpValve</code>，并且你应该能够依赖<code>HttpServletRequest</code>来报告它是否安全（即使是代理的下游 服务器处理真正的SSL终端）。标准行为是由是否存在某些请求头（<code>x-forwarded-for</code>和<code>x-forwarded-proto</code>）来决定的，它们的名字是常规的，所以它应该可以与大多数前端代理一起工作。你可以通过在<code>application.properties</code>中添加一些条目来打开阀门,例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.remote-ip-header&#x3D;x-forwarded-for</span><br><span class="line">server.tomcat.protocol-header&#x3D;x-forwarded-proto</span><br></pre></td></tr></table></figure>
<p>（任何一个属性的存在都会打开阀门，或者你可以通过添加<code>TomcatServletWebServerFactory</code> bean来自行添加<code>RemoteIpValve</code>。）</p>
<p>Spring Security也可以被配置为需要所有（或某些请求）的安全通道。 要在Spring Boot应用程序中切换，只需在<code>application.properties</code>中将<code>security.require_ssl</code>设置为<code>true</code>即可。</p>
<h2 id="热加载"><a href="#热加载" class="headerlink" title="热加载"></a>热加载</h2><h3 id="刷新静态内容"><a href="#刷新静态内容" class="headerlink" title="刷新静态内容"></a>刷新静态内容</h3><p>有几个热加载的选项。推荐的方法是使用<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#using-boot-devtools"><code>spring-boot-devtools</code></a>，因为它提供了额外的开发期间的功能，如支持快速应用程序重启和LiveReload以及合理的开发期间的配置（例如模板缓存）。Devtools通过监视类路径的变化来工作。这意味着静态资源的变化必须“构建”，以使变更生效。默认情况下，当你保存更改时，这会在Eclipse中自动发生。在IntelliJ IDEA中，Make Project将触发必要的构建。由于<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#using-boot-devtools-restart-exclude">默认的重新启动排除</a>，对静态资源的更改不会触发应用程序的重新启动。但是，他们会触发一个实时的重新加载。</p>
<p>另外，在IDE中运行（特别是在调试时）是一种很好的开发方式（所有的现代IDE都允许重新加载静态资源，并且通常也可以热加载Java类的变化）。</p>
<p>最后，可以配置Maven和Gradle插件（请参阅<code>addResources</code>属性）以支持从命令行直接从源文件重新加载静态文件。如果你使用更高级别的工具编写代码，则可以将其用于外部css/js编译。</p>
<h3 id="不重启容器刷新模板"><a href="#不重启容器刷新模板" class="headerlink" title="不重启容器刷新模板"></a>不重启容器刷新模板</h3><p>Spring Boot支持的大部分模板技术都包含禁用缓存的配置选项（请参阅下面的详细信息）。 如果你使用的是<code>spring-boot-devtools</code>模块，则在开发时将<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#using-boot-devtools-property-defaults">自动为你配置</a>这些属性。</p>
<h4 id="Thymeleaf-模板"><a href="#Thymeleaf-模板" class="headerlink" title="Thymeleaf 模板"></a>Thymeleaf 模板</h4><p>如果你使用的是Thymeleaf，则将<code>spring.thymeleaf.cache</code>设置为<code>false</code>。 有关其他Thymeleaf自定义选项，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/thymeleaf/ThymeleafAutoConfiguration.java"><code>ThymeleafAutoConfiguration</code></a>。</p>
<h4 id="FreeMarker-模板"><a href="#FreeMarker-模板" class="headerlink" title="FreeMarker 模板"></a>FreeMarker 模板</h4><p>如果你正在使用FreeMarker，则将<code>spring.freemarker.cache</code>设置为<code>false</code>。 有关其他FreeMarker自定义选项，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/freemarker/FreeMarkerAutoConfiguration.java"><code>FreeMarkerAutoConfiguration</code></a>。</p>
<h4 id="Groovy-模板"><a href="#Groovy-模板" class="headerlink" title="Groovy 模板"></a>Groovy 模板</h4><p>如果你正在使用Groovy模板，则将<code>spring.groovy.template.cache</code>设置为<code>false</code>。 有关其他Groovy自定义选项，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/groovy/template/GroovyTemplateAutoConfiguration.java"><code>GroovyTemplateAutoConfiguration</code></a>。</p>
<h3 id="快速重启"><a href="#快速重启" class="headerlink" title="快速重启"></a>快速重启</h3><p><code>spring-boot-devtools</code>模块支持应用程序自动重新启动。虽然速度不如JRebel这样的技术，但通常比“冷启动”要快得多。在调查下面讨论的一些更复杂的重新加载选项之前，你应该尝试一下。</p>
<p>有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#using-boot-devtools">第20章开发人员工具</a>部分。</p>
<h3 id="不重启容器重新加载Java类"><a href="#不重启容器重新加载Java类" class="headerlink" title="不重启容器重新加载Java类"></a>不重启容器重新加载Java类</h3><p>现代的IDE（Eclipse，IDEA等）都支持字节码的热交换，所以如果你做了一个不影响类或方法签名的改变，它应该利索地重新加载，没有副作用。</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><h3 id="生成构建信息"><a href="#生成构建信息" class="headerlink" title="生成构建信息"></a>生成构建信息</h3><p>Maven和Gradle插件都允许生成包含项目坐标，名称和版本的构建信息。该插件也可以配置为通过配置添加其他属性。 当这个文件出现时，Spring Boot会自动配置一个<code>BuildProperties</code> bean。</p>
<p>要使用Maven生成构建信息，请为<code>build-info</code> goal添加一个execution：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.BUILD-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">goal</span>&gt;</span>build-info<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/maven-plugin//">Spring Boot Maven Plugin文档</a>以获取更多详细信息。</p>
</blockquote>
<p>Gradle一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">springBoot &#123;</span><br><span class="line">	buildInfo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用DSL添加其他属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">springBoot  &#123;</span><br><span class="line">	buildInfo &#123;</span><br><span class="line">		additionalProperties &#x3D; [</span><br><span class="line">			&#39;foo&#39;: &#39;bar&#39;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成git信息"><a href="#生成git信息" class="headerlink" title="生成git信息"></a>生成git信息</h3><p>Maven和Gradle都允许在构建项目时生成一个<code>git.properties</code>文件，其中包含有关<code>git</code>源代码库状态的信息。</p>
<p>对于Maven用户来说，<code>spring-boot-starter-parent</code> POM包含一个预先配置的插件来生成一个<code>git.properties</code>文件。 只需将以下声明添加到你的POM：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>pl.project13.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>git-commit-id-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Gradle用户可以使用<a target="_blank" rel="noopener" href="https://plugins.gradle.org/plugin/com.gorylenko.gradle-git-properties"><code>gradle-git-properties</code></a>插件获得相同的结果:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id <span class="string">&quot;com.gorylenko.gradle-git-properties&quot;</span> version <span class="string">&quot;1.4.17&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>git.properties</code>中的提交时间预计与<code>yyyy-MM-dd’T’HH:mm:ssZ</code>格式匹配。这是上面列出的两个插件的默认格式。使用这种格式可以将时间解析成<code>Date</code>，并在序列化为JSON时由Jackson的日期序列化配置设置控制它的格式。</p>
</blockquote>
<h3 id="自定义依赖版本"><a href="#自定义依赖版本" class="headerlink" title="自定义依赖版本"></a>自定义依赖版本</h3><p>如果你使用直接或间接从<code>spring-boot-dependencies</code>（例如<code>spring-boot-starter-parent</code>）继承的Maven构建，但是你想重写特定的第三方依赖项，则可以添加适当的<code>&lt;properties&gt;</code>元素。浏览<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-dependencies/pom.xml"><code>spring-boot-dependencies</code></a> POM以获取完整的属性列表。 例如，要选择一个不同的slf4j版本，你可以添加以下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.7.5<span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这只适用于你的Maven项目是从<code>spring-boot-dependencies</code>继承（直接或间接）下来的。 如果你在你的<code>dependencyManagement</code>部分中用<code>&lt;scope&gt;import&lt;/scope&gt;</code>添加了<code>spring-boot-dependencies</code>，那么你必须自己重新定义这个artifact，而不是重写属性。</p>
</blockquote>
<blockquote>
<p>每个Spring Boot版本都是针对特定的第三方依赖进行设计和测试的。覆盖版本可能会导致兼容性问题。</p>
</blockquote>
<h3 id="使用Maven创建可执行jar"><a href="#使用Maven创建可执行jar" class="headerlink" title="使用Maven创建可执行jar"></a>使用Maven创建可执行jar</h3><p><code>spring-boot-maven-plugin</code>可以用来创建一个可执行的“fat”JAR。如果你使用的是<code>spring-boot-starter-parent</code> POM，则可以简单地声明该插件，并将你的jar包重新打包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你不使用父POM，你仍然可以使用这个插件，但是你必须另外添加一个<code>&lt;executions&gt;</code>部分：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.BUILD-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有关完整的使用详细信息，请参阅<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/maven-plugin//usage.html">插件文档</a>。</p>
<h3 id="使用Spring-Boot应用程序作为依赖"><a href="#使用Spring-Boot应用程序作为依赖" class="headerlink" title="使用Spring Boot应用程序作为依赖"></a>使用Spring Boot应用程序作为依赖</h3><p>像war文件一样，Spring Boot应用程序并不打算用作依赖项。如果你的应用程序包含要与其他项目共享的类，则推荐的方法是将该代码移动到单独的模块中。你的应用程序和其他项目可以依靠这个单独的模块。</p>
<p>如果你不能按照上面的建议重新调整你的代码，那么Spring Boot的Maven和Gradle插件必须被配置为产生一个适合用作依赖项的独立的组件。可执行文件不能用作依赖项，因为<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#executable-jar-jar-file-structure">可执行的jar格式</a>在<code>BOOT-INF/classes</code>中打包应用程序类。这意味着当可执行jar被用作依赖时，它们不能被找到。</p>
<p>为了生成两个组件，一个可以用作依赖关系，一个可执行，必须指定一个分类器。此分类器应用于可执行文件的名称，保留用作依赖项的默认文件。</p>
<p>要在Maven中配置<code>exec</code>的分类器，可以使用以下配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">	&lt;plugins&gt;</span><br><span class="line">		&lt;plugin&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">			&lt;configuration&gt;</span><br><span class="line">				&lt;classifier&gt;exec&lt;/classifier&gt;</span><br><span class="line">			&lt;/configuration&gt;</span><br><span class="line">		&lt;/plugin&gt;</span><br><span class="line">	&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<h3 id="当可执行的jar运行时，提取特定的库"><a href="#当可执行的jar运行时，提取特定的库" class="headerlink" title="当可执行的jar运行时，提取特定的库"></a>当可执行的jar运行时，提取特定的库</h3><p>可执行jar中的大多数内部库不需要解压来运行，但某些库可能会有问题。例如，JRuby包含自己的内部jar支持，它假设<code>jruby-complete.jar</code>总是直接作为一个文件直接使用。</p>
<p>为了处理任何有问题的库，可以标记特定的内部jar应该在可执行jar第一次运行时自动解压到“temp文件夹”。</p>
<p>例如，为了说明JRuby应该被标记为使用Maven Plugin解压，你可以添加以下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">requiresUnpack</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jruby<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jruby-complete<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">requiresUnpack</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用exclusions-创建不可执行的JAR"><a href="#使用exclusions-创建不可执行的JAR" class="headerlink" title="使用exclusions 创建不可执行的JAR"></a>使用exclusions 创建不可执行的JAR</h3><p>通常，如果你将可执行文件和不可执行的jar作为构建产品，则可执行文件版本将具有作为库的jar中不需要的其他配置文件。 例如,不可执行的JAR中可能会排除<code>application.yml</code>配置文件。</p>
<p><code>maven-jar-plugin</code>用来暴露一个<code>forceCreation</code>属性，允许你在<code>repackage</code> goal 运行后<em>再次</em>创建jar。可以说，由于它依赖于插件执行的顺序，所以它有点脆弱。 在Maven中，可执行的jar文件必须是主要的工件，你可以为库添加一个分类的jar：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">id</span>&gt;</span>lib<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">classifier</span>&gt;</span>lib<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="远程调试Maven启动的Spring-Boot应用程序"><a href="#远程调试Maven启动的Spring-Boot应用程序" class="headerlink" title="远程调试Maven启动的Spring Boot应用程序"></a>远程调试Maven启动的Spring Boot应用程序</h3><p>要将一个远程调试器连接到一个使用Maven启动的Spring Boot应用程序，你可以使用<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/maven-plugin//">maven插件</a>的<code>jvmArguments</code>属性。</p>
<p>查看<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/maven-plugin//examples/run-debug.html">这个例子</a>了解更多细节。</p>
<h3 id="用Ant构建可执行存档时不使用spring-boot-antlib"><a href="#用Ant构建可执行存档时不使用spring-boot-antlib" class="headerlink" title="用Ant构建可执行存档时不使用spring-boot-antlib"></a>用Ant构建可执行存档时不使用spring-boot-antlib</h3><h2 id="传统部署方式"><a href="#传统部署方式" class="headerlink" title="传统部署方式"></a>传统部署方式</h2><h3 id="创建可部署的war文件"><a href="#创建可部署的war文件" class="headerlink" title="创建可部署的war文件"></a>创建可部署的war文件</h3><p>生成可部署的war文件的第一步是提供一个<code>SpringBootServletInitializer</code>子类并覆盖其<code>configure</code>方法。 这将使用Spring框架的Servlet 3.0支持功能，并当它由servlet容器启动时允许你配置你的应用程序。通常，你更新你的应用程序的主类来继承<code>SpringBootServletInitializer</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> application.sources(Application.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		SpringApplication.run(Application.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步是更新你的构建配置，以便你的项目生成一个war文件，而不是一个jar文件。 如果你使用的是Maven，并使用<code>spring-boot-starter-parent</code>（会为你配置Maven的war插件），你只需修改<code>pom.xml</code>将 packaging 更改为war：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;packaging&gt;war&lt;&#x2F;packaging&gt;</span><br></pre></td></tr></table></figure>
<p>如果你使用的是Gradle，则需要修改<code>build.gradle</code>启用war插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;war&#39;</span><br></pre></td></tr></table></figure>
<p>这个过程的最后一步是确保嵌入的servlet容器不会干扰要部署war文件的servlet容器。 为此，你需要标记嵌入式servlet容器依赖项为provided。</p>
<p>在Maven中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- … --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- … --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在Gradle中：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">	<span class="comment">// …</span></span><br><span class="line">	providedRuntime <span class="string">&#x27;org.springframework.boot:spring-boot-starter-tomcat&#x27;</span></span><br><span class="line">	<span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>providedRuntime</code>比Gradle的<code>compileOnly</code>配置更受欢迎，因为在其他限制中，<code>compileOnly</code>依赖不在测试类路径上，因此任何基于Web的集成测试都将失败。</p>
</blockquote>
<p>如果你使用的是<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#build-tool-plugins">Spring Boot构建工具</a>，则标记嵌入的Servlet容器依赖项为provided将生成一个可执行的war文件，其中提供的依赖项打包在<code>lib-provided</code>的目录中。这意味着，除了可以部署到servlet容器之外，还可以在命令行上使用<code>java -jar</code>运行应用程序。</p>
<blockquote>
<p>查看Spring Boot的示例应用程序，可以找到上述配置的<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-traditional/pom.xml">基于Maven的示例</a>。</p>
</blockquote>
<h3 id="为老版本servlet容器创建可部署war文件"><a href="#为老版本servlet容器创建可部署war文件" class="headerlink" title="为老版本servlet容器创建可部署war文件"></a>为老版本servlet容器创建可部署war文件</h3><p>较老的Servlet容器不支持Servlet 3.0中使用的<code>ServletContextInitializer</code>引导进程。你仍然可以在这些容器中使用Spring和Spring Boot，但是你将需要将<code>web.xml</code>添加到你的应用程序，并将其配置为通过<code>DispatcherServlet</code>加载<code>ApplicationContext</code>。</p>
<h3 id="将现有应用转换为Spring-Boot应用"><a href="#将现有应用转换为Spring-Boot应用" class="headerlink" title="将现有应用转换为Spring Boot应用"></a>将现有应用转换为Spring Boot应用</h3><p>对于非Web应用程序来说，应该很简单（丢弃创建<code>ApplicationContext</code>的代码并将其替换为对<code>SpringApplication</code>或<code>SpringApplicationBuilder</code>的调用）。 Spring MVC Web应用程序通常可以首先创建可部署的war应用程序，然后稍后将其迁移到可执行的war和/或jar。 <a target="_blank" rel="noopener" href="http://spring.io/guides/gs/convert-jar-to-war/">“将jar转换为war的入门指南”</a>可能对你非常有用。</p>
<p>通过扩展<code>SpringBootServletInitializer</code>（例如，在一个名为<code>Application</code>的类）中创建一个可部署的war，并添加Spring Boot <code>@SpringBootApplication</code>注解。 例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Customize the application or call application.sources(...) to add sources</span></span><br><span class="line">		<span class="comment">// Since our example is itself a @Configuration class (via @SpringBootApplication)</span></span><br><span class="line">		<span class="comment">// we actually don&#x27;t need to override this method.</span></span><br><span class="line">		<span class="keyword">return</span> application;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请记住，无论你放在源代码中的是什么，只是一个Spring <code>ApplicationContext</code>，通常任何已经工作的东西都应该在这里工作。可能稍后会删除一些bean，并让Spring Boot 为它们提供自己的默认值，但应该可以先做一些工作。</p>
<p>可以将静态资源移动到类路径根中的<code>/public</code>（或<code>/static</code>或<code>/resources</code>或/ <code>META-INF/resources</code>）。<code>messages.properties</code>也是如此。（Spring Boot会在类路径的根目录中自动检测到这个）。</p>
<p>Spring <code>DispatcherServlet</code>和Spring Security的使用不需要进一步的修改。如果你的应用程序中有其他功能，例如使用其他servlet或过滤器，那么你可能需要在<code>Application</code>上下文中添加一些配置，从<code>web.xml</code>中替换这些元素，如下所示：</p>
<ul>
<li><p><code>Servlet</code>或<code>ServletRegistrationBean</code>类型的<code>@Bean</code>将该bean安装到容器中，就好像它是<code>web.xml</code>中的<code>&lt;servlet /&gt;</code>和<code>&lt;servlet-mapping /&gt;</code>一样。</p>
</li>
<li><p>类型为<code>Filter</code>或<code>FilterRegistrationBean</code>的<code>@Bean</code>的行为类似（如<code>&lt;filter /&gt;</code>和<code>&lt;filter-mapping /&gt;</code>）。</p>
</li>
<li><p>XML文件中的<code>ApplicationContext</code>可以通过<code>Application</code>中的<code>@ImportResource</code>添加。 或者注解配置大量使用的简单情况已经可以作为<code>@Bean</code>定义在几行代码中重新创建。</p>
<p>一旦war 生效，我们通过向我们的<code>Application</code>添加<code>main</code>方法来使其可以执行。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>如果你打算将应用作为war或可执行应用程序启动，则需要在<code>SpringBootServletInitializer</code>回调和<code>main</code>方法都可用的方法中共享构建器的自定义设置，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;@SpringBootApplication</span><br><span class="line">&gt;public class Application extends SpringBootServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;</span><br><span class="line">	return configureApplication(builder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	configureApplication(new SpringApplicationBuilder()).run(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static SpringApplicationBuilder configureApplication(SpringApplicationBuilder builder) &#123;</span><br><span class="line">	return builder.sources(Application.class).bannerMode(Banner.Mode.OFF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>应用程序可以分为多个类别：</p>
<ul>
<li>没有<code>web.xml</code>的Servlet 3.0+应用程序。</li>
<li>带有<code>web.xml</code>的应用程序.</li>
<li>具有上下文层次的应用程序.</li>
<li>没有上下文层次的应用程序.</li>
</ul>
<p>所有这些都应该适合转换，但每个可能需要稍微不同的技巧。</p>
<p>如果Servlet 3.0+应用程序已经使用Spring Servlet 3.0+初始化程序支持类，那么它们可能会非常容易转换。通常，来自现有<code>WebApplicationInitializer</code>的所有代码都可以移入<code>SpringBootServletInitializer</code>。如果你现有的应用程序有多个<code>ApplicationContext</code>（例如，如果它使用<code>AbstractDispatcherServletInitializer</code>），那么你可能能够将所有上下文源压缩到一个<code>SpringApplication</code>中。你可能遇到的主要难题是如果这不起作用，你需要维护上下文层次结构。请参阅<a target="_blank" rel="noopener" href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-build-an-application-context-hierarchy">构建层次结构的示例</a>。现有的包含Web特定功能父上下文通常需要分解，以便所有<code>ServletContextAware</code>组件都在子上下文中。</p>
<p>不是Spring应用的应用程序可能会转换成Spring Boot应用程序，上面的指导可能会有帮助，但是你的路可能会有所不同。</p>
<h3 id="部署WAR到WebLogic"><a href="#部署WAR到WebLogic" class="headerlink" title="部署WAR到WebLogic"></a>部署WAR到WebLogic</h3><p>要将Spring Boot应用程序部署到WebLogic，必须确保servlet初始化程序直接实现<code>WebApplicationInitializer</code>（即使从已经实现它的基类中进行继承）。</p>
<p>一个典型的WebLogic初始化器是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.web.SpringBootServletInitializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.WebApplicationInitializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用logback，则还需要告知WebLogic更喜欢打包的版本，而不是预装在服务器上的版本。 你可以通过添加具有以下内容的<code>WEB-INF/weblogic.xml</code>文件来执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wls:weblogic-web-app</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:wls</span>=<span class="string">&quot;http://xmlns.oracle.com/weblogic/weblogic-web-app&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://java.sun.com/xml/ns/javaee/ejb-jar_3_0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://xmlns.oracle.com/weblogic/weblogic-web-app</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://xmlns.oracle.com/weblogic/weblogic-web-app/1.4/weblogic-web-app.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">wls:container-descriptor</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">wls:prefer-application-packages</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">wls:package-name</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">wls:package-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">wls:prefer-application-packages</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">wls:container-descriptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">wls:weblogic-web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="在老版本容器-Servlet-2-5-中部署WAR"><a href="#在老版本容器-Servlet-2-5-中部署WAR" class="headerlink" title="在老版本容器(Servlet 2.5)中部署WAR"></a>在老版本容器(Servlet 2.5)中部署WAR</h3><p>Spring Boot使用Servlet 3.0 API来初始化<code>ServletContext</code>（注册<code>Servlets</code>等），所以不能在Servlet 2.5容器中使用相同的应用程序。然而，使用一些特殊的工具可以在一个较老的容器上运行Spring Boot应用程序。 如果你依赖了<code>org.springframework.boot:spring-boot-legacy</code>（<a target="_blank" rel="noopener" href="https://github.com/scratches/spring-boot-legacy">独立</a>于Spring Boot的核心并且目前在1.0.2.RELEASE上提供），那么你只需要创建一个<code>web.xml</code>并 声明一个上下文监听器来创建应用程序上下文以及你的过滤器和servlet。上下文监听器是Spring Boot的特殊用途，但其余部分对于Servlet 2.5中的Spring应用程序来说是正常的。 例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">&quot;2.5&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>demo.Application<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.boot.legacy.context.web.SpringBootContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>metricsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>metricsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextAttribute<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.springframework.web.context.WebApplicationContext.ROOT<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用一个应用程序上下文（由上下文监听器创建的上下文），并使用init参数将其附加到<code>DispatcherServlet</code>。 这在Spring Boot应用程序中是正常的（通常你只有一个应用程序上下文）。</p>
<h3 id="使用Jedis-代替Lettuce"><a href="#使用Jedis-代替Lettuce" class="headerlink" title="使用Jedis 代替Lettuce"></a>使用Jedis 代替Lettuce</h3><p>Spring Boot starter（<code>spring-boot-starter-data-redis</code>）默认使用<a target="_blank" rel="noopener" href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a>。 你需要排除该依赖关系，并包含<a target="_blank" rel="noopener" href="https://github.com/xetorthio/jedis/">Jedis</a>。 Spring Boot管理这些依赖关系，以使这个过程尽可能简单。<br>在Maven中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在Gradle中：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configurations</span> &#123;</span><br><span class="line">	<span class="keyword">compile</span>.<span class="keyword">exclude</span> module: <span class="string">&quot;lettuce&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">	<span class="keyword">compile</span>(<span class="string">&quot;redis.clients:jedis&quot;</span>)</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://qzztf.com">水娃</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://qzztf.com/post/6b4e/">http://qzztf.com/post/6b4e/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://qzztf.com" target="_blank">水娃火娃石榴娃</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring-Boot/">Spring Boot</a><a class="post-meta__tags" href="/tags/How-to/">How to</a></div><div class="post_share"><div class="social-share" data-image="/image/avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/d1f6/" title="Spring Boot 十 - 附录"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring Boot 十 - 附录</div></div></a></div><div class="next-post pull-right"><a href="/post/4406/" title="Spring Boot 八- 构建工具插件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring Boot 八- 构建工具插件</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/361c/" title="Idea 创建 Spring boot应用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-04-22</div><div class="title">Idea 创建 Spring boot应用</div></div></a></div><div><a href="/post/29bc/" title="Spring Boot 七 - Spring Boot CLI"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-13</div><div class="title">Spring Boot 七 - Spring Boot CLI</div></div></a></div><div><a href="/post/4406/" title="Spring Boot 八- 构建工具插件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-16</div><div class="title">Spring Boot 八- 构建工具插件</div></div></a></div><div><a href="/post/64fe/" title="Spring Boot 六 - 部署Spring Boot应用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-09</div><div class="title">Spring Boot 六 - 部署Spring Boot应用</div></div></a></div><div><a href="/post/60cf/" title="Spring Boot 五-Spring Boot执行器 - 生产就绪特性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-09-13</div><div class="title">Spring Boot 五-Spring Boot执行器 - 生产就绪特性</div></div></a></div><div><a href="/post/e2d8/" title="Spring Boot 学习1-创建Spring Boot应用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-18</div><div class="title">Spring Boot 学习1-创建Spring Boot应用</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">水娃</div><div class="author-info__description">水娃的博客 | java</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qzztf"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot-%E5%BA%94%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">Spring Boot 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84FailureAnalyzer"><span class="toc-number">1.1.</span> <span class="toc-text">创建自己的FailureAnalyzer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E9%99%A4%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%95%85%E9%9A%9C"><span class="toc-number">1.2.</span> <span class="toc-text">排除自动配置故障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D%E8%87%AA%E5%AE%9A%E4%B9%89Environment%E6%88%96ApplicationContext"><span class="toc-number">1.3.</span> <span class="toc-text">在开始之前自定义Environment或ApplicationContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BAApplicationContext%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%EF%BC%88%E6%B7%BB%E5%8A%A0%E7%88%B6%E6%88%96%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">构建ApplicationContext层次结构（添加父或上下文）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%9D%9Eweb%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">创建非web应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">属性和配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%9E%84%E5%BB%BA%E6%97%B6%E8%87%AA%E5%8A%A8%E5%B1%95%E5%BC%80%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">在构建时自动展开属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Maven%E8%87%AA%E5%8A%A8%E5%B1%95%E5%BC%80%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.1.</span> <span class="toc-text">使用Maven自动展开属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Gradle%E8%87%AA%E5%8A%A8%E5%B1%95%E5%BC%80%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.2.</span> <span class="toc-text">使用Gradle自动展开属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%8C%96SpringApplication%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.</span> <span class="toc-text">外部化SpringApplication的配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.3.</span> <span class="toc-text">更改应用程序的外部属性的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E2%80%99%E7%9F%AD%E2%80%99%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">使用’短’命令行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8YAML%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">2.5.</span> <span class="toc-text">使用YAML外部属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%BF%80%E6%B4%BB%E7%9A%84Spring-profile"><span class="toc-number">2.6.</span> <span class="toc-text">设置激活的Spring profile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E7%8E%AF%E5%A2%83%E6%94%B9%E5%8F%98%E9%85%8D%E7%BD%AE"><span class="toc-number">2.7.</span> <span class="toc-text">根据环境改变配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E7%8E%B0%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E7%9A%84%E5%86%85%E7%BD%AE%E9%80%89%E9%A1%B9"><span class="toc-number">2.8.</span> <span class="toc-text">发现外部属性的内置选项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8FWeb%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">嵌入式Web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B6%E5%AE%83Web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">使用其它Web服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEJetty"><span class="toc-number">3.2.</span> <span class="toc-text">配置Jetty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0Servlet-Filter-%E6%88%96-Listener"><span class="toc-number">3.3.</span> <span class="toc-text">添加Servlet, Filter 或 Listener</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Spring-Bean%E6%B7%BB%E5%8A%A0Servlet%EF%BC%8CFilter%E5%92%8CListener"><span class="toc-number">3.3.1.</span> <span class="toc-text">使用Spring Bean添加Servlet，Filter和Listener</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E6%B3%A8%E5%86%8CServlet-%E6%88%96-Filter"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">禁止注册Servlet 或 Filter</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E8%B7%AF%E5%BE%84%E6%89%AB%E6%8F%8F%E6%B7%BB%E5%8A%A0Servlet%EF%BC%8CFilter%E5%92%8CListener"><span class="toc-number">3.3.2.</span> <span class="toc-text">使用类路径扫描添加Servlet，Filter和Listener</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9HTTP%E7%AB%AF%E5%8F%A3"><span class="toc-number">3.4.</span> <span class="toc-text">修改HTTP端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%9C%AA%E5%88%86%E9%85%8D%E7%9A%84HTTP%E7%AB%AF%E5%8F%A3"><span class="toc-number">3.5.</span> <span class="toc-text">使用随机未分配的HTTP端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%91%E7%8E%B0HTTP%E7%AB%AF%E5%8F%A3"><span class="toc-number">3.6.</span> <span class="toc-text">在运行时发现HTTP端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AESSL"><span class="toc-number">3.7.</span> <span class="toc-text">配置SSL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97"><span class="toc-number">3.8.</span> <span class="toc-text">配置访问日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.9.</span> <span class="toc-text">使用前端代理服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Tomcat%E7%9A%84%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE"><span class="toc-number">3.9.1.</span> <span class="toc-text">自定义Tomcat的代理配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AETomcat"><span class="toc-number">3.10.</span> <span class="toc-text">配置Tomcat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E7%94%A8Tomcat%E5%A4%9AConnector%E5%8A%9F%E8%83%BD"><span class="toc-number">3.11.</span> <span class="toc-text">启用Tomcat多Connector功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Tomcat%E7%9A%84-LegacyCookieProcessor"><span class="toc-number">3.12.</span> <span class="toc-text">使用 Tomcat的 LegacyCookieProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEUndertow"><span class="toc-number">3.13.</span> <span class="toc-text">配置Undertow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E7%94%A8-Undertow-%E5%A4%9AListener%E5%8A%9F%E8%83%BD"><span class="toc-number">3.14.</span> <span class="toc-text">启用 Undertow 多Listener功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-ServerEndpoint%E5%88%9B%E5%BB%BAWebSocket%E7%AB%AF%E7%82%B9"><span class="toc-number">3.15.</span> <span class="toc-text">使用@ServerEndpoint创建WebSocket端点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E7%94%A8HTTP%E5%93%8D%E5%BA%94%E5%8E%8B%E7%BC%A9"><span class="toc-number">3.16.</span> <span class="toc-text">启用HTTP响应压缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC"><span class="toc-number">4.</span> <span class="toc-text">Spring MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99JSON-REST-%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.1.</span> <span class="toc-text">编写JSON REST 服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99XML-REST-%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.2.</span> <span class="toc-text">编写XML REST 服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Jackson-ObjectMapper"><span class="toc-number">4.3.</span> <span class="toc-text">自定义Jackson ObjectMapper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-ResponseBody%E6%B8%B2%E6%9F%93"><span class="toc-number">4.4.</span> <span class="toc-text">自定义@ResponseBody渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-number">4.5.</span> <span class="toc-text">处理文件上传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%ADSpring-MVC-DispatcherServlet"><span class="toc-number">4.6.</span> <span class="toc-text">关闭Spring MVC DispatcherServlet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E9%BB%98%E8%AE%A4MVC%E9%85%8D%E7%BD%AE"><span class="toc-number">4.7.</span> <span class="toc-text">关闭默认MVC配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89ViewResolver"><span class="toc-number">4.8.</span> <span class="toc-text">自定义ViewResolver</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">5.</span> <span class="toc-text">HTTP 客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AERestTemplate%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">配置RestTemplate使用代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">6.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AELogback%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="toc-number">6.1.</span> <span class="toc-text">配置Logback进行日志记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AElogback%E5%8F%AA%E4%BB%A5%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA"><span class="toc-number">6.1.1.</span> <span class="toc-text">配置logback只以文件输出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AELog4j%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="toc-number">6.2.</span> <span class="toc-text">配置Log4j进行日志记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8YAML%E6%88%96JSON%E6%9D%A5%E9%85%8D%E7%BD%AELog4j-2"><span class="toc-number">6.2.1.</span> <span class="toc-text">使用YAML或JSON来配置Log4j 2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="toc-number">7.</span> <span class="toc-text">数据访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">7.1.</span> <span class="toc-text">配置自定义数据源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%A4%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">7.2.</span> <span class="toc-text">配置两个数据源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Spring-Data%E4%BB%93%E5%BA%93"><span class="toc-number">7.3.</span> <span class="toc-text">使用Spring Data仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8ESpring%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%88%86%E7%A6%BB-Entity%E5%AE%9A%E4%B9%89"><span class="toc-number">7.4.</span> <span class="toc-text">从Spring配置中分离@Entity定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEJPA%E5%B1%9E%E6%80%A7"><span class="toc-number">7.5.</span> <span class="toc-text">配置JPA属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEHibernate%E5%91%BD%E5%90%8D%E7%AD%96%E7%95%A5"><span class="toc-number">7.6.</span> <span class="toc-text">配置Hibernate命名策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89EntityManagerFactory"><span class="toc-number">7.7.</span> <span class="toc-text">使用自定义EntityManagerFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E5%AE%9E%E4%BD%93%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">7.8.</span> <span class="toc-text">使用两个实体管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E7%9A%84persistence-xml"><span class="toc-number">7.9.</span> <span class="toc-text">使用传统的persistence.xml</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Spring-Data-JPA%E5%92%8CMongo%E4%BB%93%E5%BA%93"><span class="toc-number">7.10.</span> <span class="toc-text">使用Spring Data JPA和Mongo仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%B4%E9%9C%B2Spring%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%BAREST%E7%AB%AF%E7%82%B9"><span class="toc-number">7.11.</span> <span class="toc-text">暴露Spring数据仓库为REST端点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEJPA%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">7.12.</span> <span class="toc-text">配置JPA使用的组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">数据库初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JPA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">8.1.</span> <span class="toc-text">使用JPA初始化数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Hibernate%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">8.2.</span> <span class="toc-text">使用Hibernate初始化数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">8.3.</span> <span class="toc-text">初始化数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AASpring-Batch%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">8.4.</span> <span class="toc-text">初始化一个Spring Batch数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9B%B4%E9%AB%98%E7%BA%A7%E5%88%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%E5%B7%A5%E5%85%B7"><span class="toc-number">8.5.</span> <span class="toc-text">使用更高级别的数据库迁移工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%97%B6%E6%89%A7%E8%A1%8CFlyway%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB"><span class="toc-number">8.5.1.</span> <span class="toc-text">启动时执行Flyway数据库迁移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%97%B6%E6%89%A7%E8%A1%8CLiquibase%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB"><span class="toc-number">8.5.2.</span> <span class="toc-text">启动时执行Liquibase数据库迁移</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF"><span class="toc-number">9.</span> <span class="toc-text">消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E4%BA%8B%E5%8A%A1%E7%9A%84JMS%E4%BC%9A%E8%AF%9D"><span class="toc-number">9.1.</span> <span class="toc-text">禁用事务的JMS会话</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E5%BA%94%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">批处理应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%97%B6%E6%89%A7%E8%A1%8CSpring-Batch%E4%BD%9C%E4%B8%9A"><span class="toc-number">10.1.</span> <span class="toc-text">启动时执行Spring Batch作业</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Actuator"><span class="toc-number">11.</span> <span class="toc-text">Actuator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9actuator%E7%AB%AF%E7%82%B9%E7%9A%84HTTP%E7%AB%AF%E5%8F%A3%E6%88%96%E5%9C%B0%E5%9D%80"><span class="toc-number">11.1.</span> <span class="toc-text">更改actuator端点的HTTP端口或地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E2%80%9Cwhitelabel%E2%80%9D%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">11.2.</span> <span class="toc-text">自定义“whitelabel”错误页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Actuator-%E5%92%8C-Jersey"><span class="toc-number">11.3.</span> <span class="toc-text">Actuator 和 Jersey</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Security"><span class="toc-number">12.</span> <span class="toc-text">Security</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%ADSpring-Boot-%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">12.1.</span> <span class="toc-text">关闭Spring Boot 安全配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9AuthenticationManager%E5%B9%B6%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%B8%90%E6%88%B7"><span class="toc-number">12.2.</span> <span class="toc-text">更改AuthenticationManager并添加用户帐户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E5%90%AF%E7%94%A8HTTPS"><span class="toc-number">12.3.</span> <span class="toc-text">使用代理服务器时启用HTTPS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E5%8A%A0%E8%BD%BD"><span class="toc-number">13.</span> <span class="toc-text">热加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E9%9D%99%E6%80%81%E5%86%85%E5%AE%B9"><span class="toc-number">13.1.</span> <span class="toc-text">刷新静态内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">13.2.</span> <span class="toc-text">不重启容器刷新模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Thymeleaf-%E6%A8%A1%E6%9D%BF"><span class="toc-number">13.2.1.</span> <span class="toc-text">Thymeleaf 模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FreeMarker-%E6%A8%A1%E6%9D%BF"><span class="toc-number">13.2.2.</span> <span class="toc-text">FreeMarker 模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Groovy-%E6%A8%A1%E6%9D%BF"><span class="toc-number">13.2.3.</span> <span class="toc-text">Groovy 模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E5%90%AF"><span class="toc-number">13.3.</span> <span class="toc-text">快速重启</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BDJava%E7%B1%BB"><span class="toc-number">13.4.</span> <span class="toc-text">不重启容器重新加载Java类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA"><span class="toc-number">14.</span> <span class="toc-text">构建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%9E%84%E5%BB%BA%E4%BF%A1%E6%81%AF"><span class="toc-number">14.1.</span> <span class="toc-text">生成构建信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90git%E4%BF%A1%E6%81%AF"><span class="toc-number">14.2.</span> <span class="toc-text">生成git信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC"><span class="toc-number">14.3.</span> <span class="toc-text">自定义依赖版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Maven%E5%88%9B%E5%BB%BA%E5%8F%AF%E6%89%A7%E8%A1%8Cjar"><span class="toc-number">14.4.</span> <span class="toc-text">使用Maven创建可执行jar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Spring-Boot%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BD%9C%E4%B8%BA%E4%BE%9D%E8%B5%96"><span class="toc-number">14.5.</span> <span class="toc-text">使用Spring Boot应用程序作为依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84jar%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E6%8F%90%E5%8F%96%E7%89%B9%E5%AE%9A%E7%9A%84%E5%BA%93"><span class="toc-number">14.6.</span> <span class="toc-text">当可执行的jar运行时，提取特定的库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8exclusions-%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84JAR"><span class="toc-number">14.7.</span> <span class="toc-text">使用exclusions 创建不可执行的JAR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95Maven%E5%90%AF%E5%8A%A8%E7%9A%84Spring-Boot%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">14.8.</span> <span class="toc-text">远程调试Maven启动的Spring Boot应用程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8Ant%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E5%AD%98%E6%A1%A3%E6%97%B6%E4%B8%8D%E4%BD%BF%E7%94%A8spring-boot-antlib"><span class="toc-number">14.9.</span> <span class="toc-text">用Ant构建可执行存档时不使用spring-boot-antlib</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text">传统部署方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8F%AF%E9%83%A8%E7%BD%B2%E7%9A%84war%E6%96%87%E4%BB%B6"><span class="toc-number">15.1.</span> <span class="toc-text">创建可部署的war文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E8%80%81%E7%89%88%E6%9C%ACservlet%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E5%8F%AF%E9%83%A8%E7%BD%B2war%E6%96%87%E4%BB%B6"><span class="toc-number">15.2.</span> <span class="toc-text">为老版本servlet容器创建可部署war文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E7%8E%B0%E6%9C%89%E5%BA%94%E7%94%A8%E8%BD%AC%E6%8D%A2%E4%B8%BASpring-Boot%E5%BA%94%E7%94%A8"><span class="toc-number">15.3.</span> <span class="toc-text">将现有应用转换为Spring Boot应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2WAR%E5%88%B0WebLogic"><span class="toc-number">15.4.</span> <span class="toc-text">部署WAR到WebLogic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%80%81%E7%89%88%E6%9C%AC%E5%AE%B9%E5%99%A8-Servlet-2-5-%E4%B8%AD%E9%83%A8%E7%BD%B2WAR"><span class="toc-number">15.5.</span> <span class="toc-text">在老版本容器(Servlet 2.5)中部署WAR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Jedis-%E4%BB%A3%E6%9B%BFLettuce"><span class="toc-number">15.6.</span> <span class="toc-text">使用Jedis 代替Lettuce</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/5441/" title="Spring Cloud Gateway整合Spring Doc">Spring Cloud Gateway整合Spring Doc</a><time datetime="2023-04-02T12:49:15.000Z" title="发表于 2023-04-02 20:49:15">2023-04-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/f507/" title="处理字典值反显问题.md">处理字典值反显问题.md</a><time datetime="2023-04-02T12:46:42.000Z" title="发表于 2023-04-02 20:46:42">2023-04-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/9fa5/" title="Spring AOP 调用同一个对象的方法">Spring AOP 调用同一个对象的方法</a><time datetime="2020-12-05T14:55:47.000Z" title="发表于 2020-12-05 22:55:47">2020-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/39fc/" title="Spring AOP基本用法3">Spring AOP基本用法3</a><time datetime="2020-09-23T02:26:55.000Z" title="发表于 2020-09-23 10:26:55">2020-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/f93d/" title="Spring AOP基本用法2">Spring AOP基本用法2</a><time datetime="2020-09-23T02:25:58.000Z" title="发表于 2020-09-23 10:25:58">2020-09-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 水娃</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '248e3cebde8537449dbb',
      clientSecret: 'a9c539e71782374d81eb91ad932288cd41809575',
      repo: 'blog-s-gitalk',
      owner: 'qinzaizhen',
      admin: ['qzztf'],
      id: '2e64b83dca279b84f3a6d3bce714d078',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>