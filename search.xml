<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring Cloud Gateway整合Spring Doc</title>
      <link href="/post/5441/"/>
      <url>/post/5441/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud-Gateway整合Spring-Doc"><a href="#Spring-Cloud-Gateway整合Spring-Doc" class="headerlink" title="Spring Cloud Gateway整合Spring Doc"></a>Spring Cloud Gateway整合Spring Doc</h1><p>最近在新项目使用到了Spring Doc，支持open api 3.</p><h2 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h2><p>使用Spring Doc 1.6.14版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-webflux-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-webmvc-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-javadoc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-springdoc-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时想在网关项目中整合所有的服务api文档。各个服务使用nacos注册，网关读取到注册的服务路由，并初始化swagger的访问路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;swaggerRouteRefreshListener&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationListener&lt;RefreshRoutesEvent&gt; <span class="title">routeRefreshListener</span><span class="params">(RouteDefinitionLocator locator)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApplicationListener&lt;RefreshRoutesEvent&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(RefreshRoutesEvent event)</span> </span>&#123;</span><br><span class="line">            routeDefinitionLocator.getRouteDefinitions().collectList().subscribe(definitions -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                definitions.forEach(routeDefinition -&gt; &#123;</span><br><span class="line">                    <span class="comment">//注册的服务id都是特定前缀的 ReactiveCompositeDiscoveryClient_</span></span><br><span class="line">                    String group = routeDefinition.getId().replace(DISCOVERY_CLIENT_ID_PRE, <span class="string">&quot;&quot;</span>).toLowerCase();</span><br><span class="line">                    AbstractSwaggerUiConfigProperties.SwaggerUrl swaggerUrl = <span class="keyword">new</span> AbstractSwaggerUiConfigProperties.SwaggerUrl(</span><br><span class="line">                        group,</span><br><span class="line">                        routeDefinition.getUri().toString().replace(<span class="string">&quot;lb://&quot;</span>, <span class="string">&quot;&quot;</span>).toLowerCase() + <span class="string">&quot;/v3/api-docs&quot;</span>,</span><br><span class="line">                        <span class="comment">//displayName 是添加进nacos的自定义元数据，设置成中文，方便识别</span></span><br><span class="line">                        routeDefinition.getMetadata().getOrDefault(<span class="string">&quot;displayName&quot;</span>, <span class="string">&quot;&quot;</span>).toString()</span><br><span class="line">                    );</span><br><span class="line">                    Set&lt;AbstractSwaggerUiConfigProperties.SwaggerUrl&gt; urls = swaggerUiConfigProperties.getUrls();</span><br><span class="line">                    <span class="keyword">if</span> (urls == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        urls = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">                        swaggerUiConfigProperties.setUrls(urls);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//可以判断一下是不是已经加过了。</span></span><br><span class="line">                    urls.add(swaggerUrl);</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="处理knife4j"><a href="#处理knife4j" class="headerlink" title="处理knife4j"></a>处理knife4j</h2><p>如果使用knife4j作为页面展示，需要处理一下basePath。在openapi3里面貌似没有这个元素了。仅针对knife4j处理。</p><p>创建一个gateway filter，在返回值中加上basePath。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerGlobalFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        String path = request.getPath().toString();</span><br><span class="line">        String host = request.getLocalAddress().getHostString();</span><br><span class="line">        <span class="keyword">int</span> port = request.getLocalAddress().getPort();</span><br><span class="line">        <span class="keyword">if</span> (!path.endsWith(<span class="string">&quot;/v3/api-docs&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] pathArray = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        String basePath = pathArray[<span class="number">1</span>];</span><br><span class="line">        ServerHttpResponse originalResponse = exchange.getResponse();</span><br><span class="line"></span><br><span class="line">        ServerHttpResponseDecorator decoratedResponse = <span class="keyword">new</span> ServerHttpResponseDecorator(originalResponse) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">writeWith</span><span class="params">(Publisher&lt;? extends DataBuffer&gt; body)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">super</span>.getStatusCode().equals(HttpStatus.OK) &amp;&amp; body <span class="keyword">instanceof</span> Flux) &#123;</span><br><span class="line">                    Flux&lt;? extends DataBuffer&gt; fluxBody = Flux.from(body);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.writeWith(fluxBody.buffer().map(dataBuffers -&gt; &#123;</span><br><span class="line">                        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                        dataBuffers.forEach(dataBuffer -&gt; &#123;</span><br><span class="line">                            <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[dataBuffer.readableByteCount()];</span><br><span class="line">                            dataBuffer.read(content);</span><br><span class="line">                            DataBufferUtils.release(dataBuffer);</span><br><span class="line">                            list.add(<span class="keyword">new</span> String(content, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">                        &#125;);</span><br><span class="line">                        String s = <span class="keyword">this</span>.listToString(list);</span><br><span class="line">                        JSONObject jsonObject = JSONUtil.parseObj(s);</span><br><span class="line"></span><br><span class="line">                        jsonObject.put(<span class="string">&quot;host&quot;</span>, host + <span class="string">&quot;:&quot;</span> + port);</span><br><span class="line">                        jsonObject.put(<span class="string">&quot;basePath&quot;</span>, basePath);</span><br><span class="line">                        s = jsonObject.toString();</span><br><span class="line">                        <span class="comment">//设置更新后的header请求头长度</span></span><br><span class="line">                        <span class="keyword">int</span> length = s.getBytes().length;</span><br><span class="line">                        HttpHeaders headers = originalResponse.getHeaders();</span><br><span class="line">                        headers.setContentLength(length);</span><br><span class="line">                        <span class="keyword">return</span> bufferFactory().wrap(s.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">                    &#125;));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.writeWith(body);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//获取父类原始ServerHttpResponse的header请求头信息，这是代理Delegate类型</span></span><br><span class="line">                HttpHeaders httpHeaders = <span class="keyword">super</span>.getHeaders();</span><br><span class="line">                httpHeaders.set(HttpHeaders.CONTENT_TYPE, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> httpHeaders;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> String <span class="title">listToString</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">                StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">                    stringBuilder.append(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// replace response with decorator</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange.mutate().response(decoratedResponse).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附：Nacos添加自定义meta数据"><a href="#附：Nacos添加自定义meta数据" class="headerlink" title="附：Nacos添加自定义meta数据"></a>附：Nacos添加自定义meta数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; NacosDiscoveryProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosConfigDocAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired(required = false)</span></span><br><span class="line">   <span class="keyword">private</span> NacosDiscoveryProperties properties;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Value(&quot;$&#123;spring.application.displayName:$&#123;spring.application.name&#125;&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String displayName;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@PostConstruct</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      properties.getMetadata().put(<span class="string">&quot;displayName&quot;</span>, displayName);</span><br><span class="line">      properties.init();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>处理字典值反显问题.md</title>
      <link href="/post/f507/"/>
      <url>/post/f507/</url>
      
        <content type="html"><![CDATA[<h1 id="处理字典值反显问题"><a href="#处理字典值反显问题" class="headerlink" title="处理字典值反显问题"></a>处理字典值反显问题</h1><p>项目中往往只保存了字典的key值，前端页面显示时需要展示字面值。</p><p>解决方案通常有以下几种：</p><ol><li>前端展示时，根据字典key，调用专门的接口去查询字面值。为了性能考虑，可以将查询结果缓存到浏览器。适用于不常变化的字典值。</li><li>后端返回结果前将字典值处理好后一起返回。这里面也有几种处理方式：<ol><li>查询时sql关联查询字典表。适用于字典模块与业务模块没有分离的情况。</li><li>返回结果根据字典值调用字典接口查询出字面值。适用于字典与业务分离的情况。字典接口可以根据情况做缓存。</li></ol></li></ol><p>这里简单说一下最后一种处理方式。</p><p>具体思路是利用mybatis的插件去处理每条记录中特定的字段。</p><h2 id="定义标记注解FieldBind"><a href="#定义标记注解FieldBind" class="headerlink" title="定义标记注解FieldBind"></a>定义标记注解FieldBind</h2><p>该注解用来某个字段上，用来标记该字段是字典值，需要反显。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FieldBind &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字典类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写字典值目标字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">target</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">handlerName</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>type：字典通常是分类的。一个分类下只有几个字典值。</li><li>target：处理后字面值保存到哪个字段。在返回的vo中多定义一个字段用来装字面值。</li><li>handlerName：处理器bean的名称。</li></ul><h2 id="定义字典处理器FieldBindHandler"><a href="#定义字典处理器FieldBindHandler" class="headerlink" title="定义字典处理器FieldBindHandler"></a>定义字典处理器FieldBindHandler</h2><p>FieldBindHandler接口是字典处理的抽象接口，用来查询字典值及其描述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FieldBindHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 字典类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 字典值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字典显示值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span>  &lt;T&gt; <span class="function">T <span class="title">handle</span><span class="params">(String type, Object value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列出所有可能的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> List&lt;Value&gt; <span class="title">listAll</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Value</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String value;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 描述</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String desp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工具类FieldBindHandlerHelper"><a href="#工具类FieldBindHandlerHelper" class="headerlink" title="工具类FieldBindHandlerHelper"></a>工具类FieldBindHandlerHelper</h2><p>该工具会遍历要处理对象的所有字段，识别出标记注解的字段，调用处理器FieldBindHandler获取到字面值，然后将字面值设置到目标字段中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldBindHandlerHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FieldBindHandler dictService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//hutool的SpringUtil的工具类</span></span><br><span class="line">        dictService = SpringUtil.getBean(FieldBindHandler.class);</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.MINUTES, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>), <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理返回结果值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.Object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021/9/6 11:20</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">setFieldValue</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result.getClass().isPrimitive()) &#123;</span><br><span class="line">            <span class="comment">//基本类型直接返回</span></span><br><span class="line">            <span class="keyword">return</span> (T) result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">            <span class="comment">//map类型直接返回</span></span><br><span class="line">            <span class="keyword">return</span> (T) result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object obj : (Collection) result) &#123;</span><br><span class="line">                setFieldValue(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (T) result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此处可根据需要加上一些判断优化处理，如result为基本数据类型对象、Map时不再执行后续代码，或只处理限定类等</span></span><br><span class="line"></span><br><span class="line">        Field[] fs = ReflectUtil.getFields(result.getClass());</span><br><span class="line">        List&lt;Future&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;(fs.length);</span><br><span class="line">        <span class="keyword">for</span> (Field f : fs) &#123;</span><br><span class="line">            FieldBind dictBind = f.getAnnotation(FieldBind.class);</span><br><span class="line">            <span class="keyword">if</span> (dictBind == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取@FieldBind标记字段具体值</span></span><br><span class="line">            Object value = ReflectUtil.getFieldValue(result, f);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            futures.add(executor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 设置目标字段的转换值</span></span><br><span class="line">                    FieldBindHandler handler = dictService;</span><br><span class="line">                    <span class="keyword">if</span> (StrUtil.isNotBlank(dictBind.handlerName())) &#123;</span><br><span class="line">                        handler = SpringUtil.getBean(dictBind.handlerName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    ReflectUtil.setFieldValue(result, dictBind.target(), handler.handle(dictBind.type(), value));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        futures.stream().peek(future -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                future.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;字典转换失败&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> (T) result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mybatis插件FieldInterceptor"><a href="#mybatis插件FieldInterceptor" class="headerlink" title="mybatis插件FieldInterceptor"></a>mybatis插件FieldInterceptor</h2><p>此插件用来拦截mybatis处理resultset。在插件中会调用上面的工具类处理返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;@Signature(type = ResultSetHandler.class, method = &quot;handleResultSets&quot;, args = &#123;Statement.class&#125;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FieldBindHandlerHelper.setFieldValue(invocation.proceed());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target <span class="keyword">instanceof</span> ResultSetHandler) &#123;</span><br><span class="line">            <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现FieldBindHandler"><a href="#实现FieldBindHandler" class="headerlink" title="实现FieldBindHandler"></a>实现FieldBindHandler</h2><p>在项目中只需要实现字典获取的方式即可。如果公司的项目中实典的获取方式是统一的，只需要实现一次即可。</p><p><strong>如果实现了多个，则需要在其中一个指定<code>@primary</code>，并在<code>FieldBind</code>注解标记的字段中指定要使用的<code>FieldBindHandler</code></strong></p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FieldBind(type = &quot;subLabelType&quot;, target = &quot;labelTypeName&quot;, handlerName = &quot;sysDicFieldBindHandler&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String labelType;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 标签类型名称</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> String labelTypeName;</span><br></pre></td></tr></table></figure><p>至此我们就处理了字典的反显问题。</p><h2 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h2><p>优化的点：</p><ol><li>现在处理字典的时候，如果返回的是列表，是一条条数据进行处理的。同一个字典类型或同一个字典值将会查询多次，可以考虑一次处理多条记录。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP 调用同一个对象的方法</title>
      <link href="/post/9fa5/"/>
      <url>/post/9fa5/</url>
      
        <content type="html"><![CDATA[<p>经过前面的学习，我们了解了Spring AOP的执行过程。<br>这里想提醒注意一个小问题，我们在对象的方法中调用该对象的另外一个方法会出现什么现象呢？</p><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><ol><li><p>定义对象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessService</span> <span class="keyword">implements</span> <span class="title">IBusinessService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;i want to say again&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.sayAgain();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayAgain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;again&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;again&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在<code>sayHello</code> 方法中调用了该对象的<code>sayAgain</code>方法。</p><ol start="2"><li><p>配置aop</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.sexycode.spring.study.chapter5.BusinessService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.sexycode.spring.study.chapter5.LogAspect&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.sexycode.spring.study.chapter5.BusinessBeforeAdvice&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;log&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* cn.sexycode.spring.study.chapter5.BusinessService.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>在<code>BusinessService</code>的每个方法调用前打印<code>log</code>。</p><ol start="3"><li><p>执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;sameobject.xml&quot;</span>);</span><br><span class="line">    applicationContext.getBean(IBusinessService.class).sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log</span><br><span class="line">hello</span><br><span class="line">i want to say again</span><br><span class="line">again</span><br></pre></td></tr></table></figure><p>并没有想我们想象的那样在每个方法中打印<code>log</code>。</p><p>原因在前面的文章中提到过，将执行到目标对象的方法<code>sayHello</code>时，这个时直接调用<code>sayAgain</code>方法时，跟代理对象没有关系了，所以是不会生效的。我们要弄清楚方法调用之所以能被拦截，就是因为我们调用的是代理对象的方法，而不是目标对象的方法。这跟子类重写父类的方法容易混淆，当我们重写之后，调用的是子类的方法。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>想要解决这个问题也很简单，思路就是在方法内部调用代理对象的方法就可以了。</p><ol><li>暴露代理对象</li><li>将方法放到其他对象</li></ol><h2 id="暴露代理对象"><a href="#暴露代理对象" class="headerlink" title="暴露代理对象"></a>暴露代理对象</h2><p>Spring 给我们提供了一个工具类<code>org.springframework.aop.framework.AopContext#currentProxy</code>可以获取当前调用的代理对象。<strong>但是需要我们暴露出代理对象，如：<code>&lt;aop:aspectj-autoproxy expose-proxy=&quot;true&quot;&gt;</code></strong></p><h2 id="将两个方法拆分到不同的对象中"><a href="#将两个方法拆分到不同的对象中" class="headerlink" title="将两个方法拆分到不同的对象中"></a>将两个方法拆分到不同的对象中</h2><p>这个很好理解，拆分出去后调用的是两个代理对象的方法，也就可以被拦截。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP基本用法3</title>
      <link href="/post/39fc/"/>
      <url>/post/39fc/</url>
      
        <content type="html"><![CDATA[<p>前面讲到了使用XML 配置<code>ProxyFactoryBean</code>，结合注解配置<code>@Bean</code>也可以实现代码配置。还讲到了代码配置<code>ProxyFactory</code>。前者与Spring IOC 容器结合的更紧密，不需要自己调用<code>getProxy()</code>方法，从IOC 容器中获取的Bean 已经是最终的代理对象。</p><p>这两种方式需要我们自己设置目标对象，通知以及代理接口，使用起来还是比较繁琐的。每当我们需要一个代理对象时，就需要配置<code>ProxyFactoryBean</code>或<code>ProxyFactory</code>。</p><p>有没有更好的方式，只需要做简单的配置就可以为多个对象生成代理对象呢？</p><p>我们已经有了创建代理的方式，就是前面介绍的工厂类，剩下的工作只需要解决如何配置和如何解析配置的问题就可以了。</p><p>下面介绍最核心的类。</p><h2 id="AbstractAutoProxyCreator"><a href="#AbstractAutoProxyCreator" class="headerlink" title="AbstractAutoProxyCreator"></a>AbstractAutoProxyCreator</h2><p>看看Spring 官方介绍：</p><blockquote><p>该抽象类实现了BeanPostProcessor接口，用AOP代理来包装每个合适的bean，并在调用bean本身之前委托给指定的拦截器。这个类区分了“公共”拦截器和“特定”拦截器，前者用于它创建的所有代理，后者用于每个bean实例。可以不需要任何通用的拦截器。如果有，则可以使用<code>interceptorNames</code>属性设置它们。与org.springframework.aop.framework.ProxyFactoryBean 一样，使用拦截器名称而不是bean引用来正确处理原型顾问和拦截器：例如，支持有状态的混合。<code>interceptorNames</code>属性支持任何通知类型。</p><p>如果有大量的bean需要用类似的代理(即委托给相同的拦截器)来包装，那么这种自动代理特别有用。可以在bean工厂中注册一个这样的后处理程序，而不是为x个目标bean进行x个重复的代理定义，来达到相同的效果。</p><p>子类可以应用任何策略来决定一个bean是否被代理，例如通过类型、名称、bean定义细节等。它们还可以返回额外的拦截器，这些拦截器应该只应用于特定的bean实例。<code>BeanNameAutoProxyCreator</code>是一个简单的实现类，它通过指定名称识别要代理的bean。</p><p>可以使用任意数量的<code>TargetSourceCreator</code>实现来创建自定义目标源:例如，来共享原型对象。只要<code>TargetSourceCreator</code>指定了自定义<code>TargetSource</code>，即使没有通知，也会发生自动代理。如果没有设置TargetSourceCreator，或者没有匹配上，那么默认情况下将使用 <code>SingletonTargetSource</code>来包装目标bean实例.</p></blockquote><p>从上面的描述中，可以看出此类实现了<code>BeanPostProcessor</code>接口，拦截bean的创建过程。并提供了自定义获取目标对象的方式，以及识别通知，创建代理对象的核心逻辑。子类提供了多种更具体的创建代理的策略。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/post/39fc/AbstractAutoProxyCreator.png" alt="AbstractAutoProxyCreator"></p><p>从上图中可以看到此类实现了<code>SmartInstantiationAwareBeanPostProcessor</code>接口，该接口在前面<em>Bean的初始化中</em>讲到过，如果<code>postProcessBeforeInstantiation</code>方法返回了非<code>null</code>对象，则将会打断原bean的初始化过程，从而使用该方法返回的对象。如果上面的方法返回<code>null</code>，那么将走常规初始化对象方式，初始化对象之后将调用<code>postProcessAfterInitialization</code>方法，在此方法中可以根据需要返回代理对象。</p><p>我们猜想一下如何创建？</p><ol><li>判断是否需要创建</li><li>判断之前是否创建过</li><li>找到目标对象所有匹配的通知</li><li> 有了通知，剩下的就是通过之前的创建代理的方式来创建。</li></ol><h3 id="postProcessBeforeInstantiation-方法"><a href="#postProcessBeforeInstantiation-方法" class="headerlink" title="postProcessBeforeInstantiation 方法"></a>postProcessBeforeInstantiation 方法</h3><p>此方法将会在进行常规化实例bean时执行，如果不需要阻断初始化流程，则需要返回<code>null</code>。在这个方法实现中提供了一个自定义目标对象获取方式的机会，即<code>TargetSourceCreator</code>，如果注册了该接口的实现类并且返回非<code>null</code>目标对象，那么将在<code>postProcessBeforeInstantiation</code>方法中创建代理对象。如果没有注册或者注册的<code>TargetSourceCreator</code>实现都返回<code>null</code>，那么不会在<code>postProcessBeforeInstantiation</code>方法中创建代理对象，走常规初始化流程。初始化bean之后还有机会再次修改bean实例。</p><p>默认直接从Spring 工厂中拿对应的bean实例，并不会在此处实现自定义<code>TargetSourceCreator</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">    Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">    <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="postProcessAfterInitialization-方法"><a href="#postProcessAfterInitialization-方法" class="headerlink" title="postProcessAfterInitialization 方法"></a>postProcessAfterInitialization 方法</h3><p>在前面的方法中如果返回了<code>null</code>，那么将会继续初始化bean。初始化之后将调用<code>BeanPostProcessor.postProcessAfterInitialization</code>方法。<code>AbstractAutoProxyCreator</code>将在此方法中创建代理对象。这里有个小地方要注意，因为在实例化的过程中，如果是要提前暴露出来的bean，将会提前加入到<code>singletonFactories</code> map中，在获取这个bean的时候将会调用<code>getEarlyBeanReference</code>方法，也就是说可能需要在这个方法中创建代理对象，所以如果已经在<code>getEarlyBeanReference</code>方法中创建了，那么在<code>postProcessAfterInitialization</code>方法中就不需要再创建一次了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br></pre></td></tr></table></figure><h3 id="getEarlyBeanReference-方法"><a href="#getEarlyBeanReference-方法" class="headerlink" title="getEarlyBeanReference 方法"></a>getEarlyBeanReference 方法</h3><p>在提前暴露bean时会调用此方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyProxyReferences.add(cacheKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否需要创建"><a href="#判断是否需要创建" class="headerlink" title="判断是否需要创建"></a>判断是否需要创建</h3><p>看过了上面3个入口的代码，主要用<code>isInfrastructureClass(beanClass) </code>和 <code>shouldSkip(beanClass, beanName)</code>两个方法来判断。</p><p><code>isInfrastructureClass</code>用来判断该类是不是基础类，包括<code>Advice</code>、<code>Pointcut</code>、<code>Advisor</code>和<code>AopInfrastructureBean</code> 这些aop基础接口实现类，这些类的对象不应该被代理。</p><p><code>shouldSkip(beanClass, beanName)</code> 用来实现自定义的跳过逻辑，子类可以重写该方法。默认判断实例类是不是以<code>.ORIGINAL</code>结尾，是则跳过，反之则不跳过。</p><h3 id="判断之前是否创建过"><a href="#判断之前是否创建过" class="headerlink" title="判断之前是否创建过"></a>判断之前是否创建过</h3><p>通过<code>earlyProxyReferences</code> Set 将 提前暴露出来的bean缓存起来，<code>advisedBeans</code> Map用来存放经过历增强过程的Bean，已经增强过的对应的<code>value</code>为<code>True</code>，不需要增强的则为<code>False</code>。<code>targetSourcedBeans</code> Set用来将自定义<code>TargetSource</code>的bean缓存起来。</p><ol><li><p>在调用<code>postProcessBeforeInstantiation</code>方法时，如果没有传bean name，或者<code>targetSourcedBeans</code>不包含bean name，那么如果<code>advisedBeans</code>包含此缓存key(缓存key是以bean的Class和name来组成的，如果没有name则只使用class)，则代表之前已经处理过这种class或者bean name，直接返回<code>null</code>。</p><p>如果在此方法中创建了代理，则会将bean name 加入到<code>targetSourcedBeans</code>。</p></li><li><p>在调用<code>getEarlyBeanReference</code>方法时，如果<code>earlyProxyReferences</code> Set中没有包含此缓存key，则将此缓存key加入到<code>earlyProxyReferences</code>。如果bean name不为空并且<code>targetSourcedBeans</code>包含bean name，则意味着在第一中情况中已经创建了代理，直接返回该bean。</p><p>如果<code>advisedBeans</code>中缓存key对应的值为<code>False</code>，则意味着这个bean不需要创建代理，直接返回此bean。</p></li><li><p>在调用<code>postProcessAfterInitialization</code>方法时，如果<code>earlyProxyReferences</code> Set中包含此缓存key，则意味着在第二种情况中已经创建了代理，直接返回此bean即可。</p><p>如果bean name不为空并且<code>targetSourcedBeans</code>包含bean name，则意味着在第一种情况中已经创建了代理，直接返回该bean。</p><p>如果<code>advisedBeans</code>中缓存key对应的值为<code>False</code>，则意味着这个bean不需要创建代理，直接返回此bean。</p></li></ol><p>由于有三个入口可以用来创建代理对象，因此要保证只创建一次，所以用了上面的方式。</p><p>下面看一下完整的流程图：</p><p><img src="/post/39fc/AbstractAutoProxyCreator%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="AbstractAutoProxyCreator创建代理对象流程图"></p><h3 id="getAdvicesAndAdvisorsForBean-方法"><a href="#getAdvicesAndAdvisorsForBean-方法" class="headerlink" title="getAdvicesAndAdvisorsForBean 方法"></a>getAdvicesAndAdvisorsForBean 方法</h3><p>此方法用来查找当前bean匹配的通知，是一个抽象方法，需要子类去实现具体的查找逻辑。</p><p>查到到之后将通知的拦截器转换为Spring 的<code>Advisor</code>，这个转换过程中，可以预先配置通用的拦截器，可以在每个bean中生效，</p><p>具体的转换方法是<code>org.springframework.aop.framework.adapter.AdvisorAdapterRegistry#wrap()</code>。</p><h2 id="子类-BeanNameAutoProxyCreator"><a href="#子类-BeanNameAutoProxyCreator" class="headerlink" title="子类 BeanNameAutoProxyCreator"></a>子类 BeanNameAutoProxyCreator</h2><p>通过配置bean 名称过滤需要代理的bean并为其创建代理。</p><p>该类只能通过<code>interceptorNames</code>属性指定应用于所有匹配bean的拦截器名称，设置<code>beanNames</code>来配置要代理的bean，可能指定通配符<code>*</code>，如果需要为<code>FactoryBean</code>对象创建代理，需要加上<code>&amp;</code>标记。</p><p>如果bean能匹配上，则<code>getAdvicesAndAdvisorsForBean</code>将返回<code>PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS</code>，这是一个空数组，也就是说这个方法将不会返回额外的拦截器，但是会创建代理对象。</p><h2 id="子类-AbstractAdvisorAutoProxyCreator"><a href="#子类-AbstractAdvisorAutoProxyCreator" class="headerlink" title="子类 AbstractAdvisorAutoProxyCreator"></a>子类 AbstractAdvisorAutoProxyCreator</h2><blockquote><p>通用的自动代理创建器，基于每个bean检测到的advisor为特定bean构建AOP代理。<br>子类必须实现抽象<code>findCandidateAdvisors()</code>方法，以返回应用于任何对象的顾问列表。子类还可以重写继承的shouldSkip方法，以从自动代理中排除某些对象。<br>需要排序的通知应该实现<code>org.springframework.core.Ordered</code>接口。该类按<code>Ordered</code>的<code>order</code>值对通知进行排序，未实现<code>Ordered</code>接口的通知将被认为是无序的，它们将以未定义的顺序出现在advisor链的末尾。</p></blockquote><p>这个类实现了<code>getAdvicesAndAdvisorsForBean</code>方法，并提供了新的模板方法供子类去实现。主要是<code>findCandidateAdvisors</code>方法用来查找所有候选的<code>Advisor</code>，<code>findAdvisorsThatCanApply</code>方法用来筛选能匹配的<code>Advisor</code>，<code>extendAdvisors</code>方法用来注册额外的<code>Advisor</code>，<code>sortAdvisors</code>方法用来对<code>Advisor</code>进行排序。</p><h3 id="findCandidateAdvisors方法"><a href="#findCandidateAdvisors方法" class="headerlink" title="findCandidateAdvisors方法"></a>findCandidateAdvisors方法</h3><p>该方法用来查找<code>Advisor</code>实现类，默认使用工具类<code>BeanFactoryAdvisorRetrievalHelper</code>，最重要的一行代码是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">      <span class="keyword">this</span>.beanFactory, Advisor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>在beanFactory中查找所有<code>Advisor</code>实现类的Bean名称，然后再循环调用beanFactory的getBean()方法初始化advisor。</p><p>并定义了<code>volatile</code>修饰的<code>cachedAdvisorBeanNames</code>变量将找到的Advisor bean缓存起来，以便下次直接使用。</p><h3 id="findAdvisorsThatCanApply方法"><a href="#findAdvisorsThatCanApply方法" class="headerlink" title="findAdvisorsThatCanApply方法"></a>findAdvisorsThatCanApply方法</h3><p>此方法用于匹配当前目标对象和上一步中找到的Advisor。</p><p>先使用线程变量将当前bean暴露出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProxyCreationContext.setCurrentProxiedBeanName(beanName)</span><br></pre></td></tr></table></figure><p>再使用<code>AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass)</code>方法返回匹配的Advisor。</p><p>一些通用的方法都抽出放到了<code>AopUtils</code>这个工具类中。</p><p>在Spring AOP 中可以分为两种Advisor：<code>IntroductionAdvisor</code>和<code>PointcutAdvisor</code>。一种用来增强类（为对象引入新的接口），另一种用来增强具体的方法。</p><p>匹配流程：<img src="/post/39fc/advisor%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B.png" alt="advisor匹配过程"></p><p>从上面的流程图中可以看出，主要的步骤是遍历Advisor，再调用<code>IntroductionAdvisor</code>的ClassFilter的matches方法或者PointcutAdvisor的MethodMatcher的match方法，前者针对class级别的增强，后者为方法级别的增强。</p><h3 id="extendAdvisors方法"><a href="#extendAdvisors方法" class="headerlink" title="extendAdvisors方法"></a>extendAdvisors方法</h3><p>在上一步中已经找到了匹配的advisor，此方法用于子类去扩展，添加其他的advisor。</p><h3 id="sortAdvisors方法"><a href="#sortAdvisors方法" class="headerlink" title="sortAdvisors方法"></a>sortAdvisors方法</h3><p>根据<code>@Order</code>注解或者<code>Ordered</code>接口将advisor排序。</p><h2 id="子类-AspectJAwareAdvisorAutoProxyCreator"><a href="#子类-AspectJAwareAdvisorAutoProxyCreator" class="headerlink" title="子类 AspectJAwareAdvisorAutoProxyCreator"></a>子类 AspectJAwareAdvisorAutoProxyCreator</h2><p><code>AbstractAdvisorAutoProxyCreator</code>的子类，暴露出<code>AspectJ</code>的调用上下文，并解析当多个通知来自同一切面时<code>AspectJ</code>的通知优先级规则。</p><h3 id="sortAdvisors-方法"><a href="#sortAdvisors-方法" class="headerlink" title="sortAdvisors 方法"></a>sortAdvisors 方法</h3><p>按<code>AspectJ</code>优先级对通知进行排序。如果两个通知来自同一个<code>Aspect</code>，它们的顺序也会相同。来自同一<code>Aspect</code>的通知将根据以下规则进一步排序:<br>如果这一对中的任何一个是 <code>after advice</code>，那么最后声明的通知优先级最高(最后运行)。否则，先声明的通知优先级最高(先运行)。<br><strong>重要提示: <code>advisor</code>按优先级排序，从优先级最高到最低。在连接点之前，优先级最高的<code>advisor</code>先运行。在连接点之后，优先级最高的顾问最后运行。</strong></p><h3 id="extendAdvisors-方法"><a href="#extendAdvisors-方法" class="headerlink" title="extendAdvisors 方法"></a>extendAdvisors 方法</h3><p>添加<code>ExposeInvocationInterceptor</code> 到通知链开头。它将当前<code>MethodInvocation</code>对象公开为线程变量。我们偶尔需要这样的功能，例如，当切入点(例如<code>AspectJ</code>表达式切入点)需要知道完整的调用上下文时。除非真的有这个必要，一般不需要使用这个拦截器。</p><h2 id="子类-AnnotationAwareAspectJAutoProxyCreator"><a href="#子类-AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="子类 AnnotationAwareAspectJAutoProxyCreator"></a>子类 AnnotationAwareAspectJAutoProxyCreator</h2><p>继承自<code>AspectJAwareAdvisorAutoProxyCreator</code>，用来处理当前应用程序上下文中所有<code>AspectJ</code>注解声明的<code>Aspect</code>，以及Spring <code>Advisor</code>。</p><p>如果使用了<code>&lt;aop:include&gt;</code>元素，只有名称与正则匹配的@AspectJ bean 才会用于AOP。</p><h3 id="findCandidateAdvisors-方法"><a href="#findCandidateAdvisors-方法" class="headerlink" title="findCandidateAdvisors 方法"></a>findCandidateAdvisors 方法</h3><p>此方法先调用父类的方法处理常规的Advisor，以此支持上面提到过的AOP声明方式。</p><p>再由<code>BeanFactoryAspectJAdvisorsBuilder</code>获取通过AspecJ注解声明的Advisor。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring, AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP基本用法2</title>
      <link href="/post/f93d/"/>
      <url>/post/f93d/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-AOP-用法二"><a href="#Spring-AOP-用法二" class="headerlink" title="Spring AOP 用法二"></a>Spring AOP 用法二</h1><p>在上一篇中讲到通过xml配置<code>ProxyFactoryBean</code>来创建代理对象，在这一篇中看看通过编程的方式配置<code>ProxyFactory</code>。该类继承自<code>ProxyCreatorSupport</code>（之前提到过该类提供了一些创建代理对象的基础方法），提供了配置目标对象，代理接口和通知的功能。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">xmlBeanDefinitionReader.loadBeanDefinitions(<span class="string">&quot;AopXmlSimpleConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">// 获取需求代理的目标对象</span></span><br><span class="line">IBusinessService bean = beanFactory.getBean(<span class="string">&quot;businessService&quot;</span>, IBusinessService.class);</span><br><span class="line"><span class="comment">// 获取需要增强的通知</span></span><br><span class="line">Advice userBeforeAdvice = beanFactory.getBean(<span class="string">&quot;userBeforeAdvice&quot;</span>, Advice.class);</span><br><span class="line"><span class="comment">// 将目标对象传入构造函数，创建代理工厂</span></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(bean);</span><br><span class="line"><span class="comment">//添加我们的通知</span></span><br><span class="line">proxyFactory.addAdvice(userBeforeAdvice);</span><br><span class="line"><span class="comment">// 最终获取到代理对象</span></span><br><span class="line">IBusinessService proxy = (IBusinessService) proxyFactory.getProxy();</span><br><span class="line"><span class="comment">//调用代理对象的方法</span></span><br><span class="line">proxy.sayAgain();</span><br></pre></td></tr></table></figure><p>通过以上代码，我们创建出了最终的代理对象。大致步骤如下：</p><ol><li>通过构造函数，传入目标对象，创建代理工厂对象</li><li>添加通知</li><li>获取代理对象</li><li>调用代理对象的方法</li></ol><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before method advice</span><br><span class="line">again</span><br></pre></td></tr></table></figure><p>打印结果也说明了我们的代理对象正常工作，先执行了前置通知，再调用了目标对象的方法。</p><p>最重要的获取代理对象的方法都是在父类中完成的，与<code>ProxyFactoryBean</code>类似，该类只是提供了另外一种配置的方式。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数是这个类使用比较频繁的方法。可以通过目标对象，代理接口，以及通知来使用构造函数。</p><h3 id="ProxyFactory-Object-target"><a href="#ProxyFactory-Object-target" class="headerlink" title="ProxyFactory(Object target)"></a><code>ProxyFactory(Object target)</code></h3><p>通过此方法将根据目标对象创建<code>ProxyFactory</code>对象，并且会代理目标对象所有的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">  setTarget(target);</span><br><span class="line">  setInterfaces(ClassUtils.getAllInterfaces(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ProxyFactory-Class-lt-gt-proxyInterfaces"><a href="#ProxyFactory-Class-lt-gt-proxyInterfaces" class="headerlink" title="ProxyFactory(Class&lt;?&gt;... proxyInterfaces)"></a><code>ProxyFactory(Class&lt;?&gt;... proxyInterfaces)</code></h3><p>传入代理接口数组构造<code>ProxyFactory</code>对象，这种情况下只设置了代理接口，则必须手动设置通知，否则在创建代理的过程中无法通过校验。</p><p>目前创建的Jdk动态代理和cglib代理都判断了通知和目标对象不能同时为空。</p><p>Jdk代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">  Assert.notNull(config, <span class="string">&quot;AdvisedSupport must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (config.getAdvisors().length == <span class="number">0</span> &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;No advisors and no TargetSource specified&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.advised = config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cglib代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CglibAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">  Assert.notNull(config, <span class="string">&quot;AdvisedSupport must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (config.getAdvisors().length == <span class="number">0</span> &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;No advisors and no TargetSource specified&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.advised = config;</span><br><span class="line">  <span class="keyword">this</span>.advisedDispatcher = <span class="keyword">new</span> AdvisedDispatcher(<span class="keyword">this</span>.advised);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设置了拦截器，由于在最终调用目标对象方法时，没有判断目标对象是否为空，所以会报空指针异常。</p><h3 id="ProxyFactory-Class-lt-gt-proxyInterface-Interceptor-interceptor"><a href="#ProxyFactory-Class-lt-gt-proxyInterface-Interceptor-interceptor" class="headerlink" title="ProxyFactory(Class&lt;?&gt; proxyInterface, Interceptor interceptor)"></a><code>ProxyFactory(Class&lt;?&gt; proxyInterface, Interceptor interceptor)</code></h3><p>此方法同时设置代理接口和拦截器。由于没有目标对象，也会出现上面的空指针异常情况。针对只有一个拦截器的情况下，此方法创建代理对象比较方法。</p><h3 id="ProxyFactory-Class-lt-gt-proxyInterface-TargetSource-targetSource"><a href="#ProxyFactory-Class-lt-gt-proxyInterface-TargetSource-targetSource" class="headerlink" title="ProxyFactory(Class&lt;?&gt; proxyInterface, TargetSource targetSource)"></a><code>ProxyFactory(Class&lt;?&gt; proxyInterface, TargetSource targetSource)</code></h3><p>此方法根据代理接口和<code>TargetSource</code>创建<code>ProxyFactory</code>对象。</p><h2 id="getProxy方法"><a href="#getProxy方法" class="headerlink" title="getProxy方法"></a><code>getProxy</code>方法</h2><p>通过此方法将会获取最终的代理对象。</p><p>通过构造函数创建<code>ProxyFactory</code>对象后，还需要根据实际情况设置目标对象、代理接口以及通知，然后再调用<code>getProxy</code>方法获取代理对象。</p><h3 id="Object-getProxy-无参方法"><a href="#Object-getProxy-无参方法" class="headerlink" title="Object getProxy()无参方法"></a><code>Object getProxy()</code>无参方法</h3><p>根据<code>ProxyFactory</code>的设置创建代理对象。可以重复调用此方法，如果添加或删除接口，添加或者删除拦截器，效果会有所不同。由于多次调用使用的是同一个<code>ProxyFactory</code>对象，只是配置不同，在调用代理对象的方法时，会影响到代理对象的执行过程。</p><p>此方法使用默认类加载器来创建代理，一般是线程上下文类加载器。</p><h3 id="Object-getProxy-ClassLoader-classLoader"><a href="#Object-getProxy-ClassLoader-classLoader" class="headerlink" title="Object getProxy(ClassLoader classLoader)"></a><code>Object getProxy(ClassLoader classLoader)</code></h3><p>跟上面的方法类似，只是使用指定的类加载器。</p><h3 id="static-lt-T-gt-T-getProxy-Class-lt-T-gt-proxyInterface-Interceptor-interceptor"><a href="#static-lt-T-gt-T-getProxy-Class-lt-T-gt-proxyInterface-Interceptor-interceptor" class="headerlink" title="static &lt;T&gt; T getProxy(Class&lt;T&gt; proxyInterface, Interceptor interceptor)"></a><code>static &lt;T&gt; T getProxy(Class&lt;T&gt; proxyInterface, Interceptor interceptor)</code></h3><p>此方法是静态方法，根据指定的代理接口和拦截器创建代理。内部使用<code>ProxyFactory(Class&lt;?&gt; proxyInterface, Interceptor interceptor)</code>方法创建<code>ProxyFactory</code>对象之后再调用无参<code>getProxy()</code>方法。</p><h3 id="static-lt-T-gt-T-getProxy-Class-lt-T-gt-proxyInterface-TargetSource-targetSource"><a href="#static-lt-T-gt-T-getProxy-Class-lt-T-gt-proxyInterface-TargetSource-targetSource" class="headerlink" title="static &lt;T&gt; T getProxy(Class&lt;T&gt; proxyInterface, TargetSource targetSource)"></a><code>static &lt;T&gt; T getProxy(Class&lt;T&gt; proxyInterface, TargetSource targetSource)</code></h3><p>此静态方法为指定的<code>TargetSource</code>创建代理，该代理会实现指定的接口。方法内部使用<code>new ProxyFactory(proxyInterface, targetSource)</code>方法创建<code>ProxyFactory</code>对象之后再调用无参<code>getProxy()</code>方法。</p><h3 id="static-Object-getProxy-TargetSource-targetSource"><a href="#static-Object-getProxy-TargetSource-targetSource" class="headerlink" title="static Object getProxy(TargetSource targetSource)"></a><code>static Object getProxy(TargetSource targetSource)</code></h3><p>该静态方法为指定的<code>TargetSource</code>创建一个代理，扩展<code>TargetSource</code>的目标类。由于没有指定接口，所以方法内部会设置<code>proxyTargetClass</code>为<code>true</code>，通过cglib来创建目标对象的子类。</p><p>以下代码用来判断是否用jdk代理还是cglib来生成代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">  Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">  <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">                                 <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Spring, AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP基本用法</title>
      <link href="/post/fc6f/"/>
      <url>/post/fc6f/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-AOP-用法"><a href="#Spring-AOP-用法" class="headerlink" title="Spring AOP 用法"></a>Spring AOP 用法</h1><p>前面讲到了AOP相关的思想和基本概念，实现方式可分为静态编绎型和代理两种方式。前者的代表作是<code>AspectJ</code>，在编绎阶段将通知织入到class中，需要用到特殊的工具来编绎。<code>AspectJ</code>定义了一种表达式语言来定义连接点，Spring 默认是基于JDK动态代理来实现AOP，并且只支持方法作为切入点。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>Spring 自己实现了一套AOP，还部分支持<code>AspectJ</code>。两种方式都可以使用编程式和xml配置方式。</p><p>使用Spring AOP大概有以下几种方式：</p><ol><li>在xml中配置<code>ProxyFactoryBean</code>，显式地设置advisors, advice, target等，或以编程方式使用<code>ProxyFactory</code>。Spring支持通过 jdk 动态代理和 cglib 来生成代理对象。前者只支持接口，后者可以支持类。还可以以编程形式配置<code>AspectJProxyFactory</code>, 该类基于apsectj语法来配置切面。</li><li>配置<code>AutoProxyCreator</code>，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象</li><li>通过<code>&lt;aop:config&gt;</code>来配置，使用<code>AspectJ</code>的语法来定义切入点</li><li>通过<code>&lt;aop:aspectj-autoproxy&gt;</code>来配置，使用<code>AspectJ</code>的注解来标识通知及切入点</li></ol><h3 id="xml-配置-ProxyFactoryBean"><a href="#xml-配置-ProxyFactoryBean" class="headerlink" title="xml 配置 ProxyFactoryBean"></a>xml 配置 ProxyFactoryBean</h3><ol><li><p>创建通知</p><p>这里以前置通知类型为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBeforeAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method advice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建业务代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBusinessService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessService</span> <span class="keyword">implements</span> <span class="title">IBusinessService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置代理类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--业务实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.sexycode.spring.study.chapter5.BusinessService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--通知实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.sexycode.spring.study.chapter5.BusinessBeforeAdvice&quot;</span> <span class="attr">id</span>=<span class="string">&quot;userBeforeAdvice&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span> <span class="attr">id</span>=<span class="string">&quot;businessProxy&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--代理的接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interfaces&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cn.sexycode.spring.study.chapter5.IBusinessService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--目标对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;businessService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--要应用的通知实现--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptorNames&quot;</span> <span class="attr">value</span>=<span class="string">&quot;userBeforeAdvice&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>配置需要代理的接口，配置了此属性，将会使用Jdk 动态代理生成代理对象</li><li>需要代理的目标对象，即我们的业务对象</li><li>使用的通知bean名称<code>interceptorNames</code>，是个数组。如果不配置<code>targetName</code>/<code>target</code>/<code>targetSource</code>属性，数组的最后一个可以是目标对象的名字。这个属性还支持通配符<code>*</code>，如：<code>userBeforeAdvice*</code>，代表所有以<code>userBeforeAdvice</code>开头的bean都会成为通知。但是如果目标对象的名字出现在这个属性时，通配符不能是最后一个。</li></ol><p>经过上面的配置，已经将通知织入到代理对象中了，下面直接获取生成的代理对象，再调用方法即可以看到织入的结果。</p></li><li><p>获取代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">xmlBeanDefinitionReader.loadBeanDefinitions(<span class="string">&quot;AopXmlSimpleConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获取代理对象</span></span><br><span class="line">((IBusinessService) beanFactory.getBean(<span class="string">&quot;businessProxy&quot;</span>)).sayHello();</span><br></pre></td></tr></table></figure><p>这里要注意的是要直接获取代理对象，然后转成我们的接口类型，再调用方法即可。</p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;打印的是通知的内容</span><br><span class="line">Before method advice</span><br><span class="line">&#x2F;&#x2F;业务代码</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></li></ol><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>这种方式其实跟《AOP的基本概念》一文开头描述的思想类似，为每个业务实现类创建代理对象，只不过这里的织入时机已经可以配置了。</p><p>那么Spring 是如何生成代理对象的？又是如何织入通知的？</p><p>可以想象一下，在获取bean的时候，初始化所有的通知，并创建代理类，在调用代理对象的方法时调用通知的代码和原对象的方法。</p><p>看一下该类的类图：</p><p><img src="/post/fc6f/ProxyFactoryBean.png" alt="ProxyFactoryBean"></p><p><code>ProxyFactoryBean</code>类实现了<code>FactoryBean</code>接口。也就是说最终会通过<code>getObject</code>方法返回生成的对象。<code>ProxyConfig</code>类提供了一些代理对象的配置项，可以确保所有的代理创建器都具有一致的属性。<code>AdvisedSupport</code>类管理通知和切面，不提供实际的创建代理的方法，由它的子类去实现。<code>ProxyCreatorSupport</code>是代理工厂的基类，提供创建代理对象的公共操作，内部使用可配置的<code>AopProxyFactory</code>代理工厂来创建代理，默认的<code>AopProxyFactory</code>工厂实现根据情况创建<code>JdkDynamicAopProxy</code>或者<code>JdkDynamicAopProxy</code>代理。</p><h3 id="getObject-方法"><a href="#getObject-方法" class="headerlink" title="getObject 方法"></a>getObject 方法</h3><p>前面讲到了，当Spring初始化此bean时，最终会调用<code>getObject</code>方法返回实际的bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">initializeAdvisorChain();</span><br><span class="line"><span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line"><span class="keyword">return</span> getSingletonInstance();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Using non-singleton proxies with singleton targets is often undesirable. &quot;</span> +</span><br><span class="line"><span class="string">&quot;Enable prototype proxies by setting the &#x27;targetName&#x27; property.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newPrototypeInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化通知链"><a href="#初始化通知链" class="headerlink" title="初始化通知链"></a>初始化通知链</h4><p>第一步就是初始化切面链，配置此代理时，可以应用多个切面，所以最终会形成一个调用链。如果此bean是单例的，则会创建单例对象。</p><p>初始化方法<code>initializeAdvisorChain()</code>是一个线程同步的方法，方法声明上加了<code>synchronized</code>关键字。</p><p>初始化切面链时，如果之前已经初始化过，将不会再次初始化。初始化时会遍历所有配置的通知，如果是通配符<code>*</code>，则会根据类型<code>Advisor</code>和<code>Interceptor</code>查找所有的bean，并排序，再判断bean的名称是否匹配前缀，是则认为是一个通知，会将其加入到通知链中。如果不是通配符，再判断该bean或者此代理工厂bean是否单例，是的话则会在<code>BeanFactory</code>中查找该bean，加入到链中。不是单例则需要将该通知先记录下来，等到最后创建代理对象时，再创建该通知对象。这里为什么需要这样判断是不是单例？这样可以避免在初始化通知链时创建原型对象，这个时候还不需要初化原型通知对象，在最终使用到此对象时再初始化即可。</p><p>在添加通知时，由于<code>intercepterNames</code>中即可以是<code>Advice</code>也可以是<code>Advisor</code>，或者是其他自定义的通知类型（实现<code>Advice</code>接口），所以需要将通知转换成<code>Advisor</code>(Spring封装了通知以及通知的适用范围)。如果本身就是<code>Advisor</code>，则不需要转换。如果是<code>Advice</code>，并且是支持通知类型，则转换成<code>DefaultPointcutAdvisor</code>。转换时通过适配器<code>AdvisorAdapter</code>来判断是否支持该通知。<code>ProxyFactoryBean</code>默认使用<code>GlobalAdvisorAdapterRegistry.getInstance()</code>方式获取到默认的适配器注册器，可以替换该注册器，添加自定义的适配器。也可以注册<code>AdvisorAdapterRegistrationManager</code>，然后注册实现<code>AdvisorAdapter</code>的bean，该后处理器会自动注册自定义的适配器。Spring 默认注册了<code>MethodBeforeAdviceAdapter</code>、<code>AfterReturningAdviceAdapter</code>、<code>ThrowsAdviceAdapter</code>三个适配器。通过适配器最终可以将基于<code>AspectJ</code>的通知转换成Spring 的<code>Advisor</code>，达到设计上的统一。</p><h4 id="单例代理对象"><a href="#单例代理对象" class="headerlink" title="单例代理对象"></a>单例代理对象</h4><p>到这一步，初始化通知链完毕，根据<code>isSingleton()</code>方法决定是返回单例对象还是原型对象。需要返回单例代理对象时，则需要在这一步中创建。</p><p>如果之前已经创建过了，则直接返回缓存的单例对象。</p><p>如果没有创建过，则需要创建代理对象。</p><ol><li><p>刷新目标对象，从<code>BeanFactory</code>中获取到实际的目标对象。并封装成<code>TargetSource</code>。</p></li><li><p>在自动检测接口模式（未指定代理接口里默认为<code>true</code>，如果没有指定接口时，将此值设置为<code>false</code>来使用cglib创建代理对象）、代理接口未指定、不是代理目标对象的情况下，将获取到目标对象所有的接口，并代理所有接口。</p></li><li><p>准备工作做完了，接下来就是创建代理对象了。创建之前先激活<code>AdvisedSupportListener</code>监听器。这里由默认的<code>AopProxyFactory</code>工厂指定了两种创建代理对象的方式，根据情况使用jdk动态代理方式还是cglib方式。满足以下情况时：将使用cglib代理。1). 优化代理（比如说在代理对象创建之后，再更改通知不生效，默认为<code>false</code>），2). 直接代理目标对象，3). 用户没有指定代理接口。在上面提到的3点中，如果代理目标类是接口，或者是jdk代理，则还是会使用jdk代理方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">                                         <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>确定代理方式之后，就是使用对应的方式去创建代理对象了。jdk方式使用<code>JdkDynamicAopProxy</code>对象来最终生成代理对象，cglib使用<code>ObjenesisCglibAopProxy</code>对象。</p></li></ol><h4 id="JDK代理对象"><a href="#JDK代理对象" class="headerlink" title="JDK代理对象"></a>JDK代理对象</h4><p>使用jdk代理生成代理对象时，会先确定完整的接口。在原有接口基础上会新加入<code>SpringProxy</code>，<code>Advised</code>，<code>DecoratingProxy</code>接口。创建代理时会将自己作为<code>InvocationHandler</code>传进去，<code>JdkDynamicAopProxy</code>实现了<code>InvocationHandler</code>接口，最终调用代理对象的方法时会执行该接口的方法。</p><h5 id="invoke方法"><a href="#invoke方法" class="headerlink" title="invoke方法"></a>invoke方法</h5><p><code>JdkDynamicAopProxy</code>实现了<code>InvocationHandler</code>接口，也就是说当代理对象的方法被调用时，<code>JdkDynamicAopProxy</code>的<code>invoke</code>方法将会被调用，从而通过<code>invoke</code>的实现逻辑完成对目标方法调用的拦截。</p><p>主要的逻辑是<code>equals</code>，<code>hashCode</code>方法的判断，<code>Advised</code>和<code>DecoratingProxy</code>接口的判断。这些方法需要特殊处理，如果目标类实现了<code>equals</code>，<code>hashCode</code>方法，那么需要去比较原始对象，否则，直接调用代理对象的<code>equals</code>和<code>hashCode</code>方法就可以了。。</p><p>接下来需要根据当前调用的方法获取到对应的拦截器链，如果拦截器链为空，则表示当前方法不需要拦截，直接调用目标对象的方法就可以了。如果不为空，则表示需要拦截，生成<code>ReflectiveMethodInvocation</code>对象，该对象封装了拦截器的调用过程。</p><h6 id="获取拦截器链"><a href="#获取拦截器链" class="headerlink" title="获取拦截器链"></a>获取拦截器链</h6><p>获取调用方法的拦截器链，目标对象所有的通知，之前已经初始化过了，但是每个方法所需要的不一样，所以这一步还需要根据方法进行过滤。具体逻辑在<code>AdvisedSupport.getInterceptorsAndDynamicInterceptionAdvice()</code>方法中，会将结果缓存下来下次直接使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    MethodCacheKey cacheKey = <span class="keyword">new</span> MethodCacheKey(method);</span><br><span class="line">    List&lt;Object&gt; cached = <span class="keyword">this</span>.methodCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cached = <span class="keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">            <span class="keyword">this</span>, method, targetClass);</span><br><span class="line">        <span class="keyword">this</span>.methodCache.put(cacheKey, cached);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AdvisedSupport</code>通过<code>AdvisorChainFactory</code>(默认使用<code>DefaultAdvisorChainFactory</code>)创建一个拦截链，针对每个已经注册的<code>Advisor</code>，如果是<code>PointcutAdvisor</code>，获取到对应的<code>Pointcut</code>，再得到其<code>ClassFilter</code>，检查是否匹配目标类型，类型检查通过之后再得到<code>MethodMatcher</code>进行方法匹配。<em>在获取拦截链阶段，不过滤方法参数</em>。如果<code>MethodMatcher</code>是运行时的(也就是要比较参数的)，则包装成<code>InterceptorAndDynamicMethodMatcher</code>，其内部包含当前<code>MethodMatcher</code>，在<code>ReflectiveMethodInvocation</code>内方法调用时根据方法调用时的参数再判断该拦截器是否可以拦截此方法。</p><p>如果是引入<code>IntroductionAdvisor</code>，则只需要过滤class即可。</p><p>符合要求的通知会通过<code>AdvisorAdapter</code>转换成方法拦截器<code>MethodInterceptor</code>。</p><p>不同的通知类型有相应的拦截器。比如<code>MethodBeforeAdvice</code>有<code>MethodBeforeAdviceInterceptor</code>与其对应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">BeforeAdvice</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MethodBeforeAdvice advice;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new MethodBeforeAdviceInterceptor for the given advice.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> advice the MethodBeforeAdvice to wrap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MethodBeforeAdviceInterceptor</span><span class="params">(MethodBeforeAdvice advice)</span> </span>&#123;</span><br><span class="line">Assert.notNull(advice, <span class="string">&quot;Advice must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>.advice = advice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line"><span class="keyword">return</span> mi.proceed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用该拦截器的invoke方法时，会先调用其持有的advice的before方法，也就是我们的通知方法，然后再继续<code>MethodInvocation</code>的方法调用，该设计是常见的链式调用方式。</p><p>同理<code>AfterReturningAdvice</code>对应的是<code>AfterReturningAdviceInterceptor</code>，<code>ThrowsAdvice</code>对应<code>ThrowsAdviceInterceptor</code>。</p><h6 id="ReflectiveMethodInvocation-执行拦截器链"><a href="#ReflectiveMethodInvocation-执行拦截器链" class="headerlink" title="ReflectiveMethodInvocation 执行拦截器链"></a>ReflectiveMethodInvocation 执行拦截器链</h6><p>在上一步获取拦截器链之后，构造出<code>ReflectiveMethodInvocation </code>对象，封装了代理，目标对象，方法，以及拦截器链，然后调用该对象的<code>proceed</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//We start with an index of -1 and increment early.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object interceptorOrInterceptionAdvice =</span><br><span class="line">        <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">        <span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">        <span class="comment">// been evaluated and found to match.</span></span><br><span class="line">        InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">            (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dynamic matching failed.</span></span><br><span class="line">            <span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">            <span class="keyword">return</span> proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">        <span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReflectiveMethodInvocation</code>维护一个当前执行拦截器的下标值<code>currentInterceptorIndex</code>，从<code>-1</code>开始，如果<strong>等于</strong>拦截器链的<strong>长度-1</strong>，则表示拦截器已经执行完了，调用目标对象的方法。</p><p>如果不相等，则会调用拦截器的方法。</p><ol><li>获取到第一个拦截器，并将<code>currentInterceptorIndex</code>+1。</li><li>如果拦截器是<code>InterceptorAndDynamicMethodMatcher</code>类型，则需要进行参数匹配，匹配上则调用该拦截器的方法。否则调用<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法，这里是递归调用。最终结束条件就是下标值是拦截器链的<strong>长度-1</strong>。</li><li>如果是普通的<code>MethodInterceptor</code>的，则调用<code>invoke</code>方法，并将自身传进去。</li></ol><p>整个调用过程，其实在<code>Filter</code>的使用过程中，我们就已经接触了。在每个过滤器的执行过程中，将链维护对象传递到每个过滤器中，执行完成之后再调用链对象的方法，链对象的方法会继续调用下一个过滤器。如果想终止链的调用，可以不调用链的方法。</p><h4 id="CGLIB生成的代理对象"><a href="#CGLIB生成的代理对象" class="headerlink" title="CGLIB生成的代理对象"></a>CGLIB生成的代理对象</h4><p>使用<code>ObjenesisCglibAopProxy</code>对象来生成cglib代理对象时。<code>ObjenesisCglibAopProxy</code>继承了<code>CglibAopProxy</code>重写了<code>createProxyClassAndInstance()</code>方法，支持不需要通过构造器来实例化对象的功能。</p><p>cglib生成的代理对象实现aop功能，主要需要设置callback。</p><p>可以看一下<code>getProxy</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating CGLIB proxy: &quot;</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">        Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">&quot;Target class must be available for creating a CGLIB proxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">            proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">            Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">                <span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">        validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">        Enhancer enhancer = createEnhancer();</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            enhancer.setClassLoader(classLoader);</span><br><span class="line">            <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">                ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">                enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">        enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">        enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">        enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">        Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">        Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">            types[x] = callbacks[x].getClass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">        enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">            <span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">        enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">        <span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Could not generate CGLIB subclass of &quot;</span> + <span class="keyword">this</span>.advised.getTargetClass() +</span><br><span class="line">                                     <span class="string">&quot;: Common causes of this problem include using a final class or a non-visible class&quot;</span>,</span><br><span class="line">                                     ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Unexpected AOP exception&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点就在<code>getCallbacks</code>方法里，将<code>AdvisedSupport</code>对象封装成<code>DynamicAdvisedInterceptor</code>。另外加了一些性能优化相关的逻辑。<code>equals</code>和<code>hashCode</code>相关的拦截器，这两个方法是需要特殊处理的。以及是否暴露当前代理对象到当前线程中，可以设置<code>exposeProxy</code>属性为<code>true</code>，然后通过<code>AopContext.currentProxy()</code>方法取得当前代理对象。</p><p>这里Spring根据用途将callback拆成了多个:<code>aopInterceptor</code>、<code>EqualsInterceptor</code>、<code>HashCodeInterceptor</code>等，然后为<code>enhancer</code>设置<code>CallbackFilter</code>决定哪些方法使用对应的callback，每个callback对应一个固定值，<code>CallbackFilter</code>返回具体的方法所对应的值。</p><p>重点看看<code>DynamicAdvisedInterceptor</code>，也就是需要应用通知的拦截器。</p><p>该类的逻辑跟jdk代理的类似，将拦截器链封装成一个<code>CglibMethodInvocation</code>对象，这个类继承自<code>ReflectiveMethodInvocation</code>类，该类的逻辑与父类没有什么大的差别。</p><h4 id="原型代理对象"><a href="#原型代理对象" class="headerlink" title="原型代理对象"></a>原型代理对象</h4><p>当<code>ProxyFactoryBean</code>不是单例时，则需要在每次获取时创建代理对象，创建的过程与单例模式区别不大，主要是每次都需要复制一份配置，通过复制出的配置再去创建代理对象，也就是说每个代理对象拥有的配置都是独立的。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>创建代理的过程总结如下图：</p><p><img src="/post/fc6f/ProxyFactoryBean%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%A8%8B.png" alt="ProxyFactoryBean创建代理对象流程"></p><p>执行过程如下：</p><p><img src="/post/fc6f/%E4%BB%A3%E7%90%86%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="调用过程"></p><h2 id="代理属性配置"><a href="#代理属性配置" class="headerlink" title="代理属性配置"></a>代理属性配置</h2><p>在前面提到了<code>ProxyFactoryBean</code>顶层继承了<code>ProxyConfig</code>类，该类提供了一些基础属性配置。下面看一下具体有哪些属性以及其作用。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>proxyTargetClass</td><td>是否直接代理目标类，而不只是代理特定的接口。默认设置是<code>false</code>。将其设置为<code>true</code>，以强制对目标类进行代理。如果目标类是接口，则将为给定接口创建JDK代理。如果目标类是任何其他类，那么将为给定的类创建一个CGLIB代理。</td></tr><tr><td>optimize</td><td>代理是否应该执行积极的优化。“积极的优化”的确切含义在不同的代理之间会有所不同，默认设置是<code>false</code>。例如，优化通常意味着在创建代理之后将不能更改通知。由于这个原因，优化在默认情况下是禁用的。</td></tr><tr><td>opaque</td><td>是否应阻止将此配置创建的代理转换为<code>Advised</code>来查询代理状态。默认值是<code>false</code>，这意味着任何AOP代理都可以被强制转换为<code>Advised</code>的，因为会给代理对象加上<code>Advised</code>接口。</td></tr><tr><td>exposeProxy</td><td>设置AOP框架是否应该将代理公开为ThreadLocal，以便通过AopContext类获取代理。如果<code>Advised</code>的对象需要调用自己另一个被拦截的方法时可以使用这种方式。(如果使用<code>this</code>，将不会拦截调用)。默认为“false”，以避免不必要的拦截。尽量不使用此种方式，因为依赖于Spring Aop。</td></tr><tr><td>frozen</td><td>设置这个配置是否应该被冻结。当一个配置被冻结时，无法更改通知。这对于性能优化非常有用，当我们不希望调用者能够在强制转换为<code>Advised</code>后操作配置时也非常有用。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Spring, AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP的基本概念</title>
      <link href="/post/35c5/"/>
      <url>/post/35c5/</url>
      
        <content type="html"><![CDATA[<p>任何技术的出现都是为了解决某类问题。</p><h1 id="AOP是什么？"><a href="#AOP是什么？" class="headerlink" title="AOP是什么？"></a>AOP是什么？</h1><p>AOP出现以前，代码逻辑都是从上到下编写。当我们需要在原有主逻辑不变的情况下，修改一些无关逻辑时，比如我们需要在每个方法中打印出入参，这时我们需要修改每个方法，然后加上打印日志的代码。这无疑是非常消耗精力的事情，而且这样的代码也不好维护，更不符合设计原则。</p><p>有没有更好的方式可以达成这样的目的？</p><p>我们可不可以在不修改原有逻辑的情况下将需要新增的代码插入到原有的代码中？</p><p>有的。我们可以创建原有对象的代理，将新增的代码写在代码对象的方法里，这样我们就可以不用修改原有对象的方法了。但是，方法这么多，难道我们要新增N 个代理对象吗？当然不是。我们有字节码工具，可以通过代码来为每个对象生成代理对象。</p><p>这样的局限性也很大。如果要在原有方法调用前插入日志需要新增代理对象，在调用后插入日志又要新增代理对象。随着需要插入的位置变多，我们就要创建更多的代理对象。</p><p>我们也可以通过在方法调用之间增加过滤器的方式，就像<code>Servlet</code>模式中的<code>Filter</code>一样。但是要给每个方法添加过滤器，显然不现实。</p><p>有没有一种更灵活的方式可以让我们控制插入的时机？</p><p>有。</p><p>AOP（Aspect Oriented Programming）,面向切面编程。通过预编绎和运行期动态代理可以在不修改源代码的给程序添加功能。</p><p>在面向对象的世界里，我们将业务功能自顶而下地抽象为一个个的类，但是有一些功能频繁地出现在某些类中，从设计角度讲，这些功能不应该出现在这些类中，这时我们通过AOP技术将这些无关的功能抽象成切面，然后再指定这些功能往业务功能中织入的规则，最终整合到我们的系统中。</p><h2 id="AOP-相关的概念"><a href="#AOP-相关的概念" class="headerlink" title="AOP 相关的概念"></a>AOP 相关的概念</h2><p>AOP本身只是一种思想，并不涉及到具体实现。为了解决上述问题，AOP引入了相关的基本概念。</p><h3 id="Join-Point"><a href="#Join-Point" class="headerlink" title="Join Point"></a>Join Point</h3><p>连接点，表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等。也就是我们要插入代码的地方。</p><h3 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h3><p>连接点的集合。用来描述连接点。如通过通配符、正则表达式等语法来定义连接点。实际执行时代码是插入到某个具体的连接点。</p><h3 id="Target-Object"><a href="#Target-Object" class="headerlink" title="Target Object"></a>Target Object</h3><p>将被织入通知的对象。也被称作被通知对象。</p><h3 id="AOP-proxy"><a href="#AOP-proxy" class="headerlink" title="AOP proxy"></a>AOP proxy</h3><p>AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</p><h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><p>定义具体要插入的内容，以及在连接点插入的时机，通过<code>before</code>、<code>after</code>等语义关键词表示。</p><h4 id="插入时机"><a href="#插入时机" class="headerlink" title="插入时机"></a>插入时机</h4><p>也可以理解为通知的类型。Spring中可以分为以下几种：</p><ol><li><p><code>Before</code></p><p>前置通知，在连接点前调用。</p></li><li><p><code>After</code></p><p>后置通知，在连接点后调用。</p></li><li><p><code>AfterReturning</code></p><p>返回通知，在连接点方法执行并正常返回后调用</p></li><li><p><code>AfterThrowing</code></p><p>异常通知，当连接点方法异常时调用</p></li><li><p><code>Around</code></p><p>环绕通知</p></li></ol><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>引入。添加方法或字段到被通知的类。 Spring允许引入新的接口或者字段到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。</p><h3 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h3><p>切面。连接点，切点，通知的载体。由这三者组合起来，才能称为一个完整的切面。</p><p>面向切面编程，也即是将我们想要新增的不影响主逻辑的代码抽出，并将其插入到原有目标代码的过程。</p><h1 id="AOP应用场景"><a href="#AOP应用场景" class="headerlink" title="AOP应用场景"></a>AOP应用场景</h1><p>在Spring中应用最广泛地当属事务管理。将事务控制抽象出切面，交由Spring IOC容器帮我们织入到目标对象中，并管理这些目标对象。想象一下如果没有AOP，那我们需要频繁地开启、提交、回滚事务。</p><p>还有日志记录，权限验证，链路追踪等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring, AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义Scope</title>
      <link href="/post/fe03/"/>
      <url>/post/fe03/</url>
      
        <content type="html"><![CDATA[<h1 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h1><p>所谓生命周期，即是Bean何时创建，何时生存，何时销毁。也即Bean 存在的范围。更直白点儿就是Bean的作用范围，有点儿<em>变量</em>的意味。</p><p>Spring 内置了<code>singleton</code>、<code>prototype</code>两种<code>Scope</code>，Bean 默认为<code>singleton</code>，在Spring IOC 容器中，只会创建一个，并将其缓存起来。</p><p><code>prototype</code>作用域部署的bean，每一次请求（将其注入到另一个bean中，或者以程序的方式调用容器的<code>getBean()</code>方法）都会产生一个新的bean实例，相当与一个new的操作。对于<code>prototype</code>作用域的bean，有一点非常重要，那就是Spring不能对一个<code>prototype </code>bean的整个生命周期负责，容器在初始化、配置、装饰或者是装配完一个<code>prototype</code>实例后，将它交给客户端，随后就对该<code>prototype</code>实例不闻不问了。不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法，而对<code>prototype</code>而言，任何配置好的析构回调方法都将不会被调用(<code>destory-method</code>不会被调用)，因为在注册为<code>DisposableBean</code>时将<code>prototype</code>排除在外。 清除<code>prototype</code>作用域的对象并释放任何<code>prototype</code> bean所持有的昂贵资源，都是客户端代码的职责。让Spring 容器释放被<code>singleton</code>作用域 bean 占用资源的一种可行方式是，通过使用 bean的后置处理器，该处理器持有要被清除的bean的引用。</p><p>针对Web环境，Spring又增加了<code>session</code>、<code>request</code>、<code>global session</code>三种专用于Web应用程序上下文的<code>Scope</code>。</p><h2 id="Scope接口"><a href="#Scope接口" class="headerlink" title="Scope接口"></a><code>Scope</code>接口</h2><p>有时候我们还需要特殊的作用域，这时我们就可以实现该接口来达到我们的目的。上面提到的web环境中的三种也是基于此接口来实现的。</p><p>此接口是<code>ConfigurableBeanFactory</code>使用的策略接口，表示用于保存bean实例的作用范围。可以用来扩展<code>BeanFactory</code>的标准作用域<code>singleton</code>和<code>prototype</code>实现自定义作用域。</p><p>虽然该 SPI 接口主要用于扩展web环境中的Bean 作用范围，它也是完全通用的：提供了从任何底层存储机制(如HTTP会话或自定义会话机制)获取和设置对象的能力。传递到该类的<code>get</code>和<code>remove</code>方法中的名称将标识当前作用域中的目标对象。</p><p><code>Scope</code>实现类应该是线程安全的。如果需要的话，一个<code>Scope</code>实例可以供多个bean工厂同时使用(除非显式地希望知道所包含的bean工厂)，并且任意数量的线程可以从任意数量的工厂并发地访问该作用域。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><p>Object get(String name, ObjectFactory&lt;?&gt; objectFactory)：从此<code>Scope</code>返回具有给定名称的对象，如果没有找到，则通过<code>ObjectFactory#getObject()</code>创建。</p><p>这是<code>Scope</code>的核心操作，也是惟一绝对必需的操作。</p></li><li><p>Object remove(String name)：从<code>Scope</code>中删除该名称的对象。如果没有找到对象，则返回<code>null</code>；否则返回已删除的对象。</p><p>注意：实现类还应该删除指定对象已注册的销毁回调(如果有的话)。<strong>实际执行回调并销毁移除的对象是调用者的责任</strong>。</p><p>注意：这是一个可选操作。如果实现类不支持显式删除对象，则可能引发<code>UnsupportedOperationException</code>。</p></li><li><p>void registerDestructionCallback(String name, Runnable callback)：注册一个回调函数，在范围内指定对象被销毁时执行(或者在整个范围被销毁时，如果该范围没有销毁单个对象，而只是全部终止)。</p><p>注意:这是一个可选操作。此方法将仅对具有实际销毁配置的作用域bean调用(dispose - bean、destroy-method、DestructionAwareBeanPostProcessor)。实现类应该尽量在适当的时候执行给定的回调。如果底层运行时环境根本不支持这样的回调，则必须忽略回调并记录相应的警告。</p><p>请注意，“销毁”指的是作为<code>Scope</code>自身生命周期的一部分的对象的自动销毁，而不是指应用程序显式删除的单个作用域对象。如果一个作用域对象通过<code>remove(String)</code>方法被删除，那么任何已注册的销毁回调也应该被删除，假设被删除的对象将被重用或手动销毁。</p></li><li><p>Object resolveContextualObject(String key)：解析给定键的上下文对象(如果有的话)。如果此Scope支持多个上下文对象，则将每个对象与一个键值相关联，并返回与提供的<em>键</em>参数相对应的对象。否则，约定将返回<em>null</em>。例如: <code>request</code>对应的<code>HttpServletRequest</code>对象。</p><p>此方法提供了通过key来获取对象的功能。在Spring中有一个应用的地方，在自定义Scope的bean中通过<code>@Value</code>注解注入属性时，会通过此方法解析出对应的属性。</p></li><li><p>String getConversationId()：返回当前底层范围的会话ID(如果有的话)。</p><p>会话ID的确切含义取决于底层存储机制。对于<code>session</code>范围的对象，会话ID通常等于(或源自)session ID。</p><p>注意:这不是必须的。如果底层存储机制没有明显的ID时，则可以在此方法的实现中返回<code>null</code>。</p></li></ol><h2 id="自定义Scope"><a href="#自定义Scope" class="headerlink" title="自定义Scope"></a>自定义Scope</h2><p>在<code>AbstractBeanFactory</code>的<code>doGetBean</code>方法中，会判断是否是自定义<code>Scope</code>，并调用<code>get</code>方法。在我们的自定义Scope的get方法中，需要根据我们的场景来返回bean。比如我们要实现线程级别共享的bean，则需要判断当前线程是否存在，不存在就调用<code>ObjectFactory</code>的<code>getObject</code>方法创建bean，否则就返回存在的对象。<code>ObjectFactory</code>负责去创建bean，这个创建的过程跟其他的<code>Scope</code>一致，<code>Scope</code>要做的就是控制何时创建就OK了。</p><p>同时，我们还必须<strong>确保实现是线程安全的，</strong>因为Scope可以同时由多个bean工厂使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">        beforePrototypeCreation(beanName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            afterPrototypeCreation(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                    <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                                    <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                                    ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就以线程级别共享的Bean来创建自定义<code>ThreadScope</code>。</p><h3 id="自定义Scope类：ThreadScope"><a href="#自定义Scope类：ThreadScope" class="headerlink" title="自定义Scope类：ThreadScope"></a>自定义Scope类：<code>ThreadScope</code></h3><h4 id="实现Scope接口"><a href="#实现Scope接口" class="headerlink" title="实现Scope接口"></a>实现Scope接口</h4><p>实现自定义Scope，我们需要实现<code>Scope</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScope</span> <span class="keyword">implements</span> <span class="title">Scope</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="管理Scope中的对象和回调"><a href="#管理Scope中的对象和回调" class="headerlink" title="管理Scope中的对象和回调"></a>管理Scope中的对象和回调</h4><p>实现自定义<code>Scope</code>类时要考虑的第一件事是如何存储和管理作用域对象和销毁回调。</p><p>在此例中，使用<code>ThreadLocal</code>来保存对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用于保存线程变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; objectThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Map&lt;String, Runnable&gt;&gt; callbackThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure><h4 id="实现get方法"><a href="#实现get方法" class="headerlink" title="实现get方法"></a>实现<code>get</code>方法</h4><p>当Spring 容器遇到我们定义的<code>Scope</code>时，会从<code>Scope</code>中获取bean。因此我们需要实现<code>get</code>方法，当要获取的对象不在当前<code>Scope</code>中时，我们需要创建该对象并返回。</p><p>在这个例子中，则是判断当前线程中是否有该对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = Optional.ofNullable(objectThreadLocal.get()).orElse(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">Object o = Optional.ofNullable(map.get(name)).orElse(objectFactory.getObject());</span><br><span class="line">map.put(name,o);</span><br><span class="line">objectThreadLocal.set(map);</span><br><span class="line"><span class="keyword">return</span> o;</span><br></pre></td></tr></table></figure><p>在<code>Scope</code>接口定义的五个方法中，<strong>仅<code>get</code>方法才需要具有</strong>所描述行为<strong>的完整实现</strong>。其他四个方法是可选的，如果它们不需要或不支持功能，则可能引发<em>UnsupportedOperationException</em>。</p><h4 id="注册销毁回调"><a href="#注册销毁回调" class="headerlink" title="注册销毁回调"></a>注册销毁回调</h4><p>我们还需要<code>registerDestructionCallback</code>方法。此方法提供了一个回调，当命名对象被销毁或者<code>Scope</code>本身被销毁时执行此回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable callback)</span> </span>&#123;</span><br><span class="line">    callbackThreadLocal.get().put(name, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从Scope中删除对象"><a href="#从Scope中删除对象" class="headerlink" title="从Scope中删除对象"></a>从Scope中删除对象</h4><p>接下来实现<code>remove</code>方法，该方法从Scope中删除命名对象，并删除其注册的销毁回调，并返回删除的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = objectThreadLocal.get();</span><br><span class="line">Object o = map.remove(name);</span><br><span class="line">callbackThreadLocal.get().remove(name);</span><br><span class="line"><span class="keyword">return</span> o;</span><br></pre></td></tr></table></figure><p>请注意，Spring 并不会帮我们调用remove和执行回调方法，<strong>实际执行回调并销毁移除的对象是调用者的责任</strong>，因为Spring也不知道何时该remove掉对象。</p><h4 id="获取会话ID"><a href="#获取会话ID" class="headerlink" title="获取会话ID"></a>获取会话ID</h4><p>现在实现<code>getConversationId</code>方法。如果Scope支持会话ID的概念，则可以在此处将其返回。否则，约定将返回<em>null</em>：</p><p>此例中不需要会话ID，直接返回<code>null</code>。</p><h4 id="解析上下文对象"><a href="#解析上下文对象" class="headerlink" title="解析上下文对象"></a>解析上下文对象</h4><p>最后实现<code>resolveContextualObject</code>方法。如果范围支持多个上下文对象，则将每个对象与一个键值相关联，并返回与提供的<em>键</em>相对应的对象。否则，约定将返回<em>null</em>。此例中不需要。</p><h4 id="注册自定义Scope"><a href="#注册自定义Scope" class="headerlink" title="注册自定义Scope"></a>注册自定义<code>Scope</code></h4><p>为了使Spring容器知道这个新作用域，可以<strong>通过<code>ConfigurableBeanFactory</code>实例上的<code>registerScope</code>方法对其进行注册</strong>。让我们看一下该方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerScope</span><span class="params">(String scopeName, Scope scope)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数<code>scopeName</code>用于指定唯一标识，第二个参数<code>scope</code>指定具体的实例。</p><p>要拿到<code>ConfigurableBeanFactory</code>我们可以实现<code>BeanFactoryPostProcessor</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        beanFactory.registerScope(ThreadScope.SCOPE_NAME,<span class="keyword">new</span> ThreadScope());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将此<em>ThreadScopeBeanFactoryPostProcessor</em> 注册到Spring容器中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.addBeanFactoryPostProcessor(<span class="keyword">new</span> ThreadScopeBeanFactoryPostProcessor());</span><br></pre></td></tr></table></figure><p>Spring 为我们提供了一个更方便的类：<code>org.springframework.beans.factory.config.CustomScopeConfigurer</code>。</p><p>该类也实现了<code>BeanFactoryPostProcessor</code>接口，增加了两个方法：<code>setScopes(Map&lt;String, Object&gt; scopes)</code>和<code>addScope(String scopeName, Scope scope)</code>，可以更方便注册<code>Scope</code>。</p><p>同样也通过<code>context.addBeanFactoryPostProcessor()</code>方法将<code>CustomScopeConfigurer</code>注册到容器中。</p><p><em>这里手动注册的原因是可以更清楚的知道是如何使用这个<code>BeanFactoryPostProcessor</code>，在平时使用的过程中，只需要在xml中配置，或者使用注解<code>@Bean</code>配置即可</em>。</p><h4 id="使用自定义Scope"><a href="#使用自定义Scope" class="headerlink" title="使用自定义Scope"></a>使用自定义<code>Scope</code></h4><p>现在已经注册了自定义<code>Scope</code>，可以将其应用于我们的任何bean，通过使用`@Scope注解并指定我们的自定义Scope名称。</p><h5 id="定义Bean"><a href="#定义Bean" class="headerlink" title="定义Bean"></a>定义Bean</h5><p>让我们创建一个简单的<em>ScopeBean</em>类，稍后我们将声明这种类型的<code>ThreadScope</code>的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopeBean</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，我们没有在此类上使用类级别的<code>@Component</code>和<code>@Scope</code>批注。</p><h5 id="注册Bean"><a href="#注册Bean" class="headerlink" title="注册Bean"></a>注册Bean</h5><p>注册Bean有很多种方式：xml，<code>@Bean</code>注解。这里展示另一种方式：实现<code>BeanDefinitionRegistryPostProcessor</code>接口。该接口继承自<code>BeanFactoryPostProcessor</code>，在该接口的基础上添加了<code>postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)</code>方法，用来注册Bean。当你不想写配置文件或者配置类的时候，用编程的方式来注册Bean，也不愧是一种有效的方式。</p><p>从这里我们也看到<code>BeanFactoryPostProcessor</code>接口是我们想要扩展Spring时的突破口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopeBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(ScopeBean.class);</span><br><span class="line">        builder.setScope(ThreadScope.SCOPE_NAME);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;scopeBean&quot;</span>, builder.getBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中手动设置Scope为<code>ThreadScope</code>。</p><h4 id="测试自定义Scope"><a href="#测试自定义Scope" class="headerlink" title="测试自定义Scope"></a>测试自定义<code>Scope</code></h4><p>让我们编写一个测试类，通过加载<em>ApplicationContext</em>，并检索我们的<code>ThreadScope</code>的bean ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext();</span><br><span class="line">CustomScopeConfigurer customScopeConfigurer = <span class="keyword">new</span> CustomScopeConfigurer();</span><br><span class="line">customScopeConfigurer.addScope(ThreadScope.SCOPE_NAME, <span class="keyword">new</span> ThreadScope());</span><br><span class="line"><span class="comment">//只通过一种方式来注册scope</span></span><br><span class="line"><span class="comment">//context.addBeanFactoryPostProcessor(customScopeConfigurer);</span></span><br><span class="line">context.addBeanFactoryPostProcessor(<span class="keyword">new</span> ThreadScopeBeanFactoryPostProcessor());</span><br><span class="line"><span class="comment">//注册Bean</span></span><br><span class="line">context.addBeanFactoryPostProcessor(<span class="keyword">new</span> ScopeBeanDefinitionRegistryPostProcessor());</span><br><span class="line">context.refresh();</span><br><span class="line">System.out.println(<span class="string">&quot;同一线程：&quot;</span> + Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span> + context.getBean(ScopeBean.class));</span><br><span class="line">System.out.println(<span class="string">&quot;同一线程：&quot;</span> + Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span> + context.getBean(ScopeBean.class));</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不同线程：&quot;</span> + Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span> + context.getBean(ScopeBean.class));</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不同线程：&quot;</span> + Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span> + context.getBean(ScopeBean.class));</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>分别打印在同一个线程和不同线程中获取的Bean：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">同一线程：main:cn.sexycode.spring.study.chapter4.ScopeBean@e70f13a</span><br><span class="line">同一线程：main:cn.sexycode.spring.study.chapter4.ScopeBean@e70f13a</span><br><span class="line">不同线程：Thread-1:cn.sexycode.spring.study.chapter4.ScopeBean@c4c29bf</span><br><span class="line">不同线程：Thread-0:cn.sexycode.spring.study.chapter4.ScopeBean@3b41834c</span><br></pre></td></tr></table></figure><p>从结果中可以看出，在同一线程中获取的Bean 是同一个，不同线程中获取的Bean不同。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本文中，我们了解了<code>Scope</code>是什么，以及如何在Spring中定义，注册和使用自定义<code>Scope</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Scope </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ObjectFactory与BeanFactory的区别</title>
      <link href="/post/4819/"/>
      <url>/post/4819/</url>
      
        <content type="html"><![CDATA[<h1 id="ObjectFactory-与BeanFactory-的区别"><a href="#ObjectFactory-与BeanFactory-的区别" class="headerlink" title="ObjectFactory 与BeanFactory 的区别"></a>ObjectFactory 与BeanFactory 的区别</h1><p>Spring 体系中有一些跟 Bean获取相关的接口，比如：<code>ObjectFactory</code>、<code>BeanFactory </code>、<code>FactoryBean</code>、<code>ObjectProvider</code>等。有时候会让人不知道该使用哪一个。下面具体看一下区别。</p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>该接口是整个Spring容器的顶层接口，定义了从容器中获取Bean的方法。当我们的应用需要从容器中获取Bean的时候用此接口。在这里我们可以将整个容器看成是一个黑盒，不需要关心它是如何获取的，我们只关心结果。</p><h2 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h2><p>此接口定义了一个简单工厂，是一个函数式接口，可以在调用时返回一个对象实例(可能是共享的或独立的)。</p><p>这个接口类似于<code>FactoryBean</code>，但是后者的实现类通常被定义为<code>BeanFactory</code>中的SPI实例，而该类的实现通常被作为API(通过注入)提供给其他bean。因此，getObject()方法具有不同的异常处理行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回工厂管理的bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the resulting instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of creation errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><p>这个接口定义了创建单个对象的工厂。如果一个bean 实现了这个接口，那么它将被用作要公开的对象的工厂，而不是直接用作将自己公开的bean 实例。</p><p>注意： <strong>实现此接口的bean不能作为普通bean使用。<code>FactoryBean</code>是以bean形式定义的，但是引用该Bean 时是它创建的对象。</strong></p><p><code>FactoryBean</code>支持单例和原型对象，可以根据需要创建对象，也可以在启动时创建对象。<code>SmartFactoryBean</code>接口可以公开更细粒度的元数据。</p><p>这个接口在Spring 框架本身中大量使用，例如在AOP模块 <code>org.springframework.aop.framework.ProxyFactoryBean</code>或<code>org.springframework.jndi.JndiObjectFactoryBean</code>中。</p><p><code>FactoryBean</code>是一个编程规范。实现类不应该依赖于注解驱动的注入或其他反射工具。在启动过程中可能会提前调用<code>getObjectType() </code>和<code>getObject()</code>方法，甚至比后处理器都要早。如果需要访问其他bean，请实现<code>BeanFactoryAware</code>接口并通过编程获取，也就是说在<code>FactoryBean</code>中注解可能还没解析，通过注解注入其他Bean 可能不成功。</p><p>最后，<code>FactoryBean</code>对象会参与bean创建同步过程。通常不需要做内部同步，只需要在<code>FactoryBean</code>本身中进行延迟初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回此工厂对象生产的Bean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回此工厂对象生产的Bean类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 生产的Bean 是否单例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ObjectProvider"><a href="#ObjectProvider" class="headerlink" title="ObjectProvider"></a>ObjectProvider</h2><p>该接口是<code>ObjectFactory</code>的变体形式，专门为注入点设计，允许编程可选性和宽松的非惟一处理。</p><p>从Spring 5.1开始，这个接口扩展了<code>Iterable</code>并提供了流支持。因此，它可以在for循环中使用，提供forEach迭代并允许流访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectProvider</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt;, <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回该工厂管理的对象的实例(可能是共享的或独立的)。可以显式指定构造参数，类似于BeanFactory.getBean(String,Object)方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回该工厂管理的对象的实例(可能是共享的或独立的)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">T <span class="title">getIfAvailable</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回该工厂管理的对象的实例(可能是共享的或独立的)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultSupplier 回调函数，用于在工厂中不存在对象的情况下提供默认对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> T <span class="title">getIfAvailable</span><span class="params">(Supplier&lt;T&gt; defaultSupplier)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">T dependency = getIfAvailable();</span><br><span class="line"><span class="keyword">return</span> (dependency != <span class="keyword">null</span> ? dependency : defaultSupplier.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果存在该实例对象的话，则消费此对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dependencyConsumer 在对象存在的情况下，用来消费此实例的消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of creation errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getIfAvailable()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">ifAvailable</span><span class="params">(Consumer&lt;T&gt; dependencyConsumer)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">T dependency = getIfAvailable();</span><br><span class="line"><span class="keyword">if</span> (dependency != <span class="keyword">null</span>) &#123;</span><br><span class="line">dependencyConsumer.accept(dependency);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回实例，如果没有或者不唯一的话（如有多个的情况下都没有标记为primary）则返回 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of creation errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getObject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">T <span class="title">getIfUnique</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回实例，如果没有或者不唯一的话（如有多个的情况下都没有标记为primary）则返回提供的默认对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of creation errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getIfUnique()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> T <span class="title">getIfUnique</span><span class="params">(Supplier&lt;T&gt; defaultSupplier)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">T dependency = getIfUnique();</span><br><span class="line"><span class="keyword">return</span> (dependency != <span class="keyword">null</span> ? dependency : defaultSupplier.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果唯一的话，则消费此对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dependencyConsumer 如果对象唯一，则使用此消费者消费对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of creation errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getIfAvailable()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">ifUnique</span><span class="params">(Consumer&lt;T&gt; dependencyConsumer)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">T dependency = getIfUnique();</span><br><span class="line"><span class="keyword">if</span> (dependency != <span class="keyword">null</span>) &#123;</span><br><span class="line">dependencyConsumer.accept(dependency);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回所有匹配对象实例的迭代器，不保证特定的顺序(但通常按注册的顺序)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #stream()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> stream().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回所有匹配对象实例上的顺序流，不保证特定的顺序(但通常按注册的顺序)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #iterator()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #orderedStream()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;T&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Multi element access not supported&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回所有匹配对象实例上的顺序流，根据工厂的公共顺序比较器预先排序。</span></span><br><span class="line"><span class="comment">在标准Spring应用程序上下文中，这将根据 org.springframework.core.Ordered 的约定，如果是基于注解的配置，也要考虑 org.springframework.core.annotation.Order 注解，类似于列表/数组类型的多元素注入点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #stream()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.OrderComparator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;T&gt; <span class="title">orderedStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Ordered element access not supported&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="几者的区别"><a href="#几者的区别" class="headerlink" title="几者的区别"></a>几者的区别</h2><p><code>BeanFactory </code>与这几个不在一个层面上，名字比较像，所以容易混淆。<code>BeanFactory </code>是整个大的工厂，有各种各样的生产线，<code>FactoryBean</code>就好比是生产线。</p><p><code>FactoryBean</code> 与<code>ObjectFactory</code>相比，<code>FactoryBean</code> 主要强调自定义创建Bean的过程，通过编程的方式去创建我们的Bean，比配置文件的方式更加的灵活。而且<code>FactoryBean</code> 本身也是一个受Spring 容器管理的Bean，只不过我们更注重它创建出来的Bean。<code>FactoryBean</code> 还是Spring提供出来的SPI接口，用于扩展框架。而<code>ObjectFactory</code>是一个普通的工厂，与Spring 容器Bean的创建关系不大。在Spring 创建Bean的过程中，借助自定义<code>Scope</code> 可以控制创建对象的时机，参见<code>org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean</code>方法对自定义<code>Scope</code>的处理，自定义<code>Scope</code>可以参见<code>org.springframework.web.context.request.AbstractRequestAttributesScope.get</code>方法。</p><p><code>ObjectProvider</code> 扩展自<code>ObjectFactory</code>接口，提供了更多关于Bean的信息的方法，比如是否存在，是否唯一，提供和消费Bean，以及遍历Bean。通过这个接口，我们可以根据这些信息做更灵活的控制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> BeanFactory </tag>
            
            <tag> ObjectFactory </tag>
            
            <tag> FactoryBean </tag>
            
            <tag> ObjectProvider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanWrapper</title>
      <link href="/post/504e/"/>
      <url>/post/504e/</url>
      
        <content type="html"><![CDATA[<h1 id="BeanWrapper"><a href="#BeanWrapper" class="headerlink" title="BeanWrapper"></a>BeanWrapper</h1><h2 id="BeanWrapper是什么"><a href="#BeanWrapper是什么" class="headerlink" title="BeanWrapper是什么"></a>BeanWrapper是什么</h2><p>Spring底层操作Java Bean的核心接口。</p><p>通常不直接使用该接口，而是通过<code>BeanFactory</code>或<code>DataBinder</code>。</p><p>提供分析和操作标准Java Bean的操作: 获取和设置属性值(单个或批量)、获取属性描述以及查询属性的可读性/可写性的能力。</p><p>此接口还支持嵌套属性，允许将子属性上的属性设置为无限深度。</p><p><code>BeanWrapper</code>的<code>extractOldValueForEditor</code>默认值是<code>false</code>，可以避免调用 <code>getter</code>方法。将此选项设置为<code>true</code>，可以向自定义编辑器暴露当前属性值。</p><p>可以看出<code>BeanWrapper</code>是操作Java Bean 的强大利器。</p><h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><p><img src="/post/504e/BeanWrapper%E7%B1%BB%E7%BB%93%E6%9E%84.png" alt="BeanWrapper类结构"></p><p>BeanWrapper 继承自<code>TypeConverter</code>，<code>PropertyEditorRegistry</code>，<code>PropertyAccessor</code>, <code>ConfigurablePropertyAccessor</code>接口。从名称可以看出具备了类型转换，属性编辑器注册，属性访问及配置的功能。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>接下来看看如何使用BeanWrapper来操作我们的Java Bean。</p><p>Spring给我们提供了一个实现类<code>BeanWrapperImpl</code>，我们就用这个类来展示。</p><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><p>Bean对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassRoom classRoom;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassRoom <span class="title">getClassRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classRoom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassRoom</span><span class="params">(ClassRoom classRoom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classRoom = classRoom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了<em>3</em>个属性，看一下使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">BeanWrapper wrapper = <span class="keyword">new</span> BeanWrapperImpl(student);</span><br><span class="line">System.out.println(<span class="string">&quot;展示bean 的属性&quot;</span>);</span><br><span class="line">Arrays.stream(wrapper.getPropertyDescriptors()).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">展示bean 的属性</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=age]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=class]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=classRoom]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=name]</span><br></pre></td></tr></table></figure><p>可以看出将有<code>get</code>方法的属性已经打印出来了。同时可以看到多打印了一个<code>class</code>属性，但是我们的类里面没有定义这个属性，<code>Object</code>类中有<code>getClass</code>的方法。我们大胆猜测Spring会遵循Java Bean的设计原则，通过<code>get</code>方法来获取属性。 </p><p>现在将<code>age</code>改成<code>age1</code>，<code>getAge</code>方法不变，看一下结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">展示bean 的属性</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=age]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=class]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=classRoom]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=name]</span><br></pre></td></tr></table></figure><p>打印出来的属性名一样。现在交换一下，将<code>getAge</code>改成<code>getAge1</code>，属性<code>age1</code>改成<code>age</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">展示bean 的属性</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=age1]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=class]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=classRoom]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=name]</span><br></pre></td></tr></table></figure><p>可以看到获取到的属性已经变成了<code>age1</code>。这充分验证了我们的猜想。</p><p>我们可以看一下Spring的代码，里面使用了<code>java.beans</code>包下<code>Introspector</code>类来获取Bean的信息。</p><h4 id="嵌套属性"><a href="#嵌套属性" class="headerlink" title="嵌套属性"></a>嵌套属性</h4><p>上面的结果中，我们并没有获取到ClassRoom的属性。BeanWrapper并不支持这种操作，我们可以扩展一下，比如判断属性，如果是自定义的类型，那么就再调用一次BeanWrapper的方法。这有个前提是这个属性不为<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setClassRoom(<span class="keyword">new</span> ClassRoom());</span><br><span class="line">BeanWrapper wrapper = <span class="keyword">new</span> BeanWrapperImpl(student);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;展示bean 的属性&quot;</span>);</span><br><span class="line">Arrays.stream(wrapper.getPropertyDescriptors()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;展示bean 的嵌套属性&quot;</span>);</span><br><span class="line">wrapper = <span class="keyword">new</span> PowerfulBeanWrapper(student);</span><br><span class="line">Arrays.stream(wrapper.getPropertyDescriptors()).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>先上结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">展示bean 的属性</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=age]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=class]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=classRoom]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=name]</span><br><span class="line">展示bean 的嵌套属性</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=age]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=class]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=classRoom]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=name]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=class]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=name]</span><br></pre></td></tr></table></figure><p>ClassRoom类只有一个name 属性，这里看到也打印出来了。证明思路是对的，只是这个结构还需要组织一下，现在是扁平的。</p><p>下面看一下<code>PowerfulBeanWrapper</code>的实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerfulBeanWrapper</span> <span class="keyword">extends</span> <span class="title">BeanWrapperImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PowerfulBeanWrapper</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyDescriptor[] getPropertyDescriptors() &#123;</span><br><span class="line">        PropertyDescriptor[] propertyDescriptors = <span class="keyword">super</span>.getPropertyDescriptors();</span><br><span class="line">        List&lt;PropertyDescriptor&gt; propertyDescriptorList = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(propertyDescriptors));</span><br><span class="line">        Arrays.stream(propertyDescriptors).forEach(propertyDescriptor -&gt; &#123;</span><br><span class="line">            Object value = getPropertyValue(propertyDescriptor.getName());</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !(value <span class="keyword">instanceof</span> Class) &amp;&amp; !value.getClass().isPrimitive()) &#123;</span><br><span class="line">                propertyDescriptorList.addAll(Arrays.asList(<span class="keyword">new</span> BeanWrapperImpl(value).getPropertyDescriptors()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> propertyDescriptorList.toArray(<span class="keyword">new</span> PropertyDescriptor[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接继承自<code>BeanWrapperImpl</code>类，覆盖了<code>getPropertyDescriptors</code>方法。遍历属性值，如果不为空并且不是Class，则再获取一次这个属性的属性。这里只获取了2层属性，可以在获取嵌套属性时换成我们的<code>PowerfulBeanWrapper</code>类既可支持无限层。</p><h3 id="获取属性值"><a href="#获取属性值" class="headerlink" title="获取属性值"></a>获取属性值</h3><p>可以使用BeanWrapper的<code>getPropertyValue</code>方法来获取属性值。上面的代码中已经展示过了。</p><p>支持获取嵌套属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">ClassRoom classRoom = <span class="keyword">new</span> ClassRoom();</span><br><span class="line">classRoom.setName(<span class="string">&quot;room1&quot;</span>);</span><br><span class="line">student.setClassRoom(classRoom);</span><br><span class="line">BeanWrapper wrapper = <span class="keyword">new</span> BeanWrapperImpl(student);</span><br><span class="line">System.out.println(wrapper.getPropertyValue(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">System.out.println(wrapper.getPropertyValue(<span class="string">&quot;classRoom.name&quot;</span>));</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line">room1</span><br></pre></td></tr></table></figure><p>可以看出来还是很方便的。</p><p><strong>注： 当嵌套对象为空时，默认获取嵌套对象的属性会抛出异常。</strong>  这时可以加一个设置：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wrapper.setAutoGrowNestedPaths(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;嵌套对象为空时：&quot;</span> + wrapper.getPropertyValue(<span class="string">&quot;classRoom.name&quot;</span>));</span><br></pre></td></tr></table></figure><p>该属性的意义是自动扩展嵌套属性，按照默认值来初始化属性。此处就会将<code>classRoom</code>初始化，并且里面的属性为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">嵌套对象为空时：<span class="keyword">null</span></span><br></pre></td></tr></table></figure><h3 id="设置属性值"><a href="#设置属性值" class="headerlink" title="设置属性值"></a>设置属性值</h3><p>可以通过<code>setPropertyValue</code>方法来设置属性值。同上，当嵌套对象为空时，不能设置嵌套对象的属性，设置<code>wrapper.setAutoGrowNestedPaths(true)</code>即可。</p><p>注意以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">wrapper.setPropertyValue(<span class="string">&quot;age&quot;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在这里设置属性值的时候是整数型，但是<code>age</code>声明的时候是String。BeanWrapper是如何正确的赋值的呢？</p><p><code>BeanWrapperImpl</code>内部会委托给<code>TypeConverterDelegate</code>类，先查找自定义<code>PropertyEditor</code>, 如果没有找到的话，则查找<code>ConversionService</code>，没有的话查找默认的<code>PropertyEditor</code>,再没有的话使用内部定义好的转换策略（按类型去判断，然后去转换）。</p><h2 id="PropertyEditor"><a href="#PropertyEditor" class="headerlink" title="PropertyEditor"></a>PropertyEditor</h2><p><code>PropertyEditor</code>属于Java Bean规范里面的类，可以给GUI程序设置对象属性值提供方便，所以接口里有一些和GUI相关的方法，显然目前已经过时了。同时，官方文档上解释，它是线程不安全的。必须得有一个默认构造函数。可以想象一下，在界面上填入一个值，这个值一般来说都是<code>String</code>类型的，填入之后这个值能自动设置到对应的对象中（ 这里纯粹是我意淫的，对<code>awt</code>并不是很熟，不知道是不是这样）。了解安卓编程的朋友可能知道，我们要取界面上填的值，通常要拿到界面元素，然后再拿到值，然后再设置到对象中去。当界面上有很多个输入控件时，这样繁琐的操作，简直要人命。所以安卓后来出了数据绑定。这里有一篇<a href="https://www.iteye.com/blog/stamen-1525668">文章</a>讲得很好。</p><p>BeanWrapperImpl内置了一些 <code>PropertyEditor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createDefaultEditors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.defaultEditors = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple editors, without parameterization capabilities.</span></span><br><span class="line"><span class="comment">// The JDK does not contain a default editor for any of these target types.</span></span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Charset.class, <span class="keyword">new</span> CharsetEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Class.class, <span class="keyword">new</span> ClassEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Class[].class, <span class="keyword">new</span> ClassArrayEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Currency.class, <span class="keyword">new</span> CurrencyEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(File.class, <span class="keyword">new</span> FileEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(InputStream.class, <span class="keyword">new</span> InputStreamEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(InputSource.class, <span class="keyword">new</span> InputSourceEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Locale.class, <span class="keyword">new</span> LocaleEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Path.class, <span class="keyword">new</span> PathEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Pattern.class, <span class="keyword">new</span> PatternEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Properties.class, <span class="keyword">new</span> PropertiesEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Reader.class, <span class="keyword">new</span> ReaderEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Resource[].class, <span class="keyword">new</span> ResourceArrayPropertyEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(TimeZone.class, <span class="keyword">new</span> TimeZoneEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(URI.class, <span class="keyword">new</span> URIEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(URL.class, <span class="keyword">new</span> URLEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(UUID.class, <span class="keyword">new</span> UUIDEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(ZoneId.class, <span class="keyword">new</span> ZoneIdEditor());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default instances of collection editors.</span></span><br><span class="line"><span class="comment">// Can be overridden by registering custom instances of those as custom editors.</span></span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Collection.class, <span class="keyword">new</span> CustomCollectionEditor(Collection.class));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Set.class, <span class="keyword">new</span> CustomCollectionEditor(Set.class));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(SortedSet.class, <span class="keyword">new</span> CustomCollectionEditor(SortedSet.class));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(List.class, <span class="keyword">new</span> CustomCollectionEditor(List.class));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(SortedMap.class, <span class="keyword">new</span> CustomMapEditor(SortedMap.class));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default editors for primitive arrays.</span></span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">byte</span>[].class, <span class="keyword">new</span> ByteArrayPropertyEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">char</span>[].class, <span class="keyword">new</span> CharArrayPropertyEditor());</span><br><span class="line"></span><br><span class="line"><span class="comment">// The JDK does not contain a default editor for char!</span></span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">char</span>.class, <span class="keyword">new</span> CharacterEditor(<span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Character.class, <span class="keyword">new</span> CharacterEditor(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring&#x27;s CustomBooleanEditor accepts more flag values than the JDK&#x27;s default editor.</span></span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">boolean</span>.class, <span class="keyword">new</span> CustomBooleanEditor(<span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Boolean.class, <span class="keyword">new</span> CustomBooleanEditor(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// The JDK does not contain default editors for number wrapper types!</span></span><br><span class="line"><span class="comment">// Override JDK primitive number editors with our own CustomNumberEditor.</span></span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">byte</span>.class, <span class="keyword">new</span> CustomNumberEditor(Byte.class, <span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Byte.class, <span class="keyword">new</span> CustomNumberEditor(Byte.class, <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">short</span>.class, <span class="keyword">new</span> CustomNumberEditor(Short.class, <span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Short.class, <span class="keyword">new</span> CustomNumberEditor(Short.class, <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">int</span>.class, <span class="keyword">new</span> CustomNumberEditor(Integer.class, <span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Integer.class, <span class="keyword">new</span> CustomNumberEditor(Integer.class, <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">long</span>.class, <span class="keyword">new</span> CustomNumberEditor(Long.class, <span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Long.class, <span class="keyword">new</span> CustomNumberEditor(Long.class, <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">float</span>.class, <span class="keyword">new</span> CustomNumberEditor(Float.class, <span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Float.class, <span class="keyword">new</span> CustomNumberEditor(Float.class, <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">double</span>.class, <span class="keyword">new</span> CustomNumberEditor(Double.class, <span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Double.class, <span class="keyword">new</span> CustomNumberEditor(Double.class, <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(BigDecimal.class, <span class="keyword">new</span> CustomNumberEditor(BigDecimal.class, <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(BigInteger.class, <span class="keyword">new</span> CustomNumberEditor(BigInteger.class, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only register config value editors if explicitly requested.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.configValueEditorsActive) &#123;</span><br><span class="line">StringArrayPropertyEditor sae = <span class="keyword">new</span> StringArrayPropertyEditor();</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(String[].class, sae);</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">short</span>[].class, sae);</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">int</span>[].class, sae);</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">long</span>[].class, sae);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有注册<code>String</code>, 所以走的是内置方案，直接调用<code>toString</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (String.class == requiredType &amp;&amp; ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) &#123;</span><br><span class="line">  <span class="comment">// We can stringify any primitive value...</span></span><br><span class="line">  <span class="keyword">return</span> (T) convertedValue.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义PropertyEditor"><a href="#自定义PropertyEditor" class="headerlink" title="自定义PropertyEditor"></a>自定义<code>PropertyEditor</code></h3><p>当Spring提供的<code>PropertyEditor</code>无法满足我们的需求时，我们可以自定义<code>PropertyEditor</code>。</p><p>一般不直接实现接口，而是继承<code>PropertyEditorSupport</code>类。Spring中大多数场景都是将传入的字符串转换成对应的属性值，需要重写<code>setAsText</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转换String -&gt; ClassRoom;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassRoomPropertyEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">//将逗号分隔的值转换成对象的属性值：room3,3</span></span><br><span class="line">        String[] strings = Optional.ofNullable(text).orElseGet(String::<span class="keyword">new</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        ClassRoom classRoom = <span class="keyword">new</span> ClassRoom();</span><br><span class="line">        classRoom.setName(strings[<span class="number">0</span>]);</span><br><span class="line">        classRoom.setSize(Integer.parseInt(strings[<span class="number">1</span>]));</span><br><span class="line">        setValue(classRoom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，将字符串进行分隔，第一个值作为<code>ClassRoom</code>的<code>name</code>值，第二个值作为<code>size</code>。如何使用这个<code>PropertyEditor</code>?</p><p>先注册这个类，再设置<code>Student</code>的<code>classRoom</code>属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wrapper = <span class="keyword">new</span> BeanWrapperImpl(student);</span><br><span class="line"><span class="comment">//注解自定义PropertyEditor</span></span><br><span class="line">wrapper.registerCustomEditor(ClassRoom.class, <span class="keyword">new</span> ClassRoomPropertyEditor());</span><br><span class="line">wrapper.setPropertyValue(<span class="string">&quot;classRoom&quot;</span>, <span class="string">&quot;room3,3&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样就给<code>Student</code>类的<code>classRoom</code>属性进行了初始化。</p><h2 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a><code>ConversionService</code></h2><p><code>ConversionService</code>是Spring提供的一套通用的类型转换机制的入口，相比<code>PropertyEditor</code>来说：</p><ol><li>支持的类型转换范围更广。</li><li>支持从父类型转换为子类型，即多态。</li><li>省去了Java GUI相关的概念。</li><li>线程安全。</li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p><code>boolean canConvert(@Nullable Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</code>：如果可以将<code>sourceType</code>对象转换为<code>targetType</code>，则返回<code>true</code>。</p><p>如果此方法返回<code>true</code>，则意味着<code>convert(Object, Class)</code>方法能够将<code>sourceType</code>实例转换为<code>targetType</code>。</p><p>关于集合、数组和Map类型需要特别注意：<strong>对于集合、数组和Map类型之间的转换，此方法将返回true，即使在底层元素不可转换的情况下，转换过程仍然可能生成一个<code>ConversionException</code>。在处理集合和映射时，调用者需要处理这种特殊情况。</strong></p></li><li><p><code>boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType)</code>：如果可以将<code>sourceType</code>对象转换为<code>targetType</code>，则返回<code>true</code>。<code>TypeDescriptor </code>提供关于将要发生转换的源和目标位置的附加上下文信息，通常是对象字段或属性的位置。</p><p>如果此方法返回<code>true</code>，则意味着<code>convert(Object、TypeDescriptor、TypeDescriptor)</code>能够将<code>sourceType</code>实例转换为<code>targetType</code>。</p><p>关于集合、数组和Map类型需要特别注意：<strong>对于集合、数组和Map类型之间的转换，此方法将返回true，即使在底层元素不可转换的情况下，转换过程仍然可能生成一个<code>ConversionException</code>。在处理集合和映射时，调用者需要处理这种特殊情况。</strong></p></li><li><p><code>&lt;T&gt; T convert(@Nullable Object source, Class&lt;T&gt; targetType)</code>：将给定的对象转换为指定的<code>targetType</code>类型对象。</p></li><li><p><code>Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType)</code>：将给定的对象转换为指定的<code>targetType</code>类型对象。<code>TypeDescriptor </code>提供关于将要发生转换的源和目标位置的附加上下文信息，通常是对象字段或属性位置。</p></li></ul><h2 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a><code>Converter</code></h2><p><code>Converter</code>是具体的某类转换器接口，负责将某个类型的对象转成另外一个类型的对象。并且是一个函数式接口。</p><p>就提供了一个转换方法：</p><ul><li><code>T convert(S source)</code>：转换对象类型。</li></ul><h2 id="ConverterFactory"><a href="#ConverterFactory" class="headerlink" title="ConverterFactory"></a><code>ConverterFactory</code></h2><p>生产一种<code>Converter</code>，这种<code>Converter</code>可以将对象从<code>S</code>转换为<code>R</code>的子类型。也就是说支持多态功能。<br>实现类还可以实现<code>ConditionalConverter</code>接口。</p><ul><li><code>&lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType)</code>：根据目标类型<code>T</code>获取<code>Converter</code>，该<code>Converter</code>将源类型<code>S</code>转换成<code>R</code>的子类型<code>T</code>。</li></ul><h2 id="ConditionalConverter"><a href="#ConditionalConverter" class="headerlink" title="ConditionalConverter"></a><code>ConditionalConverter</code></h2><p>该接口可以根据源和目标<code>TypeDescriptor</code>的属性选择性地执行<code>Converter</code>、<code>GenericConverter</code>或<code>ConverterFactory</code>。</p><p>通常用于根据字段或类特征(如注解或方法)的存在选择性地匹配自定义转换逻辑。例如，当从<code>String</code>字段转换为<code>Date</code>字段时，如果目标字段还有<code>@DateTimeFormat</code>注解，则实现类<code>matches</code>方法可能返回<code>true</code>，也就是说如果目标字段上没有<code>@DateTimeFormat</code>注解，那么可能不会应用该转换，该接口可以控制需不需要转换。</p><p>另外一个例子，当从字符串字段转换为<code>Account</code>字段时，如果目标<code>Account</code>类定义了公共静态<code>findAccount(String)</code>方法，则实现类<code>matches</code>方法可能返回<code>true</code>。</p><ul><li><code>boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType)</code>：是否需要转换。</li></ul><h2 id="GenericConverter"><a href="#GenericConverter" class="headerlink" title="GenericConverter"></a><code>GenericConverter</code></h2><p>这是最灵活的转换器SPI接口，也是最复杂的。它的灵活性在于<code>GenericConverter</code>可以支持多个源/目标类型对之间的转换(参见<code>getConvertibleTypes()</code>方法)。此外，<code>GenericConverter</code>实现类在类型转换过程中可以访问源/目标字段上下文，允许解析源和目标字段元数据，如注解和泛型信息，这些信息可用于复杂转换逻辑。</p><p>当比较简单的<code>Converter</code>或<code>ConverterFactory</code>接口够用时，通常不应使用此接口。<br>实现类还可以实现<code>ConditionalConverter</code>接口。</p><ul><li>Set<ConvertiblePair> getConvertibleTypes()：返回此<code>Converter</code>可以在源类型和目标类型之间转换的类型。<br>Set中每条都是一个可转换的源到目标类型对。<code>ConvertiblePair</code>保存源类型与目标类型的映射关系。<br>对于<code>ConditionalConverter</code>，此方法可能返回<code>null</code>，意味着该<code>GenericConverter</code>适用于所有源与目标类型对。未实现<code>ConditionalConverter</code>接口的实现类，此方法不能返回<code>null</code>。</ConvertiblePair></li></ul><h2 id="ConverterRegistry"><a href="#ConverterRegistry" class="headerlink" title="ConverterRegistry"></a><code>ConverterRegistry</code></h2><p>用来注册<code>Converter</code>。</p><h2 id="ConversionService组件结构"><a href="#ConversionService组件结构" class="headerlink" title="ConversionService组件结构"></a><code>ConversionService</code>组件结构</h2><p><img src="/post/504e/ConversionService%E7%BB%93%E6%9E%84.png" alt="ConversionService结构"></p><p><code>ConversionService</code>提供转换功能的统一入口，<code>ConverterRegistry</code>提供<code>Converter</code>注册功能，将<code>Converter</code>集中起来，转换时从中查出对应的<code>Converter</code>。<code>Converter</code>负责具体的转换过程。<code>ConfigurableConversionService</code>继承自<code>ConversionService</code>和<code>ConverterRegistry</code>，集成转换和注册功能。</p><p>下面看一下具体的实现类。</p><h2 id="GenericConversionService类"><a href="#GenericConversionService类" class="headerlink" title="GenericConversionService类"></a><code>GenericConversionService</code>类</h2><p>基础转换服务实现，适用于大部分情况。直接实现<code>ConfigurableConversionService</code>接口，实现了注册与转换功能。在注册<code>Converter</code>、<code>ConverterFactory</code>时，会将其转换成<code>GenericConverter</code>。</p><h2 id="DefaultConversionService类"><a href="#DefaultConversionService类" class="headerlink" title="DefaultConversionService类"></a><code>DefaultConversionService</code>类</h2><p>继承自<code>GenericConversionService</code>，配置了适合大多数环境的<code>Converter</code>。<br>该类使用时可以直接实例化，暴露出静态方法<code>addDefaultConverters(ConverterRegistry)</code>，用于对某个<code>ConverterRegistry</code>实例进行特殊处理，也就是说当某个<code>ConverterRegistry</code>需要增加一个默认的<code>Converter</code>时，可以调用这个方法。</p><p>这里我们可以直接使用<code>DefaultConversionService</code>类，Spring已经配置了一些<code>Converter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">student = <span class="keyword">new</span> Student();</span><br><span class="line">wrapper = <span class="keyword">new</span> BeanWrapperImpl(student);</span><br><span class="line">wrapper.setAutoGrowNestedPaths(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//注册ConversionService</span></span><br><span class="line">wrapper.setConversionService(<span class="keyword">new</span> DefaultConversionService());</span><br><span class="line">wrapper.setPropertyValue(<span class="string">&quot;classRoom.size&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ConversionService, 设置嵌套对象的属性 size：&quot;</span> + wrapper.getPropertyValue(<span class="string">&quot;classRoom.size&quot;</span>));</span><br><span class="line"><span class="comment">//这里将字符串转换成数字</span></span><br></pre></td></tr></table></figure><h2 id="Spring-提供的Converter"><a href="#Spring-提供的Converter" class="headerlink" title="Spring 提供的Converter"></a>Spring 提供的<code>Converter</code></h2><p>在Spring 的<code>org.springframework.core.convert.support</code>包中内置了一些转换器，提供数组、集合、字符串、数字、枚举、对象、Map、Boolean等之间的转换功能。</p><table><thead><tr><th></th><th>Array</th><th>Collection</th><th>Stream</th><th>ByteBuffer</th><th>String(Character)</th><th>Number(Integer)</th><th>Object</th><th>Enum</th><th>Map</th><th>Boolean</th><th>Charset</th><th>Currency</th><th>Locale</th><th>Properties</th><th>TimeZone</th><th>UUID</th><th>Calendar</th></tr></thead><tbody><tr><td>Array</td><td><code>ArrayToArrayConverter</code></td><td><code>ArrayToCollectionConverter</code></td><td><code>StreamConverter</code></td><td><code>ByteBufferConverter</code></td><td><code>ArrayToStringConverter</code></td><td></td><td><code>ArrayToObjectConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Collection</td><td><code>CollectionToArrayConverter</code></td><td><code>CollectionToCollectionConverter</code></td><td><code>StreamConverter</code></td><td></td><td><code>CollectionToStringConverter</code></td><td></td><td><code>CollectionToObjectConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Stream</td><td><code>StreamConverter</code></td><td><code>StreamConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>String(Character)</td><td><code>StringToArrayConverter</code></td><td><code>StringToCollectionConverter</code></td><td></td><td></td><td><code>StringToCharacterConverter</code></td><td><code>StringToNumberConverterFactory</code></td><td></td><td><code>StringToEnumConverterFactory</code></td><td></td><td><code>StringToBooleanConverter</code></td><td><code>StringToCharsetConverter</code></td><td><code>StringToCurrencyConverter</code></td><td><code>StringToLocaleConverter</code></td><td><code>StringToPropertiesConverter</code></td><td><code>StringToTimeZoneConverter</code></td><td><code>StringToUUIDConverter</code></td><td></td></tr><tr><td>ByteBuffer</td><td><code>ByteBufferConverter</code></td><td></td><td></td><td></td><td></td><td></td><td><code>ByteBufferConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Number(Integer)</td><td></td><td></td><td></td><td></td><td><code>NumberToCharacterConverter</code></td><td><code>NumberToNumberConverterFactory</code></td><td></td><td><code>IntegerToEnumConverterFactory</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Object</td><td><code>ObjectToArrayConverter</code></td><td><code>ObjectToCollectionConverter</code></td><td></td><td><code>ByteBufferConverter</code></td><td><code>ObjectToStringConverter</code></td><td></td><td><code>ObjectToObjectConverter</code>,<code>IdToEntityConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Enum</td><td></td><td></td><td></td><td></td><td><code>EnumToStringConverter</code></td><td><code>EnumToIntegerConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Map</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><code>MapToMapConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Boolean</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Properties</td><td></td><td></td><td></td><td></td><td><code>PropertiesToStringConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ZoneId</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><code>ZoneIdToTimeZoneConverter</code></td><td></td><td></td></tr><tr><td>ZonedDateTime</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><code>ZonedDateTimeToCalendarConverter</code></td></tr></tbody></table><h3 id="StringToBooleanConverter"><a href="#StringToBooleanConverter" class="headerlink" title="StringToBooleanConverter"></a><code>StringToBooleanConverter</code></h3><p>将<code>String</code>转换成<code>Boolean</code>。<code>true</code>、<code>on、yes、1</code> 转换成<code>Boolean.TRUE</code>。<code>false、off</code> 、no<code> 、</code>0 <code>转换成</code>Boolean.FALSE`。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wrapper.setPropertyValue(<span class="string">&quot;good&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ConversionService, 设置bool值。 good：&quot;</span> + wrapper.getPropertyValue(<span class="string">&quot;good&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//ConversionService, 设置bool值。 good：true</span></span><br></pre></td></tr></table></figure><h2 id="自定义Converter"><a href="#自定义Converter" class="headerlink" title="自定义Converter"></a>自定义<code>Converter</code></h2><p>当Spring提供的转换器无法满足我们需要时，我们可以自定义转换逻辑。</p><p>上面提到的<code>Converter</code>、<code>GenericConverter</code>和<code>ConverterFactory</code>三个接口都可以用来实现转换逻辑。该如何选择？</p><ul><li><p><code>Converter</code>：单值。从<code>S</code>-&gt;<code>T</code>。一对一转换。</p></li><li><p><code>ConverterFactory</code>：从<code>S</code> -&gt; <code>T extends R</code>。一对多转换。 </p></li><li><p><code>GenericConverter</code> ：功能最复杂。实现多个类型对的转换。多对多转换。</p></li></ul><p>在自定义<code>PropertyEditor</code>示例中，我们实现了从<code>String</code>转换到<code>ClassRoom</code>的功能。在这里通过<code>Converter</code>来实现此功能。</p><ol><li><p><code>StringToClassRoomConverter实现</code>String<code>转换到</code>ClassRoom`的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToClassRoomConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">ClassRoom</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassRoom <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        String[] strings = Optional.ofNullable(source).orElseGet(String::<span class="keyword">new</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        ClassRoom classRoom = <span class="keyword">new</span> ClassRoom();</span><br><span class="line">        classRoom.setName(strings[<span class="number">0</span>]);</span><br><span class="line">        classRoom.setSize(Integer.parseInt(strings[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> classRoom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将此<code>StringToClassRoomConverter</code>注册到我们使用的<code>ConversionService</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DefaultConversionService conversionService = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line">conversionService.addConverter(<span class="keyword">new</span> StringToClassRoomConverter());</span><br><span class="line">wrapper.setConversionService(conversionService);</span><br></pre></td></tr></table></figure></li><li><p><code>BeanWrapper</code>使用此<code>ConversionService</code>设置Bean属性。这里不一定用<code>BeanWrapper</code> 来操作，可以直接调用<code>ConversionService</code>来转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wrapper.setPropertyValue(<span class="string">&quot;classRoom&quot;</span>, <span class="string">&quot;room4,4&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;自定义Converter, 设置嵌套对象的属性 name：&quot;</span> + wrapper.getPropertyValue(<span class="string">&quot;classRoom.name&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;自定义Converter, 设置嵌套对象的属性 size：&quot;</span> + wrapper.getPropertyValue(<span class="string">&quot;classRoom.size&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------</span></span><br><span class="line"><span class="comment">//自定义Converter, 设置嵌套对象的属性 name：room4</span></span><br><span class="line"><span class="comment">//自定义Converter, 设置嵌套对象的属性 size：4</span></span><br></pre></td></tr></table></figure><p>从输出结果来看，已经成功转换成功。</p></li></ol><p>当我们想从一个类型转换成某些类型时，可以实现<code>ConverterFactory</code>接口，因为我们也不知道总共有哪些类型，不可能每个类型都写一个<code>ConverterFactory</code>。比如说从<code>String</code>转换成枚举类型，前端传枚举类型的字面值，转换成具体的枚举类型。Spring 内置了<code>StringToEnumConverterFactory</code>来实现此功能。直接调用Enum的静态方法<code>Enum.valueOf(this.enumType, source.trim())</code>来实现转换。同理还有<code>IntegerToEnumConverterFactory</code>通过枚举的序号来转换。</p><p>当我们遇到容器型的转换需求时，因为容器内部保存的类型可能是多种多样的，比如说List里面既有String，也有int，我们要统一转成Long型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DefaultConversionService conversionService = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line">List source = <span class="keyword">new</span> ArrayList();</span><br><span class="line">source.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">source.add(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//这里要注意初始化成内部类，才能正确获取泛型，不然不会转换。因为这个例子中，如果不写成内部类，源类型和目标类型其实是一致的，CollectionToCollectionConverter（这个转换器支持集合之间的转换） 内部不会去做转换。</span></span><br><span class="line">List&lt;Long&gt; longList = <span class="keyword">new</span> ArrayList&lt;&gt;()&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (Object s : source) &#123;</span><br><span class="line">    System.out.println(s.getClass() + <span class="string">&quot; , &quot;</span> + s);</span><br><span class="line">&#125;</span><br><span class="line">List convert = conversionService.convert(source, longList.getClass());</span><br><span class="line"><span class="keyword">for</span> (Object s : convert) &#123;</span><br><span class="line">    System.out.println(s.getClass() + <span class="string">&quot; , &quot;</span> + s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------</span></span><br><span class="line"><span class="comment">//不是内部类，不转换</span></span><br><span class="line"><span class="comment">//class java.lang.String , 1</span></span><br><span class="line"><span class="comment">//class java.lang.Integer , 2</span></span><br><span class="line"><span class="comment">//class java.lang.String , 1</span></span><br><span class="line"><span class="comment">//class java.lang.Integer , 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------</span></span><br><span class="line"><span class="comment">//正确转换</span></span><br><span class="line"><span class="comment">//class java.lang.String , 1</span></span><br><span class="line"><span class="comment">//class java.lang.Integer , 2</span></span><br><span class="line"><span class="comment">//class java.lang.Long , 1</span></span><br><span class="line"><span class="comment">//class java.lang.Long , 2</span></span><br></pre></td></tr></table></figure><p>如果有多个<code>Converter</code>可以处理同一个转换需求，那么则看注意的先后顺序了，会取第一个符合条件的转换器。这里可以优化一下。</p><h2 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a><code>Formatter</code></h2><p>在前后端交互时，通常会遇到日期格式这样的问题，<code>Converter</code>虽然说也能解决这个问题，在转换时获取到正确的格式然后进行转换。但是这样无法灵活控制我们的格式，我们得把所有格式都写在我们的<code>Converter</code>里，换一种格式，又得改一次这个类。这时候<code>Formatter</code>接口出现了。</p><p><code>Formatter</code>接口位于<code>context</code>包中。</p><p>先看一下<code>Formatter</code>类，从<code>Parser</code>和<code>Printer</code>接口继承而来，实现了<code>String</code> &lt;-&gt; <code>Object</code>转换的功能。</p><p><img src="/post/504e/Formatter%E7%BB%93%E6%9E%84.png" alt="Formatter结构"></p><h2 id="FormatterRegistry"><a href="#FormatterRegistry" class="headerlink" title="FormatterRegistry"></a><code>FormatterRegistry</code></h2><p>继承自<code>ConverterRegistry</code>接口，用来注册<code>Formatter</code>。</p><ul><li><p><code>void addFormatter(Formatter&lt;?&gt; formatter)</code>：向特定类型的字段添加<code>Formatter</code>。字段类型由<code>Formatter</code>的泛型提供。</p></li><li><p><code>void addFormatterForFieldType(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter)</code>：向给定类型的字段添加<code>Formatter</code>。</p><p>在打印时，如果声明了<code>Formatter</code>的类型<code>T</code>，并且不能将<code>fieldType</code>赋值给<code>T</code>，则在打印字段值的任务委托给<code>Formatter</code>之前，将尝试强制转换为<code>T</code>。在解析时，如果<code>Formatter</code>返回的已解析对象不能分配给运行时字段类型，则在返回已解析字段值之前，将尝试强制转换为<code>fieldType</code>。例如，<code>DateFormatter</code>声明的泛型为<code>Date</code>，如果这里的<code>fieldType</code>为<code>DateTime</code>（假设存在），如果<code>DateTime</code>可以用<code>Date</code>变量接收，则意味着可以分配给<code>Date</code>，也就不需要转换。否则则需要转换为<code>Date</code>类型。具体能否分配，可以查看该方法：<code>org.springframework.core.convert.TypeDescriptor#isAssignableTo</code>。</p></li><li><p><code>void addFormatterForFieldType(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser)</code>：添加<code>Printer</code>/<code>Parser</code>对来格式化特定类型的字段，formatter 将委托给指定的<code>Printer</code>进行打印，并委托指定的<code>Parser</code>进行解析。</p><p>在打印时，如果声明了<code>Printer</code>的类型<code>T</code>，并且<code>fieldType</code>不能赋值给<code>T</code>，则在委托<code>Printer</code>打印字段值之前，将尝试转换化类型<code>T</code>。在解析时，如果<code>Parser</code>返回的对象不能分配给<code>fieldType</code>，则在返回解析后的字段值之前，将尝试转换为<code>fieldType</code>。这个方法与上一个方法的区别就是将<code>Formatter</code>拆开。</p></li><li><p><code>void addFormatterForFieldAnnotation(AnnotationFormatterFactory&lt;? extends Annotation&gt; annotationFormatterFactory)</code>：为格式化注解标注的字段添加<code>Formatter</code>。此方法与上述方法的区别是不再以类型作为转换的依据了，而是根据注解来转换。比如某个字段上使用了<code>DateTimeFormat</code>注解，那会调用对应的<code>Formatter</code>。</p></li></ul><h2 id="FormattingConversionService"><a href="#FormattingConversionService" class="headerlink" title="FormattingConversionService"></a><code>FormattingConversionService</code></h2><p><code>FormattingConversionService</code>类是Spring提供的支持<code>Formatter</code>接口的实现类，继承自<code>GenericConversionService</code>类，实现了<code>FormatterRegistry</code>和<code>EmbeddedValueResolverAware</code>接口，在<code>GenericConversionService</code>类的基础上增加了注册<code>Formatter</code>的功能。<code>EmbeddedValueResolverAware</code>接口用来解决字符串占位符、国际化等问题。注册<code>Formatter</code>时，会将<code>Formatter</code>转换成<code>GenericConverter</code>，调用此<code>GenericConverter</code>的<code>convert</code>方法时，将会调用<code>Formatter</code>的<code>print</code>或<code>parse</code>方法，由此可以看出我们需要格式化时，还是调用<code>FormattingConversionService</code>的<code>convert</code>方法即可。</p><h2 id="DefaultFormattingConversionService"><a href="#DefaultFormattingConversionService" class="headerlink" title="DefaultFormattingConversionService"></a><code>DefaultFormattingConversionService</code></h2><p>Spring 内部提供了一些<code>Formatter</code>，会通过<code>DefaultFormattingConversionService</code>注册，我们无不特殊要求，可以直接使用此类，再在此基础上注册我们自定义的<code>Formatter</code>。</p><h3 id="Spring提供的Formatter"><a href="#Spring提供的Formatter" class="headerlink" title="Spring提供的Formatter"></a>Spring提供的<code>Formatter</code></h3><table><thead><tr><th><code>Formatter</code>或<code>FormatterRegistrar</code></th><th><code>DefaultFormattingConversionService</code>是否注册</th><th>说明</th></tr></thead><tbody><tr><td><code>NumberFormatAnnotationFormatterFactory</code></td><td>Y</td><td>用于支持<code>@NumberFormat</code>注解</td></tr><tr><td><code>CurrencyUnitFormatter</code></td><td>JSR-354相关的jar包出现在classpath时注册</td><td><code>javax.money.CurrencyUnit</code></td></tr><tr><td><code>MonetaryAmountFormatter</code></td><td>JSR-354相关的jar包出现在classpath时注册</td><td><code>javax.money.MonetaryAmount</code></td></tr><tr><td><code>Jsr354NumberFormatAnnotationFormatterFactory</code></td><td>JSR-354相关的jar包出现在classpath时注册</td><td><code>@NumberFormat</code>注解</td></tr><tr><td><code>DateTimeFormatterRegistrar</code></td><td></td><td>用来注册<code>JSR-310</code>新版日期和时间相关</td></tr><tr><td><code>JodaTimeFormatterRegistrar</code></td><td></td><td>如果使用了<code>Joda</code>包，则会注册相关的``</td></tr><tr><td><code>DateFormatterRegistrar</code></td><td></td><td>注册<code>@DateTimeFormat</code>注解的<code>AnnotationFormatterFactory</code>用于<code>Date</code>，<code>Calendar</code>，<code>Long</code>之间格式化以及<code>Date</code>，<code>Calendar</code>，<code>Long</code>之间的转换的<code>Converter</code>。默认不会注册用于直接转换的<code>DateFormatter</code>，不需要<code>@DateTimeFormat</code>注解，我们可以手动注册。</td></tr></tbody></table><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><ol><li>以日期为例，如果不用注解的话，我们需要手动注册一下<code>Formatter</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService();</span><br><span class="line">conversionService.addFormatter(<span class="keyword">new</span> DateFormatter());</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(conversionService.convert(date, String.class));</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------</span></span><br><span class="line"><span class="comment">// 2019年9月3日</span></span><br></pre></td></tr></table></figure><p><code>DateFormatter</code>还支持指定格式。可以通过构造函数传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conversionService.addFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"><span class="comment">// 2019-09-03</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>还是以日期为例，使用Spring提供的<code>@DateTimeFormat</code>注解。</p><p>先创建一个类，里面有个日期字段使用<code>@DateTimeFormat</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Question</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br></pre></td></tr></table></figure><p>指定格式为<code>yyyy-MM-dd</code>，这里我们借助<code>BeanWrapper</code>来触发格式化的动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService();</span><br><span class="line"></span><br><span class="line">Question question = <span class="keyword">new</span> Question();</span><br><span class="line">BeanWrapper beanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(question);</span><br><span class="line">beanWrapper.setConversionService(conversionService);</span><br><span class="line">beanWrapper.setPropertyValue(<span class="string">&quot;createTime&quot;</span>, <span class="string">&quot;2019-09-03&quot;</span>);</span><br><span class="line">System.out.println(question.getCreateTime());</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------</span></span><br><span class="line"><span class="comment">// Tue Sep 03 00:00:00 CST 2019</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间格式化 字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;注解格式化日期：&quot;</span> + conversionService.convert(question.getCreateTime(), <span class="keyword">new</span> TypeDescriptor(question.getClass().getDeclaredField(<span class="string">&quot;createTime&quot;</span>)), TypeDescriptor.valueOf(String.class)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------</span></span><br><span class="line"><span class="comment">//注解格式化日期：2019-09-03</span></span><br></pre></td></tr></table></figure><p>通过打印的信息，可以看到已经成功将字符串<code>parse</code>为<code>Date</code>，并将日期<code>format</code>为字符串。由于注解在字段上，我们只提供了<code>Date</code>的值，所以还需要通过<code>TypeDescriptor</code>将字段的附加信息传递进去，这样才能正确识别到字段上的注解。</p></li></ol><h2 id="自定义Formatter"><a href="#自定义Formatter" class="headerlink" title="自定义Formatter"></a>自定义<code>Formatter</code></h2><p>除了Spring 给我们提供的这些<code>Formatter</code>之外，我们还可以自定义来实现特殊功能。</p><p>比如前台传过来一段字符串，我们根据正则表达式截取部分字符。</p><h3 id="定义StringFormat注解"><a href="#定义StringFormat注解" class="headerlink" title="定义StringFormat注解"></a>定义<code>StringFormat</code>注解</h3><p>此注解用来标注该字段需要用我们的自定义逻辑。可以指定具体的正则表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> StringFormat &#123;</span><br><span class="line">    <span class="function">String <span class="title">pattern</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义StringFormatAnnotationFormatterFactory"><a href="#定义StringFormatAnnotationFormatterFactory" class="headerlink" title="定义StringFormatAnnotationFormatterFactory"></a>定义<code>StringFormatAnnotationFormatterFactory</code></h3><p>此类实现<code>AnnotationFormatterFactory</code>接口，规定<code>StringFormat</code>注解支持的字段类型。我们使用正则分隔字符串，那么可能得到多个目标串，所以<code>getFieldTypes</code>返回<code>List</code>来接收目标类型。<code>getParser</code>方法返回我们的自定义<code>StringFormatFormatter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The types of fields that may be annotated with the &amp;lt;A&amp;gt; annotation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getFieldTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> Set.of(List.class, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the Printer to print the value of a field of &#123;<span class="doctag">@code</span> fieldType&#125; annotated with</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> annotation&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the type T the printer accepts is not assignable to &#123;<span class="doctag">@code</span> fieldType&#125;, a</span></span><br><span class="line"><span class="comment">     * coercion from &#123;<span class="doctag">@code</span> fieldType&#125; to T will be attempted before the Printer is invoked.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotation the annotation instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldType  the type of field that was annotated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the printer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Printer&lt;?&gt; getPrinter(StringFormat annotation, Class&lt;?&gt; fieldType) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringFormatFormatter(annotation.pattern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the Parser to parse a submitted value for a field of &#123;<span class="doctag">@code</span> fieldType&#125;</span></span><br><span class="line"><span class="comment">     * annotated with &#123;<span class="doctag">@code</span> annotation&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the object the parser returns is not assignable to &#123;<span class="doctag">@code</span> fieldType&#125;,</span></span><br><span class="line"><span class="comment">     * a coercion to &#123;<span class="doctag">@code</span> fieldType&#125; will be attempted before the field is set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotation the annotation instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldType  the type of field that was annotated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the parser</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Parser&lt;?&gt; getParser(StringFormat annotation, Class&lt;?&gt; fieldType) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringFormatFormatter(annotation.pattern());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="自定义-StringFormatFormatter"><a href="#自定义-StringFormatFormatter" class="headerlink" title="自定义 StringFormatFormatter"></a>自定义 <code>StringFormatFormatter</code></h3><p>该类实现<code>Formatter</code>。用来负责具体的解析逻辑。该类需要使用到注解中定义的正则表达式，这样我们就可以灵活控制每个字段的转换规则了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StringFormatFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span>&lt;<span class="title">Collection</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Pattern pattern;</span><br><span class="line">         StringFormatFormatter(String pattern) &#123;</span><br><span class="line">            <span class="keyword">this</span>.pattern = Pattern.compile(pattern);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Parse a text String to produce a T.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> text   the text string</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> locale the current user locale</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> an instance of T</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> ParseException           when a parse exception occurs in a java.text parsing library</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalArgumentException when a parse exception occurs</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection <span class="title">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Matcher matcher = pattern.matcher(text);</span><br><span class="line">            <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">                list.add(matcher.group());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>将我们的<code>Formatter</code>注册到<code>FormattingConversionService</code>，遇到对应的转换，则会调用我们的<code>Formatter</code>。下面的例子中<code>StringFormatEntity</code>类使用到了自定义的<code>StringFormat</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@StringFormat(pattern = &quot;\\d+&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; formats;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFormatterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">//注册 StringFormatAnnotationFormatterFactory </span></span><br><span class="line">        DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService();</span><br><span class="line">        conversionService.addFormatterForFieldAnnotation(<span class="keyword">new</span> StringFormatAnnotationFormatterFactory());</span><br><span class="line">        StringFormatEntity formatEntity = <span class="keyword">new</span> StringFormatEntity();</span><br><span class="line">        System.out.println(<span class="string">&quot;自定义注解格式化：&quot;</span> + conversionService.convert(<span class="string">&quot;fff43ffd344&quot;</span>, TypeDescriptor.valueOf(String.class) , <span class="keyword">new</span> TypeDescriptor(formatEntity.getClass().getDeclaredField(<span class="string">&quot;formats&quot;</span>))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义注解格式化：[43, 344]</span></span><br></pre></td></tr></table></figure><p>从打印出来的结果可以看出来已经正确将字符串转换成了<code>List</code>。不过<code>List</code>中都是字符串，我们还可以将字符串转换成数字类型。需要我们来主动转换吗？其实是不需要的，Spring 已经帮我们考虑到了此种情景，可以自动将<code>List</code>中的元素也转换成对应的类型。还记得<code>CollectionToCollectionConverter</code>这个转换器吗？不过有个细节要注意：**我们的<code>Formatter</code>返回的结果不能是<code>ArrayList</code>， 这样会丢失泛型，不能正确转换，所以我们可以返回<code>ArrayList</code>的子类<code>List&lt;String&gt; list = new ArrayList&lt;&gt;()&#123;&#125;;</code>， 这样会保留泛型，会调用后续的<code>Converter</code>**。</p><h2 id="Converter-的注册与获取"><a href="#Converter-的注册与获取" class="headerlink" title="Converter 的注册与获取"></a><code>Converter </code>的注册与获取</h2><p>主要通过<code>ConverterRegistry</code>和<code>FormatterRegistry</code>来注册以及移除<code>Converter</code>。</p><h3 id="ConverterRegistry-1"><a href="#ConverterRegistry-1" class="headerlink" title="ConverterRegistry"></a><code>ConverterRegistry</code></h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ol><li><p><code>void addConverter(Converter&lt;?, ?&gt; converter)</code>：注册简单的<code>Converter</code>，转换类型从<code>Converter</code>的泛型中获取。</p></li><li><p><code>&lt;S, T&gt; void addConverter(Class&lt;S&gt; sourceType, Class&lt;T&gt; targetType, Converter&lt;? super S, ? extends T&gt; converter)</code>： 注册普通转换器，并且明确指定可转换类型。</p><p>可以针对多个不同转换类型的情况重用<code>Converter</code>，而不必为每个对创建<code>Converter</code>类。指定的源类型是<code>Converter</code>定义的类型的子类型，目标类型是<code>Converter</code>定义的类型的父类型。为什么要如此定义？拿Spring提供的<code>ObjectToStringConverter</code>为例，该<code>Converter</code>定义的转换类型为<code>Object</code> -&gt; <code>String</code>，调用<code>Object.toString()</code>方法，只要是<code>Object</code>的子类，都可以调用此方法转换成<code>String</code>，因为<code>toString()</code>是共有的方法。同理，目标类型指定的类型需要是我定义的父类型，这样转换出来的一定是需要的类型。</p></li><li><p><code>void addConverter(GenericConverter converter)</code>：注册<code>GenericConverter </code>。</p></li><li><p><code>void addConverterFactory(ConverterFactory&lt;?, ?&gt; factory)</code>：注册<code>ConverterFactory</code>。</p></li><li><p><code>void removeConvertible(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</code>：移除<code>sourceType</code>到<code>targetType</code>的转换功能。</p></li></ol><h3 id="GenericConversionService"><a href="#GenericConversionService" class="headerlink" title="GenericConversionService"></a><code>GenericConversionService</code></h3><p><code>GenericConversionService</code>类实现了<code>ConverterRegistry</code>接口。现在看一下具体的注册过程。</p><ol><li><p><code>void addConverter(Converter&lt;?, ?&gt; converter)</code>：</p><p>因为没有指定转换类型，所以只能从<code>Converter</code>的泛型中获取转换类型，如果获取不到，则会抛出异常。获取到之后，则会创建<code>ConverterAdapter</code>实例，通过<code>void addConverter(GenericConverter converter)</code>方法进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ResolvableType[] typeInfo = getRequiredTypeInfo(converter.getClass(), Converter.class);</span><br><span class="line"><span class="comment">//如果是代理对象，还需要从代理类中获取</span></span><br><span class="line"><span class="keyword">if</span> (typeInfo == <span class="keyword">null</span> &amp;&amp; converter <span class="keyword">instanceof</span> DecoratingProxy) &#123;</span><br><span class="line">    typeInfo = getRequiredTypeInfo(((DecoratingProxy) converter).getDecoratedClass(), Converter.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (typeInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to determine source type &lt;S&gt; and target type &lt;T&gt; for your &quot;</span> + <span class="string">&quot;Converter [&quot;</span> + converter.getClass().getName() + <span class="string">&quot;]; does the class parameterize those types?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">addConverter(<span class="keyword">new</span> ConverterAdapter(converter, typeInfo[<span class="number">0</span>], typeInfo[<span class="number">1</span>]));</span><br></pre></td></tr></table></figure></li><li><p><code>&lt;S, T&gt; void addConverter(Class&lt;S&gt; sourceType, Class&lt;T&gt; targetType, Converter&lt;? super S, ? extends T&gt; converter)</code>：</p><p>由于指定了转换类型，直接注册就完事了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addConverter(<span class="keyword">new</span> ConverterAdapter(converter, ResolvableType.forClass(sourceType), ResolvableType.forClass(targetType)));</span><br></pre></td></tr></table></figure></li><li><p><code>void addConverterFactory(ConverterFactory&lt;?, ?&gt; factory)</code>：</p><p>也是先从泛型中推断出转换的类型，然后创建<code>ConverterFactoryAdapter</code>实例进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ResolvableType[] typeInfo = getRequiredTypeInfo(factory.getClass(), ConverterFactory.class);</span><br><span class="line"><span class="keyword">if</span> (typeInfo == <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> DecoratingProxy) &#123;</span><br><span class="line">    typeInfo = getRequiredTypeInfo(((DecoratingProxy) factory).getDecoratedClass(), ConverterFactory.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (typeInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to determine source type &lt;S&gt; and target type &lt;T&gt; for your &quot;</span> + <span class="string">&quot;ConverterFactory [&quot;</span> + factory.getClass().getName() + <span class="string">&quot;]; does the class parameterize those types?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">addConverter(<span class="keyword">new</span> ConverterFactoryAdapter(factory,  <span class="keyword">new</span> ConvertiblePair(typeInfo[<span class="number">0</span>].toClass(), typeInfo[<span class="number">1</span>].toClass())));</span><br></pre></td></tr></table></figure></li><li><p><code>void addConverter(GenericConverter converter)</code>：</p><p>上面几种注册方式最终都会调用此方法，也就是说会将<code>Converter</code>、<code>ConverterFactory</code>转换成<code>GenericConverter </code>。这里使用到了<code>适配器模式</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加到内部容器中去</span></span><br><span class="line"><span class="keyword">this</span>.converters.add(converter);</span><br><span class="line"><span class="comment">//使缓存失效</span></span><br><span class="line">invalidateCache();</span><br></pre></td></tr></table></figure></li></ol><h3 id="ConverterAdapter适配器"><a href="#ConverterAdapter适配器" class="headerlink" title="ConverterAdapter适配器"></a><code>ConverterAdapter</code>适配器</h3><p>实现了<code>ConditionalGenericConverter</code>接口，将<code>Converter</code>转换成<code>GenericConverter</code>。在<code>matches</code>方法去判断转换类型是否匹配。转换时直接调用内部转换器的转换方法。</p><h3 id="ConverterFactoryAdapter适配器"><a href="#ConverterFactoryAdapter适配器" class="headerlink" title="ConverterFactoryAdapter适配器"></a><code>ConverterFactoryAdapter</code>适配器</h3><p>实现了<code>ConditionalGenericConverter</code>接口，将<code>ConverterFactoryAdapter</code>转换成<code>GenericConverter</code>。在<code>matches</code>方法去判断转换类型是否匹配。转换时直接调用内部<code>ConverterFactory</code>获取的转换器的转换方法。</p><h3 id="ConvertiblePair"><a href="#ConvertiblePair" class="headerlink" title="ConvertiblePair"></a><code>ConvertiblePair</code></h3><p>该类保存了转换的源类型和目标类型，并重写了<code>equals</code>和<code>hashCode</code>方法用于比较。<code>GenericConverter</code>返回<code>ConvertiblePair</code>集合表示所支持的转换类型。</p><h3 id="Converters"><a href="#Converters" class="headerlink" title="Converters"></a><code>Converters</code></h3><p>此类用来管理所有注册的<code>Converter</code>。提供添加和删除的功能。添加时获取到此<code>Converter</code>支持的类型，如果为空并且是<code>ConditionalConverter</code>，则代表它支持所有类型。得到支持的类型后，遍历每个类型，获取到已经注册的<code>ConvertersForPair</code>，该类维护转换类型到<code>Converter</code>之间的关系，而且是一对多的关系，也就是说同一种转换类型，会存在多个<code>Converter</code>。拿到<code>ConvertersForPair</code>后，将该<code>Converter</code>添加进去，后添加的会在前面，获取时符合条件时会优先返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(GenericConverter converter)</span> </span>&#123;</span><br><span class="line">    Set&lt;ConvertiblePair&gt; convertibleTypes = converter.getConvertibleTypes();</span><br><span class="line">    <span class="keyword">if</span> (convertibleTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Assert.state(converter <span class="keyword">instanceof</span> ConditionalConverter,</span><br><span class="line">                     <span class="string">&quot;Only conditional converters may return null convertible types&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.globalConverters.add(converter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ConvertiblePair convertiblePair : convertibleTypes) &#123;</span><br><span class="line">            ConvertersForPair convertersForPair = getMatchableConverters(convertiblePair);</span><br><span class="line">            <span class="comment">//后添加的在前面</span></span><br><span class="line">            convertersForPair.add(converter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FormatterRegistry注册-Formatter"><a href="#FormatterRegistry注册-Formatter" class="headerlink" title="FormatterRegistry注册    Formatter"></a><code>FormatterRegistry</code>注册<code>    Formatter</code></h3><p>继承自<code>ConverterRegistry</code>接口，增加了注册<code>Formmater</code>的方法。</p><h3 id="FormattingConversionService-1"><a href="#FormattingConversionService-1" class="headerlink" title="FormattingConversionService"></a><code>FormattingConversionService</code></h3><p>该类继承自<code>GenericConversionService</code>类，并实现了<code>FormatterRegistry</code>接口。在添加<code>Formatter</code>时会将其转换为<code>PrinterConverter</code>，<code>ParserConverter</code>。在添加<code>AnnotationFormatterFactory</code>转换为<code>AnnotationPrinterConverter</code>和<code>AnnotationParserConverter</code>。可以想象到这四个类也是实现了<code>Converter</code>，最终通过<code>convert</code>方法来调用<code>parse</code>和<code>print</code>方法。</p><h3 id="获取Converter"><a href="#获取Converter" class="headerlink" title="获取Converter"></a>获取<code>Converter</code></h3><p>在<code>GenericConversionService</code>的转换过程中，来了一个转换类型，需要获取到对应的<code>Converter</code>。在<code>Converters</code>的<code>find</code>方法中先拿到源类型和目标类型继承的所有类型（包括接口），比如说源类型是<code>String</code>，那么获取到的就是<code>String</code>、<code>Serializable</code>、<code>Comparable</code>、<code>CharSequence</code>和<code>Object</code>，如果是枚举还将获取到<code>Enum</code>。找到之后一一进行组合去获取<code>Converter</code>，比如目标类型是<code>Integer</code>，则第一次组合就是<code>String</code>-&gt;<code>Integer</code>，如果找到了支持<code>String</code>-&gt;<code>Integer</code>的<code>Converter</code>，则会返回这个。这么做的目的是支持一个<code>Converter</code>可以转换多个类型，比如<code>String</code>-&gt; <code>Enum</code>，通过字面量转换成枚举，如果没有这个机制，那么我们就得为每个枚举都定义一个<code>Converter</code>，但是有了这个机制，我们就可以支持所有的枚举类型。其实就是通过这个机制来支持<code>ConverterFactory</code>。这个机制可以保证子类可以通过父类转换器进行转换（这种转换方式需要注意父类无法感知子类的特殊属性），但不能保证父类可以通过子类转换器，如果可以保证<code>Converter</code>能正确转换，则可以通过<code>&lt;S, T&gt; void addConverter(Class&lt;S&gt; sourceType, Class&lt;T&gt; targetType, Converter&lt;? super S, ? extends T&gt; converter)</code>方法显式进行注册。比如我们只有<code>String</code>-&gt;<code>Integer</code>的<code>Converter</code>，但是我们需要将<code>String</code>转换为<code>Number</code>，则可以通过这个方法注册<code>addConverter(String.class, Number.class, StringToIntegerConverter)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DefaultConversionService conversionService = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line"><span class="comment">//先去掉内置的转换器</span></span><br><span class="line">conversionService.removeConvertible(String.class, Number.class);</span><br><span class="line"><span class="comment">//再注册上我们自己定义的 String -&gt; Integer</span></span><br><span class="line">conversionService.addConverter(<span class="keyword">new</span> StringToIntegerConverter());</span><br><span class="line">System.out.println(conversionService.convert(<span class="string">&quot;1&quot;</span>, Number.class));</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种情况下是无法正确转换的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是通过这个方法显式注册之后可以正确转换</span></span><br><span class="line">conversionService.addConverter(String.class, Number.class, <span class="keyword">new</span> StringToIntegerConverter());</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>下面是查找的大致过程：</p><p><img src="/post/504e/%E6%9F%A5%E6%89%BEconverter.png" alt="查找converter的图示"></p><h1 id="DirectFieldAccessor"><a href="#DirectFieldAccessor" class="headerlink" title="DirectFieldAccessor"></a><code>DirectFieldAccessor</code></h1><p>通过反射直接访问Bean实例的字段。可以直接绑定到字段，而不需要通过JavaBean set方法。</p><p>从Spring 4.2开始，绝大多数<code>BeanWrapper</code>特性已经被合并到<code>AbstractPropertyAccessor</code>中，这意味着这个类也支持属性遍历以及集合和Map 访问。</p><p><code>DirectFieldAccessor</code>的<code>extractOldValueForEditor</code>属性默认为<code>true</code>，因为在读取字段的时候是直接通过反射去拿到的字段值，不需要调用<code>getter</code>方法。</p><h1 id="PropertyAccessorFactory"><a href="#PropertyAccessorFactory" class="headerlink" title="PropertyAccessorFactory"></a><code>PropertyAccessorFactory</code></h1><p>可以通过此类来获取<code>BeanWrapper</code>和<code>DirectFieldAccessor</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> BeanWrapper </tag>
            
            <tag> Converter </tag>
            
            <tag> Formatter </tag>
            
            <tag> ConversionService </tag>
            
            <tag> 类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bean初始化</title>
      <link href="/post/72a3/"/>
      <url>/post/72a3/</url>
      
        <content type="html"><![CDATA[<h1 id="Bean初始化过程"><a href="#Bean初始化过程" class="headerlink" title="Bean初始化过程"></a>Bean初始化过程</h1><p>如果说配置文件好比菜谱，解析配置文件好比洗菜、切菜，那么Bean初始化过程就好比炒菜的过程。Spring的核心基础就建立在对Bean的管理功能上。如何定义一个Bean，如何获取一个Bean，如何初始化一个Bean，如何销毁一个Bean。</p><h2 id="getBean方法-–-炒菜开始的信号"><a href="#getBean方法-–-炒菜开始的信号" class="headerlink" title="getBean方法 – 炒菜开始的信号"></a><code>getBean</code>方法 – 炒菜开始的信号</h2><p>想象一下<code>getBean</code>的场景，好比是食客点了一道菜（或者说菜单是由食客提供的，厨房代加工），厨房根据菜单做菜。想象一下在这个过程中需要做哪些工作？</p><ol><li>按照菜谱准备菜 – 解析配置文件</li><li>洗菜，切菜 - - 注册Bean定义</li><li>炒菜 – Bean 初始化</li><li>添加额外的佐料 – 动态注册Bean定义</li></ol><p>第1，2步可以看成是同时进行的，边准备菜，边洗菜切菜也就是边解析边注册。<code>getBean</code> 方法由<code>BeanFactory</code>接口提供。</p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a><code>BeanFactory</code></h2><p><code>BeanFactory</code>接口是整个Spring容器的核心接口。提供了多个获取 Bean 的方法。</p><ul><li>Object getBean(String name) throws BeansException;</li><li><T> T getBean(String name, Class<T> requiredType) throws BeansException;</T></T></li><li>Object getBean(String name, Object… args) throws BeansException;</li><li><T> T getBean(Class<T> requiredType) throws BeansException;</T></T></li><li><T> T getBean(Class<T> requiredType, Object… args) throws BeansException;</T></T></li><li><T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);</T></T></T></li><li><T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType);</T></T></li></ul><p>前三个是通过Bean的名字来获取，后面的是通过Bean的Class类型来获取。</p><h3 id="通过名称获取Bean"><a href="#通过名称获取Bean" class="headerlink" title="通过名称获取Bean"></a>通过名称获取Bean</h3><p>在Spring容器中，Bean的名字(id )是唯一的。</p><ol><li><p>先处理名称，获取真正的Bean的名称。</p><ol><li><p>如果 name 以 <code>&amp;</code>开头，去掉<code>&amp;</code>。</p></li><li><p>处理别名。参数有可能是别名，得跟据别名找到实际注册的 Bean 名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先看一下别名的结构</span></span><br><span class="line"><span class="comment">// aliasA ---&gt;  name</span></span><br><span class="line"><span class="comment">// aliasB ---&gt; name</span></span><br><span class="line"><span class="comment">// name ---&gt; realName</span></span><br><span class="line"><span class="comment">//name 也可以作为别名来注册，但是不能存在 name 和 alias正好相反的一对注册情况。也就是 alias --&gt; anme, name ---&gt; alias这样成对的出现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">canonicalName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">String canonicalName = name;</span><br><span class="line"><span class="comment">// Handle aliasing...</span></span><br><span class="line">String resolvedName;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 把参数当作别名来取出name, 如果能取到，说明当前参数是别名。将取到的值当作别名，继续取，如果不能取到值，那么这个就是真正的bean的名字了;如果还能取到，那么这个也是别名，重复这个过程，直到不能取到值为止。</span></span><br><span class="line">            resolvedName = <span class="keyword">this</span>.aliasMap.get(canonicalName);</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> (resolvedName != <span class="keyword">null</span>) &#123;</span><br><span class="line">canonicalName = resolvedName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (resolvedName != <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">return</span> canonicalName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>检查单例缓存中的单例。也就是说先看看有没有创建好的单例，有的就返回这个单例进一步处理。</p></li><li><p>没有在单例缓存中获取到Bean，那么就检查父容器中有没有这个Bean定义。当父容器中有这个Bean定义，并且当前容器中没有此Bean定义时，就从父容器中获取。如果父容器中没有，则从当前容器获取。</p></li><li><p>拿到Bean的定义，先对依赖Bean调用<code>getBean</code>方法。</p></li><li><p>如果Bean定义是单例<code>singleton</code>，则创建单例。如果是原型<code>prototype</code>，则创建Bean。如果是其他的scope作用域，则调用scope的<code>get</code>方法。这里可以看出，我们可以自已定义<code>scope</code>来扩展Spring提供的几种<code>scope</code>。具体的创建Bean的过程都会调用<code>createBean</code>方法。</p></li><li><p>拿到实例对象之后，如果获取时传了类型，那么将使用<code>TypeConverter</code>进行类型转换，如果转换成功，则返回这个Bean，否则将抛出异常。</p></li></ol><h3 id="通过Class-类型获取Bean"><a href="#通过Class-类型获取Bean" class="headerlink" title="通过Class 类型获取Bean"></a>通过Class 类型获取Bean</h3><p>在Spring中Bean的名称才是唯一的标识，所以根据类型获取Bean，会先获取到所有该类型的Bean 的名称。</p><ol><li>获取符合类型的Bean名称。如果有泛型的话，调用<code>doGetBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit)</code>方法；没有泛型则调用<code>getBeanNamesForType(@Nullable Class&lt;?&gt; type, boolean includeNonSingletons, boolean allowEagerInit)</code>方法。找到一个那就恭喜了。</li><li>如果获取的Bean名称多于1个，则需要根据优先权选择出一个名称，然后再跟据这个名称去获取Bean。</li></ol><h3 id="Bean-实例化"><a href="#Bean-实例化" class="headerlink" title="Bean 实例化"></a>Bean 实例化</h3><p>Bean的创建以及实例化</p><p>作为一个可扩展的框架，Spring在Bean实例化的过程中预留了大量的扩展点用于对框架进行扩展。包括修改Bean定义，获取对象类型，实例化之前，实例化的方式，实例化之后，初始化之前，初始化，初始化之后等方面。具体在<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</code>方法中实现。</p><p>参数： </p><ul><li><code>String beanName</code>: Bean的名称。</li><li><code>RootBeanDefinition mbd</code>: Bean定义。就像菜谱。</li><li><code>Object[] args</code>: 获取Bean时的参数</li></ul><p>大致过程如下：</p><ol><li><p>调用<code>InstantiationAwareBeanPostProcessor</code>接口方法。此接口继承自<code>BeanPostProcessor</code>，在实例化前和实例化后显式属性设置或自动装配发生之前调用。<br>通常用于禁止特定目标bean的默认实例化，例如创建具有特殊目标源的代理对象(池化目标、延迟初始化目标等)，或者实现额外的注入策略，如字段注入。注意: 此接口是一个专用接口，主要用于框架内部使用。建议尽可能实现简单的<code>BeanPostProcessor</code>接口，或者继承<code>InstantiationAwareBeanPostProcessorAdapter</code>，以便屏蔽对该接口的扩展。</p><ul><li><p><code>postProcessBeforeInstantiation</code> : 在实例化目标bean之前调用。默认实现返回null。返回的bean对象可以代替目标bean用作代理，从而有效地阻止了目标bean的默认实例化。<br>如果此方法返回非空对象，则bean创建过程将短路，不会再调用其他<code>InstantiationAwareBeanPostProcessor</code>的<code>postProcessBeforeInstantiation</code> 方法。进一步调用<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization</code>方法， 如果某个<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization</code>方法返回了<code>null</code>，则将返回上一个不为<code>null</code>的对象。<br>此方法仅应用于具有bean类的bean定义。尤其是不会应用于带有工厂方法的bean。后处理器可以实现<code>SmartInstantiationAwareBeanPostProcessor</code>接口，以便预测它们将在这里返回的bean对象的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">                <span class="comment">//任意一个返回了非null对象，将导致后续的不会执行</span></span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>postProcessAfterInitialization</code>: 当<code>postProcessBeforeInstantiation</code> 方法返回了非<code>null</code>对象时，则会调用此方法做进一步的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">Object result = existingBean;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">            <span class="comment">//如果当前postProcessAfterInitialization方法返回的为null,则直接返回上一个的结果</span></span><br><span class="line"><span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//否则继续调用下一个处理器</span></span><br><span class="line">result = current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果第1步中得到的Bean不为空，则直接会使用这个Bean，不会再调用后续的初始化过程。正如第一步中所说，<code>InstantiationAwareBeanPostProcessor</code>接口主要创建目标Bean的代理对象等。</p></li><li><p>如果第1步中得到的Bean为空，则走常规初始化过程。先创建Bean实例：</p><ol><li><p>从Spring 5.0开始加了<code>Supplier</code>方式来创建Bean。</p></li><li><p>工厂方法，可以是静态工厂，也可以是工厂Bean。找到对应的工厂方法过程有点儿复杂，主要是方法名和参数匹配。</p></li><li><p>从<code>SmartInstantiationAwareBeanPostProcessor</code>接口和Bean定义配置中的优先构造函数。再从获取到的构造函数中选出一个调用。</p></li><li><p>调用默认构造函数</p></li></ol></li><li><p>Bean已经创建出来了，接下来就是初始化这个Bean。先调用后处理器<code>MergedBeanDefinitionPostProcessor</code>接口的<code>postProcessMergedBeanDefinition</code>方法处理Bean定义。此接口用于在运行时对合并的bean定义（原始bean定义的已处理副本）进行后处理。</p><p>例如，<code>postProcessMergedBeanDefinition</code>方法可以内省bean定义，以便实际在对bean实例进行后的处理操作之前准备一些缓存的元数据，并且这个接口还允许修改bean定义。</p></li><li><p>提前暴露Bean，用于解决循环依赖问题，这个时候的Bean基本是个空的Bean。关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br></pre></td></tr></table></figure><p>先将Bean添加到一个Map中，后面取依赖Bean的时候会先检查这个Map。</p></li><li><p>真正初始化的过程。包括<code>InstantiationAwareBeanPostProcessor</code>接口<code>postProcessBeforeInitialization</code>方法，属性填充，Aware接口，<code>BeanPostProcessor</code>接口<code>postProcessBeforeInitialization</code>方法，<code>InitializingBean</code>的<code>afterPropertiesSet</code>方法，自定义init方法调用，调用<code>BeanPostProcessor</code>接口<code>postProcessAfterInitialization</code>方法。</p></li><li><p>注册<code>DisposableBean</code>， 当Bean销毁时回调。</p></li></ol><p>可以看一下下面的流程图，对实例化过程有个大概的了解。</p><p><img src="/post/72a3/Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="Bean实例化过程"></p><h3 id="初始化过程中的扩展点"><a href="#初始化过程中的扩展点" class="headerlink" title="初始化过程中的扩展点"></a>初始化过程中的扩展点</h3><p>这里只区分实例化和初始化两个阶段。可以看一下图：</p><p><img src="/post/72a3/Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%BB%84%E4%BB%B6%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4.png" alt="Bean实例化过程中组件作用范围"></p><h4 id="实例化之前"><a href="#实例化之前" class="headerlink" title="实例化之前"></a>实例化之前</h4><p>在实例化之前<code>InstantiationAwareBeanPostProcessor</code>有机会去阻拦常规的初始化流程，可以创建我们的代理对象。主要涉及到<code>Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)</code>和<code>Object postProcessAfterInitialization(Object bean, String beanName)</code>方法。这里<code>Object postProcessAfterInitialization(Object bean, String beanName)</code>方法实际上是<code>BeanPostProcessor</code>接口的方法，主要用在Bean初始化后做一些自定义操作。<strong>这个方法其实应该归到初始化之后阶段</strong>。</p><p>如果上面返回的是<code>null</code>，那么则走常规实例化流程。需要的话可以从<code>SmartInstantiationAwareBeanPostProcessor</code>接口的<code>Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName)</code>方法中返回构造方法。</p><h4 id="实例化之后"><a href="#实例化之后" class="headerlink" title="实例化之后"></a>实例化之后</h4><p>通过<code>MergedBeanDefinitionPostProcessor</code>接口<code>postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</code>方法获得修改Bean定义的机会，也可以通过这个方法缓存一些数据，辅助后面的初始化过程。</p><h4 id="初始化之前"><a href="#初始化之前" class="headerlink" title="初始化之前"></a>初始化之前</h4><p>通过<code>InstantiationAwareBeanPostProcessor</code>接口boolean postProcessAfterInstantiation(Object bean, String beanName)方法可以阻止(<code>return false</code>)接下来的属性设置过程。通过该接口<code>PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)</code>方法处理需要设置的属性。</p><p><code>TypeConverter</code> 接口进行属性值的类型转换。XML中配置的属性值是字符串形式的，需要转换成对应的属性类型。</p><p>调用<code>BeanNameAware</code>、<code>BeanClassLoaderAware</code>、<code>BeanFactoryAware</code>的设置方法。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>可以将上面的属性设置、Aware接口归到初始化阶段里。</p><p>调用<code>BeanPostProcessor</code>的<code>Object postProcessBeforeInitialization(Object bean, String beanName)</code>方法。</p><p>如果Bean实现了<code>InitializingBean</code>接口，则会调用<code>afterPropertiesSet</code>方法。或者调用自定义的初始化方法。</p><p>调用<code>BeanPostProcessor</code>接口的<code>Object postProcessAfterInitialization(Object bean, String beanName)</code>方法。</p><h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><p>如果Bean注册了销毁方法，则会注册为<code>DisposableBean</code>，当Bean销毁时会调用此方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Bean </tag>
            
            <tag> 初始化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错误: 未报告的异常错误X; 必须对其进行捕获或声明以便抛出</title>
      <link href="/post/e88/"/>
      <url>/post/e88/</url>
      
        <content type="html"><![CDATA[<p>今天在jdk8环境中碰到一个诡异的异常：</p><blockquote><p>错误: 未报告的异常错误X; 必须对其进行捕获或声明以便抛出</p></blockquote><p>jdk8方便是方便，但是有点儿不好排查问题。看提示应该是有个方法抛出了异常，只能按方法去排查了。最后在<code>java.util.Optional#orElseThrow</code>方法中找到了疑似代码。<br><code>java.util.Optional#orElseThrow</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;X extends Throwable&gt; <span class="function">T <span class="title">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法参数为异常产生器，X是<code>Throwable</code>的子类。</p><p>我的原始写法是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.orElseThrow(() -&gt; &#123;<span class="keyword">throw</span> <span class="keyword">new</span> MaterialException(<span class="string">&quot;&quot;</span>);&#125;)</span><br></pre></td></tr></table></figure><p>本地<code>jdk1.8_111</code>版本可以正常编绎，但是在服务器<code>jdk1.8_152</code>、<code>jdk1.8_65</code>上编绎出现上述异常。<br>尝试换了几种写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.orElseThrow(() -&gt; &#123;<span class="keyword">return</span> <span class="keyword">new</span> MaterialException(<span class="string">&quot;&quot;</span>);&#125;)</span><br><span class="line">.orElseThrow(MaterialException::<span class="keyword">new</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按说上面几种写法语法上是差不多的，都出现异常。</p><p>最后在<a href="https://stackoverflow.com/questions/25523375/java8-lambdas-and-exceptions">stackoverflow</a>上找到了一些信息。这应该是jdk的一个bug，解决方案是在加上异常限定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&lt;MaterialException&gt;orElseThrow(() -&gt; &#123;<span class="keyword">return</span> <span class="keyword">new</span> MaterialException(<span class="string">&quot;&quot;</span>);&#125;)</span><br></pre></td></tr></table></figure><p>IDEA会提示此限定是不必要的。<em>其他版本未做测试。</em> 希望后期这个bug能修复。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring bean定义文件解析</title>
      <link href="/post/172b/"/>
      <url>/post/172b/</url>
      
        <content type="html"><![CDATA[<h1 id="Bean-定义文件的解析"><a href="#Bean-定义文件的解析" class="headerlink" title="Bean 定义文件的解析"></a>Bean 定义文件的解析</h1><h2 id="初始化工厂"><a href="#初始化工厂" class="headerlink" title="初始化工厂"></a>初始化工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化一个bean 工厂</span></span><br><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"><span class="comment">// 2. 初始化XmlBeanDefinitionReader,负责从xml文件中读取bean定义</span></span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line"><span class="comment">// 3. 加载bean 定义的入口方法</span></span><br><span class="line">reader.loadBeanDefinitions(<span class="string">&quot;classpath:app.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>上述代码使用起来很简单，创建一个工厂和阅读器，传入配置文件的位置。</p><p>我们可以考虑一下，这些代码做了什么。</p><ol><li>XmlBeanDefinitionReader 是如何定位配置文件的?</li><li>如何解析配置文件的？</li><li>XmlBeanDefinitionReader的构造函数传入了一个BeanDefinitionRegistry对象，这个对象是用来注册bean定义的，那么是如何注册的呢？</li></ol><h2 id="ResourceLoader-定位资源文件"><a href="#ResourceLoader-定位资源文件" class="headerlink" title="ResourceLoader 定位资源文件"></a>ResourceLoader 定位资源文件</h2><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>Spring将各种资源统一抽象为<code>Resource</code>,并使用<code>ResourceLoader</code>来定位<code>Resource</code>。如果资源以物理形式存在，那么它可以为每个资源打开一个InputStream，但是URL或文件句柄只能由某些特定资源返回。实际的行为取决于实现类。</p><h4 id="Resource的结构"><a href="#Resource的结构" class="headerlink" title="Resource的结构"></a><code>Resource</code>的结构</h4><p>下面是Resource的类关系图</p><p><img src="/post/172b/resource%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="resource类关系图"></p><p>下面是Resource的类结构图</p><p><img src="/post/172b/resource%E7%BB%93%E6%9E%84.png" alt="resource结构"></p><p><code>Resource</code>继承自<code>InputStreamSource</code>, 得到了获取<code>InputStream</code>的能力，可以以流的形式读取资源文件。</p><p>定义的方法：</p><ul><li>boolean exists()：确定此资源是实际物理存在。此方法执行确定的存在性检查，而资源句柄的存在仅保证有效的描述符句柄。</li><li>boolean isReadable()：指示是否可以通过<code>getInputStream()</code>读取此资源的非空内容。对于存在的典型资源描述符会返回<code>true</code>，因为从5.1开始它严格地暗示了<code>exist()</code>语义。请注意，在尝试读取实际内容时仍然可能失败。但是，如果返回值为<code>false</code>，则表示资源内容无法读取。</li><li>boolean isOpen(): 指示此资源是否表示具有打开流的句柄。如果为<code>true</code>，则不能多次读取InputStream，必须读取并关闭该资源，以避免资源泄漏。对于典型的资源描述符将为false。</li><li>boolean isFile()：确定此资源是否表示文件系统中的文件。返回<code>true</code>标志着(但不保证)<code>getFile()</code>将调用成功。<br>这在默认情况下返回<code>false</code>.</li><li>URL getURL(): 返回此资源的URL句柄。</li><li>URI getURI(): 返回此资源的URI句柄。</li><li>File getFile(): 返回此资源的文件句柄。如果资源不能被解析为绝对文件路径，也就是说，如果资源在文件系统中不可用将抛出<code>FileNotFoundException</code>异常。</li><li>ReadableByteChannel readableChannel()：返回一个<code>ReadableByteChannel</code>。希望每次调用都创建一个新的通道。<br>默认实现返回<code>Channels.newChannel(getInputStream())</code>。</li><li>long contentLength()：确定此资源的内容长度。</li><li>long lastModified()：确定此资源最后修改的时间戳。</li><li>Resource createRelative(String relativePath)：创建与此资源相对路径的资源。</li><li>String getFilename()：确定此资源的文件名，通常是路径的最后一部分:例如，“myfile.txt”。如果此类资源没有文件名，则返回<code>null</code>。</li><li>String getDescription(): 返回此资源的描述，用于处理该资源时的错误输出。实现类可以从它们的<code>toString</code>方法返回这个值。</li></ul><h4 id="Resource-的子接口"><a href="#Resource-的子接口" class="headerlink" title="Resource 的子接口"></a>Resource 的子接口</h4><h5 id="ContextResource"><a href="#ContextResource" class="headerlink" title="ContextResource"></a>ContextResource</h5><p>用于从封闭的“上下文”(例如从<code>javax.servlet.ServletContext</code>)加载资源的扩展接口，也可以从普通类路径或相对于文件系统路径(没有显式指定前缀，因此应用于相对于本地<code>ResourceLoader</code>的上下文)。</p><p>定义的方法：</p><ul><li>String getPathWithinContext()：返回包含在“上下文”中的路径。通常是相对于上下文特定的根目录的路径，例如<code>ServletContext</code>根目录或<code>PortletContext</code>根目录。</li></ul><h5 id="WritableResource"><a href="#WritableResource" class="headerlink" title="WritableResource"></a>WritableResource</h5><p>支持对资源进行写入的扩展接口。该接口提供一个<code>OutputStream</code>访问器。</p><p>定义的方法：</p><ul><li>boolean isWritable()：指示是否可以通过<code>getOutputStream()</code>向此资源写入内容。适用于典型的资源描述符;注意，实际在尝试写入时仍然可能失败。但是，如果值为false，则表示资源内容不能修改</li><li>OutputStream getOutputStream()：返回底层资源的<code>OutputStream</code>，允许(过度)写入其内容.</li><li>WritableByteChannel writableChannel(): 返回一个<code>WritableByteChannel</code>。希望每个调用都创建一个新的通道。默认实现返回<code>Channels.newChannel(getOutputStream())</code>。</li></ul><h5 id="HttpResource"><a href="#HttpResource" class="headerlink" title="HttpResource"></a>HttpResource</h5><p>将资源写入HTTP响应的扩展接口</p><p>定义的方法：</p><ul><li>HttpHeaders getResponseHeaders(): 服务于当前资源的HTTP响应头。</li></ul><h4 id="常用的Resource实现类"><a href="#常用的Resource实现类" class="headerlink" title="常用的Resource实现类"></a>常用的<code>Resource</code>实现类</h4><h5 id="ClassPathResource"><a href="#ClassPathResource" class="headerlink" title="ClassPathResource"></a>ClassPathResource</h5><p>类路径资源的实现类。使用给定的类加载器或给定的类来加载资源。如果类路径资源驻留在文件系统中，而不是JAR中的资源，则支持<code>java.io.File</code>方式来加载。该类始终支持URL方式来加载。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;app.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件：&quot;</span> + resource.getFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URI：&quot;</span> + resource.getURI());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line">Resource resourceRelative = resource.createRelative(<span class="string">&quot;relative.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;相对路径资源：&quot;</span> + resourceRelative);</span><br><span class="line">System.out.println(<span class="string">&quot;相对路径资源是否存在：&quot;</span> + resourceRelative.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;相对路径资源文件：&quot;</span> + resourceRelative.getFile());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">资源文件是否存在：<span class="keyword">true</span></span><br><span class="line">资源文件是否是文件：<span class="keyword">true</span></span><br><span class="line">资源文件是否可读：<span class="keyword">true</span></span><br><span class="line">资源文件名称：app.xml</span><br><span class="line">资源文件：F:\spring-code-study\chapter3\target\classes\app.xml</span><br><span class="line">资源文件描述：class path resource [app.xml]</span><br><span class="line">资源文件URL：file:/F:/spring-code-study/chapter3/target/classes/app.xml</span><br><span class="line">资源文件URI：file:/F:/spring-code-study/chapter3/target/classes/app.xml</span><br><span class="line">资源文件长度：<span class="number">307</span></span><br><span class="line">资源文件最后修改时间：Mon Apr <span class="number">08</span> <span class="number">10</span>:<span class="number">40</span>:<span class="number">17</span> CST <span class="number">2019</span></span><br><span class="line">资源文件数据：&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line">相对路径资源：class path resource [relative.xml]</span><br><span class="line">相对路径资源是否存在：<span class="keyword">false</span></span><br><span class="line">Exception in thread &quot;main&quot; java.io.FileNotFoundException: class path resource [relative.xml] cannot be resolved to URL because it does not exist</span><br><span class="line">at org.springframework.core.io.ClassPathResource.getURL(ClassPathResource.java:<span class="number">195</span>)</span><br><span class="line">at org.springframework.core.io.AbstractFileResolvingResource.getFile(AbstractFileResolvingResource.java:<span class="number">150</span>)</span><br><span class="line">at cn.sexycode.spring.study.chapter3.ClassPathResourceDemo.main(ClassPathResourceDemo.java:<span class="number">30</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="FileSystemResource"><a href="#FileSystemResource" class="headerlink" title="FileSystemResource"></a>FileSystemResource</h5><p>处理<code>java.io.File</code>和<code>java.nio.file.Path</code>文件系统的资源实现。支持作为一个文件，也可以作为一个URL。扩展自<code>WritableResource</code>接口。</p><p><strong>注意:从Spring Framework 5.0开始，这个资源实现使用NIO.2 API进行读/写交互。从5.1开始，它可能使用一个<code>java.nio.file.Path</code>句柄实例化，在这种情况下，它将通过NIO.2执行所有文件系统交互，<br>只能通过<code>getFile()</code>来返回<code>File</code></strong></p><h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>加载资源的策略接口(例如类路径或文件系统资源)。<code>org.springframework.context.ApplicationContext</code>需要提供此功能，以及扩展<code>org.springframework.core.io.support.ResourcePatternResolver</code>支持。<br><code>DefaultResourceLoader</code>是一个独立的实现，可以在<code>ApplicationContext</code>之外使用，也可以由<code>ResourceEditor</code>使用。<br>当在<code>ApplicationContext</code>中使用时，可以使用特定上下文的资源加载策略从字符串填充Resource类型和Resource数组的Bean属性。</p><p>ResourceLoader提供的方法：</p><ul><li>Resource getResource(String location)：返回指定资源位置的资源句柄。<br>句柄应该始终是一个可重用的资源描述符，允许多次调用<code>Resource#getInputStream()</code>。<br>必须支持完全限定的url，例如。“file:C:/test.dat”。<br>必须支持类路径伪url，例如。“classpath:test.dat”。<br>应该支持相对文件路径，例如。“WEB-INF/test.dat”。(这是基于特定实现的，通常由<code>ApplicationContext</code>实现类提供。)</li></ul><p><strong>注意，资源句柄并不意味着资源实际存在;还是需要调用<code>Resource#exists</code>检查资源是否存在</strong></p><h4 id="ResourcePatternResolver子接口"><a href="#ResourcePatternResolver子接口" class="headerlink" title="ResourcePatternResolver子接口"></a><code>ResourcePatternResolver</code>子接口</h4><p>用于将位置模式(例如，ant样式的路径模式)解析为资源对象的策略接口。<br>这是ResourceLoader接口的扩展。可以检查传入的ResourceLoader(例如，当运行在上下文中时，通过<code>ResourceLoaderAware</code>传入的<code>ApplicationContext</code>)是否也实现了这个接口。<br><code>PathMatchingResourcePatternResolver</code>是一个独立的实现，可以在ApplicationContext之外使用，<code>ResourceArrayPropertyEditor</code>也使用它来填充bean的<code>Resource</code> 数组属性。<br>可以与任何类型的位置模式(例如<code>/WEB-INF/*-context.xml</code>):输入模式必须匹配策略实现。这个接口只指定转换方法，而不是特定的模式格式。<br>这个接口还为类路径中所有匹配的资源提供了一个新的资源前缀<code>classpath*:</code>。注意，在这种情况下，资源位置应该是一个没有占位符的路径(例如 <code>/beans.xml</code>);JAR文件或类目录可以包含多个同名文件</p><p>此接口提供的方法：</p><ul><li>Resource[] getResources(String locationPattern)：将给定的位置模式解析为资源对象。应该尽可能避免指向相同物理资源的重复资源项。结果应该具有set语义</li></ul><h4 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h4><h5 id="DefaultResourceLoader"><a href="#DefaultResourceLoader" class="headerlink" title="DefaultResourceLoader"></a>DefaultResourceLoader</h5><p><code>ResourceLoader</code>接口的默认实现。由<code>ResourceEditor</code>使用，并作为<code>org.springframework.context.support.AbstractApplicationContext</code>的基类。也可以单独使用。<br>如果位置值是URL，则返回UrlResource;如果非URL路径或“classpath:”伪URL，则返回ClassPathResource。</p><p>这里提到了URL, URL 是用来在互联网中描述一个资源位置的，主要包括协议，主机，路径等组成部分。</p><p>Spring 支持的URL:</p><ul><li>classpath: 表示classpath下的资源文件</li><li>file： 表示文件系统中的资源文件</li><li>jar： 表示jar包中的资源文件</li><li>war： 表示war包中的资源文件</li><li>zip：zip包中的资源文件</li><li>wsjar： WebSphere jar文件</li><li>vfszip：JBoss jar文件</li><li>vfsfile：JBoss 文件系统</li><li>vfs：通用的JBoss VFS 文件</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">DefaultResourceLoader resourceLoader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line"><span class="comment">//读取file文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------读取本地文件------------------&quot;</span> );</span><br><span class="line">Resource resource = resourceLoader.getResource(<span class="string">&quot;file:///F:\\spring-code-study\\chapter3\\target\\classes/app.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件是否可写：&quot; + ((FileSystemResource)resource).isWritable());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件：&quot;</span> + resource.getFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URI：&quot;</span> + resource.getURI());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取jar包中的文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------读取jar文件----------------------&quot;</span> );</span><br><span class="line">resource = resourceLoader.getResource(<span class="string">&quot;jar:file:///F:\\spring-code-study\\chapter3\\target\\chapter3-1.0-SNAPSHOT.jar!/app.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件是否可写：&quot; + ((FileSystemResource)resource).isWritable());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件：&quot; + resource.getFile());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件URI：&quot; + resource.getURI());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取网络文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------读取网络文件-----------------&quot;</span> );</span><br><span class="line">resource = resourceLoader.getResource(<span class="string">&quot;https://raw.githubusercontent.com/qzzsunly/spring-code-study/master/chapter3/src/main/resources/app.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件是否可写：&quot; + ((FileSystemResource)resource).isWritable());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件：&quot; + resource.getFile());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件URI：&quot; + resource.getURI());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取classpath下的文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------读取classpath文件-----------------&quot;</span> );</span><br><span class="line">resource = resourceLoader.getResource(<span class="string">&quot;classpath:app.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件是否可写：&quot; + ((FileSystemResource)resource).isWritable());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件：&quot; + resource.getFile());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件URI：&quot; + resource.getURI());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------读取本地文件------------------</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：true</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app.xml</span><br><span class="line">资源文件：F:\spring-code-study\chapter3\target\classes\app.xml</span><br><span class="line">资源文件描述：URL [file:&#x2F;F:&#x2F;spring-code-study&#x2F;chapter3&#x2F;target&#x2F;classes&#x2F;app.xml]</span><br><span class="line">资源文件URL：file:&#x2F;F:&#x2F;spring-code-study&#x2F;chapter3&#x2F;target&#x2F;classes&#x2F;app.xml</span><br><span class="line">资源文件URI：file:&#x2F;F:&#x2F;spring-code-study&#x2F;chapter3&#x2F;target&#x2F;classes&#x2F;app.xml</span><br><span class="line">资源文件长度：307</span><br><span class="line">资源文件最后修改时间：Mon Apr 08 10:40:17 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line">------------------------------------读取jar文件----------------------</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：false</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app.xml</span><br><span class="line">资源文件描述：URL [jar:file:&#x2F;&#x2F;&#x2F;F:\spring-code-study\chapter3\target\chapter3-1.0-SNAPSHOT.jar!&#x2F;app.xml]</span><br><span class="line">资源文件URL：jar:file:&#x2F;&#x2F;&#x2F;F:\spring-code-study\chapter3\target\chapter3-1.0-SNAPSHOT.jar!&#x2F;app.xml</span><br><span class="line">资源文件长度：307</span><br><span class="line">资源文件最后修改时间：Wed Apr 10 09:05:03 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line">------------------------------------读取网络文件-----------------</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：false</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app.xml</span><br><span class="line">资源文件描述：URL [https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;qzzsunly&#x2F;spring-code-study&#x2F;master&#x2F;chapter3&#x2F;src&#x2F;main&#x2F;resources&#x2F;app.xml]</span><br><span class="line">资源文件URL：https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;qzzsunly&#x2F;spring-code-study&#x2F;master&#x2F;chapter3&#x2F;src&#x2F;main&#x2F;resources&#x2F;app.xml</span><br><span class="line">资源文件长度：302</span><br><span class="line">资源文件最后修改时间：Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">资源文件数据：&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line">------------------------------------读取classpath文件-----------------</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：true</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app.xml</span><br><span class="line">资源文件描述：class path resource [app.xml]</span><br><span class="line">资源文件URL：file:&#x2F;F:&#x2F;spring-code-study&#x2F;chapter3&#x2F;target&#x2F;classes&#x2F;app.xml</span><br><span class="line">资源文件长度：307</span><br><span class="line">资源文件最后修改时间：Mon Apr 08 10:40:17 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>从上面的例子中可以看到使用<code>ResourceLoader</code>和<code>Resource</code>接口，我们可以很方便的读取文件内容。</p><h5 id="PathMatchingResourcePatternResolver"><a href="#PathMatchingResourcePatternResolver" class="headerlink" title="PathMatchingResourcePatternResolver"></a>PathMatchingResourcePatternResolver</h5><p>此实现支持ant风格的通配符形式路径。在有多个文件的情况下，我们可以利用这个类来加载多个配置文件。</p><h6 id="在没有通配符的情况"><a href="#在没有通配符的情况" class="headerlink" title="在没有通配符的情况"></a>在没有通配符的情况</h6><p>如果指定的路径没有<code>classpath*:</code>前缀，将通过底层ResourceLoader的getResource()返回单个的资源。比如“file:C:/context”。“classpath:/context”这样的伪url，以及简单的无前缀路径，如“/WEB-INF/context.xml”，后者将基于底层ResourceLoader的方式解析(例如，用于WebApplicationContext的ServletContextResource)。</p><h6 id="Ant-风格的路径"><a href="#Ant-风格的路径" class="headerlink" title="Ant 风格的路径"></a>Ant 风格的路径</h6><p>当路径包含一个ant样式的模式时，例如:<code>/WEB-INF/*-context.xml</code>、<code>com/mycompany/**/applicationContext.xml</code>、<code>file:C:/some/path/*-context.xml</code>、<code>classpath:com/mycompany/**/applicationContext.xml</code>, 解析器遵循一个更复杂但是已定义好的算法来尝试解析通配符。它为最后一个非通配符部分的路径生成一个资源，并获取一个URL。如果该URL不是<code>jar:</code> URL或特定于容器的变体(例如WebLogic中的<code>zip:</code>，WebSphere中的<code>wsjar</code>等等)，那么将从它获取<code>java.io.File</code>，并通过遍历文件系统来解析通配符。对于jar URL，解析器要么从中获取java.net.JarURLConnection，要么手动解析jar URL，然后遍历jar文件的内容来以解析通配符</p><h6 id="可移植性影响"><a href="#可移植性影响" class="headerlink" title="可移植性影响"></a>可移植性影响</h6><p>如果指定的路径已经是文件URL(由于基本ResourceLoader是基于文件系统的，所以可以显式或隐式地使用)，那么通配符就可以方便移植。如果指定的路径是类路径，那么解析器必须通过调用<code>Classloader.getResource()</code>获得最后一个非通配符路径部分的URL。由于这只是路径的一个节点(而不是末尾的文件)，所以它实际上是未定义的(在ClassLoader 的文档中有提及)。实际上，它通常是一个表示目录的<code>java.io.File</code>，其中类路径资源解析为文件系统位置，或者是某种jar URL，其中类路径解析为jar所在位置。尽管如此，这个操作仍然存在可移植性问题。为了从最后一个非通配符部分获取jar URL，解析器必须能够从中获得<code>java.net.JarURLConnection</code>，或者手动解析jar URL，以便能够遍历jar的内容并解析通配符。这将在大多数环境中工作，但在其他环境中可能会失败，强烈建议在依赖jar之前，在你的特定环境中彻底测试jar包资源的通配符解析。</p><h6 id="classpath-前缀"><a href="#classpath-前缀" class="headerlink" title="classpath*:前缀"></a>classpath*:前缀</h6><p>支持通过<code>classpath*:</code>前缀检索同名的多个类路径资源。例如,<code>classpath*:META-INF/beans.xml</code>将找到classpath下所有的<code>beans.xml</code>文件，无论是在<code>classes</code>目录中还是在JAR文件中。这对于自动检测每个jar文件中的相同位置的相同名称的配置文件特别有用。在内部是通过<code>ClassLoader.getResources()</code>方法实现的，并且是完全可移植的。<code>classpath*:</code>前缀还可以结合<code>PathMatcher</code> 模式，例如<code>classpath*:META-INF/*-beans.xml</code>。在本例中，解析策略相当简单:在最后一个非通配符路径部分上调用<code>ClassLoader.getResources()</code>来获取类加载器层次结构中所有匹配的资源，然后在每个资源之外使用上面描述的相同路径匹配器解析策略来处理通配符子路径。</p><h6 id="另注"><a href="#另注" class="headerlink" title="另注"></a>另注</h6><p>警告: 注意，<code>classpath*:</code>与ant样式的模式结合使用时，根目录在文件系统中必须存在。这意味着像<code>classpath*:*.xml</code>这样的模式不会从jar文件的根中检索文件，而是只从扩展目录的根中检索。这源于JDK的<code>ClassLoader.getResources()</code>方法中的一个限制，该方法传入空字符串只返回文件系统位置(指示潜在的要搜索的根目录)。这个<code>ResourcePatternResolver</code>实现试图通过URLClassLoader自省和<code>java.class.path</code>清单来减轻jar根目录查找的限制;但是不保证可移植性。<br><strong>警告: 当<code>classpath:</code>搭配Ant风格时，如果在多个类路径位置都能搜索到根包，则不能保证资源能够找到匹配的资源。这是因为如<br><code>com/mycompany/package1/service-context.xml</code>这样的资源可能只在一个位置，但当尝试解析这样路径时:<code>com/mycompany/**/service-context.xml</code>,解析器在处理<code>getResource(com/mycompany”)</code>返回的(第一个)URL，如果此存在于多个类加载器时，则实际的想要的资源可能不在返回的类加载器中。因此，在这种情况下，最好使用具有相同ant样式模式的<code>classpath*:</code>，它将搜索包含根包的所有类路径。</strong></p><h6 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PathMatchingResourcePatternResolver resourceLoader = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line"><span class="comment">//读取file文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------读取多个文件------------------&quot;</span>);</span><br><span class="line">Resource[] resources = resourceLoader.getResources(<span class="string">&quot;classpath:app*.xml&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件是否可写：&quot; + ((FileSystemResource)resource).isWritable());</span></span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件：&quot;</span> + resource.getFile());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件URI：&quot;</span> + resource.getURI());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------读取多个文件------------------</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：true</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app0.xml</span><br><span class="line">资源文件：F:\spring-code-study\chapter3\target\classes\app0.xml</span><br><span class="line">资源文件描述：file [F:\spring-code-study\chapter3\target\classes\app0.xml]</span><br><span class="line">资源文件URL：file:/F:/spring-code-study/chapter3/target/classes/app0.xml</span><br><span class="line">资源文件URI：file:/F:/spring-code-study/chapter3/target/classes/app0.xml</span><br><span class="line">资源文件长度：331</span><br><span class="line">资源文件最后修改时间：Wed Apr 10 20:57:17 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--配置文件0--&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：true</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app1.xml</span><br><span class="line">资源文件：F:\spring-code-study\chapter3\target\classes\app1.xml</span><br><span class="line">资源文件描述：file [F:\spring-code-study\chapter3\target\classes\app1.xml]</span><br><span class="line">资源文件URL：file:/F:/spring-code-study/chapter3/target/classes/app1.xml</span><br><span class="line">资源文件URI：file:/F:/spring-code-study/chapter3/target/classes/app1.xml</span><br><span class="line">资源文件长度：331</span><br><span class="line">资源文件最后修改时间：Wed Apr 10 10:46:52 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--配置文件1--&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：true</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app2.xml</span><br><span class="line">资源文件：F:\spring-code-study\chapter3\target\classes\app2.xml</span><br><span class="line">资源文件描述：file [F:\spring-code-study\chapter3\target\classes\app2.xml]</span><br><span class="line">资源文件URL：file:/F:/spring-code-study/chapter3/target/classes/app2.xml</span><br><span class="line">资源文件URI：file:/F:/spring-code-study/chapter3/target/classes/app2.xml</span><br><span class="line">资源文件长度：331</span><br><span class="line">资源文件最后修改时间：Wed Apr 10 10:46:50 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--配置文件2--&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="BeanDefinitionReader-加载bean定义资源"><a href="#BeanDefinitionReader-加载bean定义资源" class="headerlink" title="BeanDefinitionReader 加载bean定义资源"></a>BeanDefinitionReader 加载bean定义资源</h2><p>通过<code>ResourceLoader</code> 定位资源文件之后，那么就该<code>BeanDefinitionReader</code>开始着手加载bean定义了。</p><p>定义的方法：</p><ul><li>int loadBeanDefinitions(Resource resource)：从单个资源中加载，返回发现的bean 定义数量</li><li>int loadBeanDefinitions(Resource… resources)：从多个资源中加载</li><li>int loadBeanDefinitions(String location)：从单个资源位置加载</li><li>int loadBeanDefinitions(String… locations)：从多个资源位置加载</li></ul><p>从方法定义中可以看出，<code>BeanDefinitionReader</code>提供了多个从各种资源中加载bean定义的功能。</p><h3 id="BeanDefinitionReader-实现类"><a href="#BeanDefinitionReader-实现类" class="headerlink" title="BeanDefinitionReader 实现类"></a>BeanDefinitionReader 实现类</h3><p>Spring 提供了三个实现类，用于从不同格式的资源文件中加载bean定义。</p><h4 id="PropertiesBeanDefinitionReader"><a href="#PropertiesBeanDefinitionReader" class="headerlink" title="PropertiesBeanDefinitionReader"></a>PropertiesBeanDefinitionReader</h4><p>该类用于从properties文件中加载bean定义。</p><h4 id="GroovyBeanDefinitionReader"><a href="#GroovyBeanDefinitionReader" class="headerlink" title="GroovyBeanDefinitionReader"></a>GroovyBeanDefinitionReader</h4><p>基于Groovy的 reader。<br>这个bean定义reader还可以读取XML bean定义文件，允许与Groovy bean定义文件无缝搭配。</p><h4 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a>XmlBeanDefinitionReader</h4><p>读取xml bean定义文件，将资源解析成xml w3c document, 内部委托给<code>BeanDefinitionDocumentReader</code>接口(具体实现类是<code>DefaultBeanDefinitionDocumentReader</code>)去加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line"><span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line"><span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line"><span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line"><span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line"><span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line"><span class="comment">//任何内部的 &lt;beans&gt; 标签，将会递归调用这个方法， 为了正确地传播和保存&lt;beans&gt; 的`default-`属性值，需要跟踪当前(父)委托，它有可能为空。</span></span><br><span class="line"><span class="comment">//因为子beans 需要继承父beans的一些默认属性，比如说default-lazy-init=&quot;default&quot;, </span></span><br><span class="line"><span class="comment">//创建新的(子)委托，并使用父委托的引用进行回退，然后最终将this.delegate重置为其原始(父)引用。这种行为模拟了一堆委托，实际上并不需要委托。</span></span><br><span class="line">BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line"><span class="comment">// 为当前根节点创建新的委托解析器</span></span><br><span class="line"><span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前标签是不是在默认命名空间中，默认命名空间代表&lt;benas&gt;标签所在的命名空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="comment">//当前&lt;beans&gt; 标签指定了profile属性，则跟当前环境中激活的profile进行比较，如果是未激活，则跳过当前&lt;beans&gt; 标签</span></span><br><span class="line">String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line"><span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line"><span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line"><span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preProcessXml(root);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析当前&lt;beans&gt;标签</span></span><br><span class="line">parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">postProcessXml(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanDefinitionParserDelegate 对象是用来具体解析每个元素的，为什么需要创建一个新的。可以</p><p>再看看parseBeanDefinitions方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果当前元素属于默认命名空间，这里其实就是指&lt;beans&gt;标签</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    NodeList nl = root.getChildNodes();</span><br><span class="line">    <span class="comment">//遍历子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                <span class="comment">//如果该标签属性默认命名空间，Uri为空，或者是 http://www.springframework.org/schema/beans</span></span><br><span class="line">                <span class="comment">// import标签</span></span><br><span class="line">                <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">                    <span class="comment">// 先处理路径中的点位符，如：$&#123;user.dir&#125;</span></span><br><span class="line">                    <span class="comment">// 判断引入的资源是否绝对路径(classpath:, classpath*:, url资源)，再调用reader的loadBeanDefinitions 方法</span></span><br><span class="line">                    <span class="comment">// 相对路径则使用 当前的资源创建相对路径资源（getReaderContext().getResource().createRelative(location)）</span></span><br><span class="line">                    <span class="comment">//再调用reader的loadBeanDefinitions 方法</span></span><br><span class="line">                    importBeanDefinitionResource(ele);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//alias 标签</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">                    <span class="comment">//调用org.springframework.core.AliasRegistry.registerAlias 方法注册别名</span></span><br><span class="line">                    processAliasRegistration(ele);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// bean 标签</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">                    processBeanDefinition(ele, delegate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 内部 beans 标签， 则递归调用 doRegisterBeanDefinitions()方法，</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">                    <span class="comment">// recurse</span></span><br><span class="line">                    doRegisterBeanDefinitions(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是自定义标签，那么调用自定义标签解析</span></span><br><span class="line">                delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果是自定义标签，那么调用自定义标签解析</span></span><br><span class="line">    delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看一下 processBeanDefinition 方法，这个方法用来解析bean定义。<br>processBeanDefinition(): </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用了BeanDefinitionParserDelegate 来解析出BeanDefinitionHolder对象，这个对象中封装了 BeanDefinition 以及bean名称对象。</span></span><br><span class="line"><span class="comment">//BeanDefinition 是用来描述bean 定义的对象，主要包括 class, lazy-init ，依赖对象， 初始化方法，销毁方法，作用域, 父级bean定义等信息，这些信息都解析自xml bean标签。如果在有自定义的子标签和属性，则进一步调用自定义的 NamespaceHandler</span></span><br><span class="line"></span><br><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"><span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//处理标签中的自定义元素和自定义子标签， 调用自定义的 NamespaceHandler 来解析。</span></span><br><span class="line">    <span class="comment">// 这里返回的 BeanDefinitionHolder 可以是原始的，也可以是自己经过处理的。一切看 NamespaceHandler 里如何定义的</span></span><br><span class="line">    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">        <span class="comment">// 注册最终的 BeanDefinitionHolder</span></span><br><span class="line">        BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">        getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Send registration event.</span></span><br><span class="line">    getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看一下BeanDefinitionParserDelegate的parseBeanDefinitionElement方法，主要包括BeanDefinition的属性的设置，以及bean下的元素标签解析，bean 定义名称等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">    <span class="comment">// 解析bean name， 可以有多个，用 ,;  隔开</span></span><br><span class="line">String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String beanName = id;</span><br><span class="line"><span class="comment">// id 为空，则用第一个name 作为id</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//判断名称是否唯一</span></span><br><span class="line">checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 具体解析标签的每个元素，包括init-method, 构造参数等，设置 beanDefinition对应的属性</span></span><br><span class="line">AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"><span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"><span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line"><span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line"><span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line"><span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">!<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">aliases.add(beanClassName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line"><span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">error(ex.getMessage(), ele);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NamespaceHandler-解析自定义标签"><a href="#NamespaceHandler-解析自定义标签" class="headerlink" title="NamespaceHandler 解析自定义标签"></a>NamespaceHandler 解析自定义标签</h3><p>除了默认命名空间<code>http://www.springframework.org/schema/beans</code>之外，其他的都是自定义命名空间，需要用到<code>NamespaceHandler</code>来解析自定义标签。<code>NamespaceHandlerResolver</code>会找到命名空间所对应的<code>NamespaceHandler</code>。<code>NamespaceHandlerResolver</code>接口的默认实现类<code>DefaultNamespaceHandlerResolver</code> 会加载<code>META-INF/spring.handlers</code>文件，并根据命名空间地址来实例化<code>NamespaceHandler</code>实现类。Spring beans包下的这个文件内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/c=org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/p=org.springframework.beans.factory.xml.SimplePropertyNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler</span><br></pre></td></tr></table></figure><p><code>命名空间地址=解析器实现类</code>这样的形式。</p><h4 id="常用的-NamespaceHandler"><a href="#常用的-NamespaceHandler" class="headerlink" title="常用的 NamespaceHandler"></a>常用的 NamespaceHandler</h4><ul><li><p>SimplePropertyNamespaceHandler：简单的NamespaceHandler实现，它将特定属性直接映射到bean属性。需要注意的重要一点是，NamespaceHandler无法预知所有可能的属性名。下面是使用NamespaceHandler的一个例子: <bean id="rob" class="..TestBean" p:name="Rob Harrop" p:spouse-ref="sally">, 这里的<code>p:name</code>直接对应于类“TestBean”上的<code>name</code>属性。<code>p:spouse-ref</code>属性对应于<code>spouse</code>属性，将value 所对应的bean注入到该属性中。</bean></p></li><li><p>SimpleConstructorNamespaceHandler：设置构造函数参数。如： <bean id="author" class="..TestBean " c:name="Enescu" c:work-ref="compositions"> 。这里，“c:name”直接对应于类“TestBean”构造函数中声明的“name”参数。“c:work-ref”属性对应于“work”参数，它不作为具体值，而是包含作为参数的bean的名称。注意:这个实现支持命名参数, 下标——不支持类型。此外，容器使用这些名称作为提示，默认情况下，容器会进行类型自省 。</bean></p></li><li><p>NamespaceHandlerSupport：实现自定义NamespaceHandler的支持类。各个节点的解析和装饰分别通过<code>BeanDefinitionParser</code>和<code>BeanDefinitionDecorator</code>策略接口完成。提供<code>registerBeanDefinitionParser</code>和<code>registerBeanDefinitionDecorator</code>方法，用于注册<code>BeanDefinitionParser</code>或<code>BeanDefinitionDecorator</code>来处理特定元素。</p></li><li><p>AopNamespaceHandler: 用于 <code>aop</code> 命名空间的NamespaceHandler。为<a href="aop:config">aop:config</a>标签提供一个BeanDefinitionParser。<code>config</code>标记可以包含嵌套的<code>pointcut</code>、<code>advisor</code>和<code>aspect</code>标签。<code>pointcut</code>标签允许使用简单的语法创建命名的<code>AspectJExpressionPointcut</code> bean: &lt;aop:pointcut id=”getNameCalls” expression=”execution(* *..ITestBean.getName(..))”/&gt;. 使用<code>advisor</code>标签，你可以配置<code>org.springframework.aop.Advisor</code>并将其自动应用于你的<code>org.springframework.beans.factory.BeanFactory</code>中的所有相关bean。<code>advisor</code>标签支持内联和引用<code>org.springframework.aop.Pointcut</code>: &lt;aop:advisor id=”getAgeAdvisor”</p><pre><code> pointcut=&quot;execution(* *..ITestBean.getAge(..))&quot; advice-ref=&quot;getAgeCounter&quot;/&gt;</code></pre><p> &lt;aop:advisor id=”getNameAdvisor”</p><pre><code> pointcut-ref=&quot;getNameCalls&quot; advice-ref=&quot;getNameCounter&quot;/&gt;</code></pre><p> 标签对应的解析器：config -&gt; ConfigBeanDefinitionParser, aspectj-autoproxy -&gt; AspectJAutoProxyBeanDefinitionParser, scoped-proxy -&gt; ScopedProxyBeanDefinitionDecorator</p></li><li><p>ContextNamespaceHandler: 解析 <code>context</code> 命名空间。 标签对应的解析器：property-placeholder -&gt; PropertyPlaceholderBeanDefinitionParser, property-override -&gt; PropertyOverrideBeanDefinitionParser, annotation-config -&gt; AnnotationConfigBeanDefinitionParser, component-scan -&gt; ComponentScanBeanDefinitionParser, load-time-weaver -&gt; LoadTimeWeaverBeanDefinitionParser, spring-configured -&gt; SpringConfiguredBeanDefinitionParser, mbean-export -&gt; MBeanExportBeanDefinitionParser, mbean-server -&gt; MBeanServerBeanDefinitionParser   </p></li><li><p>LangNamespaceHandler: 解析 <code>lang</code> 命名空间。NamespaceHandler 支持由动态语言(如Groovy、JRuby和BeanShell)支持的对象织入。下面是一个示例(来自参考文档)，它详细描述了Groovy支持的bean的织入:<br>&lt;lang:groovy id=”messenger”</p><pre><code> refresh-check-delay=&quot;5000&quot; script-source=&quot;classpath:Messenger.groovy&quot;&gt;</code></pre><p> &lt;lang:property name=”message” value=”I Can Do The Frug”/&gt;<br><br>标签对应的解析器：groovy, bsh, std -&gt; ScriptBeanDefinitionParser, defaults -&gt; ScriptingDefaultsParser</p></li><li><p>UtilNamespaceHandler: 解析<code>util</code> 命名空间。标签对应的解析器：constant -&gt; ConstantBeanDefinitionParser, property-path -&gt; PropertyPathBeanDefinitionParser， list -&gt; ListBeanDefinitionParser , set -&gt; SetBeanDefinitionParser, map -&gt; MapBeanDefinitionParser , properties -&gt; PropertiesBeanDefinitionParser.</p></li><li><p>TaskNamespaceHandler: 解析<code>task</code> 命名空间. 标签对应的解析器：annotation-driven -&gt; AnnotationDrivenBeanDefinitionParser, executor -&gt; ExecutorBeanDefinitionParser , scheduled-tasks -&gt; ScheduledTasksBeanDefinitionParser, scheduler -&gt; SchedulerBeanDefinitionParser.</p></li><li><p>CacheNamespaceHandler: 允许使用XML或注释配置声明式缓存管理的NamespaceHandler。这个名称空间处理程序是Spring缓存管理工具中的核心功能。标签对应的解析器： annotation-driven -&gt; AnnotationDrivenCacheBeanDefinitionParser，advice -&gt; CacheAdviceParser. </p></li><li><p>MvcNamespaceHandler: 用于Spring MVC配置命名空间的NamespaceHandler . 标签对应的解析器：annotation-driven -&gt; AnnotationDrivenBeanDefinitionParser </p></li><li><p>JeeNamespaceHandler: 解析 <code>jee</code> 命名空间。标签对应的解析器：jndi-lookup -&gt; JndiLookupBeanDefinitionParser, local-slsb -&gt; LocalStatelessSessionBeanDefinitionParser, remote-slsb -&gt; RemoteStatelessSessionBeanDefinitionParser.</p></li></ul><h3 id="BeanDefinitionParser"><a href="#BeanDefinitionParser" class="headerlink" title="BeanDefinitionParser"></a>BeanDefinitionParser</h3><p><code>DefaultBeanDefinitionDocumentReader</code>用于处理自定义顶级标签的接口。实现类可以根据需要自由地将自定义标签中的元数据转换成任意多的bean定义。<br>解析器从关联的<code>NamespaceHandler</code>中为自定义标签所在的命名空间定位一个<code>BeanDefinitionParser</code>。通过<code>NamespaceHandlerSupport</code>的<code>registerBeanDefinitionParser</code>方法注册</p><h4 id="提供的方法"><a href="#提供的方法" class="headerlink" title="提供的方法"></a>提供的方法</h4><p>BeanDefinition parse(Element element, ParserContext parserContext)：解析指定的元素并将结果bean定义注册到所提供的ParserContext中嵌入的<code>BeanDefinitionRegistry</code>。<br>如果要以嵌套方式使用(例如作为<code>&lt;property/&gt;</code>标记中的内部标记)，实现类必须返回从解析中得到的主要bean定义。如果实现不以嵌套方式使用，则可能返回null。</p><h4 id="常用实现类-1"><a href="#常用实现类-1" class="headerlink" title="常用实现类"></a>常用实现类</h4><p>常用的就是上面所列的每个 <code>NamespaceHandler</code>中注册的解析器。</p><ul><li>ConfigBeanDefinitionParser：解析 <code>&lt;aop:config&gt;</code> 标签</li><li>AspectJAutoProxyBeanDefinitionParser: 解析 <code>&lt;aop:aspectj-autoproxy&gt;</code> 标签</li><li>ScopedProxyBeanDefinitionDecorator：解析 <code>&lt;aop:scoped-proxy&gt;</code> 标签</li><li>PropertyPlaceholderBeanDefinitionParser：解析 <code>&lt;context:property-placeholder&gt;</code> 标签</li><li>PropertyOverrideBeanDefinitionParser: 解析 <code>&lt;context:property-override&gt;</code> 标签</li><li>AnnotationConfigBeanDefinitionParser：解析 <code>&lt;context:annotation-config&gt;</code> 标签</li><li>ComponentScanBeanDefinitionParser: 解析 <code>&lt;context:component-scan&gt;</code> 标签</li><li>LoadTimeWeaverBeanDefinitionParser： 解析 <code>&lt;context:load-time-weaver&gt;</code> 标签</li><li>SpringConfiguredBeanDefinitionParser：解析 <code>&lt;context:spring-configured&gt;</code> 标签</li><li>MBeanExportBeanDefinitionParser：解析 <code>&lt;context:mbean-export&gt;</code> 标签</li><li>MBeanServerBeanDefinitionParser：解析 <code>&lt;context:mbean-server&gt;</code> 标签</li><li>ScriptBeanDefinitionParser：解析 <code>&lt;lang:groovy&gt;</code>,<code>&lt;lang:bsh&gt;</code>,<code>&lt;lang:std&gt;</code>。 实例化时需要传入一个脚本工厂类名。分别是 <code>org.springframework.scripting.groovy.GroovyScriptFactory</code>, <code>org.springframework.scripting.bsh.BshScriptFactory</code>, <code>org.springframework.scripting.support.StandardScriptFactory</code> </li><li>ScriptingDefaultsParser: 解析 <code>&lt;lang:defaults&gt;</code> 标签</li><li>ConstantBeanDefinitionParser：解析 <code>&lt;util:constant&gt;</code> 标签</li><li>PropertyPathBeanDefinitionParser：解析 <code>&lt;util:property-path&gt;</code> 标签</li><li>ListBeanDefinitionParser：解析 <code>&lt;util:list&gt;</code> 标签</li><li>SetBeanDefinitionParser：解析 <code>&lt;util:set&gt;</code> 标签</li><li>MapBeanDefinitionParser：解析 <code>&lt;util:map&gt;</code> 标签</li><li>PropertiesBeanDefinitionParser：解析 <code>&lt;util:properties&gt;</code> 标签</li><li>AnnotationDrivenBeanDefinitionParser：解析 <code>&lt;mvc:annotation-driven&gt;</code>，<code>&lt;task:annotation-driven&gt;</code> 标签</li><li>DefaultServletHandlerBeanDefinitionParser：解析 <code>&lt;mvc:default-servlet-handler&gt;</code> 标签</li><li>InterceptorsBeanDefinitionParser：解析 <code>&lt;mvc:interceptors&gt;</code> 标签</li><li>ResourcesBeanDefinitionParser：解析 <code>&lt;mvc:resources&gt;</code> 标签</li><li>ViewControllerBeanDefinitionParser：解析 <code>&lt;mvc:view-controller&gt;</code>,<code>&lt;mvc:redirect-view-controller&gt;</code>, <code>&lt;mvc:status-controller&gt;</code> 标签</li><li>ViewResolversBeanDefinitionParser：解析 <code>&lt;mvc:view-resolvers&gt; </code>标签</li><li>TilesConfigurerBeanDefinitionParser：解析 <code>&lt;mvc:tiles-configurer&gt;</code> 标签</li><li>FreeMarkerConfigurerBeanDefinitionParser：解析 <code>&lt;mvc:freemarker-configurer&gt;</code> 标签</li><li>GroovyMarkupConfigurerBeanDefinitionParser：解析 <code>&lt;mvc:groovy-configurer&gt;</code> 标签</li><li>ScriptTemplateConfigurerBeanDefinitionParser：解析 <code>&lt;mvc:script-template-configurer&gt;</code>标签</li><li>CorsBeanDefinitionParser：解析 <code>&lt;mvc:cors&gt;</code> 标签</li><li>ExecutorBeanDefinitionParser: 解析 <code>&lt;task:executor&gt;</code> 标签</li><li>ScheduledTasksBeanDefinitionParser: 解析 <code>&lt;task:scheduled-tasks&gt;</code> 标签</li><li>SchedulerBeanDefinitionParser: 解析 <code>&lt;task:scheduler&gt;</code> 标签</li><li>AnnotationDrivenCacheBeanDefinitionParser: 解析 <code>&lt;cache:annotation-driven&gt;</code> 标签</li><li>CacheAdviceParser: 解析 <code>&lt;cache:advice&gt;</code> 标签</li><li>JndiLookupBeanDefinitionParser: 解析 <code>&lt;jee:jndi-lookup&gt;</code> 标签</li><li>LocalStatelessSessionBeanDefinitionParser: 解析 <code>&lt;jee:local-slsb&gt;</code> 标签</li><li>RemoteStatelessSessionBeanDefinitionParser: 解析 <code>&lt;jee:remote-slsb&gt;</code> 标签</li></ul><h3 id="BeanDefinitionDecorator"><a href="#BeanDefinitionDecorator" class="headerlink" title="BeanDefinitionDecorator"></a>BeanDefinitionDecorator</h3><p><code>DefaultBeanDefinitionDocumentReader</code>使用的接口来处理自定义的嵌套标签(直接位于<code>&lt;bean&gt;</code>)标签下)。还可以装饰<code>&lt;bean&gt;</code>标签的自定义属性。实现类可以自由地将自定义标签中的元数据转换为所需的任意多个bean定义，并转换所包含的bean定义标签，甚至可能返回一个完全不同的<code>org.springframework.bean .factory.config.BeanDefinition</code>替换原来的。<br><code>BeanDefinitionDecorator</code> 应该意识到它们可能是解析链的一部分。特别是，应该知道，以前的BeanDefinitionDecorator可能已经用<code>ProxyFactoryBean</code>定义替换了原来的BeanDefinition，该定义允许添加自定义拦截器。希望向封闭bean添加拦截器的 <code>BeanDefinitionDecorator</code>应该扩展<code>AbstractInterceptorDrivenBeanDefinitionDecorator</code>，它处理解析链，确保只创建一个代理，并且它包含链中的所有拦截器。 解析器从<code>NamespaceHandler</code>中为自定义标签所在的命名空间定位一个<code>BeanDefinitionDecorator</code></p><h4 id="常用实现类-2"><a href="#常用实现类-2" class="headerlink" title="常用实现类"></a>常用实现类</h4><ul><li>ScopedProxyBeanDefinitionDecorator：负责解析<code>&lt;aop:scope-proxy/&gt;</code>标签</li><li>AbstractInterceptorDrivenBeanDefinitionDecorator：希望向生成的bean添加拦截器的<code>BeanDefinitionDecorator</code>的基本实现。这个基类控制<code>ProxyFactoryBean</code> bean 定义的创建，并将原始定义包装为<code>ProxyFactoryBean</code>目标属性的内部bean定义。正确处理链接，确保只创建一个<code>ProxyFactoryBean</code> 定义。如果前面的BeanDefinitionDecorator已经创建了<code>ProxyFactoryBean</code>，则只需将拦截器添加到现有定义中。子类只需要向它们希望添加的拦截器创建bean定义</li></ul><h2 id="BeanDefinitionRegistry-注册bean-定义"><a href="#BeanDefinitionRegistry-注册bean-定义" class="headerlink" title="BeanDefinitionRegistry 注册bean 定义"></a>BeanDefinitionRegistry 注册bean 定义</h2><p>BeanDefinitionReaderUtils.registerBeanDefinition()方法内部调用了org.springframework.beans.factory.support.BeanDefinitionRegistry.registerBeanDefinition 方法， 具体的实现就是beanFactory实现类（<code>org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition</code>）了。</p><p>DefaultListableBeanFactory.registerBeanDefinition():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//校验 BeanDefinition 的逻辑合法</span></span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果存在同名 bean 定义</span></span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="comment">//不允许bean 定义覆盖</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">                        existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//注册新的 bean 定义，如果正在创建 bean 实例</span></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="comment">//不能再修改启动时的集合，为了稳定的遍历</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">                    Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">                    updatedSingletons.remove(beanName);</span><br><span class="line">                    <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//还在注册阶段，直接放进去就完事了</span></span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 重置给定bean的所有bean定义缓存，包括派生自该bean的bean的缓存。</span></span><br><span class="line">        <span class="comment">//   在替换或删除现有bean定义之后调用，触发clearMergedBeanDefinition、destroySingleton和MergedBeanDefinitionPostProcessor。</span></span><br><span class="line">        <span class="comment">//   在给定bean和所有具有给定bean作为父bean的bean定义上重置beandefinition</span></span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Bean </tag>
            
            <tag> 解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring自定义命名空间解析</title>
      <link href="/post/75b6/"/>
      <url>/post/75b6/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义命名空间解析"><a href="#自定义命名空间解析" class="headerlink" title="自定义命名空间解析"></a>自定义命名空间解析</h1><p>当我们想要扩展Spring 的配置时，可以定义我们自己的标签，然后解析成 bean定义，注册到Spring 容器中。这时需要用到 <code>NamespaceHandler</code>。Spring 框架中除了beans顶级标签外，其他的顶级标签都是自定义命名空间中的标签。如，<code>p</code>、 <code>c</code>、<code>util</code>命名空间。</p><h2 id="NamespaceHandler-命名空间解析器"><a href="#NamespaceHandler-命名空间解析器" class="headerlink" title="NamespaceHandler 命名空间解析器"></a><code>NamespaceHandler</code> 命名空间解析器</h2><p>Spring 框架中<code>mvc</code>、<code>context</code>、<code>tx</code> 等功能都是通过扩展这个接口来实现的。这个接口负责将标签解析成bean 定义对象。该接口提供了<code>parse</code> 和<code>decorate</code> 方法。<code>parse</code>方法用来将顶级标签解析成<code>BeanDefinition</code>对象。<code>decorate</code> 方法负责对<code>parse</code>出来的<code>BeanDefinition</code>进行进一步处理，需要解析的可以是元素属性和标签。 可以返回原来的<code>BeanDefinition</code>，或者返回一个新的<code>BeanDefinition</code>。</p><p>为了解析的方便，Spring 提供了一个抽象类<code>NamespaceHandlerSupport</code>，封装了一些基础功能，并提供了两个新的接口(<code>BeanDefinitionParser</code>和<code>BeanDefinitionDecorator</code>)方便扩展。并提供了<code>registerBeanDefinitionDecorator</code>、<code>registerBeanDefinitionParser</code>、<code>registerBeanDefinitionDecoratorForAttribute</code>三个方法分别注册<code>BeanDefinitionParser</code>和<code>BeanDefinitionDecorator</code>实现类，内部用map来维护标签名或者属性名到<code>BeanDefinitionParser</code>和<code>BeanDefinitionDecorator</code>的映射关系，解析时用名称(无命名空间前缀)来查找。</p><h2 id="Spring提供的NamespaceHandler"><a href="#Spring提供的NamespaceHandler" class="headerlink" title="Spring提供的NamespaceHandler"></a>Spring提供的<code>NamespaceHandler</code></h2><p>Spring 提供了一些 <code>NamespaceHandler</code>来实现自身功能。下面详细了解一下。</p><h3 id="SimplePropertyNamespaceHandler-简单属性解析器"><a href="#SimplePropertyNamespaceHandler-简单属性解析器" class="headerlink" title="SimplePropertyNamespaceHandler 简单属性解析器"></a><code>SimplePropertyNamespaceHandler</code> 简单属性解析器</h3><p>解析的命名空间为 <code>http://www.springframework.org/schema/p</code>。它将特定属性直接映射到bean属性。需要注意的重要一点是，<code>NamespaceHandler</code>无法预知所有可能的属性名。该实现类直接实现了<code>NamespaceHandler</code>。</p><p>下面是使用<code>NamespaceHandler</code>的一个例子: </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;rob&quot;</span> <span class="attr">class</span> = <span class="string">&quot;..TestBean&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;Rob&quot;</span> <span class="attr">p:spouse-ref</span>=<span class="string">&quot;sally&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这里的<code>p:name</code>直接对应于类<code>TestBean</code>上的<code>name</code>属性。<code>p:spouse-ref</code>属性对应于<code>spouse</code>属性，将<code>value </code>所对应的bean注入到该属性中。</p><p><code>parse</code>方法直接记录日志信息，并返回 <code>null</code>。因为它只支持对属性进行解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">parserContext.getReaderContext().error(</span><br><span class="line"><span class="string">&quot;Class [&quot;</span> + getClass().getName() + <span class="string">&quot;] does not support custom elements.&quot;</span>, element);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>decorate</code>将元素属性表示的属性设置到对应的对象属性中。每个属性都会调用一次这个方法。拿上文提到的例子来解释一下下面代码的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorate</span><span class="params">(Node node, BeanDefinitionHolder definition, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Attr) &#123;</span><br><span class="line">       <span class="comment">//只处理标签属性</span></span><br><span class="line">      Attr attr = (Attr) node;</span><br><span class="line">       <span class="comment">//获取到属性名称，例子中为 name</span></span><br><span class="line">      String propertyName = parserContext.getDelegate().getLocalName(attr);</span><br><span class="line">       <span class="comment">//获取到属性值 例子中为 Rob</span></span><br><span class="line">      String propertyValue = attr.getValue();</span><br><span class="line">       <span class="comment">//从当前bean定义取出属性值集合</span></span><br><span class="line">      MutablePropertyValues pvs = definition.getBeanDefinition().getPropertyValues();</span><br><span class="line">       <span class="comment">//如果已经解析出了该属性，则记录一下错误日志。这里是因为我们可以用标签 &lt;property&gt; 来声明属性, p 标签实际上是一种简化形式。两种声明方式只能用一种来声明同一个属性</span></span><br><span class="line">      <span class="keyword">if</span> (pvs.contains(propertyName)) &#123;</span><br><span class="line">         parserContext.getReaderContext().error(<span class="string">&quot;Property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; is already defined using &quot;</span> +</span><br><span class="line">               <span class="string">&quot;both &lt;property&gt; and inline syntax. Only one approach may be used per property.&quot;</span>, attr);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 如果属性名以 _ref 结尾，则表示该属性值引用一个 bean ,_ref 前面是 bean 名称</span></span><br><span class="line">      <span class="keyword">if</span> (propertyName.endsWith(REF_SUFFIX)) &#123;</span><br><span class="line">         propertyName = propertyName.substring(<span class="number">0</span>, propertyName.length() - REF_SUFFIX.length());</span><br><span class="line">         <span class="comment">// 将标签属性名转换成属性名，小写，破折号形式转成驼峰形式，值转换成 RuntimeBeanReference，这个对象会在运行时转成具体的bean</span></span><br><span class="line">          pvs.add(Conventions.attributeNameToPropertyName(propertyName), <span class="keyword">new</span> RuntimeBeanReference(propertyValue));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//字面值直接添加进去就行了</span></span><br><span class="line">         pvs.add(Conventions.attributeNameToPropertyName(propertyName), propertyValue);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结：用这个自定义属性来替换<code>&lt;property&gt;</code>使用起来更方便。</strong></p><h3 id="SimpleConstructorNamespaceHandler-简单构造函数解析器"><a href="#SimpleConstructorNamespaceHandler-简单构造函数解析器" class="headerlink" title="SimpleConstructorNamespaceHandler 简单构造函数解析器"></a><code>SimpleConstructorNamespaceHandler</code> 简单构造函数解析器</h3><p>将自定义属性映射到构造函数参数。解析的命名空间地址为<code>http://www.springframework.org/schema/c</code>。需要注意该解析器无法预知所有的参数。</p><p>下面看一个简单例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;author&quot;</span> <span class="attr">class</span>=<span class="string">&quot;..TestBean&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;Enescu&quot;</span> <span class="attr">c:work-ref</span>=<span class="string">&quot;compositions&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>将<code>name</code>映射到<code>TestBean</code>的构造函数<code>name</code>参数，值为<code>Enescu</code>，而<code>work</code>参数引用了<code>compositions</code> bean。</p><p>下面看一下源代码：</p><p><code>parse</code> 方法不支持解析标签</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   parserContext.getReaderContext().error(</span><br><span class="line">         <span class="string">&quot;Class [&quot;</span> + getClass().getName() + <span class="string">&quot;] does not support custom elements.&quot;</span>, element);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>decorate</code> 方法， 每个参数都会调用一次这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorate</span><span class="params">(Node node, BeanDefinitionHolder definition, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Attr) &#123;</span><br><span class="line">       <span class="comment">//只解析标签属性</span></span><br><span class="line">      Attr attr = (Attr) node;</span><br><span class="line">       <span class="comment">//获取参数名,上例中为 name</span></span><br><span class="line">      String argName = StringUtils.trimWhitespace(parserContext.getDelegate().getLocalName(attr));</span><br><span class="line">       <span class="comment">// 获取参数值, Enescu</span></span><br><span class="line">      String argValue = StringUtils.trimWhitespace(attr.getValue());</span><br><span class="line"></span><br><span class="line">      ConstructorArgumentValues cvs = definition.getBeanDefinition().getConstructorArgumentValues();</span><br><span class="line">      <span class="keyword">boolean</span> ref = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// handle -ref arguments</span></span><br><span class="line">      <span class="keyword">if</span> (argName.endsWith(REF_SUFFIX)) &#123;</span><br><span class="line">          <span class="comment">//如果参数名以 -ref 结尾，获取到真正的参数名，work-ref 则为 work</span></span><br><span class="line">         ref = <span class="keyword">true</span>;</span><br><span class="line">         argName = argName.substring(<span class="number">0</span>, argName.length() - REF_SUFFIX.length());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果是 引用， 则创建 RuntimeBeanReference，运行时动态解析为实际bean </span></span><br><span class="line">      ValueHolder valueHolder = <span class="keyword">new</span> ValueHolder(ref ? <span class="keyword">new</span> RuntimeBeanReference(argValue) : argValue);</span><br><span class="line">      valueHolder.setSource(parserContext.getReaderContext().extractSource(attr));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// handle &quot;escaped&quot;/&quot;_&quot; arguments</span></span><br><span class="line">      <span class="keyword">if</span> (argName.startsWith(DELIMITER_PREFIX)) &#123;</span><br><span class="line">         <span class="comment">// 如果参数名以 _ 开头</span></span><br><span class="line">         String arg = argName.substring(<span class="number">1</span>).trim();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// fast default check</span></span><br><span class="line">         <span class="keyword">if</span> (!StringUtils.hasText(arg)) &#123;</span><br><span class="line">             <span class="comment">// 如果参数名为空，那么添加常规参数值</span></span><br><span class="line">            cvs.addGenericArgumentValue(valueHolder);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// assume an index otherwise</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//解析通过构造函数参数下标来指定的参数</span></span><br><span class="line">            <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               index = Integer.parseInt(arg);</span><br><span class="line">                <span class="comment">//如果不是下标，则记录一下错误</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">               parserContext.getReaderContext().error(</span><br><span class="line">                     <span class="string">&quot;Constructor argument &#x27;&quot;</span> + argName + <span class="string">&quot;&#x27; specifies an invalid integer&quot;</span>, attr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 下标小于0记录错误</span></span><br><span class="line">               parserContext.getReaderContext().error(</span><br><span class="line">                     <span class="string">&quot;Constructor argument &#x27;&quot;</span> + argName + <span class="string">&quot;&#x27; specifies a negative index&quot;</span>, attr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cvs.hasIndexedArgumentValue(index)) &#123;</span><br><span class="line">                <span class="comment">//已经通过&lt;constructor-arg&gt;标签定义了</span></span><br><span class="line">               parserContext.getReaderContext().error(</span><br><span class="line">                     <span class="string">&quot;Constructor argument &#x27;&quot;</span> + argName + <span class="string">&quot;&#x27; with index &quot;</span>+ index+<span class="string">&quot; already defined using &lt;constructor-arg&gt;.&quot;</span> +</span><br><span class="line">                     <span class="string">&quot; Only one approach may be used per argument.&quot;</span>, attr);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 到这里则解析成功，添加进到ConstructorArgumentValues中去</span></span><br><span class="line">            cvs.addIndexedArgumentValue(index, valueHolder);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// no escaping -&gt; ctr name</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 不是下标形式，则直接转换参数名</span></span><br><span class="line">         String name = Conventions.attributeNameToPropertyName(argName);</span><br><span class="line">         <span class="keyword">if</span> (containsArgWithName(name, cvs)) &#123;</span><br><span class="line">             <span class="comment">//检查是否已经定义过</span></span><br><span class="line">            parserContext.getReaderContext().error(</span><br><span class="line">                  <span class="string">&quot;Constructor argument &#x27;&quot;</span> + argName + <span class="string">&quot;&#x27; already defined using &lt;constructor-arg&gt;.&quot;</span> +</span><br><span class="line">                  <span class="string">&quot; Only one approach may be used per argument.&quot;</span>, attr);</span><br><span class="line">         &#125;</span><br><span class="line">         valueHolder.setName(Conventions.attributeNameToPropertyName(argName));</span><br><span class="line">         cvs.addGenericArgumentValue(valueHolder);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结：配置构造函数的方式"><a href="#小结：配置构造函数的方式" class="headerlink" title="小结：配置构造函数的方式"></a>小结：配置构造函数的方式</h4><ol><li><p>使用<code>&lt;constructor-arg&gt;</code>标签，可以使用名称来定义，也可以使用下标。</p></li><li><p>在<code>&lt;bean&gt;</code>标签中使用<code>c:</code>自定义属性, 属性名有两种方式：</p><ol><li>下标形式<code>_0</code> </li><li>构造函数参数名形式<code>c:name=&quot;value&quot;</code></li></ol><p>如果参数值需要引用bean，那么需要在属性名后加上<code>_ref</code>表示引用。</p></li></ol><p>两种方式对比：</p><table><thead><tr><th>方式</th><th>名称</th><th>下标</th></tr></thead><tbody><tr><td><code>&lt;constructor-arg&gt;</code>标签</td><td>name=“name” value=“value” (ref=“beanid”)</td><td>index=“0” value=“value”(ref=“beanid”)</td></tr><tr><td><code>c:</code>属性</td><td>c: name=“value”(c:name_ref=“beanid”)</td><td>c:_0=“value” (c:_0_ref=“beanid”)</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="NamespaceHandlerSupport-命名空间解析器支持类"><a href="#NamespaceHandlerSupport-命名空间解析器支持类" class="headerlink" title="NamespaceHandlerSupport 命名空间解析器支持类"></a><code>NamespaceHandlerSupport</code> 命名空间解析器支持类</h3><p>实现自定义<code>NamespaceHandler</code>的支持类。各个节点的解析和装饰分别通过<code>BeanDefinitionParser</code>和<code>BeanDefinitionDecorator</code>策略接口完成。提供<code>registerBeanDefinitionParser</code>和<code>registerBeanDefinitionDecorator</code>方法，用于注册<code>BeanDefinitionParser</code>或<code>BeanDefinitionDecorator</code>来处理特定元素。</p><h4 id="BeanDefinitionParser"><a href="#BeanDefinitionParser" class="headerlink" title="BeanDefinitionParser"></a><code>BeanDefinitionParser</code></h4><p><code>DefaultBeanDefinitionDocumentReader</code>用于处理自定义顶级标签的接口。实现类可以根据需要自由地将自定义标签中的元数据转换成任意多的bean定义。</p><h5 id="AbstractBeanDefinitionParser-类"><a href="#AbstractBeanDefinitionParser-类" class="headerlink" title="AbstractBeanDefinitionParser 类"></a><code>AbstractBeanDefinitionParser</code> 类</h5><p><code>BeanDefinitionParser</code>实现类，该类提供了许多方便的方法和模板方法，子类必须重写这些方法才能提供实际的解析逻辑。</p><p>当你想将任意复杂的XML解析为一个或多个bean定义时，请使用这个<code>BeanDefinitionParser</code>实现。如果只是想将一些XML解析为一个bean定义，那么可以考虑该类更简单的扩展类，即 <code>AbstractSingleBeanDefinitionParser</code> 和 <code>AbstractSimpleBeanDefinitionParser</code>。</p><h6 id="parse-方法"><a href="#parse-方法" class="headerlink" title="parse 方法"></a><code>parse</code> 方法</h6><p><code>parse</code> 方法是该解析器的入口，定义了整个解析的流程以及子类可以扩展的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//解析出 BeanDefinition， parseInternal 方法是一个抽象方法，子类需要实现</span></span><br><span class="line">   AbstractBeanDefinition definition = parseInternal(element, parserContext);</span><br><span class="line">   <span class="keyword">if</span> (definition != <span class="keyword">null</span> &amp;&amp; !parserContext.isNested()) &#123;</span><br><span class="line">       <span class="comment">// 不是嵌套定义</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//解析出 bean id， 该方法是 protected级别，子类可以重写</span></span><br><span class="line">         String id = resolveId(element, definition, parserContext);</span><br><span class="line">         <span class="keyword">if</span> (!StringUtils.hasText(id)) &#123;</span><br><span class="line">            parserContext.getReaderContext().error(</span><br><span class="line">                  <span class="string">&quot;Id is required for element &#x27;&quot;</span> + parserContext.getDelegate().getLocalName(element)</span><br><span class="line">                        + <span class="string">&quot;&#x27; when used as a top-level tag&quot;</span>, element);</span><br><span class="line">         &#125;</span><br><span class="line">         String[] aliases = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">if</span> (shouldParseNameAsAliases()) &#123;</span><br><span class="line">             <span class="comment">//是否需要将名字解析成 别名，默认为 true, 名称可以用逗号指定多个，那么分隔出来之后作为别名</span></span><br><span class="line">            String name = element.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(name)) &#123;</span><br><span class="line">               aliases = StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray(name));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(definition, id, aliases);</span><br><span class="line">          <span class="comment">//注册bean 定义</span></span><br><span class="line">         registerBeanDefinition(holder, parserContext.getRegistry());</span><br><span class="line">         <span class="keyword">if</span> (shouldFireEvents()) &#123;</span><br><span class="line">             <span class="comment">//发布事件</span></span><br><span class="line">            BeanComponentDefinition componentDefinition = <span class="keyword">new</span> BeanComponentDefinition(holder);</span><br><span class="line">            postProcessComponentDefinition(componentDefinition);</span><br><span class="line">             <span class="comment">//嵌套bean 定义不发布事件</span></span><br><span class="line">            parserContext.registerComponent(componentDefinition);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         String msg = ex.getMessage();</span><br><span class="line">         parserContext.getReaderContext().error((msg != <span class="keyword">null</span> ? msg : ex.toString()), element);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><p>解析流程：</p><ol><li><p>调用<code>parseInternal</code> 方法将 xml 解析成<code>BeanDefinition</code>，该方法由子类去实现</p></li><li><p>调用<code>resolveId</code>方法得到bean 定义id，可以由子类重写</p></li><li><p>别名解析</p></li><li><p>注册bean 定义</p></li><li><p>发布事件，实现<code>ReaderEventListener</code> 进行监听</p></li></ol><h5 id="AbstractSingleBeanDefinitionParser-类"><a href="#AbstractSingleBeanDefinitionParser-类" class="headerlink" title="AbstractSingleBeanDefinitionParser 类"></a><code>AbstractSingleBeanDefinitionParser</code> 类</h5><p>只需要解析和定义一个bean定义的<code>BeanDefinitionParser</code>实现基类，继承自<code>AbstractBeanDefinitionParser</code>类，实现<code>parseInternal</code>方法，近一步细化解析逻辑。</p><p>只需要从任意复杂的XML元素创建单个bean定义时，可以扩展这个解析器类。当你想从一个相对简单的自定义XML元素创建一个bean定义时，可以考虑扩展<code>AbstractSimpleBeanDefinitionParser</code>类。</p><p>生成的bean定义将自动注册到<code>org.springframework.beans.factory.support.BeanDefinitionRegistry</code>。只需要将自定义XML元素解析为一个bean定义就可以了。</p><h6 id="parseInternal方法"><a href="#parseInternal方法" class="headerlink" title="parseInternal方法"></a><code>parseInternal</code>方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建builder</span></span><br><span class="line">BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition();</span><br><span class="line">String parentName = getParentName(element);</span><br><span class="line"><span class="keyword">if</span> (parentName != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//是否有父定义，默认为空，表示顶层 定义 </span></span><br><span class="line">   builder.getRawBeanDefinition().setParentName(parentName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回与元素对应的bean class</span></span><br><span class="line"><span class="comment">//注意，对于应用程序层的类，通常最好重写getBeanClassName，以避免直接依赖于bean实现类。BeanDefinitionParser及其NamespaceHandler可以在IDE插件中使用，即使应用程序类不在插件的类路径中。</span></span><br><span class="line">Class&lt;?&gt; beanClass = getBeanClass(element);</span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">   builder.getRawBeanDefinition().setBeanClass(beanClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//没有设置 beanClass,则通过beanClassName去获取对应的bean</span></span><br><span class="line">   String beanClassName = getBeanClassName(element);</span><br><span class="line">   <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.getRawBeanDefinition().setBeanClassName(beanClassName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">builder.getRawBeanDefinition().setSource(parserContext.extractSource(element));</span><br><span class="line">BeanDefinition containingBd = parserContext.getContainingBeanDefinition();</span><br><span class="line"><span class="keyword">if</span> (containingBd != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//内部bean 定义从父级bean定义中获取scope</span></span><br><span class="line">   <span class="comment">// Inner bean definition must receive same scope as containing bean.</span></span><br><span class="line">   builder.setScope(containingBd.getScope());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (parserContext.isDefaultLazyInit()) &#123;</span><br><span class="line">   <span class="comment">// Default-lazy-init applies to custom bean definitions as well.</span></span><br><span class="line">   builder.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//留给子类去重写的方法，将xml标签属性等映射为bean 定义</span></span><br><span class="line">doParse(element, parserContext, builder);</span><br><span class="line"><span class="keyword">return</span> builder.getBeanDefinition();</span><br></pre></td></tr></table></figure><h6 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h6><p>解析流程：</p><ol><li><p>创建builder</p></li><li><p>设置父级定义名称</p></li><li><p>设置要转换成bean类，通过<code>getBeanClass</code>方法或者<code>getBeanClassName</code></p></li><li><p>根据父级bean定义设置scope</p></li><li><p>设置lazyInit属性</p></li><li><p>调用<code>doParse</code>方法将xml对应的相关属性设置到builder中</p></li><li><p>获取<code>BeanDefinition</code></p><p>对于只需要将xml映射为bean这样简单的解析情形，可以继承这个类实现<code>doParse</code>方法，将xml的属性设置到<code>BeanDefinitionBuilder</code>中即可。</p></li></ol><h3 id="ContextNamespaceHandler上下文命名空间解析器"><a href="#ContextNamespaceHandler上下文命名空间解析器" class="headerlink" title="ContextNamespaceHandler上下文命名空间解析器"></a><code>ContextNamespaceHandler</code>上下文命名空间解析器</h3><p>继承自<code>NamespaceHandlerSupport</code>类，在<code>init</code>方法中注册了<code>context</code>命名空间下的标签解析类。用来解析命名空间地址<code>http://www.springframework.org/schema/context</code>。</p><h4 id="context命名空间下的自定义标签"><a href="#context命名空间下的自定义标签" class="headerlink" title="context命名空间下的自定义标签"></a><code>context</code>命名空间下的自定义标签</h4><p><code>init</code>方法为每个标签都注册了一个解析类</p><table><thead><tr><th>标签</th><th>解析类</th></tr></thead><tbody><tr><td><code>property-placeholder</code></td><td><code>org.springframework.context.config.PropertyPlaceholderBeanDefinitionParser</code></td></tr><tr><td><code>property-override</code></td><td><code>org.springframework.context.config.PropertyOverrideBeanDefinitionParser</code></td></tr><tr><td><code>annotation-config</code></td><td><code>org.springframework.context.annotation.AnnotationConfigBeanDefinitionParser</code></td></tr><tr><td><code>component-scan</code></td><td><code>org.springframework.context.annotation.ComponentScanBeanDefinitionParser</code></td></tr><tr><td><code>load-time-weaver</code></td><td><code>org.springframework.context.config.LoadTimeWeaverBeanDefinitionParser</code></td></tr><tr><td><code>spring-configured</code></td><td><code>org.springframework.context.config.SpringConfiguredBeanDefinitionParser</code></td></tr><tr><td><code>mbean-export</code></td><td><code>org.springframework.context.config.MBeanExportBeanDefinitionParser</code></td></tr><tr><td><code>mbean-server</code></td><td><code>org.springframework.context.config.MBeanServerBeanDefinitionParser</code></td></tr></tbody></table><h5 id="property-placeholder标签解析"><a href="#property-placeholder标签解析" class="headerlink" title="property-placeholder标签解析"></a><code>property-placeholder</code>标签解析</h5><p><code>org.springframework.context.config.PropertyPlaceholderBeanDefinitionParser</code> 类用来解析该标签。继承自<code>AbstractPropertyLoadingBeanDefinitionParser</code>， 该类又继承自<code>AbstractSingleBeanDefinitionParser</code>，因此只返回单个<code>BeanDefinition</code>。</p><p><code>AbstractPropertyLoadingBeanDefinitionParser</code>的<code>doParse</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">   String location = element.getAttribute(<span class="string">&quot;location&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(location)) &#123;</span><br><span class="line">      location = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(location);</span><br><span class="line">      String[] locations = StringUtils.commaDelimitedListToStringArray(location);</span><br><span class="line">      builder.addPropertyValue(<span class="string">&quot;locations&quot;</span>, locations);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String propertiesRef = element.getAttribute(<span class="string">&quot;properties-ref&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(propertiesRef)) &#123;</span><br><span class="line">      builder.addPropertyReference(<span class="string">&quot;properties&quot;</span>, propertiesRef);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String fileEncoding = element.getAttribute(<span class="string">&quot;file-encoding&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(fileEncoding)) &#123;</span><br><span class="line">      builder.addPropertyValue(<span class="string">&quot;fileEncoding&quot;</span>, fileEncoding);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String order = element.getAttribute(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(order)) &#123;</span><br><span class="line">      builder.addPropertyValue(<span class="string">&quot;order&quot;</span>, Integer.valueOf(order));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   builder.addPropertyValue(<span class="string">&quot;ignoreResourceNotFound&quot;</span>,</span><br><span class="line">         Boolean.valueOf(element.getAttribute(<span class="string">&quot;ignore-resource-not-found&quot;</span>)));</span><br><span class="line"></span><br><span class="line">   builder.addPropertyValue(<span class="string">&quot;localOverride&quot;</span>,</span><br><span class="line">         Boolean.valueOf(element.getAttribute(<span class="string">&quot;local-override&quot;</span>)));</span><br><span class="line"></span><br><span class="line">   builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出只是简单的将xml标签的属性取出并设置到builder中。</p><p>再看看<code>PropertyPlaceholderBeanDefinitionParser</code>的<code>doParse</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.doParse(element, parserContext, builder);</span><br><span class="line"></span><br><span class="line">   builder.addPropertyValue(<span class="string">&quot;ignoreUnresolvablePlaceholders&quot;</span>,</span><br><span class="line">         Boolean.valueOf(element.getAttribute(<span class="string">&quot;ignore-unresolvable&quot;</span>)));</span><br><span class="line"></span><br><span class="line">   String systemPropertiesModeName = element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(systemPropertiesModeName) &amp;&amp;</span><br><span class="line">         !systemPropertiesModeName.equals(SYSTEM_PROPERTIES_MODE_DEFAULT)) &#123;</span><br><span class="line">       <span class="comment">// system-properties-mode 不是 ENVIRONMENT</span></span><br><span class="line">      builder.addPropertyValue(<span class="string">&quot;systemPropertiesModeName&quot;</span>, <span class="string">&quot;SYSTEM_PROPERTIES_MODE_&quot;</span> + systemPropertiesModeName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (element.hasAttribute(<span class="string">&quot;value-separator&quot;</span>)) &#123;</span><br><span class="line">      builder.addPropertyValue(<span class="string">&quot;valueSeparator&quot;</span>, element.getAttribute(<span class="string">&quot;value-separator&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (element.hasAttribute(<span class="string">&quot;trim-values&quot;</span>)) &#123;</span><br><span class="line">      builder.addPropertyValue(<span class="string">&quot;trimValues&quot;</span>, element.getAttribute(<span class="string">&quot;trim-values&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (element.hasAttribute(<span class="string">&quot;null-value&quot;</span>)) &#123;</span><br><span class="line">      builder.addPropertyValue(<span class="string">&quot;nullValue&quot;</span>, element.getAttribute(<span class="string">&quot;null-value&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的bean ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">   <span class="comment">// As of Spring 3.1, the default value of system-properties-mode has changed from</span></span><br><span class="line">   <span class="comment">// &#x27;FALLBACK&#x27; to &#x27;ENVIRONMENT&#x27;. This latter value indicates that resolution of</span></span><br><span class="line">   <span class="comment">// placeholders against system properties is a function of the Environment and</span></span><br><span class="line">   <span class="comment">// its current set of PropertySources.</span></span><br><span class="line">   <span class="keyword">if</span> (SYSTEM_PROPERTIES_MODE_DEFAULT.equals(element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE))) &#123;</span><br><span class="line">       <span class="comment">//3.1 开始 system-properties-mode 默认值为 ENVIRONMENT, </span></span><br><span class="line">      <span class="keyword">return</span> PropertySourcesPlaceholderConfigurer.class;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The user has explicitly specified a value for system-properties-mode: revert to</span></span><br><span class="line">   <span class="comment">// PropertyPlaceholderConfigurer to ensure backward compatibility with 3.0 and earlier.</span></span><br><span class="line">    <span class="comment">//3.0以前用这个</span></span><br><span class="line">   <span class="keyword">return</span> PropertyPlaceholderConfigurer.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h6><p>从<code>property-placeholder</code>标签中解析出的属性：</p><table><thead><tr><th>xml属性</th><th>bean 属性</th></tr></thead><tbody><tr><td>location</td><td>locations</td></tr><tr><td>properties-ref</td><td>properties</td></tr><tr><td>file-encoding</td><td>fileEncoding</td></tr><tr><td>order</td><td>order</td></tr><tr><td>ignore-resource-not-found</td><td>ignoreResourceNotFound</td></tr><tr><td>local-override</td><td>localOverride</td></tr><tr><td>ignore-unresolvable</td><td>ignoreUnresolvablePlaceholders</td></tr><tr><td>system-properties-mode</td><td>systemPropertiesModeName</td></tr><tr><td>value-separator</td><td>valueSeparator</td></tr><tr><td>trim-values</td><td>trimValues</td></tr><tr><td>null-value</td><td>nullValue</td></tr></tbody></table><h5 id="property-override标签解析"><a href="#property-override标签解析" class="headerlink" title="property-override标签解析"></a><code>property-override</code>标签解析</h5><p><code>org.springframework.context.config.PropertyOverrideBeanDefinitionParser</code>类用来解析该标签，与<code>property-placeholder</code>标签类似，该类也继承自<code>AbstractPropertyLoadingBeanDefinitionParser</code>，与<code>property-placeholder</code>标签有一些共有的属性。</p><p><code>doParse</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.doParse(element, parserContext, builder);</span><br><span class="line"></span><br><span class="line">   builder.addPropertyValue(<span class="string">&quot;ignoreInvalidKeys&quot;</span>,</span><br><span class="line">         Boolean.valueOf(element.getAttribute(<span class="string">&quot;ignore-unresolvable&quot;</span>)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getBeanClass</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">   <span class="keyword">return</span> PropertyOverrideConfigurer.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h6><p>从<code>property-override</code>标签中解析出的属性：</p><table><thead><tr><th>xml属性</th><th>bean 属性</th></tr></thead><tbody><tr><td>location</td><td>locations</td></tr><tr><td>properties-ref</td><td>properties</td></tr><tr><td>file-encoding</td><td>fileEncoding</td></tr><tr><td>order</td><td>order</td></tr><tr><td>ignore-resource-not-found</td><td>ignoreResourceNotFound</td></tr><tr><td>local-override</td><td>localOverride</td></tr><tr><td>ignore-unresolvable</td><td>ignoreInvalidKeys</td></tr></tbody></table><h5 id="annotation-config标签解析"><a href="#annotation-config标签解析" class="headerlink" title="annotation-config标签解析"></a><code>annotation-config</code>标签解析</h5><p><code>org.springframework.context.annotation.AnnotationConfigBeanDefinitionParser</code>用来解析该标签。该类直接实现了<code>BeanDefinitionParser</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   Object source = parserContext.extractSource(element);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Obtain bean definitions for all relevant BeanPostProcessors.</span></span><br><span class="line">    <span class="comment">// 获取所有相关 BeanPostProcessor 的bean定义。</span></span><br><span class="line">    <span class="comment">// 注册 ConfigurationClassPostProcessor，AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">    <span class="comment">// CommonAnnotationBeanPostProcessor, EventListenerMethodProcessor</span></span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; processorDefinitions =</span><br><span class="line">         AnnotationConfigUtils.registerAnnotationConfigProcessors(parserContext.getRegistry(), source);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register component for the surrounding &lt;context:annotation-config&gt; element.</span></span><br><span class="line">    <span class="comment">// 注册 &lt;context:annotation-config&gt; 标签代表的组件</span></span><br><span class="line">   CompositeComponentDefinition compDefinition = <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), source);</span><br><span class="line">    <span class="comment">//将该组件入栈，处理嵌套bean定义。</span></span><br><span class="line">    <span class="comment">//入栈代表当前组件是上层组件，后面注册的是其内部组件</span></span><br><span class="line">   parserContext.pushContainingComponent(compDefinition);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Nest the concrete beans in the surrounding component.</span></span><br><span class="line">    <span class="comment">//将上面注册的 BeanDefinitionHolder 作为组件的内部bean定义</span></span><br><span class="line">   <span class="keyword">for</span> (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123;</span><br><span class="line">      parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(processorDefinition));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Finally register the composite component.</span></span><br><span class="line">    <span class="comment">// 最后注册该组合组件，发布事件</span></span><br><span class="line">   parserContext.popAndRegisterContainingComponent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该解析器本身不返回bean 定义，只是注册其他相关的bean定义</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可以看到，该解析器注册了几个<code>BeanPostProcessor</code>， 用来处理注解配置，这里先不展开，后面再具体看一下这几个类的作用。其实整个解析器关键的代码只有这一句:</p><blockquote><p>AnnotationConfigUtils.registerAnnotationConfigProcessors(parserContext.getRegistry(), source);</p></blockquote><p>后面的代码用来保证整个解析链的完整性，需要发布解析完成的事件。</p><h5 id="component-scan标签解析"><a href="#component-scan标签解析" class="headerlink" title="component-scan标签解析"></a><code>component-scan</code>标签解析</h5><p><code>org.springframework.context.annotation.ComponentScanBeanDefinitionParser</code> 类用来解析该标签。该类直接实现了<code>BeanDefinitionParser</code>接口。</p><h6 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a><code>parse</code>方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取root 包名</span></span><br><span class="line">   String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line">    <span class="comment">//解析出完整的包名，配置的包名是可以写占位符的</span></span><br><span class="line">   basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);</span><br><span class="line">    <span class="comment">//将包名进行分隔，,; 可以配置多个包</span></span><br><span class="line">   String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</span><br><span class="line">         ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Actually scan for bean definitions and register them.</span></span><br><span class="line">    <span class="comment">// 配置 ClassPathBeanDefinitionScanner，主要包括 bean定义属性默认值，资源类型（**/*.class），</span></span><br><span class="line">    <span class="comment">//BeanNameGenerator，默认筛选注解类型(@Component), 以及筛选类型过滤器&lt;include-filter&gt;,&lt;exclude-filter&gt;</span></span><br><span class="line">   ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line">    <span class="comment">// 开始扫描所有bean定义</span></span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">   <span class="comment">// 注册组件， 这个解析器也调用了 AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source);方法注册BeanPostProcessor</span></span><br><span class="line">    registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h6><p>该解析器主要是配置一个<code>ClassPathBeanDefinitionScanner</code>，然后调用其<code>doScan</code>方法，默认扫描<code>@Component</code>注解的类，并且可以配置过滤器调整扫描范围。解析出来的扫描路径以<code>classpath*:</code>开头，因此可以扫描到jar里面的注解。</p><h5 id="load-time-weaver标签解析"><a href="#load-time-weaver标签解析" class="headerlink" title="load-time-weaver标签解析"></a><code>load-time-weaver</code>标签解析</h5><p><code>org.springframework.context.config.LoadTimeWeaverBeanDefinitionParser</code>标签用来解析该标签。继承自<code>org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser</code>，返回一个bean定义。</p><p><code>getBeanClassName</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getBeanClassName</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (element.hasAttribute(WEAVER_CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">      <span class="keyword">return</span> element.getAttribute(WEAVER_CLASS_ATTRIBUTE);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//默认返回 org.springframework.context.weaving.DefaultContextLoadTimeWeaver</span></span><br><span class="line">   <span class="keyword">return</span> DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doParse</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">   builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (isAspectJWeavingEnabled(element.getAttribute(ASPECTJ_WEAVING_ATTRIBUTE), parserContext)) &#123;</span><br><span class="line">       <span class="comment">//是否启用aspectj</span></span><br><span class="line">      <span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(ASPECTJ_WEAVING_ENABLER_BEAN_NAME)) &#123;</span><br><span class="line">          <span class="comment">//如果还没注册 org.springframework.context.config.internalAspectJWeavingEnabler 就注册</span></span><br><span class="line">         RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ASPECTJ_WEAVING_ENABLER_CLASS_NAME);</span><br><span class="line">         parserContext.registerBeanComponent(</span><br><span class="line">               <span class="keyword">new</span> BeanComponentDefinition(def, ASPECTJ_WEAVING_ENABLER_BEAN_NAME));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isBeanConfigurerAspectEnabled(parserContext.getReaderContext().getBeanClassLoader())) &#123;</span><br><span class="line">          <span class="comment">//如果引入了 org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect 类则调用</span></span><br><span class="line">          <span class="comment">//SpringConfiguredBeanDefinitionParser来解析标签</span></span><br><span class="line">         <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser().parse(element, parserContext);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="spring-configured标签解析"><a href="#spring-configured标签解析" class="headerlink" title="spring-configured标签解析"></a><code>spring-configured</code>标签解析</h5><p>该标签由<code>org.springframework.context.config.SpringConfiguredBeanDefinitionParser</code>来解析。</p><p><code>parse</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;  <span class="keyword">if</span>(!parserContext.getRegistry().containsBeanDefinition(BEAN_CONFIGURER_ASPECT_BEAN_NAME)) &#123;</span><br><span class="line">   <span class="comment">//如果没注册 org.springframework.context.config.internalBeanConfigurerAspect</span></span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">      <span class="comment">// org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect</span></span><br><span class="line">      def.setBeanClassName(BEAN_CONFIGURER_ASPECT_CLASS_NAME);</span><br><span class="line">      def.setFactoryMethodName(<span class="string">&quot;aspectOf&quot;</span>);</span><br><span class="line">      def.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">      def.setSource(parserContext.extractSource(element));</span><br><span class="line">      parserContext.registerBeanComponent(<span class="keyword">new</span> BeanComponentDefinition(def, BEAN_CONFIGURER_ASPECT_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AopNamespaceHandler-Aop-命名空间解析器"><a href="#AopNamespaceHandler-Aop-命名空间解析器" class="headerlink" title="AopNamespaceHandler Aop 命名空间解析器"></a><code>AopNamespaceHandler</code> Aop 命名空间解析器</h3><p>用于<code>aop</code>命名空间的<code>NamespaceHandler</code>。继承自<code>NamespaceHandlerSupport</code>,注册以下<code>BeanDefinitionParser</code>:</p><table><thead><tr><th>标签</th><th>解析类</th></tr></thead><tbody><tr><td><code>config</code></td><td><code>ConfigBeanDefinitionParser</code></td></tr><tr><td><code>aspectj-autoproxy</code></td><td><code>AspectJAutoProxyBeanDefinitionParser</code></td></tr></tbody></table><p>注册<code>BeanDefinitionDecorator</code>:</p><table><thead><tr><th>属性</th><th>解析类</th></tr></thead><tbody><tr><td><code>scoped-proxy</code></td><td><code>ScopedProxyBeanDefinitionDecorator</code></td></tr></tbody></table><p>为<code>&lt;aop:config&gt;</code>标签提供一个<code>BeanDefinitionParser</code>。<code>config</code>标签可以包含嵌套的<code>pointcut</code>、<code>advisor</code>和<code>aspect</code>标签。</p><p><code>pointcut</code>标签允许使用简单的语法创建命名的<code>AspectJExpressionPointcut</code> bean:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;getNameCalls&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..ITestBean.getName(..))&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>advisor</code>标签，可以配置<code>org.springframework.aop.Advisor</code>并自动将其应用于<code>org.springframework.beans.factory.BeanFactory</code>中所有相关bean。<code>advisor</code>标签支持内联和引用<code>pointcut</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">id</span>=<span class="string">&quot;getAgeAdvisor&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *..ITestBean.getAge(..))&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">advice-ref</span>=<span class="string">&quot;getAgeCounter&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">id</span>=<span class="string">&quot;getNameAdvisor&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">pointcut-ref</span>=<span class="string">&quot;getNameCalls&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">advice-ref</span>=<span class="string">&quot;getNameCounter&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="lt-aop-config-gt-标签解析"><a href="#lt-aop-config-gt-标签解析" class="headerlink" title="&lt;aop:config&gt;标签解析"></a><code>&lt;aop:config&gt;</code>标签解析</h4><p><code>org.springframework.aop.config.ConfigBeanDefinitionParser</code>类用来解析该标签。实现了<code>BeanDefinitionParser</code> 接口</p><h5 id="parse方法："><a href="#parse方法：" class="headerlink" title="parse方法："></a><code>parse</code>方法：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   CompositeComponentDefinition compositeDef =</span><br><span class="line">         <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element));</span><br><span class="line">    <span class="comment">//标识当前组件是容器组件</span></span><br><span class="line">   parserContext.pushContainingComponent(compositeDef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册 AspectJAwareAdvisorAutoProxyCreator</span></span><br><span class="line">   configureAutoProxyCreator(parserContext, element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析子标签 pointcut advisor aspect</span></span><br><span class="line">   List&lt;Element&gt; childElts = DomUtils.getChildElements(element);</span><br><span class="line">   <span class="keyword">for</span> (Element elt: childElts) &#123;</span><br><span class="line">      String localName = parserContext.getDelegate().getLocalName(elt);</span><br><span class="line">      <span class="keyword">if</span> (POINTCUT.equals(localName)) &#123;</span><br><span class="line">         parsePointcut(elt, parserContext);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ADVISOR.equals(localName)) &#123;</span><br><span class="line">         parseAdvisor(elt, parserContext);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ASPECT.equals(localName)) &#123;</span><br><span class="line">         parseAspect(elt, parserContext);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈并注册当前容器组件，容器组件会发布事件</span></span><br><span class="line">   parserContext.popAndRegisterContainingComponent();</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="parsePointcut-方法解析切入点"><a href="#parsePointcut-方法解析切入点" class="headerlink" title="parsePointcut 方法解析切入点"></a><code>parsePointcut </code>方法解析切入点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractBeanDefinition <span class="title">parsePointcut</span><span class="params">(Element pointcutElement, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// id</span></span><br><span class="line">   String id = pointcutElement.getAttribute(ID);</span><br><span class="line">    <span class="comment">// 表达式</span></span><br><span class="line">   String expression = pointcutElement.getAttribute(EXPRESSION);</span><br><span class="line"></span><br><span class="line">   AbstractBeanDefinition pointcutDefinition = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 将当前元素入栈</span></span><br><span class="line">      <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> PointcutEntry(id));</span><br><span class="line">       <span class="comment">// 创建切入点对应的bean定义，bean类型为 AspectJExpressionPointcut</span></span><br><span class="line">      pointcutDefinition = createPointcutDefinition(expression);</span><br><span class="line">      pointcutDefinition.setSource(parserContext.extractSource(pointcutElement));</span><br><span class="line"></span><br><span class="line">      String pointcutBeanName = id;</span><br><span class="line">       <span class="comment">// 注册当前bean定义</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(pointcutBeanName)) &#123;</span><br><span class="line">         parserContext.getRegistry().registerBeanDefinition(pointcutBeanName, pointcutDefinition);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         pointcutBeanName = parserContext.getReaderContext().registerWithGeneratedName(pointcutDefinition);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将切入点组件加入到 config标签容器组件中，作为其内部组件</span></span><br><span class="line">      parserContext.registerComponent(</span><br><span class="line">            <span class="keyword">new</span> PointcutComponentDefinition(pointcutBeanName, pointcutDefinition, expression));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">// 解析完当前切入点元素，出栈</span></span><br><span class="line">      <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> pointcutDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="parseAdvisor-解析advisor标签"><a href="#parseAdvisor-解析advisor标签" class="headerlink" title="parseAdvisor 解析advisor标签"></a><code>parseAdvisor</code> 解析<code>advisor</code>标签</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseAdvisor</span><span class="params">(Element advisorElement, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对应的bean定义，bean类型为 DefaultBeanFactoryPointcutAdvisor, advice-ref 属性需要引用一个实现了org.aopalliance.aop.Advice 接口的bean</span></span><br><span class="line">   AbstractBeanDefinition advisorDef = createAdvisorBeanDefinition(advisorElement, parserContext);</span><br><span class="line">   String id = advisorElement.getAttribute(ID);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> AdvisorEntry(id));</span><br><span class="line">      String advisorBeanName = id;</span><br><span class="line">       <span class="comment">//注册当前bean定义</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(advisorBeanName)) &#123;</span><br><span class="line">         parserContext.getRegistry().registerBeanDefinition(advisorBeanName, advisorDef);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         advisorBeanName = parserContext.getReaderContext().registerWithGeneratedName(advisorDef);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//解析pointcut</span></span><br><span class="line">      Object pointcut = parsePointcutProperty(advisorElement, parserContext);</span><br><span class="line">       <span class="comment">//如果是pointcut bean定义，其实就是expression</span></span><br><span class="line">      <span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> BeanDefinition) &#123;</span><br><span class="line">         advisorDef.getPropertyValues().add(POINTCUT, pointcut);</span><br><span class="line">         parserContext.registerComponent(</span><br><span class="line">               <span class="keyword">new</span> AdvisorComponentDefinition(advisorBeanName, advisorDef, (BeanDefinition) pointcut));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">         advisorDef.getPropertyValues().add(POINTCUT, <span class="keyword">new</span> RuntimeBeanReference((String) pointcut));</span><br><span class="line">         parserContext.registerComponent(</span><br><span class="line">               <span class="keyword">new</span> AdvisorComponentDefinition(advisorBeanName, advisorDef));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="parseAspect-解析切面"><a href="#parseAspect-解析切面" class="headerlink" title="parseAspect 解析切面"></a><code>parseAspect</code> 解析切面</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseAspect</span><span class="params">(Element aspectElement, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   String aspectId = aspectElement.getAttribute(ID);</span><br><span class="line">    <span class="comment">//切面bean</span></span><br><span class="line">   String aspectName = aspectElement.getAttribute(REF);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> AspectEntry(aspectId, aspectName));</span><br><span class="line">      List&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      List&lt;BeanReference&gt; beanReferences = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//解析declare-parents 子标签， 对应的bean为 DeclareParentsAdvisor</span></span><br><span class="line">      List&lt;Element&gt; declareParents = DomUtils.getChildElementsByTagName(aspectElement, DECLARE_PARENTS);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = METHOD_INDEX; i &lt; declareParents.size(); i++) &#123;</span><br><span class="line">         Element declareParentsElement = declareParents.get(i);</span><br><span class="line">         beanDefinitions.add(parseDeclareParents(declareParentsElement, parserContext));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We have to parse &quot;advice&quot; and all the advice kinds in one loop, to get the</span></span><br><span class="line">      <span class="comment">// ordering semantics right.</span></span><br><span class="line">       <span class="comment">// 必须得在一个循环中解析出所有的advice，保证其顺序</span></span><br><span class="line">      NodeList nodeList = aspectElement.getChildNodes();</span><br><span class="line">      <span class="keyword">boolean</span> adviceFoundAlready = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">         Node node = nodeList.item(i);</span><br><span class="line">         <span class="keyword">if</span> (isAdviceNode(node, parserContext)) &#123;</span><br><span class="line">             <span class="comment">// 通知类型 before，after，after-returning，after-throwing，around</span></span><br><span class="line">            <span class="keyword">if</span> (!adviceFoundAlready) &#123;</span><br><span class="line">               adviceFoundAlready = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">if</span> (!StringUtils.hasText(aspectName)) &#123;</span><br><span class="line">                  parserContext.getReaderContext().error(</span><br><span class="line">                        <span class="string">&quot;&lt;aspect&gt; tag needs aspect bean reference via &#x27;ref&#x27; attribute when declaring advices.&quot;</span>,</span><br><span class="line">                        aspectElement, <span class="keyword">this</span>.parseState.snapshot());</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               beanReferences.add(<span class="keyword">new</span> RuntimeBeanReference(aspectName));</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 为每个 advice创建 AspectJPointcutAdvisor</span></span><br><span class="line">            AbstractBeanDefinition advisorDefinition = parseAdvice(</span><br><span class="line">                  aspectName, i, aspectElement, (Element) node, parserContext, beanDefinitions, beanReferences);</span><br><span class="line">            beanDefinitions.add(advisorDefinition);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      AspectComponentDefinition aspectComponentDefinition = createAspectComponentDefinition(</span><br><span class="line">            aspectElement, aspectId, beanDefinitions, beanReferences, parserContext);</span><br><span class="line">      parserContext.pushContainingComponent(aspectComponentDefinition);</span><br><span class="line"></span><br><span class="line">      List&lt;Element&gt; pointcuts = DomUtils.getChildElementsByTagName(aspectElement, POINTCUT);</span><br><span class="line">       <span class="comment">//解析切入点，跟单独定义在外面的切入点一样解析</span></span><br><span class="line">      <span class="keyword">for</span> (Element pointcutElement : pointcuts) &#123;</span><br><span class="line">         parsePointcut(pointcutElement, parserContext);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      parserContext.popAndRegisterContainingComponent();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h5><p>注册的<code>BeanDefinition</code>如下：</p><table><thead><tr><th>标签</th><th>BeanDefinition</th></tr></thead><tbody><tr><td>config</td><td><code>AspectJAwareAdvisorAutoProxyCreator</code></td></tr><tr><td>pointcut</td><td>AspectJExpressionPointcut</td></tr><tr><td>advisor</td><td>DefaultBeanFactoryPointcutAdvisor</td></tr><tr><td>before，after，after-returning，after-throwing，around</td><td>AspectJPointcutAdvisor</td></tr><tr><td>declare-parents</td><td>DeclareParentsAdvisor</td></tr></tbody></table><h4 id="lt-aop-aspectj-autoproxy-gt-标签解析"><a href="#lt-aop-aspectj-autoproxy-gt-标签解析" class="headerlink" title="&lt;aop:aspectj-autoproxy&gt;标签解析"></a><code>&lt;aop:aspectj-autoproxy&gt;</code>标签解析</h4><p><code>AspectJAutoProxyBeanDefinitionParser</code>类用来解析该标签，实现了<code>BeanDefinitionParser</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">//注册或增强 AnnotationAwareAspectJAutoProxyCreator类</span></span><br><span class="line">   <span class="comment">// 解析 proxy-target-class和 expose-proxy</span></span><br><span class="line">    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">   extendBeanDefinition(element, parserContext);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">extendBeanDefinition</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   BeanDefinition beanDef =</span><br><span class="line">         parserContext.getRegistry().getBeanDefinition(AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">   <span class="keyword">if</span> (element.hasChildNodes()) &#123;</span><br><span class="line">       <span class="comment">//解析 include 标签</span></span><br><span class="line">      addIncludePatterns(element, parserContext, beanDef);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addIncludePatterns</span><span class="params">(Element element, ParserContext parserContext, BeanDefinition beanDef)</span> </span>&#123;</span><br><span class="line">   ManagedList&lt;TypedStringValue&gt; includePatterns = <span class="keyword">new</span> ManagedList&lt;&gt;();</span><br><span class="line">   NodeList childNodes = element.getChildNodes();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childNodes.getLength(); i++) &#123;</span><br><span class="line">      Node node = childNodes.item(i);</span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">         Element includeElement = (Element) node;</span><br><span class="line">         TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(includeElement.getAttribute(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">         valueHolder.setSource(parserContext.extractSource(includeElement));</span><br><span class="line">         includePatterns.add(valueHolder);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!includePatterns.isEmpty()) &#123;</span><br><span class="line">      includePatterns.setSource(parserContext.extractSource(element));</span><br><span class="line">      beanDef.getPropertyValues().add(<span class="string">&quot;includePatterns&quot;</span>, includePatterns);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h6><p>注册的<code>BeanDefinition</code>如下：</p><table><thead><tr><th>标签</th><th>BeanDefinition</th></tr></thead><tbody><tr><td>aspectj-autoproxy</td><td>AnnotationAwareAspectJAutoProxyCreator</td></tr></tbody></table><h3 id="MvcNamespaceHandler解析MVC命名空间"><a href="#MvcNamespaceHandler解析MVC命名空间" class="headerlink" title="MvcNamespaceHandler解析MVC命名空间"></a><code>MvcNamespaceHandler</code>解析MVC命名空间</h3><p>该类<code>init</code>方法中注册了下面的解析器：</p><table><thead><tr><th>annotation-driven</th><th>AnnotationDrivenBeanDefinitionParser</th></tr></thead><tbody><tr><td>default-servlet-handler</td><td>DefaultServletHandlerBeanDefinitionParser</td></tr><tr><td>interceptors</td><td>InterceptorsBeanDefinitionParser</td></tr><tr><td>resources</td><td>ResourcesBeanDefinitionParser</td></tr><tr><td>view-controller</td><td>ViewControllerBeanDefinitionParser</td></tr><tr><td>redirect-view-controller</td><td>ViewControllerBeanDefinitionParser</td></tr><tr><td>status-controller</td><td>ViewControllerBeanDefinitionParser</td></tr><tr><td>view-resolvers</td><td>ViewResolversBeanDefinitionParser</td></tr><tr><td>tiles-configurer</td><td>TilesConfigurerBeanDefinitionParser</td></tr><tr><td>freemarker-configurer</td><td>FreeMarkerConfigurerBeanDefinitionParser</td></tr><tr><td>groovy-configurer</td><td>GroovyMarkupConfigurerBeanDefinitionParser</td></tr><tr><td>script-template-configurer</td><td>ScriptTemplateConfigurerBeanDefinitionParser</td></tr><tr><td>cors</td><td>CorsBeanDefinitionParser</td></tr></tbody></table><p>后面再专门写一篇讲MVC的。</p><h2 id="自定义命名空间示例"><a href="#自定义命名空间示例" class="headerlink" title="自定义命名空间示例"></a>自定义命名空间示例</h2><p>自定义命名空间可以分为步：</p><ol><li>定义<code>NamespaceHandler</code></li><li>定义命名空间地址，创建<code>META-INF/spring.handlers</code>文件，注册<code>NamespaceHandler</code></li><li>如果<code>NamespaceHandler</code>继承自<code>NamespaceHandlerSupport</code>，则定义<code>BeanDefinitionParser</code>。用来解析具体的标签</li></ol><h3 id="自定义NamespaceHandler"><a href="#自定义NamespaceHandler" class="headerlink" title="自定义NamespaceHandler"></a>自定义<code>NamespaceHandler</code></h3><p>为了方便，通常是继承<code>NamespaceHandlerSupport</code>。在<code>init</code>方法中注册标签解析器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;start-up&quot;</span>,<span class="keyword">new</span> MyNamespaceStartUpBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册NamespaceHandler"><a href="#注册NamespaceHandler" class="headerlink" title="注册NamespaceHandler"></a>注册<code>NamespaceHandler</code></h3><p>在<code>META-INF</code>目录下创建<code>spring.handlers</code>文件，文件内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;my &#x3D;cn.sexycode.spring.study.chapter3.MyNamespaceHandler</span><br></pre></td></tr></table></figure><p>Spring 在会读到自定义命名空间时，从这个文件中解析对应的handler。<code>=</code> 前面为命名空间地址</p><h3 id="实现BeanDefinitionParser"><a href="#实现BeanDefinitionParser" class="headerlink" title="实现BeanDefinitionParser"></a>实现<code>BeanDefinitionParser</code></h3><p>由于handler继承自<code>NamespaceHandlerSupport</code>，那么我们可以实现这个接口用来解析标签。Spring 为我们提供了一个抽象类，用来只返回一个bean 定义的时候使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNamespaceStartUpBeanDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractSingleBeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">        <span class="comment">// 这里我们注册的bean为 MyBeanPostProcessor, 换成我们实际想要注册的类，这里仅供演示</span></span><br><span class="line">        <span class="keyword">return</span> MyBeanPostProcessor.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldGenerateId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为我们生成id</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>上述几步之后，我们就可以在例子中使用了。xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:my</span>=<span class="string">&quot;http://www.springframework.org/schema/my&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my:start-up</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为我们没有定义dtd，导致无法通过校验。我们使用时可以设置为不校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNamespaceHandlerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初始化一个bean 工厂</span></span><br><span class="line">        DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 2. 初始化XmlBeanDefinitionReader,负责从xml文件中读取bean定义</span></span><br><span class="line">        XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">        <span class="comment">//不校验dtd</span></span><br><span class="line">        reader.setValidating(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 3. 加载bean 定义的入口方法</span></span><br><span class="line">        reader.loadBeanDefinitions(<span class="string">&quot;MyNamespaceHandlerDemo.xml&quot;</span>);</span><br><span class="line">        System.out.println(factory.getBean(MyBeanPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>cn.sexycode.spring.study.chapter3.MyBeanPostProcessor@78b1cc93</p></blockquote><p>可以看到已经正确注册到容器中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 自定义 </tag>
            
            <tag> 命名空间 </tag>
            
            <tag> NamespaceHandler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring ApplicationContext初始化过程</title>
      <link href="/post/736b/"/>
      <url>/post/736b/</url>
      
        <content type="html"><![CDATA[<p>在<code>ApplicationContext</code>初始化过程中各组件所处的位置。</p><p><img src="/post/736b/1557729188468.png" alt="初始化"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 初始化 </tag>
            
            <tag> ApplicationContext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 常用接口</title>
      <link href="/post/dac1/"/>
      <url>/post/dac1/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-常用接口"><a href="#Spring-常用接口" class="headerlink" title="Spring 常用接口"></a>Spring 常用接口</h1><h2 id="Bean-工厂相关"><a href="#Bean-工厂相关" class="headerlink" title="Bean 工厂相关"></a>Bean 工厂相关</h2><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p><img src="/post/dac1/59e2e5d2.png" alt="类图"></p><p>这个接口是访问Spring bean 容器的顶层接口。实现类会持有一些bean定义，每一个都有唯一的名称。根据bean定义，这个工厂将返回一个独立的（原型设计模式），或者是一个共享的实例(单例模式的强力替代品，实例在工厂的生存周期内是一个单例),返回的实例类型取决于工厂配置。</p><p>这种方式的要点是BeanFactory是应用程序组件的注册中心，并集中配置应用的组件(例如，单个对象不再需要读取配置文件)。</p><h4 id="ListableBeanFactory"><a href="#ListableBeanFactory" class="headerlink" title="ListableBeanFactory"></a>ListableBeanFactory</h4><p>继承自<code>BeanFactory</code>, 这个接口的用途是枚举所有bean 实例，而不是客户端通过名称一个个查找。</p><h4 id="HierarchicalBeanFactory"><a href="#HierarchicalBeanFactory" class="headerlink" title="HierarchicalBeanFactory"></a>HierarchicalBeanFactory</h4><p>这个接口用来实现工厂的继承关系，</p><h4 id="AutowireCapableBeanFactory"><a href="#AutowireCapableBeanFactory" class="headerlink" title="AutowireCapableBeanFactory"></a>AutowireCapableBeanFactory</h4><p>此工厂提供bean自动注入功能。</p><h4 id="ConfigurableBeanFactory"><a href="#ConfigurableBeanFactory" class="headerlink" title="ConfigurableBeanFactory"></a>ConfigurableBeanFactory</h4><p>提供配置bean工厂的功能，但是此工厂一般是框架内部使用。</p><h4 id="ConfigurableListableBeanFactory"><a href="#ConfigurableListableBeanFactory" class="headerlink" title="ConfigurableListableBeanFactory"></a>ConfigurableListableBeanFactory</h4><p>提供分析和修改bean定义和预初始化单例bean的功能。</p><h3 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h3><p>用于类型转换的服务接口。这是转换系统的入口点。调用<code>convert(Object, Class)</code>方法来使用此系统执行线程安全类型转换</p><h3 id="AliasRegistry"><a href="#AliasRegistry" class="headerlink" title="AliasRegistry"></a>AliasRegistry</h3><p>用来注册别名的顶层接口</p><h4 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h4><p>用来注册bean 定义</p><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>接口由BeanFactory中的对象实现，这些对象本身是用于单个对象的工厂。如果一个bean实现了这个接口，那么它将被用作要公开的对象的工厂，而不是将自己公开的bean实例。</p><p><strong>注意:实现此接口的bean不能作为普通bean使用。FactoryBean是以bean形式定义的，但是bean引用公开的对象(<code>getObject()</code>)总是它创建的对象。</strong></p><p><code>FactoryBean</code>s可以支持单例和原型，可以根据需要创建对象，也可以在启动时创建对象。<code>SmartFactoryBean</code>接口允许公开更细粒度的行为元数据。</p><p>这个接口在框架本身中大量使用，例如在AOP <code>org.springframework.aop.framework.ProxyFactoryBean</code>或<code>org.springframework.jndi.JndiObjectFactoryBean</code>中。它也可以用于定制组件; 然而，这只在基础组件代码中很常见。<br><code>FactoryBean</code>是一个编程契约。实现不应该依赖于<code>annotation-driven</code>注入或其他反射工具。可能会在启动过程中提前调用<code>getObjectType()</code> 和<code>getObject()</code>，甚至比任何后处理器设置都要早。如果需要访问其他bean，请实现<code>BeanFactoryAware</code>并通过编写代码获取。</p><p>最后，<code>FactoryBean</code>对象参与bean工厂的bean创建同步过程。通常不需要内部同步，只需要在<code>FactoryBean</code>本身(或类似的东西)中进行延迟初始化即可</p><h3 id="SmartFactoryBean"><a href="#SmartFactoryBean" class="headerlink" title="SmartFactoryBean"></a>SmartFactoryBean</h3><p><code>FactoryBean</code>接口的扩展。当<code>isSingleton()</code>实现返回<code>false</code>而没有明确表示独立实例时，实现类可能会指示它们是否总是返回独立实例。</p><p>如果它们的<code>isSingleton()</code>实现返回false，那么不实现这个扩展接口的纯<code>FactoryBean</code>实现类将始终返回独立实例;只有在需要时才访问公开的对象。</p><p><strong>注意:这个接口是一个特殊用途的接口，主要用于框架内部和协作框架内部。通常，应用程序提供的<code>FactoryBean</code>应该简单地实现普通的<code>FactoryBean</code>接口。新的方法可能会被添加到这个扩展的接口中.</strong></p><h3 id="BeanNameGenerator"><a href="#BeanNameGenerator" class="headerlink" title="BeanNameGenerator"></a>BeanNameGenerator</h3><p>用于为bean定义生成bean名称的策略接口</p><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>允许自定义修改应用程序上下文的bean定义，调整上下文的底层bean工厂的bean属性值。</p><p>应用程序上下文可以自动检测bean定义中的<code>BeanFactoryPostProcessor</code> bean，并在创建任何其他bean之前应用它们。</p><p>系统管理员使用自定义配置文件覆盖在应用程序上下文中配置的bean属性非常有用。</p><p>有关解决此类配置需求的开箱即用解决方案，请参见<code>PropertyResourceConfigurer</code>及其具体实现。</p><p><code>BeanFactoryPostProcessor</code>可以与bean定义交互并修改bean定义，但不能与bean实例交互。这样做可能会导致过早的bean实例化，破坏容器并导致意想不到的副作用。如果需要与bean实例交互，可以考虑实现<code>BeanPostProcessor</code>。</p><h4 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h4><p>扩展标准的<code>BeanFactoryPostProcessor</code> SPI，允许在常规的<code>BeanFactoryPostProcessor</code>检测开始之前注册更多的bean定义。特别是，<code>BeanDefinitionRegistryPostProcessor</code>可以注册更多的bean定义，这些bean定义又定义<code>BeanFactoryPostProcessor</code>实例。</p><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>工厂允许自定义修改新的bean实例的入口，例如检查标记接口或用代理包装它们。</p><p><code>ApplicationContext</code>可以自动检测bean定义中的<code>BeanPostProcessor</code> bean，并将它们应用于随后创建的任何bean。普通bean工厂允许编程式注册后处理程序，适用于通过该工厂创建的所有bean。</p><p>通常，通过标记接口或类似方法填充bean的后处理程序将实现<code>postProcessBeforeInitialization</code>方法，而使用代理包装bean的后处理器通常实现<code>postProcessAfterInitialization</code>方法.</p><h3 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="ImportSelector"></a>ImportSelector</h3><p>根据给定的选择标准(通常是一个或多个注解属性)确定应该导入哪个<code>@Configuration</code>类。<br><code>ImportSelector</code>可以实现以下任何一个感知接口，它们各自的方法将在<code>selectImports</code>之前被调用:</p><ul><li><code>EnvironmentAware</code></li><li><code>BeanFactoryAware</code></li><li><code>BeanClassLoaderAware</code></li><li><code>ResourceLoaderAware</code><br><code>ImportSelector</code>通常以与常规<code>@Import</code>注解相同的方式处理，但是，也可以推迟选择导入，直到处理完所有<code>@Configuration</code>类(有关详细信息，请参阅<code>DeferredImportSelector</code>)</li></ul><h4 id="DeferredImportSelector"><a href="#DeferredImportSelector" class="headerlink" title="DeferredImportSelector"></a>DeferredImportSelector</h4><p><code>ImportSelector</code>的一个变体，它在处理完所有<code>@Configuration</code> bean之后运行。当选择的导入是<code>@Conditional</code>时，这种类型的选择器特别有用。<br>实现类还可以扩展<code>org.springframework.core.Ordered</code>接口或使用<code>org.springframework.core.annotation.Order</code>注解，指示相对于其他<code>DeferredImportSelector</code>的优先级。</p><p>实现类还可以提供一个导入组（<code>getImportGroup()</code>），该导入组可以跨不同的选择器提供额外的排序和过滤逻辑.</p><h3 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h3><p>可以用来在处理<code>@Configuration</code>类时注册其他bean定义。在bean定义级别(与<code>@Bean</code>方法/实例级别相反)操作是需要的或必要的。<br>与<code>@Configuration</code>和<code>ImportSelector</code>一起，可以向<code>@Import</code>注解提供这种类型的类(或者也可以从<code>ImportSelector</code>返回)。<br><code>ImportBeanDefinitionRegistrar</code>可以实现以下任何一个可感知的接口，它们各自的方法将在<code>registerBeanDefinitions</code>之前被调用:</p><ul><li><code>EnvironmentAware</code></li><li><code>BeanFactoryAware</code></li><li><code>BeanClassLoaderAware</code></li><li><code>ResourceLoaderAware</code></li></ul><h2 id="应用上下文相关"><a href="#应用上下文相关" class="headerlink" title="应用上下文相关"></a>应用上下文相关</h2><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p><img src="/post/dac1/990d4ca9.png" alt="类图"></p><p>此接口用来为应用程序提供配置。在应用运行过程中，配置应该是只读的，但是可以根据实现类来实现重新加载。</p><p><code>ApplicationContext</code> 提供：</p><ul><li>访问应用组件的工厂方法，从<code>ListableBeanFactory</code> 接口继承而来。</li><li>通用的方式加载资源文件，从<code>ResourceLoader</code>接口继承而来。</li><li>向注册的监听器发布事件。从<code>ApplicationEventPublisher</code>接口继承而来。</li><li>转换消息，并支持国际化，从<code>MessageSource</code>接口继承而来。</li><li>继承父级上下文能力。后代上下文中的定义将保持优先。这意味着，比如说一个父上下文可以被整个web应用访问，然而每个servlet有它自己的子类上下文，这个上下文是和别的servlet隔离的。</li></ul><h4 id="ConfigurableApplicationContext"><a href="#ConfigurableApplicationContext" class="headerlink" title="ConfigurableApplicationContext"></a>ConfigurableApplicationContext</h4><p>此接口提供配置应用上下文的方法</p><h3 id="AttributeAccessor"><a href="#AttributeAccessor" class="headerlink" title="AttributeAccessor"></a>AttributeAccessor</h3><p>该接口定义用于向任意对象设置和访问元数据的通用协议。</p><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p>bean定义描述了一个bean实例的属性值、构造函数参数值和由具体实现提供的进一步信息。<br>这只是一个最小的接口:主要目的是允许<code>BeanFactoryPostProcessor</code>(如<code>PropertyPlaceholderConfigurer</code>)反省和修改属性值和bean其他的元数据</p><h4 id="AnnotatedBeanDefinition"><a href="#AnnotatedBeanDefinition" class="headerlink" title="AnnotatedBeanDefinition"></a>AnnotatedBeanDefinition</h4><p>bean定义的扩展接口，它暴露<code>AnnotationMetadata</code>的bean 类型——而不需要加载该类。</p><h2 id="类型元数据相关"><a href="#类型元数据相关" class="headerlink" title="类型元数据相关"></a>类型元数据相关</h2><h3 id="ClassMetadata"><a href="#ClassMetadata" class="headerlink" title="ClassMetadata"></a>ClassMetadata</h3><p>该接口定义特定类的抽象元数据，不需要加载该类。</p><h3 id="AnnotatedTypeMetadata"><a href="#AnnotatedTypeMetadata" class="headerlink" title="AnnotatedTypeMetadata"></a>AnnotatedTypeMetadata</h3><p>定义对特定类型(类<code>AnnotationMetadata</code>或方法<code>MethodMetadata</code>)的注解的访问，其方式不一定需要加载类</p><h3 id="AnnotationMetadata"><a href="#AnnotationMetadata" class="headerlink" title="AnnotationMetadata"></a>AnnotationMetadata</h3><p>定义访问特定类型注解的方式</p><h3 id="MethodMetadata"><a href="#MethodMetadata" class="headerlink" title="MethodMetadata"></a>MethodMetadata</h3><h3 id="MetadataReader"><a href="#MetadataReader" class="headerlink" title="MetadataReader"></a>MetadataReader</h3><p>用于访问类元数据的简单门面，由ASM<code>org.springframework.asm.ClassReader</code>类实现</p><h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>加载资源的策略接口(例如类路径或文件系统资源)。<code>org.springframework.context.ApplicationContext</code>需要提供此功能，以及扩展<code>org.springframework.core.io.support.ResourcePatternResolver</code>支持。</p><p><code>DefaultResourceLoader</code>是一个独立的实现，可以在<code>ApplicationContext</code>之外使用，也可以由<code>ResourceEditor</code>使用。</p><p>当在<code>ApplicationContext</code>中使用时，可以使用特定上下文的资源加载策略从字符串填充Resource类型和Resource数组的Bean属性</p><h4 id="ResourcePatternResolver"><a href="#ResourcePatternResolver" class="headerlink" title="ResourcePatternResolver"></a>ResourcePatternResolver</h4><p>用于将位置模式(例如，ant样式的路径模式)解析为资源对象的策略接口。</p><p>这是<code>ResourceLoader</code>接口的扩展。可以检查传入的ResourceLoader(比如在容器中运行时，通过<code>org.springframework.context.ResourceLoaderAware</code>)是否也实现了这个扩展接口。</p><p><code>PathMatchingResourcePatternResolver</code>是一个独立的实现，可以在<code>ApplicationContext</code>之外使用，<code>ResourceArrayPropertyEditor</code>也使用它来填充bean的资源数组属性。</p><p>可以与任何类型的位置模式(例如<code>/WEB-INF/*-context.xml</code>):输入模式必须匹配策略实现。这个接口只指定转换方法，而不是特定的模式格式。</p><p>这个接口还为类路径中所有匹配的资源提供了一个新的资源前缀<code>classpath*:</code>。注意，在这种情况下，资源位置应该是一个没有占位符的路径(例如<code>/beans.xml</code>); JAR文件或类目录可以包含多个同名文件</p><h3 id="MessageSource"><a href="#MessageSource" class="headerlink" title="MessageSource"></a>MessageSource</h3><p>用于解析消息的策略接口，支持此类消息的参数化和国际化。<br>Spring为生产提供了两种开箱即用的实现:</p><ul><li><code>org.springframework.context.support.ResourceBundleMessageSource</code>, 基于<code>java.util.ResourceBundle</code></li><li><code>org.springframework.context.support.ReloadableResourceBundleMessageSource</code> , 不重启的情况下重新加载消息定义</li></ul><h4 id="HierarchicalMessageSource"><a href="#HierarchicalMessageSource" class="headerlink" title="HierarchicalMessageSource"></a>HierarchicalMessageSource</h4><p>继承自<code>MessageSource</code>, 体现层次结构</p><h3 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h3><p>封装事件发布功能。作为<code>ApplicationContext</code>的顶级接口</p><h3 id="EnvironmentCapable"><a href="#EnvironmentCapable" class="headerlink" title="EnvironmentCapable"></a>EnvironmentCapable</h3><p>此接口标志着组件包含和暴露<code>Environment</code>引用。</p><p>所有Spring应用程序上下文都是<code>EnvironmentCapable</code>，并且该接口主要用于在框架方法中执行<code>instanceof</code>检查，这些框架方法接受<code>BeanFactory</code>实例(这些实例可能是，也可能不是实际的<code>ApplicationContext</code>实例)，以便在环境确实可用时与环境进行交互。</p><p>如前所述，<code>ApplicationContext</code>扩展了<code>EnvironmentCapable</code>，从而公开了<code>getEnvironment()</code>方法; 然而，<code>ConfigurableApplicationContext</code>重新定义了<code>getEnvironment()</code>，并缩小了方法签名的范围，返回一个<code>ConfigurableEnvironment</code>。其结果是，在从<code>ConfigurableApplicationContext</code>访问环境对象之前，<code>Environment</code>对象是“只读的”，此时也可以配置它</p><h3 id="PropertyResolver"><a href="#PropertyResolver" class="headerlink" title="PropertyResolver"></a>PropertyResolver</h3><p>此接口用于根据任何来源解析属性。</p><h4 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h4><p>此接口表示当前应用程序运行所在的环境。对应用程序环境的两个关键方面建模:<code>profiles</code>和<code>properties</code>。与属性访问相关的方法通过<code>PropertyResolver</code>父接口公开。</p><p><code>profile</code>是一个命名的bean定义逻辑组，只有在给定<code>profile</code>处于<code>active</code>状态时才向容器注册。可以将bean分配给一个<code>profile</code>，无论是在XML中定义的还是通过注解定义的; 有关语法细节，请参阅spring-beans 3.1 schema 或<code>@Profile</code>注解。与 profiles 相关的<code>Environment</code>对象的角色是确定哪些profiles(如果有的话)当前(<code>getActiveProfiles</code>)是<code>active</code>的，以及哪些profiles (如果有的话)在默认情况(<code>getDefaultProfiles</code>)下应该是<code>active</code>的。</p><p><code>Properties</code>几乎在所有的应用程序中都扮演着重要的角色，并且可能来自各种各样的源:属性文件、JVM系统属性、系统环境变量、JNDI、servlet上下文参数、特殊属性对象、Maps 等等。<code>Environment</code>对象与<code>Properties</code>之间的关系的作用是为用户提供一个方便的服务接口，用于配置<code>Properties</code>源并从中解析<code>Properties</code>。</p><p>在<code>ApplicationContext</code>中管理的bean可以注册为<code>EnvironmentAware</code> bean或<code>@Inject</code> <code>Environment</code>bean，以便直接查询<code>profile</code>状态或解析属性。</p><p>然而，在大多数情况下，应用级bean不需要直接与<code>Environment</code>交互，而是必须使用<code>$&#123;…&#125;</code>属性值替换为属性占位符配置程序，如<code>PropertySourcesPlaceholderConfigurer</code>，它本身是<code>EnvironmentAware</code>的，从Spring 3.1开始，默认情况下使用<code>&lt;context:property-placeholder/&gt;</code>注册。</p><p><code>environment</code>对象的配置必须通过<code>ConfigurableEnvironment</code>接口完成，该接口由所有<code>AbstractApplicationContext</code>子类的<code>getEnvironment()</code>方法返回。有关在应用程序上下文<code>refresh()</code>之前操作属性源的使用示例，请参阅<code>ConfigurableEnvironment</code> Javadoc。</p><h4 id="ConfigurableEnvironment"><a href="#ConfigurableEnvironment" class="headerlink" title="ConfigurableEnvironment"></a>ConfigurableEnvironment</h4><p>此接口提供设置<code>active</code>和<code>default</code>配置文件以及操作基础属性源的工具。允许客户端通过<code>ConfigurablePropertyResolver</code> 父接口设置和验证所需的属性、定制转换服务等等。</p><h4 id="ConfigurablePropertyResolver"><a href="#ConfigurablePropertyResolver" class="headerlink" title="ConfigurablePropertyResolver"></a>ConfigurablePropertyResolver</h4><p>此接口提供访问的工具和自定义转换属性值时使用的<code>ConversionService</code>。</p><h2 id="xml-解析与BeanDefinition-解析相关"><a href="#xml-解析与BeanDefinition-解析相关" class="headerlink" title="xml 解析与BeanDefinition 解析相关"></a>xml 解析与BeanDefinition 解析相关</h2><h3 id="NamespaceHandler"><a href="#NamespaceHandler" class="headerlink" title="NamespaceHandler"></a>NamespaceHandler</h3><p><code>DefaultBeanDefinitionDocumentReader</code>使用的基本接口，用于处理Spring XML配置文件中的自定义名称空间。</p><p>实现类将返回用于自定义顶级标签的<code>BeanDefinitionParser</code>接口的实现，以及用于自定义嵌套标签的<code>BeanDefinitionDecorator</code>接口的实现。</p><p>解析器将在遇到<code>&lt;beans&gt;</code>标签下的自定义标签时调用<code>parse</code>方法，并在遇到<code>&lt;bean&gt;</code>标签下的自定义标签时进行调用<code>decorate</code>方法。</p><p>编写自己的自定义元素扩展时通常不需要直接实现这个接口，而是使用提供的<code>NamespaceHandlerSupport</code>类</p><h3 id="NamespaceHandlerResolver"><a href="#NamespaceHandlerResolver" class="headerlink" title="NamespaceHandlerResolver"></a>NamespaceHandlerResolver</h3><p><code>DefaultBeanDefinitionDocumentReader</code>用这个接口为特定名称空间URI定位<code>NamespaceHandler</code>实现类</p><h3 id="BeanDefinitionParser"><a href="#BeanDefinitionParser" class="headerlink" title="BeanDefinitionParser"></a>BeanDefinitionParser</h3><p><code>DefaultBeanDefinitionDocumentReader</code>用来处理自定义顶级(直接位于<code>&lt;beans/&gt;</code>下)标签的接口。</p><p>实现类可以根据需要自由地将自定义标记中的元数据转换成任意多的<code>BeanDefinition</code>。</p><p>解析器从相关联的<code>NamespaceHandler</code>中为自定义标记所在的命名空间定位一个<code>BeanDefinitionParser</code></p><h3 id="BeanDefinitionDecorator"><a href="#BeanDefinitionDecorator" class="headerlink" title="BeanDefinitionDecorator"></a>BeanDefinitionDecorator</h3><p><code>DefaultBeanDefinitionDocumentReader</code>使用该接口来处理自定义的嵌套(直接位于<code>&lt;bean&gt;</code>下)标签。</p><p>还可以用于装饰<code>&lt;bean&gt;</code>标签的自定义属性。实现类可以自由地将自定义标签中的元数据转换为所需的任意多个<code>BeanDefinition</code>，并转换包含的<code>&lt;bean&gt;</code>标签为<code>BeanDefinition</code>，甚至可能返回一个完全不同的<code>BeanDefinition</code>来替换原来的。</p><p><code>BeanDefinitionDecorator</code>应该感知到它们可能是解析链的一部分。特别是，<code>BeanDefinitionDecorator</code>应该感知到之前的<code>BeanDefinitionDecorator</code>可能已经用<code>org.springframework.aop.framework.ProxyFactoryBean</code>定义替换了原来的<code>org.springframework.bean.factory.config.BeanDefinition</code>，它允许添加自定义拦截器。</p><p>希望向所包含的bean添加拦截器的<code>BeanDefinitionDecorator</code>应该扩展<code>org.springframework.aop.config.AbstractInterceptorDrivenBeanDefinitionDecorator</code>，它处理解析链，确保只创建一个代理，并且它包含链中的所有拦截器。</p><p>解析器从<code>NamespaceHandler</code>中为自定义标签所在的命名空间定位一个<code>BeanDefinitionDecorator</code>。</p><h3 id="MergedBeanDefinitionPostProcessor"><a href="#MergedBeanDefinitionPostProcessor" class="headerlink" title="MergedBeanDefinitionPostProcessor"></a>MergedBeanDefinitionPostProcessor</h3><p>用于在运行时<code>合并</code>bean定义的后处理器回调接口。为了后处理Spring <code>BeanFactory</code>用来创建bean实例的合并bean定义(原始bean定义的已处理副本)，BeanPostProcessor实现可以实现这个子接口。</p><p>例如，<code>postProcessMergedBeanDefinition</code>方法可以内省bean定义，以便在对bean的实际实例进行后处理之前准备一些缓存的元数据。它还允许修改bean定义，但是<code>只</code>允许修改实际上用于并发修改的定义属性。本质上，这只适用于在<code>RootBeanDefinition</code>本身上定义的操作，而不适用于其基类的属性</p><h3 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h3><p>bean定义阅读器的简单接口。定义带有<code>Resource</code>和<code>String</code>位置参数的加载方法。</p><p>当然具体的bean定义阅读器可以为bean定义添加额外的加载和注册方法，具体到它们的bean定义格式。</p><p>请注意，bean定义阅读器不必实现此接口。它仅为希望遵循标准命名约定的bean定义读者提供建议。</p><h3 id="BeanDefinitionDocumentReader"><a href="#BeanDefinitionDocumentReader" class="headerlink" title="BeanDefinitionDocumentReader"></a>BeanDefinitionDocumentReader</h3><p>用于解析包含Spring bean定义的XML文档的SPI。<code>XmlBeanDefinitionReader</code>用于实际解析DOM文档。</p><p>要解析的每个文档实例化:实现类可以在<code>registerBeanDefinitions</code>方法执行期间在实例变量中保存状态——例如，为文档中所有bean定义定义的全局设置</p><h3 id="DestructionAwareBeanPostProcessor"><a href="#DestructionAwareBeanPostProcessor" class="headerlink" title="DestructionAwareBeanPostProcessor"></a>DestructionAwareBeanPostProcessor</h3><h3 id="InstantiationAwareBeanPostProcessor"><a href="#InstantiationAwareBeanPostProcessor" class="headerlink" title="InstantiationAwareBeanPostProcessor"></a>InstantiationAwareBeanPostProcessor</h3><h3 id="SmartInstantiationAwareBeanPostProcessor"><a href="#SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="SmartInstantiationAwareBeanPostProcessor"></a>SmartInstantiationAwareBeanPostProcessor</h3><h2 id="标记接口相关"><a href="#标记接口相关" class="headerlink" title="标记接口相关"></a>标记接口相关</h2><h3 id="Aware"><a href="#Aware" class="headerlink" title="Aware"></a>Aware</h3><h4 id="BeanFactoryAware"><a href="#BeanFactoryAware" class="headerlink" title="BeanFactoryAware"></a>BeanFactoryAware</h4><h4 id="ApplicationEventPublisherAware"><a href="#ApplicationEventPublisherAware" class="headerlink" title="ApplicationEventPublisherAware"></a>ApplicationEventPublisherAware</h4><h4 id="NotificationPublisherAware"><a href="#NotificationPublisherAware" class="headerlink" title="NotificationPublisherAware"></a>NotificationPublisherAware</h4><h4 id="MessageSourceAware"><a href="#MessageSourceAware" class="headerlink" title="MessageSourceAware"></a>MessageSourceAware</h4><h4 id="EnvironmentAware"><a href="#EnvironmentAware" class="headerlink" title="EnvironmentAware"></a>EnvironmentAware</h4><h4 id="EmbeddedValueResolverAware"><a href="#EmbeddedValueResolverAware" class="headerlink" title="EmbeddedValueResolverAware"></a>EmbeddedValueResolverAware</h4><h4 id="ResourceLoaderAware"><a href="#ResourceLoaderAware" class="headerlink" title="ResourceLoaderAware"></a>ResourceLoaderAware</h4><h4 id="ImportAware"><a href="#ImportAware" class="headerlink" title="ImportAware"></a>ImportAware</h4><h4 id="LoadTimeWeaverAware"><a href="#LoadTimeWeaverAware" class="headerlink" title="LoadTimeWeaverAware"></a>LoadTimeWeaverAware</h4><h4 id="BeanNameAware"><a href="#BeanNameAware" class="headerlink" title="BeanNameAware"></a>BeanNameAware</h4><h4 id="BeanClassLoaderAware"><a href="#BeanClassLoaderAware" class="headerlink" title="BeanClassLoaderAware"></a>BeanClassLoaderAware</h4><h4 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h4>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>年会</title>
      <link href="/post/821c/"/>
      <url>/post/821c/</url>
      
        <content type="html"><![CDATA[<p>果然不出意外，今年年会又没中奖。号码为<code>96</code>, 这么顺的号码，依然没中。果然是没有中奖的运气，长这么大好像没中过。总共160人左右，56个奖品，中奖率<code>35%</code>左右。我坐的是11号桌，10个人有7个中奖了，跟我邻座的同事没中。感觉有点儿被愚弄了啊。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 年会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建my-jpa初衷</title>
      <link href="/post/b6a/"/>
      <url>/post/b6a/</url>
      
        <content type="html"><![CDATA[<p>现在项目中大多数都用Mybatis来做持久化框架，虽然mybatis很灵活，能够定制sql，但是在基础的curd功能上，还是很繁琐，每次都需要创建xml文件，添加相应的sql。也有一些第三方框架如mybatis-plus等，对mybatis做了增强，提供了基础的curd，以及其他的高级功能。但是需要在我们的源代码上加入一些框架里的注解，侵入性大。如果需要更换为hibernate，则代码更改起来非常麻烦，而且这些注解在jpa中都已经定义好了。因此在想如果让mybatis-plus支持jpa的注解就可以了，最开始也只打算做到这一步。但是无意中看到了spring-data-jpa，发现spring对jpa提供了更好的支持，比如通过方法名来转换成查询条件。因此在想干脆用mybatis来实现一个jpa，一来是使用标准的注解，二来是保持mybatis的灵活性。由此便有了<code>my-jpa</code>项目。</p><p>my-jpa项目需要达到的目标：</p><ol><li>支持jpa的大部分注解。</li><li>支持mybatis的sql定制。</li><li>集成<code>spring-data-jpa</code>。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> my-jpa </tag>
            
            <tag> jpa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>org.springframework.boot.actuate.endpoint.EndpointId cannot be cast to java.lang.String 异常处理</title>
      <link href="/post/b2e0/"/>
      <url>/post/b2e0/</url>
      
        <content type="html"><![CDATA[<p>用了<code>spring-boot-starter-actuator</code> 之后出现异常: <code>java.lang.ClassCastException:    org.springframework.boot.actuate.endpoint.EndpointId cannot be cast to java.lang.String</code>.<br>详细的异常如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Failed to instantiate [org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar]: Factory method <span class="string">&#x27;servletEndpointRegistrar&#x27;</span> threw exception; nested exception is java.lang.ClassCastException: org.springframework.boot.actuate.endpoint.EndpointId cannot be cast to java.lang.String</span><br><span class="line">at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:<span class="number">185</span>) ~[spring-beans-<span class="number">5.1</span>.<span class="number">3.</span>RELEASE.jar:<span class="number">5.1</span>.<span class="number">3.</span>RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:<span class="number">622</span>) ~[spring-beans-<span class="number">5.1</span>.<span class="number">3.</span>RELEASE.jar:<span class="number">5.1</span>.<span class="number">3.</span>RELEASE]</span><br><span class="line">... <span class="number">55</span> common frames omitted</span><br><span class="line">Caused by: java.lang.ClassCastException: org.springframework.boot.actuate.endpoint.EndpointId cannot be cast to java.lang.String</span><br><span class="line">at org.springframework.boot.MvcEndpointUtil.filterCanonicalEndpoints(MvcEndpointUtil.java:<span class="number">102</span>) ~[MvcEndpointUtil.class:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at org.springframework.boot.MvcEndpointUtil.filterEndpoints(MvcEndpointUtil.java:<span class="number">73</span>) ~[MvcEndpointUtil.class:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.discoverEndpoints(EndpointDiscoverer.java:<span class="number">125</span>) ~[spring-boot-actuator-<span class="number">2.1</span>.<span class="number">1.</span>RELEASE.jar:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.getEndpoints(EndpointDiscoverer.java:<span class="number">119</span>) ~[spring-boot-actuator-<span class="number">2.1</span>.<span class="number">1.</span>RELEASE.jar:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at org.springframework.boot.actuate.autoconfigure.endpoint.web.ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration.servletEndpointRegistrar(ServletEndpointManagementContextConfiguration.java:<span class="number">76</span>) ~[spring-boot-actuator-autoconfigure-<span class="number">2.1</span>.<span class="number">1.</span>RELEASE.jar:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at org.springframework.boot.actuate.autoconfigure.endpoint.web.ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration$$EnhancerBySpringCGLIB$$<span class="number">1005825f</span>.CGLIB$servletEndpointRegistrar$<span class="number">0</span>(&lt;generated&gt;) ~[spring-boot-actuator-autoconfigure-<span class="number">2.1</span>.<span class="number">1.</span>RELEASE.jar:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at org.springframework.boot.actuate.autoconfigure.endpoint.web.ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration$$EnhancerBySpringCGLIB$$<span class="number">1005825f</span>$$FastClassBySpringCGLIB$$<span class="number">1</span>c44d4f2.invoke(&lt;generated&gt;) ~[spring-boot-actuator-autoconfigure-<span class="number">2.1</span>.<span class="number">1.</span>RELEASE.jar:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:<span class="number">244</span>) ~[spring-core-<span class="number">5.1</span>.<span class="number">3.</span>RELEASE.jar:<span class="number">5.1</span>.<span class="number">3.</span>RELEASE]</span><br><span class="line">at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:<span class="number">363</span>) ~[spring-context-<span class="number">5.1</span>.<span class="number">3.</span>RELEASE.jar:<span class="number">5.1</span>.<span class="number">3.</span>RELEASE]</span><br><span class="line">at org.springframework.boot.actuate.autoconfigure.endpoint.web.ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration$$EnhancerBySpringCGLIB$$<span class="number">1005825f</span>.servletEndpointRegistrar(&lt;generated&gt;) ~[spring-boot-actuator-autoconfigure-<span class="number">2.1</span>.<span class="number">1.</span>RELEASE.jar:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:<span class="number">1.8</span>.<span class="number">0_111</span>]</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>) ~[na:<span class="number">1.8</span>.<span class="number">0_111</span>]</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.__invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>) ~[na:<span class="number">1.8</span>.<span class="number">0_111</span>]</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">45009</span>) ~[na:<span class="number">1.8</span>.<span class="number">0_111</span>]</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">45012</span>) ~[na:<span class="number">1.8</span>.<span class="number">0_111</span>]</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>) ~[na:<span class="number">1.8</span>.<span class="number">0_111</span>]</span><br><span class="line">at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:<span class="number">154</span>) ~[spring-beans-<span class="number">5.1</span>.<span class="number">3.</span>RELEASE.jar:<span class="number">5.1</span>.<span class="number">3.</span>RELEASE]</span><br><span class="line">... <span class="number">56</span> common frames omitted</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很奇怪的异常，看EndpointId的代码也重写了<code>toString()</code>方法，更奇怪的是找不到<code>MvcEndpointUtil</code>的代码出处。困扰了好几天，关键是百度了好久也没到有用的信息，也在群里问了一下，没有人回复。今天用google搜了一下，本来也不太抱希望。最后无意中发现了一篇文章(异常处理)[<a href="http://www.codeleading.com/article/8276162799/]%EF%BC%8C">http://www.codeleading.com/article/8276162799/]，</a> 发现跟我碰到同一个问题，最后解决方法不显眼，但还是被我发现了。</p><p><strong>更新 IDEA Jreble 插件</strong></p><p>果断试了一下不用jrebel来启动，果然可以了。不晓得jrebel在这个过程中做了什么操作。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> EndpointId </tag>
            
            <tag> MvcEndpointUtil </tag>
            
            <tag> 异常 </tag>
            
            <tag> jrebel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在controller 参数中使用枚举</title>
      <link href="/post/4085/"/>
      <url>/post/4085/</url>
      
        <content type="html"><![CDATA[<p>我们通常将一些固定的值定义为枚举类型, 这样就可以限制别人在接口中不能随便传参数,只能是其中的几个.</p><p>但是作为框架的设计者, 这样定义之后,框架的使用者想要扩展的话非学不方便, 因为枚举类型默认就继承<code>Enum</code> 类型,无法再继承其他的类. 因此我们考虑将枚举类实现一个接口,同时,使用时也是用这个接口来定义变量类型.</p><p>定义枚举接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEnum</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 默认就是枚举值的name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个子接口来表示某一类枚举值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormFiledType</span> <span class="keyword">extends</span> <span class="title">IEnum</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> <span class="keyword">implements</span> <span class="title">FormFiledType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        VARCHAR, DATE, NUMBER, INT;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name().toLowerCase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FormFiledType</code>是一个接口类型, <code>Type</code>枚举实现这个接口, 在类中使用接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> FormFiledType type;</span><br></pre></td></tr></table></figure><p>但这样存在问题:</p><ol><li>controller接收时,传的json数据如何转换成正确的枚举值</li><li>mybatis 如何解析这个枚举值.</li></ol><p>由于传的是枚举的值, 需要将这个值转换成对应的枚举类型,那么我们需要:</p><ol><li>目标变量的接口类型</li><li>根据这个类型获取到所有实现这个接口的枚举类</li><li>遍历所有的枚举类,看看是否跟这个值匹配</li></ol><p>Spring MVC 默认使用Jackson来将json数据转换成java对象. </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC异常处理方式总结</title>
      <link href="/post/a15d/"/>
      <url>/post/a15d/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>activiti 表</title>
      <link href="/post/c5d6/"/>
      <url>/post/c5d6/</url>
      
        <content type="html"><![CDATA[<ul><li><p>ACT_RE_*: RE stands for <code>repository</code>. Tables with this prefix contain static information such as process definitions and process resources (images, rules, etc.).</p></li><li><p>ACT_RU_*: RU stands for <code>runtime</code>. These are the runtime tables that contain the runtime data of process instances, user tasks, variables, jobs, etc. Activiti only stores the runtime data during process instance execution, and removes the records when a process instance ends. This keeps the runtime tables small and fast.</p></li><li><p>ACT_ID_*: ID stands for <code>identity</code>. These tables contain identity information, such as users, groups, etc.</p></li><li><p>ACT_HI_*: HI stands for <code>history</code>. These are the tables that contain historic data, such as past process instances, variables, tasks, etc.</p></li><li><p>ACT_GE_*: general <code>data</code>, which is used in various use cases.</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> activiti </tag>
            
            <tag> table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql - You must reset your password using ALTER USER statement before executing this statement</title>
      <link href="/post/7521/"/>
      <url>/post/7521/</url>
      
        <content type="html"><![CDATA[<p>新安装的mysql服务器，执行任何命令都报以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You must reset your password using ALTER USER statement before executing this statement.</span><br></pre></td></tr></table></figure><p>意思是必须得先修改默认密码才能执行命令。<br>解决方法：</p><p>修改密码。直接使用<code>ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;</code>报同样的错，使用<code>SET PASSWORD=PASSWORD(&#39;123456&#39;);</code> 这种方式报这个错误<code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;PASSWORD(&#39;123456&#39;)&#39; at line 1 </code>。可以使用另外一种<code>alter user user() identified by &quot;123456&quot;;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> alter user </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并行——使用流还是 CompletableFutures?</title>
      <link href="/post/743/"/>
      <url>/post/743/</url>
      
        <content type="html"><![CDATA[<h4 id="并行——使用流还是-CompletableFutures"><a href="#并行——使用流还是-CompletableFutures" class="headerlink" title="并行——使用流还是 CompletableFutures ?"></a>并行——使用流还是 CompletableFutures ?</h4><p>目前为止,你已经知道对集合进行并行计算有两种方式:要么将其转化为并行流,利用 <code>map</code>这样的操作开展工作,要么枚举出集合中的每一个元素,创建新的线程,在 <code>CompletableFuture</code> 内对其进行操作。后者提供了更多的灵活性,你可以调整线程池的大小,而这能帮助你确保整体的计算不会因为线程都在等待I/O而发生阻塞。<br>我们对使用这些API的建议如下。</p><ul><li>如果你进行的是计算密集型的操作,并且没有I/O,那么推荐使用 Stream 接口,因为实现简单,同时效率也可能是最高的(如果所有的线程都是计算密集型的,那就没有必要创建比处理器核数更多的线程)。</li><li>反之,如果你并行的工作单元还涉及等待I/O的操作(包括网络连接等待),那么使用<code>CompletableFuture</code> 灵活性更好,你可以像前文讨论的那样,依据<code>等待/计算</code>,或者<code>W/C</code>的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是,处理流的流水线中如果发生I/O等待,流的延迟特性会让我们很难判断到底什么时候触发了等待。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Stream </tag>
            
            <tag> CompletableFuture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 多默认方法解决冲突机制</title>
      <link href="/post/9a42/"/>
      <url>/post/9a42/</url>
      
        <content type="html"><![CDATA[<p>如果一个类的默认方法使用相同的函数签名继承自多个接口,解决冲突的机制其实相当简单。你只需要遵守下面这三条准则就能解决所有可能的冲突。</p><ol><li>首先,类或父类中显式声明的方法,其优先级高于所有的默认方法。</li><li>如果用第一条无法判断,方法签名又没有区别,那么选择提供最具体实现的默认方法的 接口。</li><li>最后,如果冲突依旧无法解决,你就只能在你的类中覆盖该默认方法,显式地指定在你的类中使用哪一个接口中的方法。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> 默认方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring resource配置文件写法</title>
      <link href="/post/b3b1/"/>
      <url>/post/b3b1/</url>
      
        <content type="html"><![CDATA[<p>为了管理方便，通常将Spring 的配置文件拆成多个，但也带来了复杂性的问题，不晓得它是如何加载的。</p><p>解析xml <code>import</code>元素主要是<code>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#importBeanDefinitionResource()</code>方法为入口，看一下这个方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">String location = ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是不是绝对路径</span></span><br><span class="line">    <span class="comment">//CLASSPATH_ALL_URL_PREFIX  --&gt;   classpath*:</span></span><br><span class="line">    <span class="comment">//(resourceLocation != null &amp;&amp;</span></span><br><span class="line">(resourceLocation.startsWith(ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX) ||</span><br><span class="line">ResourceUtils.isUrl(resourceLocation)));</span><br><span class="line">absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Absolute or relative?</span></span><br><span class="line"><span class="keyword">if</span> (absoluteLocation) &#123;</span><br><span class="line"><span class="keyword">int</span> importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// No URL -&gt; considering resource location as relative to the current file.</span></span><br><span class="line"></span><br><span class="line">Resource relativeResource = getReaderContext().getResource().createRelative(location);</span><br><span class="line"><span class="keyword">if</span> (relativeResource.exists()) &#123;</span><br><span class="line">importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">actualResources.add(relativeResource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String baseLocation = getReaderContext().getResource().getURL().toString();</span><br><span class="line">importCount = getReaderContext().getReader().loadBeanDefinitions(</span><br><span class="line">StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在配置文件中引入其他文件，为了方便，本文件名为<code>application.xml</code>，通常有以下几种写法：</p><h2 id="直接写文件名"><a href="#直接写文件名" class="headerlink" title="直接写文件名"></a>直接写文件名</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;beans.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况下表示的是相对路径，<code>getReaderContext().getResource()</code>代表的是当前配置文件<code>application.xml</code>，它是通过<code>classpath</code>加载的，<code>Resource.createRelative(location)</code>创建的资源类也是<code>classpath</code>的，里面封装了<code>classloader</code>，可以从Jar包里面加载对应的配置文件。这种解析方式也适用于<code>beans.xml</code>还引入了<code>&lt;import resource=&quot;imports.xml&quot;/&gt;</code>的情形，创建的相对资源都是通过<code>classloader</code>去加载的。</p><h2 id="classpath-beans-xml"><a href="#classpath-beans-xml" class="headerlink" title="classpath:beans.xml"></a>classpath:beans.xml</h2><p>这种方式代表绝对路径，最终由<code>org.springframework.core.io.support.PathMatchingResourcePatternResolver#getResources</code>方法处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">Assert.notNull(locationPattern, <span class="string">&quot;Location pattern must not be null&quot;</span>);</span><br><span class="line"><span class="comment">//如果是classpath*:形式的</span></span><br><span class="line"><span class="keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;</span><br><span class="line">    <span class="comment">//classpath*</span></span><br><span class="line"><span class="comment">// a class path resource (multiple resources for same name possible)</span></span><br><span class="line"><span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;</span><br><span class="line"><span class="comment">// a class path resource pattern</span></span><br><span class="line"><span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// all class path resources with the given name</span></span><br><span class="line"><span class="keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Generally only look for a pattern after a prefix here,</span></span><br><span class="line"><span class="comment">// and on Tomcat only after the &quot;*/&quot; separator for its &quot;war:&quot; protocol.</span></span><br><span class="line"><span class="keyword">int</span> prefixEnd = (locationPattern.startsWith(<span class="string">&quot;war:&quot;</span>) ? locationPattern.indexOf(<span class="string">&quot;*/&quot;</span>) + <span class="number">1</span> :</span><br><span class="line">locationPattern.indexOf(<span class="string">&quot;:&quot;</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;</span><br><span class="line">    <span class="comment">//匹配模式</span></span><br><span class="line"><span class="comment">// a file pattern</span></span><br><span class="line"><span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// a single resource with the given name</span></span><br><span class="line"><span class="comment">//加载指定名称的文件</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为文件名中不含表达式，则通过<code>org.springframework.core.io.DefaultResourceLoader#getResource</code>方法在<code>classpath</code>中加载指定的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Resource getResource(String location) &#123;</span><br><span class="line">Assert.notNull(location, &quot;Location must not be null&quot;);</span><br><span class="line"></span><br><span class="line">for (ProtocolResolver protocolResolver : this.protocolResolvers) &#123;</span><br><span class="line">Resource resource &#x3D; protocolResolver.resolve(location, this);</span><br><span class="line">if (resource !&#x3D; null) &#123;</span><br><span class="line">return resource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (location.startsWith(&quot;&#x2F;&quot;)) &#123;</span><br><span class="line">return getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line">else if (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">&#x2F;&#x2F;classpath:开头， 通过classpath加载</span><br><span class="line">return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; Try to parse the location as a URL...</span><br><span class="line">URL url &#x3D; new URL(location);</span><br><span class="line">return new UrlResource(url);</span><br><span class="line">&#125;</span><br><span class="line">catch (MalformedURLException ex) &#123;</span><br><span class="line">&#x2F;&#x2F; No URL -&gt; resolve as resource path.</span><br><span class="line">return getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bean-xml"><a href="#bean-xml" class="headerlink" title="bean*.xml"></a>bean*.xml</h2><p>此方式也是相对路径的形式，只会在引入此配置文件(即<code>application.xml</code>)的目录中去查找符合此表达式的文件。</p><h2 id="classpath-bean-xml"><a href="#classpath-bean-xml" class="headerlink" title="classpath:bean*.xml"></a>classpath:bean*.xml</h2><p>与第二种方式类似，会走模式查找方法<code>findPathMatchingResources(locationPattern)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Resource[] findPathMatchingResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//locationPattern  =  classpath:bean*.xml</span></span><br><span class="line">    <span class="comment">//rootDirPath = classpath:</span></span><br><span class="line">String rootDirPath = determineRootDir(locationPattern);</span><br><span class="line"><span class="comment">//subPattern = bean*.xml</span></span><br><span class="line">String subPattern = locationPattern.substring(rootDirPath.length());</span><br><span class="line"><span class="comment">//找到父目录对应的资源路径，此时classpath对应的目录，只有这一个</span></span><br><span class="line">Resource[] rootDirResources = getResources(rootDirPath);</span><br><span class="line">Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;Resource&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">for</span> (Resource rootDirResource : rootDirResources) &#123;</span><br><span class="line">rootDirResource = resolveRootDirResource(rootDirResource);</span><br><span class="line"><span class="comment">//rootDirURL = &quot;/home/qzz/qinzaizhen/springstudy/min/target/classes/&quot;</span></span><br><span class="line">URL rootDirURL = rootDirResource.getURL();</span><br><span class="line"><span class="keyword">if</span> (equinoxResolveMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (rootDirURL.getProtocol().startsWith(<span class="string">&quot;bundle&quot;</span>)) &#123;</span><br><span class="line">rootDirURL = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, <span class="keyword">null</span>, rootDirURL);</span><br><span class="line">rootDirResource = <span class="keyword">new</span> UrlResource(rootDirURL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rootDirURL.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123;</span><br><span class="line">result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirURL, subPattern, getPathMatcher()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ResourceUtils.isJarURL(rootDirURL) || isJarResource(rootDirResource)) &#123;</span><br><span class="line">result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirURL, subPattern));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Resolved location pattern [&quot;</span> + locationPattern + <span class="string">&quot;] to resources &quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[result.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有classpath对应的目录，只会在这个目录中去查找<code>bean*.xml</code>对应的文件。</p><h2 id="classpath-beans-xml-1"><a href="#classpath-beans-xml-1" class="headerlink" title="classpath*:beans.xml"></a>classpath*:beans.xml</h2><p>跟方式4的区别在于<code>findPathMatchingResources</code>方法中<code>Resource[] rootDirResources = getResources(rootDirPath);</code>会查找到当前所有资源classpath目录以及jar包等。</p><p>总结：</p><p>方式|是否加载其他jar包等|是否模式匹配|是否相对路径<br>—|—|—<br>直接写文件名<code>beans.xml</code>|是|否|相对路径<br><code>classpath:beans.xml</code>|是|否|绝对路径<br><code>bean*.xml</code>|否|是|相对路径<br><code>classpath:bean*.xml</code>|否|是|绝对路径<br><code>classpath*:bean*.xml</code>|是|是|绝对路径</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Resource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻塞、非阻塞、同步、异步</title>
      <link href="/post/45af/"/>
      <url>/post/45af/</url>
      
        <content type="html"><![CDATA[<p>我常说我女朋友是同步的，因为她只能一件事做完之后才能响应的我的话。那我肯定不能一直等她啦，先干别的事，不能阻塞在这里，同时呢，我会看她是不是搞完事了，搞完了我就再跟她说，这就是非阻塞了。有时候干脆等她搞完事了，她会主动跟我说的，这就是异步了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 阻塞 </tag>
            
            <tag> 非阻塞 </tag>
            
            <tag> 同步 </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven依赖总结</title>
      <link href="/post/14f5/"/>
      <url>/post/14f5/</url>
      
        <content type="html"><![CDATA[<p>假设<code>A</code> 有两个<code>1.0</code> 和<code>2.0</code>两个版本。</p><p><code>B</code>依赖<code>A</code> <code>1.0</code>版本，<code>C</code>依赖<code>A</code> <code>2.0</code>版本， <code>D</code> 依赖<code>B</code>和<code>C</code> ,在<code>D</code>打包的时候<code>A</code>的版本为高版本<code>2.0</code>。</p><p><code>E</code> 依赖 <code>C</code>， <code>D</code>改为依赖<code>B</code>和<code>E</code>，这时候<code>A</code>的版本为高版本<code>1.0</code>。如果在<code>D</code>中直接依赖<code>A</code> 2.0版本，这时会存在两个版本的包。</p><p><strong>总结：同级的会高版本覆盖低版本，层次浅的会覆盖层次深的。依赖引入的，都会存在。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> MAVEN </tag>
            
            <tag> 依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错误记录20180521</title>
      <link href="/post/6917/"/>
      <url>/post/6917/</url>
      
        <content type="html"><![CDATA[<p>昨天出现了一个问题<code>java.lang.NoClassDefFoundError</code>.</p><p>由于在pom中加入了一个新的A包，这个包依赖了另外一个新版本的B jar，项目中原本有B的低版本，编绎的时候可以通过，但是运行的时候就会报上述异常。<code>mvn clean</code>了好多次，<code>reimport</code>好多次，生成的war目录里面就是没有新版本的B jar。</p><ol><li>尝试将这个包手动在IDEA 项目配置里面的dependencies中去，这样做不好，这些依赖是由IDEA根据pom解析后自动生成的。</li><li>最后想起来打包的配置都在artifacts中配置的，果断去里面加上这个依赖。再次运行就可以了。</li></ol><p>按说IDEA会自动在artifacts中加入这个新的jar包才对。最开始想的是不是pom配置的有问题，一直在从这个方面去解决。</p><p>最后发现还是依赖配置的有问题，版本不同的话会导致出现这样的问题，<a href="http://www.qzztf.com/2018/05/23/maven%E4%BE%9D%E8%B5%96%E6%80%BB%E7%BB%93/">解决方法看另外一篇</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 错误记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery prop与attr的区别</title>
      <link href="/post/8b63/"/>
      <url>/post/8b63/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>今天在操作<code>checkbox</code>的时候，想让它选中，用了下面的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#id1&quot;).attr(&quot;checked&quot;,true);</span><br></pre></td></tr></table></figure><p>结果并没有选中。查看了一下dom，发现多了一个属性<code>checked=&quot;checked&quot;</code>，看似是应该选中才对，然而并没有啥用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id&#x3D;&quot;id1&quot; type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;1&quot; checked&#x3D;&quot;checked&quot;&gt;</span><br></pre></td></tr></table></figure><p>网上也发现我不少朋友遇到这问题，换用<code>prop</code>方法试了一下，结果选中了。dom为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id&#x3D;&quot;id1&quot; type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;1&quot; offval&#x3D;&quot;0&quot;&gt;</span><br></pre></td></tr></table></figure><p>有点儿奇怪。</p><h3 id="attr-方法"><a href="#attr-方法" class="headerlink" title="attr()方法"></a><code>attr()</code>方法</h3><p>获取匹配的元素集合中的第一个元素的属性的值 或 设置每一个匹配元素的一个或多个属性。</p><ul><li>e.attr( attributeName )</li><li>e.attr( attributeName, value )</li><li>e.attr( attributes )</li><li>e.attr( attributeName, function(index, attr) )</li></ul><h3 id="prop-方法"><a href="#prop-方法" class="headerlink" title="prop() 方法"></a><code>prop()</code> 方法</h3><p>获取匹配的元素集中第一个元素的属性（property）值或设置每一个匹配元素的一个或多个属性。 - e.prop( propertyName )</p><ul><li>e.prop( propertyName, value )</li><li>e.prop( properties )</li><li>e.prop( propertyName, function(index, oldPropertyValue) )</li></ul><p>看出区别了吗，没错，是参数有区别，<code>attr()</code>传入的是<code>attributeName</code>，而<code>prop()</code>传入的是<code>propertyName</code>。现在我们的问题转移了，我们需要研究的是<code>attributeName</code>和<code>propertyName</code>之间的区别了。</p><h3 id="Attributes-vs-Properties"><a href="#Attributes-vs-Properties" class="headerlink" title="Attributes vs. Properties"></a><code>Attributes</code> vs. <code>Properties</code></h3><p>在这里，我们可以将<code>attribute</code>理解为<code>特性</code>，<code>property</code>理解为为<code>属性</code>从而来区分俩者的差异。</p><p>如果把DOM元素看成是一个普通的Object对象，这个对象在其定义时就具有一些属性（property），比如把<code>checkbox</code>当做一个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var checkbox &#x3D; &#123;</span><br><span class="line">    checked: false</span><br><span class="line">    attributes: [],</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>实际情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">accept: &quot;&quot;</span><br><span class="line">accessKey: &quot;&quot;</span><br><span class="line">align: &quot;&quot;</span><br><span class="line">alt: &quot;&quot;</span><br><span class="line">attributes:NamedNodeMap &#123;0: id, 1: type, 2: value, 3: offval, 4: checked, id: id, type: type, value: value, offval: offval, checked: checked, …&#125;</span><br><span class="line">checked: false</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>attributes:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:id</span><br><span class="line">  baseURI:&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;x5&#x2F;bims&#x2F;material&#x2F;materialNode&#x2F;materialNodeEdit?productId&#x3D;DDKD_NJY_OTH&amp;productName&#x3D;%25E5%25A4%25A7%25E9%2581%2593%25E5%25BF%25AB%25E8%25B4%25B7%25EF%25BC%2588%25E8%2587%25AA%25E8%2590%25A5%25E7%2589%2588%25EF%25BC%2589&quot;</span><br><span class="line">  childNodes:NodeList []</span><br><span class="line">  firstChild:null</span><br><span class="line">  isConnected:false</span><br><span class="line">  lastChild:null</span><br><span class="line">  localName:&quot;id&quot;</span><br><span class="line">  name:&quot;id&quot;</span><br><span class="line">  namespaceURI:null</span><br><span class="line">  nextSibling:null</span><br><span class="line">  nodeName:&quot;id&quot;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>现在，我们一目了然了，<code>attribute</code>是一个特性节点，每个DOM元素都有一个对应的<code>attributes</code>属性来存放所有的<code>attribute</code>节点，它是一个类数组的容器。<code>attributes</code>的每个数字索引以键值对(<code>name=&quot;value&quot;</code>)的形式存放了一个<code>attribute</code>节点。而<code>property</code>就是一个属性，是一个以键值对(<code>name=&quot;value&quot;</code>)的形式存放在Object中的属性。<br>回到一开始的问题，复选框的状态改变只会修改<code>checked</code>属性(<code>property</code>)，换句话说，要想选中<code>checkbox</code>，只能修改<code>checked</code>属性(<code>property</code>)。因此，用jQuery请使用<code>prop()</code>方法。</p><h3 id="jquery中attr和prop的区别介绍"><a href="#jquery中attr和prop的区别介绍" class="headerlink" title="jquery中attr和prop的区别介绍"></a>jquery中attr和prop的区别介绍</h3><p>在高版本的jQuery引入<code>prop</code>方法后，什么时候该用<code>prop</code>？什么时候用<code>attr</code>？它们两个之间有什么区别？这些问题就出现了。<br>关于它们两个的区别，网上的答案很多。这里谈谈我的心得，我的心得很简单：</p><ol><li>对于HTML元素本身就带有的<strong>固有</strong>属性，在处理时，使用<code>prop</code>方法。</li><li>对于HTML元素我们自己<strong>自定义</strong>的DOM属性，在处理时，使用<code>attr</code>方法。</li></ol><p>上面的描述也许有点模糊，举几个例子就知道了。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot; target&#x3D;&quot;_self&quot; class&#x3D;&quot;btn&quot;&gt;百度&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>这个例子里<code>&lt;a&gt;</code>元素的DOM属性有<code>href</code>、<code>target</code>和<code>class</code>，这些属性就是<code>&lt;a&gt;</code>元素本身就带有的属性，也是W3C标准里就包含有这几个属性，或者说在IDE里能够智能提示出的属性，这些就叫做固有属性。处理这些属性时，建议使用prop方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;#&quot; id&#x3D;&quot;link1&quot; action&#x3D;&quot;delete&quot;&gt;删除&lt;&#x2F;a&gt; </span><br></pre></td></tr></table></figure><p>这个例子里<code>&lt;a&gt;</code>元素的DOM属性有<code>href</code>、<code>id</code>和<code>action</code>，很明显，前两个是固有属性，而后面一个<code>action</code>属性是我们自己<strong>自定义</strong>上去的，<code>&lt;a&gt;</code>元素本身是没有这个属性的。这种就是自定义的DOM属性。处理这些属性时，建议使用<code>attr</code>方法。使用<code>prop</code>方法取值和设置属性值时，都会返回<code>undefined</code>值。</p><p>再举一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id&#x3D;&quot;chk1&quot; type&#x3D;&quot;checkbox&quot; &#x2F;&gt;是否可见&lt;input id&#x3D;&quot;chk2&quot; type&#x3D;&quot;checkbox&quot; checked&#x3D;&quot;checked&quot; &#x2F;&gt;是否可见</span><br></pre></td></tr></table></figure><p>像<code>checkbox</code>，<code>radio</code>和<code>select</code>这样的元素，选中属性对应<code>checked</code>和<code>selected</code>，这些也属于固有属性，因此需要使用prop方法去操作才能获得正确的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#chk1&quot;).prop(&quot;checked&quot;) &#x3D;&#x3D; false</span><br><span class="line">$(&quot;#chk2&quot;).prop(&quot;checked&quot;) &#x3D;&#x3D; true</span><br></pre></td></tr></table></figure><p>如果上面使用attr方法，则会出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#chk1&quot;).attr(&quot;checked&quot;) &#x3D;&#x3D; undefined</span><br><span class="line">$(&quot;#chk2&quot;).attr(&quot;checked&quot;) &#x3D;&#x3D; &quot;checked&quot;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="prop-函数的结果"><a href="#prop-函数的结果" class="headerlink" title="prop()函数的结果:"></a><code>prop()</code>函数的结果:</h4><p>1.如果有相应的属性，返回指定属性值。<br>2.如果没有相应的属性，返回值是空字符串。</p><h4 id="attr-函数的结果"><a href="#attr-函数的结果" class="headerlink" title="attr()函数的结果:"></a><code>attr()</code>函数的结果:</h4><p>1.如果有相应的属性，返回指定属性值。<br>2.如果没有相应的属性，返回值是undefined。</p><p>对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。<br>对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jquery </tag>
            
            <tag> prop </tag>
            
            <tag> attr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA中创建测试用例</title>
      <link href="/post/2011/"/>
      <url>/post/2011/</url>
      
        <content type="html"><![CDATA[<p>ctrl+shift+t  –&gt; create new test</p>]]></content>
      
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> JUnit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四月三日语录</title>
      <link href="/post/c4c9/"/>
      <url>/post/c4c9/</url>
      
        <content type="html"><![CDATA[<p>我希望很多小事，你有自己的想法和见解，不需要我说你就安排的妥妥当当，有男人的成熟。大事不是一定听我的，但是需要跟我商量，一起做决定。当然如果你有能力让我折服，有歧义时可以说服我，心服口服的，就说明你厉害，我也ok。</p><p>我也不确定你最后是什么样啊。</p><p>选了不能退货。顺其自然吧。看你自己造化。我也控制不了。毕竟你是一个人，不是一个泥娃娃，不可能我自己来捏造。</p><p>你自己看吧。</p><p>弄死你。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 媳妇儿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO 之BIO,NIO,AIO</title>
      <link href="/post/f34a/"/>
      <url>/post/f34a/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-IO概要"><a href="#Java-IO概要" class="headerlink" title="Java IO概要"></a>Java IO概要</h1><p>Java 的核心库java.io提供了全面的IO接口。包括：文件读写、标准设备输入输出等。JAVA中IO是以流为基础进行输入输出的，所有数据被串行化写入输出流，或者从输入流中读入。</p><p>JAVA IO主要包括三个部分：</p><ol><li>流式部分 - IO的核心部分</li><li>非流式部分 - 主要包含一些辅助流式部分的类，如：<code>File</code>、<code>RandomAccessFile</code>和 <code>FileDescriptor</code>等类</li><li>其他类 - 文件读取部分与安全相关的类，如：<code>SerializablePermission</code>类，以及与本地操作系统相关的文件系统的类，如：<code>FileSystem</code>类、<code>Win32FileSystem</code>和<code>WinNtFileSystem</code>类。</li></ol><h2 id="Java-IO中常用的类"><a href="#Java-IO中常用的类" class="headerlink" title="Java IO中常用的类"></a>Java IO中常用的类</h2><ol><li><code>File</code>: 对文件或目录的抽象，封装了描述信息和常用操作，如创建文件，修改文件名，删除文件，生成新目录，判断文件所在路径等。</li><li><code>InputStream</code>：抽象类，基于字节的输入操作，是所有输入流的父类。</li><li><code>OutputStream</code>: 抽象类，基于字节的输出操作，是所有输出流的父类。</li><li><code>Reader</code>: 抽象类，基于字符的输入操作。</li><li><code>Writer</code>: 抽象类，基于字符的输出操作。</li><li><code>RandomAccessFile</code>: 随机文件操作，是一个独立的类，直接继承自Object，功能丰富，可以从文件的位置进行存取操作。</li></ol><h2 id="常用Java流类的类结构图"><a href="#常用Java流类的类结构图" class="headerlink" title="常用Java流类的类结构图"></a>常用Java流类的类结构图</h2><p><img src="http://ooll8xqpq.bkt.clouddn.com/IO%E6%B5%81.png" alt="image"></p><h2 id="流的概念和作用"><a href="#流的概念和作用" class="headerlink" title="流的概念和作用"></a>流的概念和作用</h2><p> 流：</p><blockquote><p>代表任何有能力产出数据的数据源对象或者是有能力接收数据的数据端对象 – Thinking in Java</p></blockquote><p>流的本质：数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。<br>流的作用：为数据源和数据接收端建立一个输送通道。</p><p>Java将输入输出抽象为流，就好像水管，将两个容器连接起来。流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流。</p><h2 id="Java-IO所采用的模型"><a href="#Java-IO所采用的模型" class="headerlink" title="Java IO所采用的模型:"></a>Java IO所采用的模型:</h2><p>Java的IO模型设计非常优秀，它使用<code>Decorator</code>模式，按功能划分。可以动态装配这些流，来获得想要的功能。如需要一个具有缓冲的文件输入流，则可以组合使用<code>FileInputStream</code>和<code>BufferedInputStream</code>。</p><h2 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h2><ul><li>根据处理数据类型的不同分为：字符流和字节流</li><li>根据数据流向不同分为：输入流和输出流</li><li>根据操作对象分为：<ol><li>基本数据类型操作</li><li>对象序列化操作</li><li>转换</li><li>打印</li><li>文件操作</li><li>管道</li><li>数组操作</li></ol></li><li>节点流和处理流：<ol><li>节点流：直接与数据源相连，读入或读出。</li><li>处理流：与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。</li></ol></li></ul><h3 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h3><p>流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种：</p><ol><li>字节流：数据流中最小的数据单元是字节</li><li>字符流：数据流中最小的数据单元是字符，Java的字符是Unicode编码的，一个字符占用两个字节。</li></ol><p>字符流的由来：Java中字符是采用Unicode编码，一个字符是16位，即一个字符使用两个字节来表示。为了处理方便，Java中引入了处理字符的流。</p><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><h5 id="输入字节流InputStream："><a href="#输入字节流InputStream：" class="headerlink" title="输入字节流InputStream："></a>输入字节流InputStream：</h5><ul><li><code>InputStream</code>是所有的输入字节流的父类，是一个抽象类。</li><li><code>FileInputStream</code>： 是三种基本的介质流，它们分别从Byte数组、StringBuffer、和本地文件中读取数据。</li><li><code>ByteArrayInputStream</code>：</li><li><code>PipedInputStream</code>： 是从与其它线程共用的管道中读取数据。<code>PipedInputStream</code>的一个实例要和<code>PipedOutputStream</code>的一个实例共同使用，共同完成管道的读取写入操作。主要用于线程操作。<br><code>ObjectInputStream</code> 和所有<code>FilterInputStream</code> 的子类都是装饰流（装饰器模式的主角）</li></ul><h6 id="InputStream中的三个基本的读方法"><a href="#InputStream中的三个基本的读方法" class="headerlink" title="InputStream中的三个基本的读方法"></a>InputStream中的三个基本的读方法</h6><ol><li>abstract int read(): 读取一个字节数据，并返回读到的数据，如果返回<code>-1</code>，表示读到了输入流的末尾。</li><li>int read(byte[] b): 将数据读入到字节数据，同时返回实际读取的字节数。如果返回<code>-1</code>，表示读到了输入流的末尾</li><li>int read(byte b[], int off, int len)： 将数据读入一个字节数组，同时返回实际读取的字节数。如果返回<code>-1</code>，表示读到了输入流的末尾。<code>off</code>指定在数据b中存放数据的起始偏移位置，<code>len</code>指定读取的最大字节数。</li></ol><p><strong>流结束的判断：方法<code>read()</code>的返回值为<code>-1</code>时，<code>readLine()</code>的返回值为<code>null</code>时。</strong></p><h6 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h6><ol><li>long skip(long n): 在输入流中跳过n个字节，并返回实际跳过的字节数。</li><li>int available(): 返回在不发生阻塞的情况下，可读取的字节数。</li><li>void close(): 关闭输入流，释放和这个流相关的系统资源。</li><li>void mark(int readlimit): 在输入流的当前位置放置一个标记，如果读取的字节数多于<code>readlimit</code>设置的值，则流忽略这个标记。</li><li>void reset() ：返回到上一个标记。</li><li>boolean markSupported() ：测试当前流是否支持<code>mark</code>和<code>reset</code>方法。如果支持，返回<code>true</code>，否则返回<code>false</code>。</li></ol><h5 id="输出字节流OutputStream："><a href="#输出字节流OutputStream：" class="headerlink" title="输出字节流OutputStream："></a>输出字节流OutputStream：</h5><ul><li><code>OutputStream</code>是所有的输出字节流的父类，它是一个抽象类。</li><li><code>FileOutputStream</code>、<code>ByteArrayOutputStream</code>： 是两种基本的介质流，它们分别向本地文件和Byte数组中写入数据。</li><li><code>PipedOutputStream</code>：是向与其它线程共用的管道中写入数据。</li><li><code>ObjectOutputStream</code> 和所有<code>FilterOutputStream</code>的子类都是装饰流。</li></ul><h6 id="OutputStream中的三个基本的写方法"><a href="#OutputStream中的三个基本的写方法" class="headerlink" title="OutputStream中的三个基本的写方法"></a>OutputStream中的三个基本的写方法</h6><ul><li>abstract void write(int b): 往输出流中写入一个字节。 写入的是<code>b</code>的低8位，剩余的24位高位将会忽略。</li><li>void write(byte[] b): 往输出流中写入数组b中的所有字节。</li><li>void write(byte[] b, int off, int len): 往输出流中写入数组b中从偏移量<code>off</code>开始的<code>len</code>个字节的数据。</li></ul><h6 id="其他方法-1"><a href="#其他方法-1" class="headerlink" title="其他方法"></a>其他方法</h6><ul><li>void flush(): 刷新输出流，强制缓冲区中的字节被写出。</li><li>void close(): 关闭输出流，释放和这个流相关的系统资源。</li></ul><p>字节流的输入和输出对照图：<br><img src="http://ooll8xqpq.bkt.clouddn.com/%E5%AD%97%E8%8A%82%E6%B5%81%E5%AF%B9%E6%AF%94.jpg" alt="字节流对比"><br>图中蓝色的为主要的对应部分，红色的部分就是不对应部分。从上面的图中可以看出JavaIO中的字节流是极其对称的。下面看看几个不对称的几个类</p><ol><li><code>LineNumberInputStream</code> 主要完成从流中读取数据时，会得到相应的等号，到于什么时候分行、在哪里分行是由该类主动确定的，并不是原始流中有这样一个行号。在输出部分没有对应的部分，我们完全可以自己建立一个<code>LineNumberOutputStream</code>，在最初写入时会有一个基准的行号，以后每次遇到换行时会在下一行添加一个行号。(由于该类错误地认为这些字节完全代表的是字符，从1.1开始已经废弃了，使用<code>LineNumberReader</code>)</li><li><code>PushbackInputStream</code>的功能是查看读取的字节，不满意就重新放入输入流再次读取。主要用在编译器的语法、记法分析部分。</li><li><code>StringBufferInputStream</code> 已经被Deprecated。</li><li><code>SequenceInputStream</code> 可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。</li><li><code>PrintStream</code> 也可以认为是一个辅助工具。主要可以向其他输出流，或者FileInputStream写入数据，本身内部实现还是带缓冲的。<code>System.out</code>和<code>System.out</code>就是<code>PrintStream</code>的实例！</li></ol><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><h5 id="字符输入流Reader"><a href="#字符输入流Reader" class="headerlink" title="字符输入流Reader"></a>字符输入流Reader</h5><ul><li><code>Reader</code>是所有的输入字符流的父类，它是一个抽象类。</li><li><code>FileReader</code>：从文件中读取字符</li><li><code>PipedReader</code>：是从与其它线程共用的管道中读取数据</li><li><code>CharArrayReader</code> 、<code>StringReader</code> 是两种基本的介质流，它们分别将Char 数组、String中读取数据。</li><li><code>BufferedReader</code> 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。</li><li><code>FilterReader</code> 是所有自定义具体装饰流的父类，其子类<code>PushbackReader</code> 对Reader 对象进行装饰，允许向缓存中填入字符之后重新读取。</li><li><code>InputStreamReader</code>： 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。<code>FileReader</code> 可以说是一个达到此功能、常用的工具类。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。</li></ul><h6 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h6><ul><li>int read() throws IOException: 读取一个字符，返回值为读取的字符</li><li>int read(char[] cbuf) throws IOException: 读取一组字符到数据cbuf[]中，返回值为实际读取的字符的数量</li><li>abstract int read(char[] cbuf, int off, int len) throws IOException: 读取<code>len</code>个字符，从数组<code>cbuf[]</code>的下标<code>off</code>处开始存放，返回值为实际读取的字符数量，该方法必须由子类实现。</li></ul><h5 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h5><ul><li><code>Writer</code>是所有的输出字符流的父类，它是一个抽象类</li><li><code>FileWriter</code>: 向文件中写入字符</li><li><code>PipedWriter</code>:是向与其它线程共用的管道中写入数据</li><li><code>CharArrayWriter</code>: CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。</li><li><code>BufferedWriter</code> 是一个装饰器，为Writer 提供缓冲功能。</li><li><code>PrintWriter</code> 和<code>PrintStream</code> 极其类似，功能和使用也非常相似。</li><li><code>OutputStreamWriter</code>： 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter其实就是一个实现此功能的具体类（具体可以研究源代码）。功能和使用和OutputStream 极其类似，后面会有它们的对应图。</li></ul><h6 id="主要方法："><a href="#主要方法：" class="headerlink" title="主要方法："></a>主要方法：</h6><ul><li>void wirte(int c) thrwos IOException: 将整型值<code>c</code>的低<code>16</code>位写入输出流</li><li>void write(char cbuf[]) throws IOException: 将字符数组<code>cbuf[]</code> 写入输出流</li><li>abstract void write(char cbuf[], int off, int len) throws IOException: 将字符数组<code>cbuf[]</code> 中的从索引为<code>off</code>的位置处开始的<code>len</code>个字符写入输出流</li><li>void write(String str) thrwos IOException: 将字符串<code>str</code>中的字符写入输出流</li><li>void write(String str, int off, int len) throws IOException: 将字符串<code>str</code>中从索引<code>off</code>开始处的<code>len</code>个字符写入输出流</li></ul><p>字符流的输入和输出对照图：<br><img src="http://ooll8xqpq.bkt.clouddn.com/%E5%AD%97%E7%AC%A6%E6%B5%81%E5%AF%B9%E6%AF%94.jpg" alt="字符流对比"></p><h4 id="字符流和字节流的转换"><a href="#字符流和字节流的转换" class="headerlink" title="字符流和字节流的转换"></a>字符流和字节流的转换</h4><p>有时候为了读取方便，需要进行字符流和字节流的转换操作，引此引入了转换流。转换流是字符流和字节流之间的桥梁，可以将读取到的字节数据经过指定编码转换成字符，也可以将读取到的字符数据经过解码转换成字节。</p><p><code>InputStreamReader</code>:字符流转到字节流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String fileName= <span class="string">&quot;d:&quot;</span>+File.separator+<span class="string">&quot;hello.txt&quot;</span>;</span><br><span class="line">File file=<span class="keyword">new</span> File(fileName);</span><br><span class="line">Writer out=<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">out.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure><p><code>OutputStreamWriter</code>:字节流转到字符流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String fileName= <span class="string">&quot;d:&quot;</span>+File.separator+<span class="string">&quot;hello.txt&quot;</span>;</span><br><span class="line">File file=<span class="keyword">new</span> File(fileName);</span><br><span class="line">Reader read=<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line"><span class="keyword">char</span>[] b=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> len=read.read(b);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b,<span class="number">0</span>,len));</span><br><span class="line">read.close();</span><br></pre></td></tr></table></figure><p>这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来。</p><h4 id="字节流和字符流的区别"><a href="#字节流和字符流的区别" class="headerlink" title="字节流和字符流的区别"></a>字节流和字符流的区别</h4><p>字节流没有缓冲区，是直接输出的，而字符流是输出到缓冲区的。因此在输出时，字节流不调用<code>close()</code>方法时，信息已经输出了，而字符流只有在调用<code>close()</code>方法关闭缓冲区时，信息才输出。要想字符流在未关闭时输出信息，则需要手动调用<code>flush()</code>方法。</p><p>流写单位不同：字节流以字节为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</p><p>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</p><p>只要是处理纯文本数据，就优先考虑使用字符流。除此之外都使用字节流。</p><h3 id="输入流和输出流"><a href="#输入流和输出流" class="headerlink" title="输入流和输出流"></a>输入流和输出流</h3><p>根据数据的输入、输出方向的不同而将流分为输入流和输出流。</p><h4 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h4><p>程序从输入流读取数据。将源自外界键盘、文件、网络等的数据读入程序的通信通道。</p><h4 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h4><p>程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络等）的通信通道。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li>先进先出，最先写入输出流的数据最先被输入流读取到。</li><li>顺序存取，可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节 ，不能随机访问中间的数据。（<strong>RandomAccessFile可以从文件的任意位置进行存取操作</strong>）。</li><li>只读或只写，每个流只能是输入流和输出流的一种，不能同时具备两个功能，输入流只进行读操作，对输出流只进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流。</li></ol><h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h3><ul><li>节点流：直接与数据源相连，读或写。</li><li>处理流：与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。</li></ul><p>为什么要有处理流？直接使用节点流，读写不方便，为了更快的读写，才有了处理流。</p><h3 id="按数据源分类"><a href="#按数据源分类" class="headerlink" title="按数据源分类"></a>按数据源分类</h3><p><img src="http://ooll8xqpq.bkt.clouddn.com/%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%AF%B9%E6%AF%94.jpg" alt="image"></p><ol><li><p>对文件进行操作（节点流）：</p><ul><li><code>FileInputStream</code>（字节输入流）</li><li><code>FileOutputStream</code>（字节输出流）</li><li><code>FileReader</code>（字符输入流）</li><li><code>FileWriter</code>（字符输出流）</li></ul></li><li><p>对管道进行操作（节点流）</p><ul><li><code>PipedInputStream</code>（字节输入流）</li><li><code>PipedOutStream</code>（字节输出流）</li><li><code>PipedReader</code>（字符输入流）</li><li><code>PipedWriter</code>（字符输出流）</li></ul></li></ol><p><code>PipedInputStream</code>的一个实例要和<code>PipedOutputStream</code>的一个实例共同使用，共同完成管道的读取写入操作。主要用于线程间的数据共享操作。</p><ol start="3"><li>字节/字符数组流（节点流）<ul><li><code>ByteArrayInputStream</code></li><li><code>ByteArrayOutputStream</code></li><li><code>CharArrayReader</code></li><li><code>CharArrayWriter</code></li></ul></li></ol><p>在内存中开辟了一个字节或字符数组。如果需要临时的输出数据等可以用这几个流。</p><p>除了上述三种是节点流，其他都是处理流，需要跟节点流配合使用。</p><ol start="4"><li>Buffered缓冲流（处理流）：<ul><li><code>BufferedInputStream</code></li><li><code>BufferedOutputStream</code></li><li><code>BufferedReader</code></li><li><code>BufferedWriter</code></li></ul></li></ol><p>这些是带缓冲区的处理流，缓冲区的作用的主要目的是：避免每次和硬盘打交道，提高数据访问的效率。</p><ol start="5"><li><p>转换流（处理流）：</p><ul><li><code>InputStreamReader</code>：把字节转换成字符；</li><li><code>OutputStreamWriter</code>：把字节转换成字符。</li></ul></li><li><p>基本类型数据流（处理流）：用于操作基本数据类型值。</p><ul><li><code>DataInputStream</code></li><li><code>DataOutputStream</code></li></ul></li></ol><p>如果输出一个8字节的long类型或4个字节的float类型，那怎么办呢？可以一个字节一个字节输出，也可以把转换成字符串输出，但是这样转换费时间，若是直接输出该多好啊，因此这个数据流就解决了我们输出数据类型的困难。数据流可以直接输出float类型或long类型，提高了数据读写的效率。</p><ol start="7"><li>打印流（处理流）：<ul><li><code>PrintStream</code></li><li><code>PrintWriter</code></li></ul></li></ol><p>一般是打印到控制台，可以控制打印的地方。</p><ol start="8"><li>对象流（处理流）：<ul><li><code>ObjectInputStream</code>:对象反序列化</li><li><code>ObjectOutputStream</code>:对象序列化</li></ul></li></ol><p>把封装的对象直接输出，而不是一个个转换成字符串再输出。</p><ol start="9"><li>合并流（处理流）：<ul><li><code>SequenceInputStream</code>：可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。</li></ul></li></ol><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>File类是对文件系统中文件以及文件夹进行封装的对象，可以通过面向对象的思想来操作文件和文件夹。</p><p>File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。 </p><p>以下是常用的操作函数</p><table><thead><tr><th>方法或常量</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>public static final String separator</td><td>常量</td><td>表示路径分隔符<code>\</code>(Windows)或<code>/</code>(Linux等)</td></tr><tr><td>public static final String pathSeparator</td><td>常量</td><td>表示路径分隔，<code>;</code>(Windows)或<code>:</code>(Linux等)</td></tr><tr><td>public boolean createNewFile() throws IOException</td><td>普通</td><td>创建新文件</td></tr><tr><td>public boolean delete()</td><td>普通</td><td>删除文件</td></tr><tr><td>public String getParent()</td><td>普通</td><td>得到文件的上一级路径</td></tr><tr><td>public boolean isDirectory()</td><td>普通</td><td>判断给定的路径是不是文件夹</td></tr><tr><td>public boolean isFile()</td><td>普通</td><td>判断给定的路径是不是文件</td></tr><tr><td>public String[] list()</td><td>普通</td><td>列出文件夹中的文件</td></tr><tr><td>public File[] listFiles()</td><td>普通</td><td>列出文件夹中的所有文件</td></tr><tr><td>public boolean mkdir()</td><td>普通</td><td>创建新的文件夹</td></tr><tr><td>public boolean renameTo(File dest)</td><td>普通</td><td>为文件重命名</td></tr><tr><td>public long length()</td><td>普通</td><td>返回文件大小</td></tr></tbody></table><h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><p>该对象并不是流体系中的一员，其封装了字节流，同时还封装了一个缓冲区（字符数组），通过内部的指针来操作字符数组中的数据。 该对象特点：</p><ol><li>该对象只能操作文件，所以构造函数接收两种类型的参数：<ol><li>字符串文件路径</li><li>File对象</li></ol></li><li>该对象既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(<code>r</code>,<code>rw</code>)。</li></ol><p>注意：<br><strong>该对象在实例化时，如果要操作的文件不存在，会自动创建；如果文件存在，写数据未指定位置，会从头开始写，即覆盖原有的内容。</strong> 可以用于多线程下载或多个线程同时写数据到文件。</p><h2 id="System类对IO的支持"><a href="#System类对IO的支持" class="headerlink" title="System类对IO的支持"></a>System类对IO的支持</h2><p>在System 类中提供了以下的几个常量：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>public static final PrintStream out</td><td>对应标准输出（默认为显示器）</td></tr><tr><td>public static final PrintStream err</td><td>对应标准错误输出（默认为显示器）</td></tr><tr><td>public static final InputStream in</td><td>对应标准输入（默认为键盘）</td></tr></tbody></table><h3 id="标准I-O重定向"><a href="#标准I-O重定向" class="headerlink" title="标准I/O重定向"></a>标准I/O重定向</h3><p>在<code>System</code>类中提供了三个重定向标准输入/输出的方法 </p><ul><li>static void setErr(PrintStream err): 重定向“标准”错误输出流 </li><li>static void setIn(InputStream in): 重定向“标准”输入流 </li><li>static void setOut(PrintStream out): 重定向“标准”输出流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Demonstrates standard I/O redirection.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redirecting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintStream console = System.out;</span><br><span class="line">        BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">&quot;Redirecting.java&quot;</span>));</span><br><span class="line">        PrintStream out = <span class="keyword">new</span> PrintStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        System.setIn(in);</span><br><span class="line">        System.setOut(out);</span><br><span class="line">        System.setErr(out);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close(); <span class="comment">// Remember this!</span></span><br><span class="line">        System.setOut(console);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="BIO编程"><a href="#BIO编程" class="headerlink" title="BIO编程"></a>BIO编程</h2><h3 id="传统BIO通信模型图"><a href="#传统BIO通信模型图" class="headerlink" title="传统BIO通信模型图"></a>传统BIO通信模型图</h3><p>传统的同步阻塞Socket通信模型开发中，ServerSocket负责绑定ip地址，启动监听端口;Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。</p><p>采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行通信操作，客户端与服务端通过输入输出流来通信，处理完成后，线程销毁。</p><p>BIO通信模型<br><a href="http://ooll8xqpq.bkt.clouddn.com/bio%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.png">BIO通信模型</a><br>该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端连接数呈1：1的正比关系，Java中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降。</p><h2 id="伪异步IO编程"><a href="#伪异步IO编程" class="headerlink" title="伪异步IO编程"></a>伪异步IO编程</h2><p>我们可以使用线程池来管理服务端这些线程，实现1个或多个线程处理N个客户端的模型（但是底层还是使用的同步阻塞IO），通常被称为“伪异步IO模型”。</p><p>如果使用<code>java.util.concurrent.Executors#newCachedThreadPool()</code>线程池（不限制线程数量），其实除了能自动帮我们管理线程（复用），看起来也就像是<code>1：1</code>的客户端线程模型，而使用<code>java.util.concurrent.Executors#newFixedThreadPool(int)</code>可以有效控制线程的最大数量，保证了系统有限资源的控制，实现了<code>N:M</code>的伪异步IO模型。但是当发生大量并发请求时，超过最大数量的线程就只能等待，直到线程池中有空闲的线程可以使用。</p><h3 id="伪异步IO编程模型图"><a href="#伪异步IO编程模型图" class="headerlink" title="伪异步IO编程模型图"></a>伪异步IO编程模型图</h3><h3 id="伪异步IO编程实例"><a href="#伪异步IO编程实例" class="headerlink" title="伪异步IO编程实例"></a>伪异步IO编程实例</h3><h1 id="NIO编程"><a href="#NIO编程" class="headerlink" title="NIO编程"></a>NIO编程</h1><p>Java NIO（New IO）是一个可以替代标准Java IO API（从Java 1.4开始）的新的API。<br>主要由以下几个核心部分组成：</p><ul><li>Channel</li><li>Buffer</li><li>Selector</li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h2 id="Java-NIO和IO的主要区别"><a href="#Java-NIO和IO的主要区别" class="headerlink" title="Java NIO和IO的主要区别"></a>Java NIO和IO的主要区别</h2><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流</td><td>面向Buffer</td></tr><tr><td>阻塞</td><td>非阻塞</td></tr></tbody></table><ul><li>| Selector</li></ul><h3 id="面向流与面向缓冲"><a href="#面向流与面向缓冲" class="headerlink" title="面向流与面向缓冲"></a>面向流与面向缓冲</h3><p>NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的</p><p>IO面向流意味着每次从流中读取一个或多个字节，直到读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO的读取方式略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有需要处理的数据，而且需要确保当更多的数据读入缓冲区时，不要覆盖缓冲区里沿未处理的数据。</p><h3 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a>阻塞与非阻塞IO</h3><p>IO的各种流都是阻塞的。这意味着，当一个线程调用<code>read()</code>或<code>write()</code>时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情。NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它公能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以在可以读取数据之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做其他的事情。</p><h2 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道 Channel"></a>通道 Channel</h2><p>Channel 是对数据的源头或数据目标点流径途径的抽象，在这个意义上和<code>Inputstream</code>和<code>OutputStream</code>类似。</p><h3 id="Java-NIO的通道与流区别"><a href="#Java-NIO的通道与流区别" class="headerlink" title="Java NIO的通道与流区别"></a>Java NIO的通道与流区别</h3><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li><li>通道可以地读写。</li><li>通道中的数据总是要先读到一个<code>Buffer</code>，或者总是要从一个<code>Buffer</code>中写入。</li></ul><p><strong>通道必须结合Buffer使用，不能直接向通道中读/写数据</strong></p><h3 id="Channel主要分类"><a href="#Channel主要分类" class="headerlink" title="Channel主要分类"></a>Channel主要分类</h3><p>广义来说通道可以被分为两类：File IO和Stream IO，也就是文件通道和套接字通道。具体细分为：</p><ul><li><code>FileChannel</code> 从文件读写数据</li><li><code>SocketChannel</code>通过TCP读写网络数据</li><li><code>ServerSocketChannel</code>可以监听新进来的TCP连接，并对每个连接创建对应的<code>SocketChannel</code></li><li><code>DatagramChannel</code> 通过UDP读写网络数据</li></ul><h4 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h4><p>从File中读取数据</p><h5 id="打开FileChannel"><a href="#打开FileChannel" class="headerlink" title="打开FileChannel"></a>打开FileChannel</h5><p>在使用<code>FileChannel</code>之前，必须先打开。但是不无法直接打开一个<code>FileChannel</code>, 需要通过使用<code>InputStream</code>、<code>OutputStream</code>或<code>RandomAccessFile</code>来获取一个<code>FileChannel</code>实例。下面通过<code>RandomAccessFile</code>打开<code>FileChannel</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;c:/data.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel channel = file.getChannel();</span><br></pre></td></tr></table></figure><h5 id="从FileChannel读取数据"><a href="#从FileChannel读取数据" class="headerlink" title="从FileChannel读取数据"></a>从FileChannel读取数据</h5><p>有多个read()可以从FileChannel中读取数据。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = channel.read(buf);</span><br></pre></td></tr></table></figure><p>首先，分配一个Buffer，从FileChannel中读取到的数据将被存放在Buffer中。</p><p>然后调用<code>FileChannel.read()</code>方法，该方法将数据从<code>FileChannel</code>读取到<code>Buffer</code>中。<code>read()</code>方法返回的<code>int</code>值表示了有多少字节被读到了<code>Bubber</code>中。如果返回<code>-1</code>，表示到了文件<code>末尾</code>。</p><h5 id="向FileChannel写数据"><a href="#向FileChannel写数据" class="headerlink" title="向FileChannel写数据"></a>向FileChannel写数据</h5><p>使用FileChannel.write()方法向FileChannel写数据，该方法的参数是一个Buffer。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String data = <span class="string">&quot;写入数据&quot;</span> + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(data.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意FileChannel.write()是在while循环中调用的，因为无法保证write()方法一次能向FileChannel写入所有字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的数据。</p><h5 id="关闭FileChannel"><a href="#关闭FileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h5><p>用完FileChannel后必须将其关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure><h5 id="FileChannel的position方法"><a href="#FileChannel的position方法" class="headerlink" title="FileChannel的position方法"></a>FileChannel的position方法</h5><p>有时需要在<code>FileChannel</code>的某个特定位置进行数据的读写操作，可以通过调用<code>position()</code>方法获取<code>FileChannel</code>的当前位置。<br>也可以通过调用<code>position(long pos)</code>方法设置<code>FileChannel</code>的当前位置。</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long pos &#x3D; channel.position();</span><br><span class="line">channel.position(pos + 10);</span><br></pre></td></tr></table></figure><p>如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回 <code>-1</code>  – 文件结束标志。</p><p>如果向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“文件空洞”。</p><h5 id="FileChannel的size方法"><a href="#FileChannel的size方法" class="headerlink" title="FileChannel的size方法"></a>FileChannel的size方法</h5><p><code>FileChannel</code>实例的<code>size()</code>方法将返回该实例所关联文件的大小。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> fileSize = channel.size();</span><br></pre></td></tr></table></figure><h5 id="FileChannel的truncate方法"><a href="#FileChannel的truncate方法" class="headerlink" title="FileChannel的truncate方法"></a>FileChannel的truncate方法</h5><p>可以使用<code>FileChannel.truncate(size)</code>方法截取一个文件。截取文件时，如果文件当前的长度大于给定长度，那么指定长度后的文件内容会被删除，如果给定的大小大于等于当前文件大小，则不会修改该文件。在任何一种情况下，如果这个通道的<code>position</code>大于给定的大小，然后它被设置为这个大小。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.truncate(1024); </span><br></pre></td></tr></table></figure><p>这个例子截取文件的前1024个字节。</p><h5 id="FileChannel的force方法"><a href="#FileChannel的force方法" class="headerlink" title="FileChannel的force方法"></a>FileChannel的force方法</h5><p><code>FileChannel.force()</code>方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到<code>FileChannel</code>里的数据一定会即时写到磁盘上。要保证这一点，需要调用<code>force()</code>方法。</p><p><code>force()</code>方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。</p><p>下面的例子同时将文件数据和元数据强制写到磁盘上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.force(true);</span><br></pre></td></tr></table></figure><h5 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h5><p><code>FileChannel</code>的<code>transferFrom()</code>方法可以将数据从源通道传输到<code>FileChannel</code>中。下面是一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile accessFile &#x3D; new RandomAccessFile(&quot;E:\\qinzaizhen\\javasedemo\\src\\io\\nio\\nio.txt&quot;,&quot;rw&quot;);</span><br><span class="line">FileChannel channel &#x3D; accessFile.getChannel();</span><br><span class="line">RandomAccessFile toFile &#x3D; new RandomAccessFile(&quot;E:\\qinzaizhen\\javasedemo\\src\\io\\nio\\niotofile.txt&quot;,&quot;rw&quot;);</span><br><span class="line">FileChannel toChannel &#x3D; toFile.getChannel();</span><br><span class="line">toChannel.transferFrom(channel,0,10);</span><br><span class="line">channel.close();</span><br><span class="line">accessFile.close();</span><br><span class="line">toChannel.close();</span><br><span class="line">&#x2F;&#x2F;源文件中有中文，写入到新文件中后乱码</span><br></pre></td></tr></table></figure><p><code>transferFrom</code> 方法的输入参数 <code>position</code> 表示从 <code>position</code> 处开始向目标文件写入数据，count 表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。如果给定的<code>position</code>大于文件的大小，则不会传输数据。此方法不会修改<code>position</code>。如果源通道有<code>position</code>，那么将会从源通道此位置开始读取，并且会根据读取的字节增加<code>position</code>。</p><p>此外要注意，在 <code>SoketChannel</code>的实现中，<code>SocketChannel</code>只会传输此刻准备好的数据（可能不足<code>count</code>字节）。因此，<code>SocketChannel</code> 可能不会将请求的所有数据(<code>count</code>个字节)全部传输到 <code>FileChannel</code>中。</p><h5 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h5><p><code>transferTo()</code>方法将数据从<code>FileChannel</code>传输到其他的<code>channel</code>中。下面是一个简单的例子：</p><p>是不是发现这个例子和前面那个例子特别相似？除了调用方法的FileChannel对象不一样外，其他的都一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile accessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;E:\\qinzaizhen\\javasedemo\\src\\io\\nio\\nio.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel channel = accessFile.getChannel();</span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;E:\\qinzaizhen\\javasedemo\\src\\io\\nio\\niotofile.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel toChannel = toFile.getChannel();</span><br><span class="line">System.out.println(toChannel.position());</span><br><span class="line"><span class="comment">//        toChannel.transferFrom(channel,1,10);</span></span><br><span class="line"></span><br><span class="line">channel.transferTo(<span class="number">2</span>,<span class="number">10</span>, toChannel);</span><br><span class="line">System.out.println(toChannel.position());</span><br><span class="line">System.out.println(channel.position());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.close();</span><br><span class="line">accessFile.close();</span><br><span class="line">toChannel.close();</span><br><span class="line"><span class="comment">//此方式不乱码</span></span><br></pre></td></tr></table></figure><p>上面所说的关于<code>SocketChannel</code>的问题在<code>transferTo()</code>方法中同样存在。<code>SocketChannel</code>会一直传输数据直到目标<code>buffer</code>被填满。</p><h2 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区 Buffer"></a>缓冲区 Buffer</h2><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来访问这块内存。</p><h3 id="Buffer的基本用法"><a href="#Buffer的基本用法" class="headerlink" title="Buffer的基本用法"></a>Buffer的基本用法</h3><p>使用Buffer读写数据一般遵循以下四个步骤：</p><ul><li>写入数据到Buffer </li><li>从Buffer中读取数据</li><li>调用clear()方法或者compact()方法</li></ul><p>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。</p><p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。<code>clear()</code>方法会清空整个缓冲区，<code>ByteBuffer</code>的<code>compact()</code>方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p><h3 id="Buffer的三个属性"><a href="#Buffer的三个属性" class="headerlink" title="Buffer的三个属性"></a>Buffer的三个属性</h3><p>为了理解Buffer的工作原理，需要熟悉它的三个属性：</p><ul><li><code>capacity</code>：作为一个内存块，Buffer有一个固定的大小值。你只能写<code>capacity</code>个<code>byte</code>、<code>long</code>、<code>char</code>等类型数据。</li><li><code>position</code>：当你写数据到<code>Buffer</code>中时，<code>position</code>表示当前的位置。初始的<code>position</code>值为<code>0</code>，当一个<code>byte</code>、<code>long</code>等数据写到Buffer后，<code>position</code>会向前移动到下一个可插入数据的<code>Buffer</code>单元。<code>position</code>最大可为<code>capacity - 1</code>。当<code>Buffer</code>切换到读模式时，<code>position</code>会被重置为<code>0</code>，当从<code>Buffer</code>的<code>position</code>处读取数据时，<code>position</code>向前移动到下一个可读的位置。</li><li><code>limit</code>：在写模式下，<code>Buffer</code>的<code>limit</code>表示你最多能往<code>Buffer</code>里写多少数据。<code>写模式</code>下，<code>limit</code> 等于<code>Buffer</code>的<code>capacity</code>。当切换到<code>读模式</code>时，<code>limit</code> 表示你最多能读到多少数据。因此，当切换<code>Buffer</code>到读模式时，<code>limit</code>会被设置成写模式下的<code>position</code>值。</li></ul><p><img src="http://ooll8xqpq.bkt.clouddn.com/buffer%E5%B1%9E%E6%80%A7.png" alt="模型示意图"></p><h3 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a>Buffer的类型</h3><p>NIO 有以下Buffer 类型：</p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><h3 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h3><p>要想获取一个Buffer对象，首先要进行分配。每一个Buffer类都有一个<code>allocate</code>方法。下面是一个分配48字节<code>capacity</code>的<code>ByteBuffer</code>的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br></pre></td></tr></table></figure><p>下面是分配一个可存储1024个字符的CharBuffer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer buf = CharBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><h3 id="Buffer写数据"><a href="#Buffer写数据" class="headerlink" title="Buffer写数据"></a>Buffer写数据</h3><p>写数据到<code>Buffer</code>有两种方式：</p><ul><li>从<code>Channel</code>写到<code>Buffer</code></li><li>通过<code>Buffer</code>的<code>put()</code>方法写到<code>Buffer</code>里</li></ul><p>从<code>Channel</code>写到<code>Buffer</code>，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead = channel.read(buf);</span><br></pre></td></tr></table></figure><p>通过<code>put</code>方法写到Buffer的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(<span class="number">128</span>);</span><br></pre></td></tr></table></figure><p><code>put</code> 方法有很多个，允许你以不同的方式把数据写入到<code>Buffer</code>中。例如，写到一个指定的位置，或者把一个字节数据写入到<code>Buffer</code>。</p><h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><p><code>flip()</code>方法将<code>Buffer</code>从写模式切换到读模式。调用<code>flip()</code>方法会将<code>position</code>设为<code>0</code>，并将<code>limit</code>设置成之前<code>position</code>的值。</p><p>换句话说，<code>position</code>现在用于标记读的位置，<code>limit</code> 表示之前写进了多少个<code>byte</code>、<code>char</code>等  — 现在能读多少个<code>byte</code> 、<code>char</code>等。</p><h3 id="Buffer中读取数据"><a href="#Buffer中读取数据" class="headerlink" title="Buffer中读取数据"></a>Buffer中读取数据</h3><p>从<code>Buffer</code>中读取数据有两种方式：</p><ul><li>从<code>Buffer</code>读取数据到<code>Channel</code></li><li>使用<code>get()</code>方法从<code>Buffer</code>中读取数据</li></ul><p>从Buffer读取数据到Channel的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesWritten = channel.write(buf);</span><br></pre></td></tr></table></figure><p>使用get()方法从Buffer中读取数据的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = buf.get();</span><br></pre></td></tr></table></figure><p><code>get</code>方法有很多版本，允许你以不同的方式从<code>Buffer</code>中读取数据。例如，从指定<code>position</code>读取，或者从<code>Buffer</code>中读取数据到字节数组。</p><h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h4><p>Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit 保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）</p><h4 id="clear-与compact-方法"><a href="#clear-与compact-方法" class="headerlink" title="clear()与compact()方法"></a>clear()与compact()方法</h4><p>一旦读完<code>Buffer</code>中的数据，需要让<code>Buffer</code>准备好再次被写入。可以通过<code>clear()</code>或<code>compact()</code>方法来完成。</p><p>如果调用的是<code>clear()</code>方法，<code>position</code>将被设为<code>0</code>，<code>limit</code>被设置成<code>capacity</code>的值。换句话说，<code>Buffer</code>被清空了。</p><p>如果<code>Buffer</code>中有一些未读的数据，调用<code>clear()</code>方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。</p><p>如果<code>Buffer</code>中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用<code>compact()</code>方法。<code>compact()</code>方法将所有未读的数据拷贝到<code>Buffer</code>起始处，然后将<code>position</code>设置为最后一个未读元素的下一个位置。<code>limit</code>属性依然像<code>clear()</code>方法一样，设置成<code>capacity</code>。现在<code>Buffer</code>准备好写数据了，但不会覆盖未读的数据。</p><h4 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h4><p>通过调用<code>Buffer.mark()</code>方法，可以标记<code>Buffer</code>中的一个特定<code>position</code>。之后可以通过调用<code>Buffer.reset()</code>方法恢复到这个<code>position</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();  </span><br><span class="line"><span class="comment">//回退</span></span><br><span class="line">buffer.reset();  </span><br></pre></td></tr></table></figure><h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>当满足下列条件时，表示两个<code>Buffer</code>相等：</p><ul><li>有相同的类型（<code>byte</code>、<code>char</code>、<code>int</code>等）</li><li><code>Buffer</code>中剩余的<code>byte</code>、<code>char</code>等的个数相等</li><li><code>Buffer</code>中所有剩余的<code>byte</code>、<code>char</code>等都相同</li></ul><p>equals只是比较Buffer剩余的部分中的元素。</p><h4 id="compareTo-方法"><a href="#compareTo-方法" class="headerlink" title="compareTo()方法"></a>compareTo()方法</h4><p>`compareTo()方法比较两个Buffer的剩余元素（byte、char等），如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：</p><ul><li>第一个不相等的元素小于另外一个BUffer中对应的元素</li><li>所有元素都相等，但第一个Buffer比另一个先耗尽（第一个Buffer中的元素个数比另一个少）</li></ul><h2 id="选择器（-Selector）"><a href="#选择器（-Selector）" class="headerlink" title="选择器（ Selector）"></a>选择器（ Selector）</h2><p>Java NIO 引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。<code>Selector</code>提供选择已经就绪的任务的能力：<code>Selector</code>会不断旬注册在其上的<code>Channel</code>，如果某个<code>Channel</code>上面发读或写事件，这个<code>Channel</code>就处于就绪状态，会被<code>Selector</code>轮询出来，然后通过<code>SelectionKey</code>可以获取就结果<code>Channel</code>的集合，进行后续的IO操作。</p><p>一个<code>Selector</code>可以同时轮询多个<code>Channel</code>，因为JDK使用了<code>epoll()</code>代替传统的<code>select</code> 实现，所有没有最大连接句柄<code>1024/2048</code>的限制。所以只需要一个线程负责<code>Selector</code>的轮询，就可以接入成千上万的客户端。</p><p>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，比如新连接进来，数据接收等。</p><h3 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h3><p>通过调用Selector.open()方法创建一个Selector,例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><h3 id="Selector注册通道"><a href="#Selector注册通道" class="headerlink" title="Selector注册通道"></a>Selector注册通道</h3><p>为了将<code>Channerl</code>和<code>Selector</code>配合使用，必须将Channel注册到selector上，通过SelectableChannel.register()方法实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><p>和Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式，而套接字通道都可以。</p><p>注意register()方法的第二个参数，这是一个“interest集合”,意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p><ul><li>Connnect</li><li>Accept</li><li>Read</li><li>Write</li></ul><p>通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收就进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>当向<code>Selector</code>注册<code>Channel</code>时，<code>register()</code>方法会返回一个<code>SelectionKey</code>对象，这个对象包含了一些你感兴趣的属性：</p><ul><li>interest集合</li><li>read集合</li><li>Channel</li><li>Selector</li><li>附加的对象（可选）</li></ul><h4 id="interest集合"><a href="#interest集合" class="headerlink" title="interest集合"></a>interest集合</h4><p><code>interest集合</code>是你所选择的感兴趣的事件集合。可以通过<code>SelectionKey</code>读写<code>interest集合</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line">SocketChannel channel = SocketChannel.open();</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line"><span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line"><span class="keyword">boolean</span> inAccept = (interestOps &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT;</span><br><span class="line"><span class="keyword">boolean</span> inConnect = (interestOps &amp; SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> inRead = (interestOps &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> inWrite= (interestOps &amp; SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><p>可以看到，用“位与”操作<code>interest集合</code>和给定的<code>SelectionKey</code>常量比较，可以确定某个确定的事件是否在<code>interest集合</code>中。</p><h4 id="ready集合"><a href="#ready集合" class="headerlink" title="ready集合"></a>ready集合</h4><p>ready集合是通道已经准备就绪的操作的集合。在一次选择之后，你会首先访问这个read集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure><p>可以用检测interest集合的方式来检测channel中什么事件或操作已经就绪。也可以使用以下四个方法，它们都会返回一个布尔类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key.isAcceptable();</span><br><span class="line">key.isConnectable();</span><br><span class="line">key.isReadable();</span><br><span class="line">key.isWritable();</span><br></pre></td></tr></table></figure><h4 id="附加对象"><a href="#附加对象" class="headerlink" title="附加对象"></a>附加对象</h4><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以与通道一起使用的Buffer，或是包含聚焦数据的某个对象。使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key.attach(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">Object obj = key.attachment();</span><br></pre></td></tr></table></figure><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, obj);</span><br></pre></td></tr></table></figure><h3 id="通过Selector选择通道"><a href="#通过Selector选择通道" class="headerlink" title="通过Selector选择通道"></a>通过Selector选择通道</h3><p>一旦向Selector注册了一个或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p><p>下面是<code>select()</code>方法：</p><ul><li>int select()</li><li>int select(long timeout)</li><li>int selectNow()</li></ul><p><code>select()</code>阻塞到至少有一个通道在你注册的事件上就绪了。</p><p><code>select(long timeout)</code> 和<code>select()</code> 一样，除了最长会阻塞timeout毫秒（参数）。</p><p><code>selectNow()</code> 不会阻塞，不管什么通道就绪就立刻返回（此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零）。</p><p><code>select()</code>方法返回的<code>int</code>值表示有多少个通道已经就绪，也就是自上次调用<code>select()</code>方法有多少通道变成就绪状态。如果调用<code>select()</code>方法，因为有一个通道变成就绪状态，返回了<code>1</code>，若再次调用<code>select()</code>方法，如果另外一个通道就绪了，它会再次返回<code>1</code>。如果对第一个就绪的<code>channel</code>没有做任何操作，现在就有两个就绪的通道，但在每次<code>select()</code>方法调用之间，只有一个通道就绪了。</p><h3 id="selectedKeys"><a href="#selectedKeys" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h3><p>一旦调用了<code>select()</code>方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用<code>selector</code>的<code>selectedKeys()</code>方法，访问“已选择key集合（selected key set）”中的就绪通道。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure><p>当向<code>Selector</code>注册<code>Channel</code>时，<code>Channel.register()</code>方法会返回一个<code>SelectionKey</code>对象，这个对象代表了注册到该<code>Selector</code>的通道。可以通过<code>Selector</code>的<code>keys()</code>方法访问这些对象。</p><p>可以遍历这个已选择的Key 集合来访问就绪的通道。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个循环遍历已选择Key 集合的每个key，并检测各个键所对应的通道的就绪事件。</p><p>注意每次迭代末尾的 <code>keyIterator.remove()</code>调用。<code>Selector</code>不会自己从已选择Key集合中移除 <code>SelectionKey</code>实例。必须在处理完通道时自己移除。下次该通道变成就绪时，<code>Selector</code>会再次将其放入已选择键集中。</p><p><code>SelectionKey.channel()</code> 方法返回的通道需要转型成你要处理的类型，如 <code>ServerSocketChannel</code> 或 <code>SocketChannel</code> 等。</p><h3 id="wakeUp"><a href="#wakeUp" class="headerlink" title="wakeUp()"></a>wakeUp()</h3><p>某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让他它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可，阻塞在select()方法上的线程会立即返回。</p><h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>用完 <code>Selector</code> 后调用其 <code>close()</code> 方法会关闭该<code>Selector</code>，且使注册到该<code>Selector</code>上的所有<code>SelectionKey</code>实例无效。通道本身并不会关闭。</p><h2 id="分散（Scatter）-聚集（Gather）"><a href="#分散（Scatter）-聚集（Gather）" class="headerlink" title="分散（Scatter）/聚集（Gather）"></a>分散（Scatter）/聚集（Gather）</h2><p>分散（scatter）：从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);  </span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);  </span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;  </span><br><span class="line">channel.read(bufferArray);  </span><br></pre></td></tr></table></figure><p>注意<code>buffer</code>首先被插入到数组，然后再将数组作为<code>channel.read()</code>的输入参数。<code>read()</code>按照<code>buffer</code>在数组中的顺序将从<code>channel</code>中读取的数据写入到<code>buffer</code>，当一个<code>buffer</code>被写满后，<code>channel</code>紧接着向另一个<code>buffer</code>中写。</p><p>Scattering Reads在移动下一个<code>buffer</code>前，必须填满当前的<code>buffer</code>，这也意味着它不适用于动态消息。换句话说，如果存在消息头和消息体，消息头必须完成填充，Scattering Reads才能正常工作。</p><p>聚集（gatter）:在写操作时将多个<code>buffer</code>的数据写入同一个<code>Channel</code>，因此，<code>Channel</code>将多个<code>buffer</code>的数据“聚集（gather）”后发送到<code>Channel</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);  </span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);  </span><br><span class="line"><span class="comment">//write data into buffers  </span></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;  </span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure><p><code>buffer</code>的一个数组被传递给了<code>write()</code>方法，如果一个buffer有一个128字节的容量，但是只包含了58个字节，只有58个字节可以从buffer中写到channel。</p><h3 id="分散-聚集的应用"><a href="#分散-聚集的应用" class="headerlink" title="分散/聚集的应用"></a>分散/聚集的应用</h3><p>scatter / gather 经常用于需要将传输的数据分开处理的场合。例如，在编写一个使用消息对象的网络应用程序时，每一个消息被划分为固定长度的头部和固定长度的正文。可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容纳正文的缓冲区。当将它们放入一个数组中并使用分散读取来向它们读入消息时，头部和正文将整齐地划分到这两个缓冲区中。</p><h2 id="通道实现"><a href="#通道实现" class="headerlink" title="通道实现"></a>通道实现</h2><h3 id="文件通道"><a href="#文件通道" class="headerlink" title="文件通道"></a>文件通道</h3><h3 id="Socket管道"><a href="#Socket管道" class="headerlink" title="Socket管道"></a>Socket管道</h3><p>Java NIO中的 <code>SocketChannel</code> 是一个连接到 TCP网络套接字的通道。可以通过以下2种方式创建 <code>SocketChannel</code>：</p><ul><li>打开一个<code>SocketChannel</code>并连接到互联网上的某台服务器</li><li>一个新连接到达 <code>ServerSocketChannel</code> 时，会创建一个<code>SocketChannel</code></li></ul><h4 id="打开-SocketChannel"><a href="#打开-SocketChannel" class="headerlink" title="打开 SocketChannel"></a>打开 SocketChannel</h4><p>下面是<code>SocketChannel</code>的打开方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;http://localhost&quot;</span>,<span class="number">80</span>));</span><br></pre></td></tr></table></figure><h4 id="从-SocketChannel-读取数据"><a href="#从-SocketChannel-读取数据" class="headerlink" title="从 SocketChannel 读取数据"></a>从 <code>SocketChannel</code> 读取数据</h4><p>要从<code>SocketChannel</code>中读取数据，调用一个<code>read()</code>的方法之一。以下是例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = socketChannel.read(buf);</span><br></pre></td></tr></table></figure><p>首先，分配一个<code>Buffer</code>。从<code>SocketChannel</code>读取到的数据将会放到这个<code>Buffer</code>中。</p><p>然后，调用<code>SocketChannel.read()</code>方法。该方法将数据从<code>SocketChannel </code>读到<code>Buffer</code>中。<code>read()</code>方法返回的<code>int</code>值表示读了多少字节进<code>Buffer</code>里。如果返回的是<code>-1</code>，表示已经读到了流的末尾（连接关闭了）。</p><h4 id="写入-SocketChannel"><a href="#写入-SocketChannel" class="headerlink" title="写入 SocketChannel"></a>写入 SocketChannel</h4><p>写数据到<code>SocketChannel</code>用的是<code>SocketChannel.write()</code>方法，该方法以一个<code>Buffer</code>作为参数。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">&quot;新数据&quot;</span> + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>SocketChannel.write()</code>方法的调用是在一个<code>while</code>循环中的。<code>write()</code>方法无法保证能写多少字节到<code>SocketChannel</code>。所以，我们重复调用<code>write()</code>直到<code>Buffer</code>没有要写的字节为止。</p><h4 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h4><p>可以设置 <code>SocketChannel</code> 为<code>非阻塞</code>模式（<code>non-blocking</code> mode）.设置之后，就可以在异步模式下调用<code>connect()</code>, <code>read() </code>和<code>write()</code>了。</p><h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><p>如果<code>SocketChannel</code>在<code>非阻塞</code>模式下，此时调用<code>connect()</code>，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用<code>finishConnect()</code>的方法。像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;http://localhost&quot;</span>, <span class="number">80</span>));</span><br><span class="line"><span class="keyword">while</span>(! socketChannel.finishConnect() )&#123;</span><br><span class="line">    <span class="comment">//wait, or do something else...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h4><p>非阻塞模式下，<code>write()</code>方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用<code>write()</code>。前面已经有例子了，这里就不赘述了。</p><h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><p>非阻塞模式下,<code>read()</code>方法在尚未读取到任何数据时可能就返回了。所以需要关注它的<code>int</code>返回值，它会告诉你读取了多少字节。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ServerSocketChannel channel = ServerSocketChannel.open();</span><br><span class="line">        channel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; selectionKeyIterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (selectionKeyIterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = selectionKeyIterator.next();</span><br><span class="line">                <span class="comment">//防止重复处理</span></span><br><span class="line">                selectionKeyIterator.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    SocketChannel socketChannel = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">                    socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;welcome to connect...&quot;</span>.getBytes()));</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">                    SocketChannel selectableChannel = (SocketChannel) key.channel();</span><br><span class="line">                    selectableChannel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;read from client : &quot;</span> + <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                    selectableChannel.write(ByteBuffer.wrap(<span class="string">&quot;i received your message.&quot;</span>.getBytes()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NIOServer(<span class="number">9000</span>).init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOClient</span><span class="params">(String ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ip = ip;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        SocketChannel channel = SocketChannel.open();</span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        channel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        channel.connect(<span class="keyword">new</span> InetSocketAddress(ip, port));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext())&#123;</span><br><span class="line">                SelectionKey selectionKey = keyIterator.next();</span><br><span class="line">                <span class="comment">//防止重复处理</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isConnectable())&#123;</span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">//如果正在连接，则完成连接</span></span><br><span class="line">                    <span class="keyword">if</span> (socketChannel.isConnectionPending()) &#123;</span><br><span class="line">                        socketChannel.finishConnect();</span><br><span class="line">                    &#125;</span><br><span class="line">                    socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;test connecting&quot;</span>.getBytes()));</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable())&#123;</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    socketChannel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NIOClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>).init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Datagram-通道"><a href="#Datagram-通道" class="headerlink" title="Datagram 通道"></a>Datagram 通道</h3><p>Java NIO中的<code>DatagramChannel</code>是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p><h2 id="管道（Pipe）"><a href="#管道（Pipe）" class="headerlink" title="管道（Pipe）"></a>管道（Pipe）</h2><p>Java NIO 管道是2个线程之间的单向数据连接。<code>Pipe</code>有一个<code>source</code>通道和一个<code>sink</code>通道。数据会被写到<code>sink</code>通道，从<code>source</code>通道读取。</p><h3 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h3><p>通过<code>Pipe.open()</code>方法打开管道。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe pipe = Pipe.open(); </span><br></pre></td></tr></table></figure><h3 id="向管道写数据"><a href="#向管道写数据" class="headerlink" title="向管道写数据"></a>向管道写数据</h3><p>要向管道写数据，需要访问<code>sink</code>通道。像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink(); </span><br></pre></td></tr></table></figure><p>通过调用<code>SinkChannel</code>的<code>write()</code>方法，将数据写入<code>SinkChannel</code>,像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">&quot;新数据&quot;</span> + System.currentTimeMillis();  </span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);  </span><br><span class="line">buf.clear();  </span><br><span class="line">buf.put(newData.getBytes());  </span><br><span class="line">buf.flip();  </span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;  </span><br><span class="line">   sinkChannel.write(buf);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a>从管道读取数据</h3><p>要读取管道的数据，需要访问<code>source</code>通道，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SourceChannel sourceChannel = pipe.source(); </span><br></pre></td></tr></table></figure><p>调用<code>source</code>通道的<code>read()</code>方法来读取数据，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);  </span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);  </span><br></pre></td></tr></table></figure><p>read()方法返回的int值会告诉我们多少字节被读进了缓冲区。</p><h3 id="简单完整实例"><a href="#简单完整实例" class="headerlink" title="简单完整实例"></a>简单完整实例</h3><h1 id="AIO编程"><a href="#AIO编程" class="headerlink" title="AIO编程"></a>AIO编程</h1><h2 id="AIO的特点"><a href="#AIO的特点" class="headerlink" title="AIO的特点"></a>AIO的特点</h2><ul><li>读完了再通知我</li><li>不会加快IO，只是在读完后进行通知</li><li>使用回调函数，进行业务处理</li></ul><p>AIO的相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AsynchronousServerSocketChannel类</span></span><br><span class="line">server = AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br></pre></td></tr></table></figure><p>使用server上的<code>accept</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;A&gt; <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(A attachment,CompletionHandler&lt;AsynchronousSocketChannel,? <span class="keyword">super</span> A&gt; handler)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>Server:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AIOServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AsynchronousServerSocketChannel channel = AsynchronousServerSocketChannel.open();</span><br><span class="line">        channel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        channel.accept(<span class="keyword">new</span> HashMap&lt;&gt;(), <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, HashMap&lt;? extends Object, ? extends Object&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, HashMap&lt;?, ?&gt; attachment)</span> </span>&#123;</span><br><span class="line">                result.write(ByteBuffer.wrap(<span class="string">&quot;welcome to connect...&quot;</span>.getBytes()));</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result.read(buffer).get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;read from client : &quot;</span> + <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, HashMap&lt;?, ?&gt; attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;connect fail&quot;</span> + exc.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AIOServer(<span class="number">9000</span>).init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AIOClient</span><span class="params">(String ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ip = ip;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        AsynchronousSocketChannel channel = AsynchronousSocketChannel.open();</span><br><span class="line">        channel.connect(<span class="keyword">new</span> InetSocketAddress(ip, port), <span class="keyword">new</span> HashMap&lt;&gt;(), <span class="keyword">new</span> CompletionHandler&lt;Void, HashMap&lt;? extends Object, ? extends Object&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Void result, HashMap&lt;?, ?&gt; attachment)</span> </span>&#123;</span><br><span class="line">                channel.write(ByteBuffer.wrap(<span class="string">&quot;test connecting&quot;</span>.getBytes()));</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">                channel.read(buffer, <span class="string">&quot;&quot;</span>, <span class="keyword">new</span> CompletionHandler&lt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, String attachment)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (result != -<span class="number">1</span>) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;read from server : &quot;</span> + <span class="keyword">new</span> String(buffer.array(),<span class="number">0</span>, result));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, String attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, HashMap&lt;?, ?&gt; attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;connect fail&quot;</span> + exc.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AIOClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>).init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NIO与AIO区别"><a href="#NIO与AIO区别" class="headerlink" title="NIO与AIO区别"></a>NIO与AIO区别</h2><ul><li>NIO是同步非阻塞的，AIO是异步非阻塞的</li><li>由于NIO的读写过程依然在应用线程里完成，所以对于那些读写过程时间长的，NIO就不太适合。而AIO的读写过程完成后才被通知，所以AIO能够胜任那些重量级，读写过程长的任务。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IO </tag>
            
            <tag> BIO </tag>
            
            <tag> NIO </tag>
            
            <tag> AIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习方法</title>
      <link href="/post/3eee/"/>
      <url>/post/3eee/</url>
      
        <content type="html"><![CDATA[<p>学习阶段可以大致分几下几步：</p><ol><li>初识（10%）：系统地过一遍整个内容。了解一些相关的资料，写一些测试的代码。这个阶段通常只需要了解一些基本的概念。</li><li>搭建知识体系（20%）：了解基本概念之后，再过一遍所有内容，这次同样不需要关注细节，但是需要注意章节体系以及章节的核心点所在。</li></ol><ul><li>如这门课有哪些课程。</li><li>对每个章节列出核心点。<br>这一步是整个方法论中的重中之重，建立知识体系结构对知识的深入理解至关重要。只有拥有了全局的视野，你才知道现在自己学习了哪些，还有哪些没有学。就像盖别墅，你需要首先画图纸，有个全局的设计。很多朋友在学习一门技能的时候总是这里看点资料，那里学点优化方法，缺乏全局的视野，缺乏系统性，学到的东西永远支离破碎。做到这个阶段，就可以由浅入深地概括一本书了。</li></ul><ol start="3"><li>深入探索（20%）：知识体系建立起来之后，需要更加深入。针对每个章节的核心点一个个重点击破，深入其工作原理。这个阶段有两点建议：<br>(1)经典内容检索：这个阶段拼的是检索能力和阅读理解能力，强烈推荐技术多关注国外技术大牛的博客以及官方博客、文档、youtube视频。<br>(2)画图整理：网络上相关的内容会非常多，经典的内容更不少，一般遇到经典内容之后都会一口气读完，再加入书签。但是久而久之，很多内容都会慢慢模糊，当你再想去查的时候已经不知道是哪个博客的内容了，相信很多人会有这样的苦恼。针对这样的问题，需要将一些自己体会非常深刻的内容记录下来，建议使用画图工具，俗话说一图胜千言。</li><li>实践探索（30%）：第三步完成之后，相信你已经可以就这项技能和别人谈笑风生了，但也仅此而已。一旦别人问你一个线上问题，相信你就会从滔滔不绝变得支支吾吾，因为你缺少实践。当然，只有在知识体系构建完成后的实践才是真正意义上的实践。有理论依据作为支撑，实践才有更多意义。实践是一个遇坑填坑的过程，没有遇到坑也不能称为实践。因为只有遇到问题，你才会完整地将监控、日志信息利用起来追踪整个系统工作流程，你才会真真切切地去想如何通过修改配置、修改源码来进一步改造它。</li></ol><p>这个阶段主要考察你解决问题的能力，一般来说通常就三板斧：监控、日志和源码。监控分为硬件监控以及业务监控，两者都需要看懂并会分析。日志也有很多，比如业务日志、GC日志等。<br>5. 分享交流（20%）：上面四步都是你自己对知识的理解，你还需要看看同行是如何理解的。实践结束之后一定记得需要以博客的形式系统完整的将这个模块完完整整、成体系地、由浅及深地进行复盘整理、分享交流。</p><p>（<a href="http://swiftlet.net/archives/2348">本文整理自网络</a>）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>控制台乱码</title>
      <link href="/post/5123/"/>
      <url>/post/5123/</url>
      
        <content type="html"><![CDATA[<p> 在<code>run configuration</code>配置中<code>VM options</code>一栏填入<code>-Dfile.encoding=utf-8</code>即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> 乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac环境feign访问服务出现超时</title>
      <link href="/post/794f/"/>
      <url>/post/794f/</url>
      
        <content type="html"><![CDATA[<p>配置文件中注册服务时的地址都是用的<code>localhost</code>,但是eureka显示的都是用的主机名称，导致会出现访问超时的情况。将主机名称和配置文件里面的域名匹配之后就可以了。修改主机名称可以在</p><ol><li><code>系统设置</code>-&gt;<code>共享</code>。</li><li><code>scutil --set HostName qin.local</code><br>里面修改</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> spring cloud </tag>
            
            <tag> feign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习3-自动配置</title>
      <link href="/post/6749/"/>
      <url>/post/6749/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习2-项目结构</title>
      <link href="/post/fba8/"/>
      <url>/post/fba8/</url>
      
        <content type="html"><![CDATA[<h1 id="避免使用“default”包"><a href="#避免使用“default”包" class="headerlink" title="避免使用“default”包"></a>避免使用“default”包</h1><p>当默认包中的类中有<code>@ComponentScan</code>, <code>@EntityScan</code> , <code>@SpringBootApplication</code>注解时，Spring Boot容易引起特殊的问题。因为会读取每个jar包中的所有类。这样很明显会耗费更多的时间跟资源。</p><blockquote><p>建议将域名反过来之后作为你的包名。</p></blockquote><h1 id="主类的位置"><a href="#主类的位置" class="headerlink" title="主类的位置"></a>主类的位置</h1><p>强烈建议将主类放在其他类之上，并放置在最上层的包中。<code>@EnableAutoConfiguration</code>注解通常是放在主类上的，而且它隐含地指出了组件扫描会以这个类所在的包为基础。比如，当你用了JPA的时候，将会使用<code>@EnableAutoConfiguration</code>注解的类的包来搜索<code>@Entity</code>实体。</p><p>在这个类上也可以添加<code>@ComponentScan</code>注解，不需要指定<code>basePackage</code>属性。如果你这个主类在最上层的话，可以在这个类上添加<code>@SpringBootApplication</code>注解。</p><p>关于<code>@SpringBootApplication</code>,<code>@EnableAutoConfiguration</code>,<code>@Configuration</code>,<code>@Configurable</code>的区别，以及背后了做了什么事情，后面有时间再写。</p><p>看下面典型的结构布局：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line"> +- example</span><br><span class="line">     +- myapplication</span><br><span class="line">         +- Application.java</span><br><span class="line">         |</span><br><span class="line">         +- customer</span><br><span class="line">         |   +- Customer.java</span><br><span class="line">         |   +- CustomerController.java</span><br><span class="line">         |   +- CustomerService.java</span><br><span class="line">         |   +- CustomerRepository.java</span><br><span class="line">         |</span><br><span class="line">         +- order</span><br><span class="line">             +- Order.java</span><br><span class="line">             +- OrderController.java</span><br><span class="line">             +- OrderService.java</span><br><span class="line">             +- OrderRepository.java</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>Application</code>就是我们的主类，可以在上面加上经典的<code>@Configuration</code>注解。在里面声明一个<code>main</code>作为我们Spring Boot 应用的入口。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.example.myapplication;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h1><p>Spring Boot 倾向于Java代码方式的配置。尽管可以使用XML来配置Spring Boot应用，但是建议使用一个<code>@Configuration</code>类作为主要的配置源。通常定义了<code>main</code>方法的类作为主要的<code>@Configuration</code>类是比较好的方式。可以在这个配置类里面引入其他的配置，比如引入xml文件。</p><p>许多Spring 的配置例子里面都是用XML来配置，如果要改成java代码方式，可以搜一下<code>Enable*</code>开头的注解。</p><h1 id="引入其他配置类"><a href="#引入其他配置类" class="headerlink" title="引入其他配置类"></a>引入其他配置类</h1><p>通常我们不需要将所有的<code>@Configuration</code>注解放在一个类上，为了划分模块，通常会写多个配置类。可以在我们的主配置类上添加<code>@Import</code>注解，引入其他的配置类。还可以在这个类上直接添加<code>@ComponentScan</code>注解，这个注解会将所有的Spring 组件都扫描进来，包括<code>@Configuration</code>注解的类。看一下<code>@Configuration</code>注解的文档：</p><blockquote><p><code>@Configuration</code> is meta-annotated with <code>@Component</code>, therefore <code>@Configuration</code> classes are candidates for component scanning (typically using Spring XML’s <code>&lt;context:component-scan/&gt;</code> element) and therefore may also take advantage of <code>@Autowired</code>/<code>@Inject</code> like any regular <code>@Component</code>. In particular, if a single constructor is present autowiring semantics will be applied transparently:<br>   @Configuration<br>   public class AppConfig {<br>       private final SomeBean someBean;</p><pre><code>   public AppConfig(SomeBean someBean) &#123;       this.someBean = someBean;   &#125;   // @Bean definition using &quot;SomeBean&quot;</code></pre><p>   }</p></blockquote><p>大致意思是<code>@Configuration</code>注解使用了元注解<code>@Component</code>,因此<code>@Configuration</code>注解的类可以被组件扫描出来（经典的方式是使用Spring XML的<code>&lt;context:component-scan/&gt;</code>元素）而且也可以像其他组件一样使用<code>@Autowired</code>/<code>@Inject</code>的优势。如果这个类提供了一个单独的构造函数，那么自动注入将会透明地进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    private final SomeBean someBean;</span><br><span class="line">   </span><br><span class="line">    public AppConfig(SomeBean someBean) &#123;</span><br><span class="line">       this.someBean &#x3D; someBean;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; @Bean definition using &quot;SomeBean&quot;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引入XML配置"><a href="#引入XML配置" class="headerlink" title="引入XML配置"></a>引入XML配置</h1><p>如果仍然要使用XML配置，有些老项目改起来也挺麻烦，可以在主配置类上使用<code>@ImportResource</code>注解来引入XML配置文件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> 项目结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习1-创建Spring Boot应用</title>
      <link href="/post/e2d8/"/>
      <url>/post/e2d8/</url>
      
        <content type="html"><![CDATA[<p>如果使用Maven, 确保先安装好<a href="http://maven.apache.org/">Maven</a>再继续。</p><h3 id="创建POM文件"><a href="#创建POM文件" class="headerlink" title="创建POM文件"></a>创建POM文件</h3><p>在这里有两种方式：</p><ol><li>继承Spring Boot parent的pom。</li><li>不继承。</li></ol><h4 id="继承Spring-Boot-pom"><a href="#继承Spring-Boot-pom" class="headerlink" title="继承Spring Boot pom"></a>继承Spring Boot pom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;com.example&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;myproject&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.0.0.BUILD-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Additional lines to be added here... --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- (保用正式版的时候不需要下面的配置) --&gt;</span><br><span class="line">&lt;repositories&gt;</span><br><span class="line">&lt;repository&gt;</span><br><span class="line">&lt;id&gt;spring-snapshots&lt;&#x2F;id&gt;</span><br><span class="line">&lt;url&gt;http:&#x2F;&#x2F;repo.spring.io&#x2F;snapshot&lt;&#x2F;url&gt;</span><br><span class="line">&lt;snapshots&gt;&lt;enabled&gt;true&lt;&#x2F;enabled&gt;&lt;&#x2F;snapshots&gt;</span><br><span class="line">&lt;&#x2F;repository&gt;</span><br><span class="line">&lt;repository&gt;</span><br><span class="line">&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">&lt;url&gt;http:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">&lt;&#x2F;repository&gt;</span><br><span class="line">&lt;&#x2F;repositories&gt;</span><br><span class="line">&lt;pluginRepositories&gt;</span><br><span class="line">&lt;pluginRepository&gt;</span><br><span class="line">&lt;id&gt;spring-snapshots&lt;&#x2F;id&gt;</span><br><span class="line">&lt;url&gt;http:&#x2F;&#x2F;repo.spring.io&#x2F;snapshot&lt;&#x2F;url&gt;</span><br><span class="line">&lt;&#x2F;pluginRepository&gt;</span><br><span class="line">&lt;pluginRepository&gt;</span><br><span class="line">&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">&lt;url&gt;http:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">&lt;&#x2F;pluginRepository&gt;</span><br><span class="line">&lt;&#x2F;pluginRepositories&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>此种方式会约定Spring Boot 依赖的版本，它最终继承自<code>spring-boot-dependencies</code>模块，此模块规定了各种依赖的版本号，我们只需要引入groupId 和artifactId就可以了。而且还引入了一些maven的插件，可以让我们用maven的方式<code>mvn spring-boot:run </code>来启动我们的应用。当然如果你用了强大的IDEA,直接可以像普通的应用程序一样启动。</p><h4 id="不继承Spring-Boot-parent"><a href="#不继承Spring-Boot-parent" class="headerlink" title="不继承Spring Boot parent"></a>不继承Spring Boot parent</h4><p>因为实际开发过程中我们可能会有自己的parent，要开发的功能只是项目中一个模块，这时候就没法使用spring boot parent。这时只需要将spring boot dependencies引入到我们的项目中来就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;!-- Import dependency management from Spring Boot --&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.0.0.BUILD-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">        &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure><p>然后我们还是可以在我们的项目中声明groupdId和artifactId来引入依赖。如果需要使用spring boot 的maven插件来启动，则需要手动引入.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">        &lt;!--使用boot的maven插件来方便运行boot应用--&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;plugin&gt;</span><br><span class="line">&lt;&#x2F;plugins&gt;</span><br></pre></td></tr></table></figure><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>上面也提到了，如果你继承了spring boot parent，或者引入了spring boot dependencies模块，那么spring boot 就帮你管理了常用的依赖，你可以在引入的时候省略掉版本号。使用这种方式的好处是，spring boot已经帮你考虑了兼容性的问题。</p><p>另外，spring boot 引入了starter的概念。其实就是帮你将相关的依赖整理在一起，你只需要依赖这个starter就可以引入所需要的所有依赖。另外就是starter会帮你做一些自动配置，这个后面会讲到。例如我们要开发web项目，只需要引入<code>spring-boot-starter-web</code>依赖就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;!--版本号已经省略--&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p>我们可以看一下引入了哪些依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:tree</span><br><span class="line"></span><br><span class="line">[INFO] life.qzz:springboot.demo1:jar:1.0-SNAPSHOT</span><br><span class="line">[INFO] \- org.springframework.boot:spring-boot-starter-web:jar:2.0.0.BUILD-SNAPSHOT:compile</span><br><span class="line">[INFO]    +- org.springframework.boot:spring-boot-starter:jar:2.0.0.BUILD-SNAPSHOT:compile</span><br><span class="line">[INFO]    |  +- org.springframework.boot:spring-boot:jar:2.0.0.BUILD-SNAPSHOT:compile</span><br><span class="line">[INFO]    |  +- org.springframework.boot:spring-boot-autoconfigure:jar:2.0.0.BUILD-SNAPSHOT:compile</span><br><span class="line">[INFO]    |  +- org.springframework.boot:spring-boot-starter-logging:jar:2.0.0.BUILD-SNAPSHOT:compile</span><br><span class="line">[INFO]    |  |  +- ch.qos.logback:logback-classic:jar:1.2.3:compile</span><br><span class="line">[INFO]    |  |  |  +- ch.qos.logback:logback-core:jar:1.2.3:compile</span><br><span class="line">[INFO]    |  |  |  \- org.slf4j:slf4j-api:jar:1.7.25:compile</span><br><span class="line">[INFO]    |  |  +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.9.1:compile</span><br><span class="line">[INFO]    |  |  |  \- org.apache.logging.log4j:log4j-api:jar:2.9.1:compile</span><br><span class="line">[INFO]    |  |  +- org.slf4j:jul-to-slf4j:jar:1.7.25:compile</span><br><span class="line">[INFO]    |  |  \- org.slf4j:log4j-over-slf4j:jar:1.7.25:compile</span><br><span class="line">[INFO]    |  +- javax.annotation:javax.annotation-api:jar:1.3.1:compile</span><br><span class="line">[INFO]    |  +- org.springframework:spring-core:jar:5.0.2.BUILD-SNAPSHOT:compile</span><br><span class="line">[INFO]    |  |  \- org.springframework:spring-jcl:jar:5.0.2.BUILD-SNAPSHOT:compile</span><br><span class="line">[INFO]    |  \- org.yaml:snakeyaml:jar:1.19:runtime</span><br><span class="line">[INFO]    +- org.springframework.boot:spring-boot-starter-json:jar:2.0.0.BUILD-SNAPSHOT:compile</span><br><span class="line">[INFO]    |  +- com.fasterxml.jackson.core:jackson-databind:jar:2.9.2:compile</span><br><span class="line">[INFO]    |  |  +- com.fasterxml.jackson.core:jackson-annotations:jar:2.9.0:compile</span><br><span class="line">[INFO]    |  |  \- com.fasterxml.jackson.core:jackson-core:jar:2.9.2:compile</span><br><span class="line">[INFO]    |  +- com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.9.2:compile</span><br><span class="line">[INFO]    |  +- com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.9.2:compile</span><br><span class="line">[INFO]    |  +- com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.9.2:compile</span><br><span class="line">[INFO]    |  \- com.fasterxml.jackson.module:jackson-module-kotlin:jar:2.9.2:compile</span><br><span class="line">[INFO]    +- org.springframework.boot:spring-boot-starter-tomcat:jar:2.0.0.BUILD-SNAPSHOT:compile</span><br><span class="line">[INFO]    |  +- org.apache.tomcat.embed:tomcat-embed-core:jar:8.5.23:compile</span><br><span class="line">[INFO]    |  |  \- org.apache.tomcat:tomcat-annotations-api:jar:8.5.23:compile</span><br><span class="line">[INFO]    |  +- org.apache.tomcat.embed:tomcat-embed-el:jar:8.5.23:compile</span><br><span class="line">[INFO]    |  \- org.apache.tomcat.embed:tomcat-embed-websocket:jar:8.5.23:compile</span><br><span class="line">[INFO]    +- org.hibernate.validator:hibernate-validator:jar:6.0.4.Final:compile</span><br><span class="line">[INFO]    |  +- javax.validation:validation-api:jar:2.0.0.Final:compile</span><br><span class="line">[INFO]    |  +- org.jboss.logging:jboss-logging:jar:3.3.1.Final:compile</span><br><span class="line">[INFO]    |  \- com.fasterxml:classmate:jar:1.3.4:compile</span><br><span class="line">[INFO]    +- org.springframework:spring-web:jar:5.0.2.BUILD-SNAPSHOT:compile</span><br><span class="line">[INFO]    |  \- org.springframework:spring-beans:jar:5.0.2.BUILD-SNAPSHOT:compile</span><br><span class="line">[INFO]    \- org.springframework:spring-webmvc:jar:5.0.2.BUILD-SNAPSHOT:compile</span><br><span class="line">[INFO]       +- org.springframework:spring-aop:jar:5.0.2.BUILD-SNAPSHOT:compile</span><br><span class="line">[INFO]       +- org.springframework:spring-context:jar:5.0.2.BUILD-SNAPSHOT:compile</span><br><span class="line">[INFO]       \- org.springframework:spring-expression:jar:5.0.2.BUILD-SNAPSHOT:compile</span><br></pre></td></tr></table></figure><p>主要是spring web, tomcat等web相关的jar。可以看出来这种方式会相比我们之前的开发方式方便快捷许多。spring boot 提供了一系列的starter，当然如果这些还不能满足你的话，完全可以开发自己的starter，只需要遵循spring boot提供的命名规范就可以了。后面会讲到如何开发starter。</p><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>在src/main/java目录中新建一个简单的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.*;</span><br><span class="line">import org.springframework.boot.autoconfigure.*;</span><br><span class="line">import org.springframework.stereotype.*;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">public class Example &#123;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">String home() &#123;</span><br><span class="line">return &quot;Hello World!&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">SpringApplication.run(Example.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类中指定了我们的spring boot 的入口<code>main</code>函数，这个类就是下步中的main-class。<br>类上有<code>@EnableAutoConfiguration</code>注解，这个注解会告诉Spring Boot 自动该应用，具体做了哪些配置，以后再说。比如说我们添加了web的starter，那么Spring Boot 会认为我们在开发一个web应用，那么会创建一个web applicationContext。自动配置和starter没有完全的绑定有关系，如果把相关的依赖都单独加进来，而不使用starter, Spring Boot 也会尽量做好自动配置工作。另外两个注解<code>@RestController</code>和<code>@RequestMapping(&quot;/&quot;)</code>是Spring MVC的。</p><p>main方法里面调用<code>SpringApplication.run()</code>方法，将我们的主配置类传递给<code>SpringApplication</code>,还可以通过args参数将控制台参数传递进去。</p><h3 id="运行我们的程序"><a href="#运行我们的程序" class="headerlink" title="运行我们的程序"></a>运行我们的程序</h3><p>Spring Boot 要求编绎环境为1.8以上，可以在maven pom中设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">    &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;$&#123;java.version&#125;&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;$&#123;java.version&#125;&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure><ol><li>使用maven 插件来运行<code>mvn spring-boot:run</code>。</li><li>在IDEA中如果不能自动创建spring boot运行配置，可以手动创建。如图所示<br><img src="http://ooll8xqpq.bkt.clouddn.com/FA1A8449-B29F-4AE0-8449-BD2FA6F04FF5.png" alt="image"></li></ol><p>添加的时候选择spring boot, 主要是指定main class和module路径 。可以将应用添加到spring boot run dashboard中,方便我们管理 spring boot应用。dashboard 如图所示 <img src="http://ooll8xqpq.bkt.clouddn.com/4F5AE28E-3D9A-4D4D-8BE9-49E51706928F.png" alt="image"></p><h3 id="打包程序"><a href="#打包程序" class="headerlink" title="打包程序"></a>打包程序</h3><p>可以将spring boot 应用打包为一个独立的jar，然后上传到服务器中运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- maven-jar-plugin:3.0.2:jar (default-jar) @ springboot.demo2 ---</span><br><span class="line">[INFO] Building jar: &#x2F;Volumes&#x2F;DATA&#x2F;code&#x2F;springboot-demo&#x2F;demo2&#x2F;target&#x2F;springboot.demo2-2.0.0.BUILD-SNAPSHOT.jar</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果没有继承spring boot parent，那么需要自己配置一下spring boot maven 插件，不然无法打包成spring boot jar。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.0.0.BUILD-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;repackage&lt;&#x2F;goal&gt;</span><br><span class="line">          &lt;&#x2F;goals&gt;</span><br><span class="line">        &lt;&#x2F;execution&gt;</span><br><span class="line">      &lt;&#x2F;executions&gt;</span><br><span class="line">    &lt;&#x2F;plugin&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;&#x2F;plugins&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><p>如果继承了spring boot parent，只需要引入spring boot maven plugin即可，不需要做如上配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;plugin&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;&#x2F;plugins&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><p>运行的时候执行命令即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar target&#x2F;springboot.demo2-2.0.0.BUILD-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 十 - 附录</title>
      <link href="/post/d1f6/"/>
      <url>/post/d1f6/</url>
      
        <content type="html"><![CDATA[<h2 id="附录-A-常用应用属性"><a href="#附录-A-常用应用属性" class="headerlink" title="附录 A. 常用应用属性"></a>附录 A. 常用应用属性</h2><p>可以在<code>application.properties</code>/<code>application.yml</code>文件中指定各种属性，或者作为命令行开关。 本节提供了常用Spring Boot属性的列表以及对使用它们的基础类的引用。</p><blockquote><p>属性可以来自你的类路径上的其他jar文件，所以你不应该认为这是一个详尽的列表。 定义自己的属性也是完全合法的。</p></blockquote><blockquote><p>此示例文件仅作为指导。 <strong>不要</strong>将整个内容复制/粘贴到应用程序中; 而只选择你需要的属性。</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================================</span></span><br><span class="line"><span class="comment"># COMMON SPRING BOOT PROPERTIES</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This sample file is provided as a guideline. Do NOT copy it in its</span></span><br><span class="line"><span class="comment"># entirety to your own application.               ^^^</span></span><br><span class="line"><span class="comment"># ===================================================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># CORE PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BANNER</span></span><br><span class="line"><span class="meta">banner.charset</span>=<span class="string">UTF-8 # Banner file encoding.</span></span><br><span class="line"><span class="meta">banner.location</span>=<span class="string">classpath:banner.txt # Banner file location.</span></span><br><span class="line"><span class="meta">banner.image.location</span>=<span class="string">classpath:banner.gif # Banner image file location (jpg/png can also be used).</span></span><br><span class="line"><span class="meta">banner.image.width</span>= <span class="string"># Width of the banner image in chars (default 76)</span></span><br><span class="line"><span class="meta">banner.image.height</span>= <span class="string"># Height of the banner image in chars (default based on image height)</span></span><br><span class="line"><span class="meta">banner.image.margin</span>= <span class="string"># Left hand image margin in chars (default 2)</span></span><br><span class="line"><span class="meta">banner.image.invert</span>= <span class="string"># If images should be inverted for dark terminal themes (default false)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LOGGING</span></span><br><span class="line"><span class="meta">logging.config</span>= <span class="string"># Location of the logging configuration file. For instance `classpath:logback.xml` for Logback</span></span><br><span class="line"><span class="meta">logging.exception-conversion-word</span>=<span class="string">%wEx # Conversion word used when logging exceptions.</span></span><br><span class="line"><span class="meta">logging.file</span>= <span class="string"># Log file name. For instance `myapp.log`</span></span><br><span class="line"><span class="meta">logging.level.*</span>= <span class="string"># Log levels severity mapping. For instance `logging.level.org.springframework=DEBUG`</span></span><br><span class="line"><span class="meta">logging.path</span>= <span class="string"># Location of the log file. For instance `/var/log`</span></span><br><span class="line"><span class="meta">logging.pattern.console</span>= <span class="string"># Appender pattern for output to the console. Only supported with the default logback setup.</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>= <span class="string"># Appender pattern for output to the file. Only supported with the default logback setup.</span></span><br><span class="line"><span class="meta">logging.pattern.level</span>= <span class="string"># Appender pattern for log level (default %5p). Only supported with the default logback setup.</span></span><br><span class="line"><span class="meta">logging.register-shutdown-hook</span>=<span class="string">false # Register a shutdown hook for the logging system when it is initialized.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AOP</span></span><br><span class="line"><span class="meta">spring.aop.auto</span>=<span class="string">true # Add @EnableAspectJAutoProxy.</span></span><br><span class="line"><span class="meta">spring.aop.proxy-target-class</span>=<span class="string">true # Whether subclass-based (CGLIB) proxies are to be created (true) as opposed to standard Java interface-based proxies (false).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># IDENTITY (ContextIdApplicationContextInitializer)</span></span><br><span class="line"><span class="meta">spring.application.index</span>= <span class="string"># Application index.</span></span><br><span class="line"><span class="meta">spring.application.name</span>= <span class="string"># Application name.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ADMIN (SpringApplicationAdminJmxAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.application.admin.enabled</span>=<span class="string">false # Enable admin features for the application.</span></span><br><span class="line"><span class="meta">spring.application.admin.jmx-name</span>=<span class="string">org.springframework.boot:type=Admin,name=SpringApplication # JMX name of the application admin MBean.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AUTO-CONFIGURATION</span></span><br><span class="line"><span class="meta">spring.autoconfigure.exclude</span>= <span class="string"># Auto-configuration classes to exclude.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING CORE</span></span><br><span class="line"><span class="meta">spring.beaninfo.ignore</span>=<span class="string">true # Skip search of BeanInfo classes.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING CACHE (CacheProperties)</span></span><br><span class="line"><span class="meta">spring.cache.cache-names</span>= <span class="string"># Comma-separated list of cache names to create if supported by the underlying cache manager.</span></span><br><span class="line"><span class="meta">spring.cache.caffeine.spec</span>= <span class="string"># The spec to use to create caches. Check CaffeineSpec for more details on the spec format.</span></span><br><span class="line"><span class="meta">spring.cache.couchbase.expiration</span>=<span class="string">0 # Entry expiration in milliseconds. By default the entries never expire.</span></span><br><span class="line"><span class="meta">spring.cache.ehcache.config</span>= <span class="string"># The location of the configuration file to use to initialize EhCache.</span></span><br><span class="line"><span class="meta">spring.cache.infinispan.config</span>= <span class="string"># The location of the configuration file to use to initialize Infinispan.</span></span><br><span class="line"><span class="meta">spring.cache.jcache.config</span>= <span class="string"># The location of the configuration file to use to initialize the cache manager.</span></span><br><span class="line"><span class="meta">spring.cache.jcache.provider</span>= <span class="string"># Fully qualified name of the CachingProvider implementation to use to retrieve the JSR-107 compliant cache manager. Only needed if more than one JSR-107 implementation is available on the classpath.</span></span><br><span class="line"><span class="meta">spring.cache.type</span>= <span class="string"># Cache type, auto-detected according to the environment by default.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING CONFIG - using environment property only (ConfigFileApplicationListener)</span></span><br><span class="line"><span class="meta">spring.config.location</span>= <span class="string"># Config file locations.</span></span><br><span class="line"><span class="meta">spring.config.name</span>=<span class="string">application # Config file name.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HAZELCAST (HazelcastProperties)</span></span><br><span class="line"><span class="meta">spring.hazelcast.config</span>= <span class="string"># The location of the configuration file to use to initialize Hazelcast.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PROJECT INFORMATION (ProjectInfoProperties)</span></span><br><span class="line"><span class="meta">spring.info.build.location</span>=<span class="string">classpath:META-INF/build-info.properties # Location of the generated build-info.properties file.</span></span><br><span class="line"><span class="meta">spring.info.git.location</span>=<span class="string">classpath:git.properties # Location of the generated git.properties file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JMX</span></span><br><span class="line"><span class="meta">spring.jmx.default-domain</span>= <span class="string"># JMX domain name.</span></span><br><span class="line"><span class="meta">spring.jmx.enabled</span>=<span class="string">true # Expose management beans to the JMX domain.</span></span><br><span class="line"><span class="meta">spring.jmx.server</span>=<span class="string">mbeanServer # MBeanServer bean name.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Email (MailProperties)</span></span><br><span class="line"><span class="meta">spring.mail.default-encoding</span>=<span class="string">UTF-8 # Default MimeMessage encoding.</span></span><br><span class="line"><span class="meta">spring.mail.host</span>= <span class="string"># SMTP server host. For instance `smtp.example.com`</span></span><br><span class="line"><span class="meta">spring.mail.jndi-name</span>= <span class="string"># Session JNDI name. When set, takes precedence to others mail settings.</span></span><br><span class="line"><span class="meta">spring.mail.password</span>= <span class="string"># Login password of the SMTP server.</span></span><br><span class="line"><span class="meta">spring.mail.port</span>= <span class="string"># SMTP server port.</span></span><br><span class="line"><span class="meta">spring.mail.properties.*</span>= <span class="string"># Additional JavaMail session properties.</span></span><br><span class="line"><span class="meta">spring.mail.protocol</span>=<span class="string">smtp # Protocol used by the SMTP server.</span></span><br><span class="line"><span class="meta">spring.mail.test-connection</span>=<span class="string">false # Test that the mail server is available on startup.</span></span><br><span class="line"><span class="meta">spring.mail.username</span>= <span class="string"># Login user of the SMTP server.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># APPLICATION SETTINGS (SpringApplication)</span></span><br><span class="line"><span class="meta">spring.main.banner-mode</span>=<span class="string">console # Mode used to display the banner when the application runs.</span></span><br><span class="line"><span class="meta">spring.main.sources</span>= <span class="string"># Sources (class name, package name or XML resource location) to include in the ApplicationContext.</span></span><br><span class="line"><span class="meta">spring.main.web-application-type</span>= <span class="string"># Flag to explicitly request a specific type of web application. Auto-detected based on the classpath if not set.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FILE ENCODING (FileEncodingApplicationListener)</span></span><br><span class="line"><span class="meta">spring.mandatory-file-encoding</span>= <span class="string"># Expected character encoding the application must use.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># INTERNATIONALIZATION (MessageSourceAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.messages.always-use-message-format</span>=<span class="string">false # Set whether to always apply the MessageFormat rules, parsing even messages without arguments.</span></span><br><span class="line"><span class="meta">spring.messages.basename</span>=<span class="string">messages # Comma-separated list of basenames, each following the ResourceBundle convention.</span></span><br><span class="line"><span class="meta">spring.messages.cache-seconds</span>=<span class="string">-1 # Loaded resource bundle files cache expiration, in seconds. When set to -1, bundles are cached forever.</span></span><br><span class="line"><span class="meta">spring.messages.encoding</span>=<span class="string">UTF-8 # Message bundles encoding.</span></span><br><span class="line"><span class="meta">spring.messages.fallback-to-system-locale</span>=<span class="string">true # Set whether to fall back to the system Locale if no files for a specific Locale have been found.</span></span><br><span class="line"><span class="meta">spring.messages.use-code-as-default-message</span>=<span class="string">false # Set whether to use the message code as default message instead of throwing a &quot;NoSuchMessageException&quot;. Recommended during development only.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OUTPUT</span></span><br><span class="line"><span class="meta">spring.output.ansi.enabled</span>=<span class="string">detect # Configure the ANSI output.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PID FILE (ApplicationPidFileWriter)</span></span><br><span class="line"><span class="meta">spring.pid.fail-on-write-error</span>= <span class="string"># Fail if ApplicationPidFileWriter is used but it cannot write the PID file.</span></span><br><span class="line"><span class="meta">spring.pid.file</span>= <span class="string"># Location of the PID file to write (if ApplicationPidFileWriter is used).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PROFILES</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>= <span class="string"># Comma-separated list (or list if using YAML) of active profiles.</span></span><br><span class="line"><span class="meta">spring.profiles.include</span>= <span class="string"># Unconditionally activate the specified comma separated profiles (or list of profiles if using YAML).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># QUARTZ SCHEDULER (QuartzProperties)</span></span><br><span class="line"><span class="meta">spring.quartz.job-store-type</span>=<span class="string">memory # Quartz job store type.</span></span><br><span class="line"><span class="meta">spring.quartz.properties.*</span>= <span class="string"># Additional Quartz Scheduler properties.</span></span><br><span class="line"><span class="meta">spring.quartz.jdbc.initialize-schema</span>=<span class="string">embedded # Database schema initialization mode.</span></span><br><span class="line"><span class="meta">spring.quartz.jdbc.schema</span>=<span class="string">classpath:org/quartz/impl/jdbcjobstore/tables_@@platform@@.sql # Path to the SQL file to use to initialize the database schema.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reactor</span></span><br><span class="line"><span class="meta">spring.reactor.stacktrace-mode.enabled</span>=<span class="string">false # Set whether Reactor should collect stacktrace information at runtime.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SENDGRID (SendGridAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.sendgrid.api-key</span>= <span class="string"># SendGrid API key.</span></span><br><span class="line"><span class="meta">spring.sendgrid.proxy.host</span>= <span class="string"># SendGrid proxy host.</span></span><br><span class="line"><span class="meta">spring.sendgrid.proxy.port</span>= <span class="string"># SendGrid proxy port.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># WEB PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># EMBEDDED SERVER CONFIGURATION (ServerProperties)</span></span><br><span class="line"><span class="meta">server.address</span>= <span class="string"># Network address to which the server should bind to.</span></span><br><span class="line"><span class="meta">server.compression.enabled</span>=<span class="string">false # If response compression is enabled.</span></span><br><span class="line"><span class="meta">server.compression.excluded-user-agents</span>= <span class="string"># List of user-agents to exclude from compression.</span></span><br><span class="line"><span class="meta">server.compression.mime-types</span>=<span class="string">text/html,text/xml,text/plain,text/css,text/javascript,application/javascript # Comma-separated list of MIME types that should be compressed.</span></span><br><span class="line"><span class="meta">server.compression.min-response-size</span>=<span class="string">2048 # Minimum response size that is required for compression to be performed.</span></span><br><span class="line"><span class="meta">server.connection-timeout</span>= <span class="string"># Time in milliseconds that connectors will wait for another HTTP request before closing the connection. When not set, the connector&#x27;s container-specific default will be used. Use a value of -1 to indicate no (i.e. infinite) timeout.</span></span><br><span class="line"><span class="meta">server.display-name</span>=<span class="string">application # Display name of the application.</span></span><br><span class="line"><span class="meta">server.max-http-header-size</span>=<span class="string">0 # Maximum size in bytes of the HTTP message header.</span></span><br><span class="line"><span class="meta">server.error.include-exception</span>=<span class="string">false # Include the &quot;exception&quot; attribute.</span></span><br><span class="line"><span class="meta">server.error.include-stacktrace</span>=<span class="string">never # When to include a &quot;stacktrace&quot; attribute.</span></span><br><span class="line"><span class="meta">server.error.path</span>=<span class="string">/error # Path of the error controller.</span></span><br><span class="line"><span class="meta">server.error.whitelabel.enabled</span>=<span class="string">true # Enable the default error page displayed in browsers in case of a server error.</span></span><br><span class="line"><span class="meta">server.jetty.acceptors</span>= <span class="string"># Number of acceptor threads to use.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.append</span>=<span class="string">false # Append to log.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.date-format</span>=<span class="string">dd/MMM/yyyy:HH:mm:ss Z # Timestamp format of the request log.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.enabled</span>=<span class="string">false # Enable access log.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.extended-format</span>=<span class="string">false # Enable extended NCSA format.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.file-date-format</span>= <span class="string"># Date format to place in log file name.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.filename</span>= <span class="string"># Log filename. If not specified, logs will be redirected to &quot;System.err&quot;.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.locale</span>= <span class="string"># Locale of the request log.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.log-cookies</span>=<span class="string">false # Enable logging of the request cookies.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.log-latency</span>=<span class="string">false # Enable logging of request processing time.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.log-server</span>=<span class="string">false # Enable logging of the request hostname.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.retention-period</span>=<span class="string">31 # Number of days before rotated log files are deleted.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.time-zone</span>=<span class="string">GMT # Timezone of the request log.</span></span><br><span class="line"><span class="meta">server.jetty.max-http-post-size</span>=<span class="string">0 # Maximum size in bytes of the HTTP post or put content.</span></span><br><span class="line"><span class="meta">server.jetty.selectors</span>= <span class="string"># Number of selector threads to use.</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080 # Server HTTP port.</span></span><br><span class="line"><span class="meta">server.server-header</span>= <span class="string"># Value to use for the Server response header (no header is sent if empty)</span></span><br><span class="line"><span class="meta">server.use-forward-headers</span>= <span class="string"># If X-Forwarded-* headers should be applied to the HttpRequest.</span></span><br><span class="line"><span class="meta">server.servlet.context-parameters.*</span>= <span class="string"># Servlet context init parameters</span></span><br><span class="line">   <span class="meta">server.servlet.context-path</span>= <span class="string"># Context path of the application.</span></span><br><span class="line">   <span class="meta">server.servlet.jsp.class-name</span>=<span class="string">org.apache.jasper.servlet.JspServlet # The class name of the JSP servlet.</span></span><br><span class="line"><span class="meta">server.servlet.jsp.init-parameters.*</span>= <span class="string"># Init parameters used to configure the JSP servlet</span></span><br><span class="line"><span class="meta">server.servlet.jsp.registered</span>=<span class="string">true # Whether or not the JSP servlet is registered</span></span><br><span class="line">   <span class="meta">server.servlet.path</span>=<span class="string">/ # Path of the main dispatcher servlet.</span></span><br><span class="line"><span class="meta">server.session.cookie.comment</span>= <span class="string"># Comment for the session cookie.</span></span><br><span class="line"><span class="meta">server.session.cookie.domain</span>= <span class="string"># Domain for the session cookie.</span></span><br><span class="line"><span class="meta">server.session.cookie.http-only</span>= <span class="string"># &quot;HttpOnly&quot; flag for the session cookie.</span></span><br><span class="line"><span class="meta">server.session.cookie.max-age</span>= <span class="string"># Maximum age of the session cookie in seconds.</span></span><br><span class="line"><span class="meta">server.session.cookie.name</span>= <span class="string"># Session cookie name.</span></span><br><span class="line"><span class="meta">server.session.cookie.path</span>= <span class="string"># Path of the session cookie.</span></span><br><span class="line"><span class="meta">server.session.cookie.secure</span>= <span class="string"># &quot;Secure&quot; flag for the session cookie.</span></span><br><span class="line"><span class="meta">server.session.persistent</span>=<span class="string">false # Persist session data between restarts.</span></span><br><span class="line"><span class="meta">server.session.store-dir</span>= <span class="string"># Directory used to store session data.</span></span><br><span class="line"><span class="meta">server.session.timeout</span>= <span class="string"># Session timeout in seconds.</span></span><br><span class="line"><span class="meta">server.session.tracking-modes</span>= <span class="string"># Session tracking modes (one or more of the following: &quot;cookie&quot;, &quot;url&quot;, &quot;ssl&quot;).</span></span><br><span class="line"><span class="meta">server.ssl.ciphers</span>= <span class="string"># Supported SSL ciphers.</span></span><br><span class="line"><span class="meta">server.ssl.client-auth</span>= <span class="string"># Whether client authentication is wanted (&quot;want&quot;) or needed (&quot;need&quot;). Requires a trust store.</span></span><br><span class="line"><span class="meta">server.ssl.enabled</span>= <span class="string"># Enable SSL support.</span></span><br><span class="line"><span class="meta">server.ssl.enabled-protocols</span>= <span class="string"># Enabled SSL protocols.</span></span><br><span class="line"><span class="meta">server.ssl.key-alias</span>= <span class="string"># Alias that identifies the key in the key store.</span></span><br><span class="line"><span class="meta">server.ssl.key-password</span>= <span class="string"># Password used to access the key in the key store.</span></span><br><span class="line"><span class="meta">server.ssl.key-store</span>= <span class="string"># Path to the key store that holds the SSL certificate (typically a jks file).</span></span><br><span class="line"><span class="meta">server.ssl.key-store-password</span>= <span class="string"># Password used to access the key store.</span></span><br><span class="line"><span class="meta">server.ssl.key-store-provider</span>= <span class="string"># Provider for the key store.</span></span><br><span class="line"><span class="meta">server.ssl.key-store-type</span>= <span class="string"># Type of the key store.</span></span><br><span class="line"><span class="meta">server.ssl.protocol</span>=<span class="string">TLS # SSL protocol to use.</span></span><br><span class="line"><span class="meta">server.ssl.trust-store</span>= <span class="string"># Trust store that holds SSL certificates.</span></span><br><span class="line"><span class="meta">server.ssl.trust-store-password</span>= <span class="string"># Password used to access the trust store.</span></span><br><span class="line"><span class="meta">server.ssl.trust-store-provider</span>= <span class="string"># Provider for the trust store.</span></span><br><span class="line"><span class="meta">server.ssl.trust-store-type</span>= <span class="string"># Type of the trust store.</span></span><br><span class="line"><span class="meta">server.tomcat.accept-count</span>= <span class="string"># Maximum queue length for incoming connection requests when all possible request processing threads are in use.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.buffered</span>=<span class="string">true # Buffer output such that it is only flushed periodically.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.directory</span>=<span class="string">logs # Directory in which log files are created. Can be relative to the tomcat base dir or absolute.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.enabled</span>=<span class="string">false # Enable access log.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.file-date-format</span>=<span class="string">.yyyy-MM-dd # Date format to place in log file name.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.pattern</span>=<span class="string">common # Format pattern for access logs.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.prefix</span>=<span class="string">access_log # Log file name prefix.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.rename-on-rotate</span>=<span class="string">false # Defer inclusion of the date stamp in the file name until rotate time.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.request-attributes-enabled</span>=<span class="string">false # Set request attributes for IP address, Hostname, protocol and port used for the request.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.rotate</span>=<span class="string">true # Enable access log rotation.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.suffix</span>=<span class="string">.log # Log file name suffix.</span></span><br><span class="line"><span class="meta">server.tomcat.additional-tld-skip-patterns</span>= <span class="string"># Comma-separated list of additional patterns that match jars to ignore for TLD scanning.</span></span><br><span class="line"><span class="meta">server.tomcat.background-processor-delay</span>=<span class="string">30 # Delay in seconds between the invocation of backgroundProcess methods.</span></span><br><span class="line"><span class="meta">server.tomcat.basedir</span>= <span class="string"># Tomcat base directory. If not specified a temporary directory will be used.</span></span><br><span class="line"><span class="meta">server.tomcat.internal-proxies</span>=<span class="string">10\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span></span><br><span class="line"><span class="attr">192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span></span><br><span class="line"><span class="attr">169\\.254\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span></span><br><span class="line"><span class="attr">127\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span></span><br><span class="line"><span class="attr">172\\.1[6-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span></span><br><span class="line"><span class="attr">172\\.2[0-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span></span><br><span class="line"><span class="meta">172\\.3[0-1]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;</span> <span class="string"># regular expression matching trusted IP addresses.</span></span><br><span class="line"><span class="meta">server.tomcat.max-connections</span>= <span class="string"># Maximum number of connections that the server will accept and process at any given time.</span></span><br><span class="line"><span class="meta">server.tomcat.max-http-header-size</span>=<span class="string">0 # Maximum size in bytes of the HTTP message header.</span></span><br><span class="line"><span class="meta">server.tomcat.max-http-post-size</span>=<span class="string">0 # Maximum size in bytes of the HTTP post content.</span></span><br><span class="line"><span class="meta">server.tomcat.max-threads</span>=<span class="string">0 # Maximum amount of worker threads.</span></span><br><span class="line"><span class="meta">server.tomcat.min-spare-threads</span>=<span class="string">0 # Minimum amount of worker threads.</span></span><br><span class="line"><span class="meta">server.tomcat.port-header</span>=<span class="string">X-Forwarded-Port # Name of the HTTP header used to override the original port value.</span></span><br><span class="line"><span class="meta">server.tomcat.protocol-header</span>= <span class="string"># Header that holds the incoming protocol, usually named &quot;X-Forwarded-Proto&quot;.</span></span><br><span class="line"><span class="meta">server.tomcat.protocol-header-https-value</span>=<span class="string">https # Value of the protocol header that indicates that the incoming request uses SSL.</span></span><br><span class="line"><span class="meta">server.tomcat.redirect-context-root</span>= <span class="string"># Whether requests to the context root should be redirected by appending a / to the path.</span></span><br><span class="line"><span class="meta">server.tomcat.remote-ip-header</span>= <span class="string"># Name of the http header from which the remote ip is extracted. For instance `X-FORWARDED-FOR`</span></span><br><span class="line"><span class="meta">server.tomcat.uri-encoding</span>=<span class="string">UTF-8 # Character encoding to use to decode the URI.</span></span><br><span class="line"><span class="meta">server.undertow.accesslog.dir</span>= <span class="string"># Undertow access log directory.</span></span><br><span class="line"><span class="meta">server.undertow.accesslog.enabled</span>=<span class="string">false # Enable access log.</span></span><br><span class="line"><span class="meta">server.undertow.accesslog.pattern</span>=<span class="string">common # Format pattern for access logs.</span></span><br><span class="line"><span class="meta">server.undertow.accesslog.prefix</span>=<span class="string">access_log. # Log file name prefix.</span></span><br><span class="line"><span class="meta">server.undertow.accesslog.rotate</span>=<span class="string">true # Enable access log rotation.</span></span><br><span class="line"><span class="meta">server.undertow.accesslog.suffix</span>=<span class="string">log # Log file name suffix.</span></span><br><span class="line"><span class="meta">server.undertow.buffer-size</span>= <span class="string"># Size of each buffer in bytes.</span></span><br><span class="line"><span class="meta">server.undertow.direct-buffers</span>= <span class="string"># Allocate buffers outside the Java heap.</span></span><br><span class="line"><span class="meta">server.undertow.io-threads</span>= <span class="string"># Number of I/O threads to create for the worker.</span></span><br><span class="line"><span class="meta">server.undertow.eager-filter-init</span>=<span class="string">true # Whether servlet filters should be initialized on startup.</span></span><br><span class="line"><span class="meta">server.undertow.max-http-post-size</span>=<span class="string">0 # Maximum size in bytes of the HTTP post content.</span></span><br><span class="line"><span class="meta">server.undertow.worker-threads</span>= <span class="string"># Number of worker threads.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FREEMARKER (FreeMarkerAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.freemarker.allow-request-override</span>=<span class="string">false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.</span></span><br><span class="line"><span class="meta">spring.freemarker.allow-session-override</span>=<span class="string">false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.</span></span><br><span class="line"><span class="meta">spring.freemarker.cache</span>=<span class="string">false # Enable template caching.</span></span><br><span class="line"><span class="meta">spring.freemarker.charset</span>=<span class="string">UTF-8 # Template encoding.</span></span><br><span class="line"><span class="meta">spring.freemarker.check-template-location</span>=<span class="string">true # Check that the templates location exists.</span></span><br><span class="line"><span class="meta">spring.freemarker.content-type</span>=<span class="string">text/html # Content-Type value.</span></span><br><span class="line"><span class="meta">spring.freemarker.enabled</span>=<span class="string">true # Enable MVC view resolution for this technology.</span></span><br><span class="line"><span class="meta">spring.freemarker.expose-request-attributes</span>=<span class="string">false # Set whether all request attributes should be added to the model prior to merging with the template.</span></span><br><span class="line"><span class="meta">spring.freemarker.expose-session-attributes</span>=<span class="string">false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.</span></span><br><span class="line"><span class="meta">spring.freemarker.expose-spring-macro-helpers</span>=<span class="string">true # Set whether to expose a RequestContext for use by Spring&#x27;s macro library, under the name &quot;springMacroRequestContext&quot;.</span></span><br><span class="line"><span class="meta">spring.freemarker.prefer-file-system-access</span>=<span class="string">true # Prefer file system access for template loading. File system access enables hot detection of template changes.</span></span><br><span class="line"><span class="meta">spring.freemarker.prefix</span>= <span class="string"># Prefix that gets prepended to view names when building a URL.</span></span><br><span class="line"><span class="meta">spring.freemarker.request-context-attribute</span>= <span class="string"># Name of the RequestContext attribute for all views.</span></span><br><span class="line"><span class="meta">spring.freemarker.settings.*</span>= <span class="string"># Well-known FreeMarker keys which will be passed to FreeMarker&#x27;s Configuration.</span></span><br><span class="line"><span class="meta">spring.freemarker.suffix</span>=<span class="string">.ftl # Suffix that gets appended to view names when building a URL.</span></span><br><span class="line"><span class="meta">spring.freemarker.template-loader-path</span>=<span class="string">classpath:/templates/ # Comma-separated list of template paths.</span></span><br><span class="line"><span class="meta">spring.freemarker.view-names</span>= <span class="string"># White list of view names that can be resolved.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GROOVY TEMPLATES (GroovyTemplateAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.groovy.template.allow-request-override</span>=<span class="string">false # Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.</span></span><br><span class="line"><span class="meta">spring.groovy.template.allow-session-override</span>=<span class="string">false # Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.</span></span><br><span class="line"><span class="meta">spring.groovy.template.cache</span>= <span class="string"># Enable template caching.</span></span><br><span class="line"><span class="meta">spring.groovy.template.charset</span>=<span class="string">UTF-8 # Template encoding.</span></span><br><span class="line"><span class="meta">spring.groovy.template.check-template-location</span>=<span class="string">true # Check that the templates location exists.</span></span><br><span class="line"><span class="meta">spring.groovy.template.configuration.*</span>= <span class="string"># See GroovyMarkupConfigurer</span></span><br><span class="line"><span class="meta">spring.groovy.template.content-type</span>=<span class="string">test/html # Content-Type value.</span></span><br><span class="line"><span class="meta">spring.groovy.template.enabled</span>=<span class="string">true # Enable MVC view resolution for this technology.</span></span><br><span class="line"><span class="meta">spring.groovy.template.expose-request-attributes</span>=<span class="string">false # Set whether all request attributes should be added to the model prior to merging with the template.</span></span><br><span class="line"><span class="meta">spring.groovy.template.expose-session-attributes</span>=<span class="string">false # Set whether all HttpSession attributes should be added to the model prior to merging with the template.</span></span><br><span class="line"><span class="meta">spring.groovy.template.expose-spring-macro-helpers</span>=<span class="string">true # Set whether to expose a RequestContext for use by Spring&#x27;s macro library, under the name &quot;springMacroRequestContext&quot;.</span></span><br><span class="line"><span class="meta">spring.groovy.template.prefix</span>= <span class="string"># Prefix that gets prepended to view names when building a URL.</span></span><br><span class="line"><span class="meta">spring.groovy.template.request-context-attribute</span>= <span class="string"># Name of the RequestContext attribute for all views.</span></span><br><span class="line"><span class="meta">spring.groovy.template.resource-loader-path</span>=<span class="string">classpath:/templates/ # Template path.</span></span><br><span class="line"><span class="meta">spring.groovy.template.suffix</span>=<span class="string">.tpl # Suffix that gets appended to view names when building a URL.</span></span><br><span class="line"><span class="meta">spring.groovy.template.view-names</span>= <span class="string"># White list of view names that can be resolved.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING HATEOAS (HateoasProperties)</span></span><br><span class="line"><span class="meta">spring.hateoas.use-hal-as-default-json-media-type</span>=<span class="string">true # Specify if application/hal+json responses should be sent to requests that accept application/json.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP message conversion</span></span><br><span class="line"><span class="meta">spring.http.converters.preferred-json-mapper</span>= <span class="string"># Preferred JSON mapper to use for HTTP message conversion, auto-detected according to the environment by default.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP encoding (HttpEncodingProperties)</span></span><br><span class="line"><span class="meta">spring.http.encoding.charset</span>=<span class="string">UTF-8 # Charset of HTTP requests and responses. Added to the &quot;Content-Type&quot; header if not set explicitly.</span></span><br><span class="line"><span class="meta">spring.http.encoding.enabled</span>=<span class="string">true # Enable http encoding support.</span></span><br><span class="line"><span class="meta">spring.http.encoding.force</span>= <span class="string"># Force the encoding to the configured charset on HTTP requests and responses.</span></span><br><span class="line"><span class="meta">spring.http.encoding.force-request</span>= <span class="string"># Force the encoding to the configured charset on HTTP requests. Defaults to true when &quot;force&quot; has not been specified.</span></span><br><span class="line"><span class="meta">spring.http.encoding.force-response</span>= <span class="string"># Force the encoding to the configured charset on HTTP responses.</span></span><br><span class="line"><span class="meta">spring.http.encoding.mapping</span>= <span class="string"># Locale to Encoding mapping.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MULTIPART (MultipartProperties)</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.enabled</span>=<span class="string">true # Enable support of multipart uploads.</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.file-size-threshold</span>=<span class="string">0 # Threshold after which files will be written to disk. Values can use the suffixes &quot;MB&quot; or &quot;KB&quot; to indicate megabytes or kilobytes respectively.</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.location</span>= <span class="string"># Intermediate location of uploaded files.</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.max-file-size</span>=<span class="string">1MB # Max file size. Values can use the suffixes &quot;MB&quot; or &quot;KB&quot; to indicate megabytes or kilobytes respectively.</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.max-request-size</span>=<span class="string">10MB # Max request size. Values can use the suffixes &quot;MB&quot; or &quot;KB&quot; to indicate megabytes or kilobytes respectively.</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.resolve-lazily</span>=<span class="string">false # Whether to resolve the multipart request lazily at the time of file or parameter access.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JACKSON (JacksonProperties)</span></span><br><span class="line"><span class="meta">spring.jackson.date-format</span>= <span class="string"># Date format string or a fully-qualified date format class name. For instance `yyyy-MM-dd HH:mm:ss`.</span></span><br><span class="line"><span class="meta">spring.jackson.default-property-inclusion</span>= <span class="string"># Controls the inclusion of properties during serialization.</span></span><br><span class="line"><span class="meta">spring.jackson.deserialization.*</span>= <span class="string"># Jackson on/off features that affect the way Java objects are deserialized.</span></span><br><span class="line"><span class="meta">spring.jackson.generator.*</span>= <span class="string"># Jackson on/off features for generators.</span></span><br><span class="line"><span class="meta">spring.jackson.joda-date-time-format</span>= <span class="string"># Joda date time format string. If not configured, &quot;date-format&quot; will be used as a fallback if it is configured with a format string.</span></span><br><span class="line"><span class="meta">spring.jackson.locale</span>= <span class="string"># Locale used for formatting.</span></span><br><span class="line"><span class="meta">spring.jackson.mapper.*</span>= <span class="string"># Jackson general purpose on/off features.</span></span><br><span class="line"><span class="meta">spring.jackson.parser.*</span>= <span class="string"># Jackson on/off features for parsers.</span></span><br><span class="line"><span class="meta">spring.jackson.property-naming-strategy</span>= <span class="string"># One of the constants on Jackson&#x27;s PropertyNamingStrategy. Can also be a fully-qualified class name of a PropertyNamingStrategy subclass.</span></span><br><span class="line"><span class="meta">spring.jackson.serialization.*</span>= <span class="string"># Jackson on/off features that affect the way Java objects are serialized.</span></span><br><span class="line"><span class="meta">spring.jackson.time-zone</span>= <span class="string"># Time zone used when formatting dates. For instance `America/Los_Angeles`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JERSEY (JerseyProperties)</span></span><br><span class="line"><span class="meta">spring.jersey.application-path</span>= <span class="string"># Path that serves as the base URI for the application. Overrides the value of &quot;@ApplicationPath&quot; if specified.</span></span><br><span class="line"><span class="meta">spring.jersey.filter.order</span>=<span class="string">0 # Jersey filter chain order.</span></span><br><span class="line"><span class="meta">spring.jersey.init.*</span>= <span class="string"># Init parameters to pass to Jersey via the servlet or filter.</span></span><br><span class="line"><span class="meta">spring.jersey.servlet.load-on-startup</span>=<span class="string">-1 # Load on startup priority of the Jersey servlet.</span></span><br><span class="line"><span class="meta">spring.jersey.type</span>=<span class="string">servlet # Jersey integration type.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">   # SPRING LDAP (LdapProperties)</span></span><br><span class="line">   <span class="meta">spring.ldap.urls</span>= <span class="string"># LDAP URLs of the server.</span></span><br><span class="line">   <span class="meta">spring.ldap.base</span>= <span class="string"># Base suffix from which all operations should originate.</span></span><br><span class="line">   <span class="meta">spring.ldap.username</span>= <span class="string"># Login user of the server.</span></span><br><span class="line">   <span class="meta">spring.ldap.password</span>= <span class="string"># Login password of the server.</span></span><br><span class="line">   <span class="meta">spring.ldap.base-environment.*</span>= <span class="string"># LDAP specification settings.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">   # EMBEDDED LDAP (EmbeddedLdapProperties)</span></span><br><span class="line">   <span class="meta">spring.ldap.embedded.base-dn</span>= <span class="string"># The base DN</span></span><br><span class="line">   <span class="meta">spring.ldap.embedded.credential.username</span>= <span class="string"># Embedded LDAP username.</span></span><br><span class="line">   <span class="meta">spring.ldap.embedded.credential.password</span>= <span class="string"># Embedded LDAP password.</span></span><br><span class="line">   <span class="meta">spring.ldap.embedded.ldif</span>=<span class="string">classpath:schema.ldif # Schema (LDIF) script resource reference.</span></span><br><span class="line">   <span class="meta">spring.ldap.embedded.port</span>= <span class="string"># Embedded LDAP port.</span></span><br><span class="line">   <span class="meta">spring.ldap.embedded.validation.enabled</span>=<span class="string">true # Enable LDAP schema validation.</span></span><br><span class="line">   <span class="meta">spring.ldap.embedded.validation.schema</span>= <span class="string"># Path to the custom schema.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING MOBILE DEVICE VIEWS (DeviceDelegatingViewResolverAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.mobile.devicedelegatingviewresolver.enable-fallback</span>=<span class="string">false # Enable support for fallback resolution.</span></span><br><span class="line"><span class="meta">spring.mobile.devicedelegatingviewresolver.enabled</span>=<span class="string">false # Enable device view resolver.</span></span><br><span class="line"><span class="meta">spring.mobile.devicedelegatingviewresolver.mobile-prefix</span>=<span class="string">mobile/ # Prefix that gets prepended to view names for mobile devices.</span></span><br><span class="line"><span class="meta">spring.mobile.devicedelegatingviewresolver.mobile-suffix</span>= <span class="string"># Suffix that gets appended to view names for mobile devices.</span></span><br><span class="line"><span class="meta">spring.mobile.devicedelegatingviewresolver.normal-prefix</span>= <span class="string"># Prefix that gets prepended to view names for normal devices.</span></span><br><span class="line"><span class="meta">spring.mobile.devicedelegatingviewresolver.normal-suffix</span>= <span class="string"># Suffix that gets appended to view names for normal devices.</span></span><br><span class="line"><span class="meta">spring.mobile.devicedelegatingviewresolver.tablet-prefix</span>=<span class="string">tablet/ # Prefix that gets prepended to view names for tablet devices.</span></span><br><span class="line"><span class="meta">spring.mobile.devicedelegatingviewresolver.tablet-suffix</span>= <span class="string"># Suffix that gets appended to view names for tablet devices.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING MOBILE SITE PREFERENCE (SitePreferenceAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.mobile.sitepreference.enabled</span>=<span class="string">true # Enable SitePreferenceHandler.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MUSTACHE TEMPLATES (MustacheAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.mustache.allow-request-override</span>= <span class="string"># Set whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.</span></span><br><span class="line"><span class="meta">spring.mustache.allow-session-override</span>= <span class="string"># Set whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.</span></span><br><span class="line"><span class="meta">spring.mustache.cache</span>= <span class="string"># Enable template caching.</span></span><br><span class="line"><span class="meta">spring.mustache.charset</span>= <span class="string"># Template encoding.</span></span><br><span class="line"><span class="meta">spring.mustache.check-template-location</span>= <span class="string"># Check that the templates location exists.</span></span><br><span class="line"><span class="meta">spring.mustache.content-type</span>= <span class="string"># Content-Type value.</span></span><br><span class="line"><span class="meta">spring.mustache.enabled</span>= <span class="string"># Enable MVC view resolution for this technology.</span></span><br><span class="line"><span class="meta">spring.mustache.expose-request-attributes</span>= <span class="string"># Set whether all request attributes should be added to the model prior to merging with the template.</span></span><br><span class="line"><span class="meta">spring.mustache.expose-session-attributes</span>= <span class="string"># Set whether all HttpSession attributes should be added to the model prior to merging with the template.</span></span><br><span class="line"><span class="meta">spring.mustache.expose-spring-macro-helpers</span>= <span class="string"># Set whether to expose a RequestContext for use by Spring&#x27;s macro library, under the name &quot;springMacroRequestContext&quot;.</span></span><br><span class="line"><span class="meta">spring.mustache.prefix</span>=<span class="string">classpath:/templates/ # Prefix to apply to template names.</span></span><br><span class="line"><span class="meta">spring.mustache.request-context-attribute</span>= <span class="string"># Name of the RequestContext attribute for all views.</span></span><br><span class="line"><span class="meta">spring.mustache.suffix</span>=<span class="string">.mustache # Suffix to apply to template names.</span></span><br><span class="line"><span class="meta">spring.mustache.view-names</span>= <span class="string"># White list of view names that can be resolved.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING MVC (WebMvcProperties)</span></span><br><span class="line"><span class="meta">spring.mvc.async.request-timeout</span>= <span class="string"># Amount of time (in milliseconds) before asynchronous request handling times out.</span></span><br><span class="line"><span class="meta">spring.mvc.date-format</span>= <span class="string"># Date format to use. For instance `dd/MM/yyyy`.</span></span><br><span class="line"><span class="meta">spring.mvc.dispatch-trace-request</span>=<span class="string">false # Dispatch TRACE requests to the FrameworkServlet doService method.</span></span><br><span class="line"><span class="meta">spring.mvc.dispatch-options-request</span>=<span class="string">true # Dispatch OPTIONS requests to the FrameworkServlet doService method.</span></span><br><span class="line"><span class="meta">spring.mvc.favicon.enabled</span>=<span class="string">true # Enable resolution of favicon.ico.</span></span><br><span class="line"><span class="meta">spring.mvc.formcontent.putfilter.enabled</span>=<span class="string">true # Enable Spring&#x27;s HttpPutFormContentFilter.</span></span><br><span class="line"><span class="meta">spring.mvc.ignore-default-model-on-redirect</span>=<span class="string">true # If the content of the &quot;default&quot; model should be ignored during redirect scenarios.</span></span><br><span class="line"><span class="meta">spring.mvc.locale</span>= <span class="string"># Locale to use. By default, this locale is overridden by the &quot;Accept-Language&quot; header.</span></span><br><span class="line"><span class="meta">spring.mvc.locale-resolver</span>=<span class="string">accept-header # Define how the locale should be resolved.</span></span><br><span class="line"><span class="meta">spring.mvc.log-resolved-exception</span>=<span class="string">false # Enable warn logging of exceptions resolved by a &quot;HandlerExceptionResolver&quot;.</span></span><br><span class="line"><span class="meta">spring.mvc.media-types.*</span>= <span class="string"># Maps file extensions to media types for content negotiation.</span></span><br><span class="line"><span class="meta">spring.mvc.message-codes-resolver-format</span>= <span class="string"># Formatting strategy for message codes. For instance `PREFIX_ERROR_CODE`.</span></span><br><span class="line"><span class="meta">spring.mvc.servlet.load-on-startup</span>=<span class="string">-1 # Load on startup priority of the Spring Web Services servlet.</span></span><br><span class="line"><span class="meta">spring.mvc.static-path-pattern</span>=<span class="string">/** # Path pattern used for static resources.</span></span><br><span class="line"><span class="meta">spring.mvc.throw-exception-if-no-handler-found</span>=<span class="string">false # If a &quot;NoHandlerFoundException&quot; should be thrown if no Handler was found to process a request.</span></span><br><span class="line"><span class="meta">spring.mvc.view.prefix</span>= <span class="string"># Spring MVC view prefix.</span></span><br><span class="line"><span class="meta">spring.mvc.view.suffix</span>= <span class="string"># Spring MVC view suffix.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING RESOURCES HANDLING (ResourceProperties)</span></span><br><span class="line"><span class="meta">spring.resources.add-mappings</span>=<span class="string">true # Enable default resource handling.</span></span><br><span class="line"><span class="meta">spring.resources.cache-period</span>= <span class="string"># Cache period for the resources served by the resource handler, in seconds.</span></span><br><span class="line"><span class="meta">spring.resources.chain.cache</span>=<span class="string">true # Enable caching in the Resource chain.</span></span><br><span class="line"><span class="meta">spring.resources.chain.enabled</span>= <span class="string"># Enable the Spring Resource Handling chain. Disabled by default unless at least one strategy has been enabled.</span></span><br><span class="line"><span class="meta">spring.resources.chain.gzipped</span>=<span class="string">false # Enable resolution of already gzipped resources.</span></span><br><span class="line"><span class="meta">spring.resources.chain.html-application-cache</span>=<span class="string">false # Enable HTML5 application cache manifest rewriting.</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.content.enabled</span>=<span class="string">false # Enable the content Version Strategy.</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.content.paths</span>=<span class="string">/** # Comma-separated list of patterns to apply to the Version Strategy.</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.fixed.enabled</span>=<span class="string">false # Enable the fixed Version Strategy.</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.fixed.paths</span>=<span class="string">/** # Comma-separated list of patterns to apply to the Version Strategy.</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.fixed.version</span>= <span class="string"># Version string to use for the Version Strategy.</span></span><br><span class="line"><span class="meta">spring.resources.static-locations</span>=<span class="string">classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ # Locations of static resources.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING SESSION (SessionProperties)</span></span><br><span class="line"><span class="meta">spring.session.store-type</span>= <span class="string"># Session store type.</span></span><br><span class="line"><span class="meta">spring.session.servlet.filter-order</span>=<span class="string">-2147483598 # Session repository filter order.</span></span><br><span class="line"><span class="meta">spring.session.servlet.filter-dispatcher-types</span>=<span class="string">ASYNC,ERROR,REQUEST # Session repository filter dispatcher types.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING SESSION HAZELCAST (HazelcastSessionProperties)</span></span><br><span class="line"><span class="meta">spring.session.hazelcast.flush-mode</span>=<span class="string">on-save # Sessions flush mode.</span></span><br><span class="line"><span class="meta">spring.session.hazelcast.map-name</span>=<span class="string">spring:session:sessions # Name of the map used to store sessions.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING SESSION JDBC (JdbcSessionProperties)</span></span><br><span class="line"><span class="meta">spring.session.jdbc.initialize-schema</span>=<span class="string">embedded # Database schema initialization mode.</span></span><br><span class="line"><span class="meta">spring.session.jdbc.schema</span>=<span class="string">classpath:org/springframework/session/jdbc/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.</span></span><br><span class="line"><span class="meta">spring.session.jdbc.table-name</span>=<span class="string">SPRING_SESSION # Name of database table used to store sessions.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING SESSION MONGODB (MongoSessionProperties)</span></span><br><span class="line"><span class="meta">spring.session.mongodb.collection-name</span>=<span class="string">sessions # Collection name used to store sessions.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING SESSION REDIS (RedisSessionProperties)</span></span><br><span class="line"><span class="meta">spring.session.redis.flush-mode</span>=<span class="string">on-save # Sessions flush mode.</span></span><br><span class="line"><span class="meta">spring.session.redis.namespace</span>= <span class="string"># Namespace for keys used to store sessions.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING SOCIAL (SocialWebAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.social.auto-connection-views</span>=<span class="string">false # Enable the connection status view for supported providers.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING SOCIAL FACEBOOK (FacebookAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.social.facebook.app-id</span>= <span class="string"># your application&#x27;s Facebook App ID</span></span><br><span class="line"><span class="meta">spring.social.facebook.app-secret</span>= <span class="string"># your application&#x27;s Facebook App Secret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING SOCIAL LINKEDIN (LinkedInAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.social.linkedin.app-id</span>= <span class="string"># your application&#x27;s LinkedIn App ID</span></span><br><span class="line"><span class="meta">spring.social.linkedin.app-secret</span>= <span class="string"># your application&#x27;s LinkedIn App Secret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING SOCIAL TWITTER (TwitterAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.social.twitter.app-id</span>= <span class="string"># your application&#x27;s Twitter App ID</span></span><br><span class="line"><span class="meta">spring.social.twitter.app-secret</span>= <span class="string"># your application&#x27;s Twitter App Secret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># THYMELEAF (ThymeleafAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.thymeleaf.cache</span>=<span class="string">true # Enable template caching.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.check-template</span>=<span class="string">true # Check that the template exists before rendering it.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.check-template-location</span>=<span class="string">true # Check that the templates location exists.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.enabled</span>=<span class="string">true # Enable Thymeleaf view resolution for Web frameworks.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.encoding</span>=<span class="string">UTF-8 # Template files encoding.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.excluded-view-names</span>= <span class="string"># Comma-separated list of view names that should be excluded from resolution.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.mode</span>=<span class="string">HTML5 # Template mode to be applied to templates. See also StandardTemplateModeHandlers.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.prefix</span>=<span class="string">classpath:/templates/ # Prefix that gets prepended to view names when building a URL.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.reactive.max-chunk-size</span>= <span class="string"># Maximum size of data buffers used for writing to the response, in bytes.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.reactive.media-types</span>= <span class="string"># Media types supported by the view technology.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.servlet.content-type</span>=<span class="string">text/html # Content-Type value written to HTTP responses.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.suffix</span>=<span class="string">.html # Suffix that gets appended to view names when building a URL.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.template-resolver-order</span>= <span class="string"># Order of the template resolver in the chain.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.view-names</span>= <span class="string"># Comma-separated list of view names that can be resolved.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING WEB FLUX (WebFluxProperties)</span></span><br><span class="line"><span class="meta">spring.webflux.static-path-pattern</span>=<span class="string">/** # Path pattern used for static resources.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING WEB SERVICES (WebServicesProperties)</span></span><br><span class="line"><span class="meta">spring.webservices.path</span>=<span class="string">/services # Path that serves as the base URI for the services.</span></span><br><span class="line"><span class="meta">spring.webservices.servlet.init</span>= <span class="string"># Servlet init parameters to pass to Spring Web Services.</span></span><br><span class="line"><span class="meta">spring.webservices.servlet.load-on-startup</span>=<span class="string">-1 # Load on startup priority of the Spring Web Services servlet.</span></span><br><span class="line"><span class="meta">spring.webservices.wsdl-locations</span>= <span class="string"># Comma-separated list of locations of WSDLs and accompanying XSDs to be exposed as beans.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># SECURITY PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># SECURITY (SecurityProperties)</span></span><br><span class="line"><span class="meta">spring.security.filter.order</span>=<span class="string">0 # Security filter chain order.</span></span><br><span class="line"><span class="meta">spring.security.filter.dispatcher-types</span>=<span class="string">ASYNC,ERROR,REQUEST # Security filter chain dispatcher types.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SECURITY OAUTH2 CLIENT (OAuth2ClientProperties)</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.*</span>= <span class="string"># OAuth provider details.</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.*</span>= <span class="string"># OAuth client registrations.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># DATA PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FLYWAY (FlywayProperties)</span></span><br><span class="line"><span class="meta">spring.flyway.allow-mixed-migrations</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.baseline-description</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.baseline-on-migrate</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.baseline-version</span>=<span class="string">1 # version to start migration</span></span><br><span class="line"><span class="meta">spring.flyway.check-location</span>=<span class="string">false # Check that migration scripts location exists.</span></span><br><span class="line"><span class="meta">spring.flyway.clean-disabled</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.clean-on-validation-error</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.enabled</span>=<span class="string">true # Enable flyway.</span></span><br><span class="line"><span class="meta">spring.flyway.encoding</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.group</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.ignore-failed-future-migration</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.ignore-future-migrations</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.ignore-missing-migrations</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.init-sqls</span>= <span class="string"># SQL statements to execute to initialize a connection immediately after obtaining it.</span></span><br><span class="line"><span class="meta">spring.flyway.installed-by</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.locations</span>=<span class="string">classpath:db/migration # locations of migrations scripts</span></span><br><span class="line"><span class="meta">spring.flyway.mixed</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.out-of-order</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.password</span>= <span class="string"># JDBC password if you want Flyway to create its own DataSource</span></span><br><span class="line"><span class="meta">spring.flyway.placeholder-prefix</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.placeholder-replacement</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.placeholder-suffix</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.placeholders.*</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.repeatable-sql-migration-prefix</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.schemas</span>= <span class="string"># schemas to update</span></span><br><span class="line"><span class="meta">spring.flyway.skip-default-callbacks</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.skip-default-resolvers</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.sql-migration-prefix</span>=<span class="string">V #</span></span><br><span class="line"><span class="meta">spring.flyway.sql-migration-separator</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.sql-migration-suffix</span>=<span class="string">.sql #</span></span><br><span class="line"><span class="meta">spring.flyway.table</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.target</span>= <span class="string">#</span></span><br><span class="line"><span class="meta">spring.flyway.url</span>= <span class="string"># JDBC url of the database to migrate. If not set, the primary configured data source is used.</span></span><br><span class="line"><span class="meta">spring.flyway.user</span>= <span class="string"># Login user of the database to migrate.</span></span><br><span class="line"><span class="meta">spring.flyway.validate-on-migrate</span>= <span class="string">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LIQUIBASE (LiquibaseProperties)</span></span><br><span class="line"><span class="meta">spring.liquibase.change-log</span>=<span class="string">classpath:/db/changelog/db.changelog-master.yaml # Change log configuration path.</span></span><br><span class="line"><span class="meta">spring.liquibase.check-change-log-location</span>=<span class="string">true # Check the change log location exists.</span></span><br><span class="line"><span class="meta">spring.liquibase.contexts</span>= <span class="string"># Comma-separated list of runtime contexts to use.</span></span><br><span class="line"><span class="meta">spring.liquibase.default-schema</span>= <span class="string"># Default database schema.</span></span><br><span class="line"><span class="meta">spring.liquibase.drop-first</span>=<span class="string">false # Drop the database schema first.</span></span><br><span class="line"><span class="meta">spring.liquibase.enabled</span>=<span class="string">true # Enable liquibase support.</span></span><br><span class="line"><span class="meta">spring.liquibase.labels</span>= <span class="string"># Comma-separated list of runtime labels to use.</span></span><br><span class="line"><span class="meta">spring.liquibase.parameters.*</span>= <span class="string"># Change log parameters.</span></span><br><span class="line"><span class="meta">spring.liquibase.password</span>= <span class="string"># Login password of the database to migrate.</span></span><br><span class="line"><span class="meta">spring.liquibase.rollback-file</span>= <span class="string"># File to which rollback SQL will be written when an update is performed.</span></span><br><span class="line"><span class="meta">spring.liquibase.url</span>= <span class="string"># JDBC url of the database to migrate. If not set, the primary configured data source is used.</span></span><br><span class="line"><span class="meta">spring.liquibase.user</span>= <span class="string"># Login user of the database to migrate.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># COUCHBASE (CouchbaseProperties)</span></span><br><span class="line"><span class="meta">spring.couchbase.bootstrap-hosts</span>= <span class="string"># Couchbase nodes (host or IP address) to bootstrap from.</span></span><br><span class="line"><span class="meta">spring.couchbase.bucket.name</span>=<span class="string">default # Name of the bucket to connect to.</span></span><br><span class="line"><span class="meta">spring.couchbase.bucket.password</span>=  <span class="string"># Password of the bucket.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.endpoints.key-value</span>=<span class="string">1 # Number of sockets per node against the Key/value service.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.endpoints.query</span>=<span class="string">1 # Number of sockets per node against the Query (N1QL) service.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.endpoints.view</span>=<span class="string">1 # Number of sockets per node against the view service.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.ssl.enabled</span>= <span class="string"># Enable SSL support. Enabled automatically if a &quot;keyStore&quot; is provided unless specified otherwise.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.ssl.key-store</span>= <span class="string"># Path to the JVM key store that holds the certificates.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.ssl.key-store-password</span>= <span class="string"># Password used to access the key store.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.timeouts.connect</span>=<span class="string">5000 # Bucket connections timeout in milliseconds.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.timeouts.key-value</span>=<span class="string">2500 # Blocking operations performed on a specific key timeout in milliseconds.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.timeouts.query</span>=<span class="string">7500 # N1QL query operations timeout in milliseconds.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.timeouts.socket-connect</span>=<span class="string">1000 # Socket connect connections timeout in milliseconds.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.timeouts.view</span>=<span class="string">7500 # Regular and geospatial view operations timeout in milliseconds.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DAO (PersistenceExceptionTranslationAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.dao.exceptiontranslation.enabled</span>=<span class="string">true # Enable the PersistenceExceptionTranslationPostProcessor.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CASSANDRA (CassandraProperties)</span></span><br><span class="line"><span class="meta">spring.data.cassandra.cluster-name</span>= <span class="string"># Name of the Cassandra cluster.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.compression</span>=<span class="string">none # Compression supported by the Cassandra binary protocol.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.connect-timeout-millis</span>= <span class="string"># Socket option: connection time out.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.consistency-level</span>= <span class="string"># Queries consistency level.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.contact-points</span>=<span class="string">localhost # Comma-separated list of cluster node addresses.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.fetch-size</span>= <span class="string"># Queries default fetch size.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.keyspace-name</span>= <span class="string"># Keyspace name to use.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.load-balancing-policy</span>= <span class="string"># Class name of the load balancing policy.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.port</span>= <span class="string"># Port of the Cassandra server.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.password</span>= <span class="string"># Login password of the server.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.pool.heartbeat-interval</span>=<span class="string">30 # Heartbeat interval (in seconds) after which a message is sent on an idle connection to make sure it&#x27;s still alive.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.pool.idle-timeout</span>=<span class="string">120 # Idle timeout (in seconds) before an idle connection is removed.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.pool.max-queue-size</span>=<span class="string">256 # Maximum number of requests that get enqueued if no connection is available.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.pool.pool-timeout</span>=<span class="string">5000 # Pool timeout (in milliseconds) when trying to acquire a connection from a host&#x27;s pool.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.reactive-repositories.enabled</span>=<span class="string">true # Enable Cassandra reactive repositories.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.read-timeout-millis</span>= <span class="string"># Socket option: read time out.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.reconnection-policy</span>= <span class="string"># Reconnection policy class.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.repositories.enabled</span>= <span class="string"># Enable Cassandra repositories.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.retry-policy</span>= <span class="string"># Class name of the retry policy.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.serial-consistency-level</span>= <span class="string"># Queries serial consistency level.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.schema-action</span>=<span class="string">none # Schema action to take at startup.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.ssl</span>=<span class="string">false # Enable SSL support.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.username</span>= <span class="string"># Login user of the server.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DATA COUCHBASE (CouchbaseDataProperties)</span></span><br><span class="line"><span class="meta">spring.data.couchbase.auto-index</span>=<span class="string">false # Automatically create views and indexes.</span></span><br><span class="line"><span class="meta">spring.data.couchbase.consistency</span>=<span class="string">read-your-own-writes # Consistency to apply by default on generated queries.</span></span><br><span class="line"><span class="meta">spring.data.couchbase.repositories.enabled</span>=<span class="string">true # Enable Couchbase repositories.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ELASTICSEARCH (ElasticsearchProperties)</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.cluster-name</span>=<span class="string">elasticsearch # Elasticsearch cluster name.</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.cluster-nodes</span>= <span class="string"># Comma-separated list of cluster node addresses.</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.properties.*</span>= <span class="string"># Additional properties used to configure the client.</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.repositories.enabled</span>=<span class="string">true # Enable Elasticsearch repositories.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DATA LDAP</span></span><br><span class="line"><span class="meta">spring.data.ldap.repositories.enabled</span>=<span class="string">true # Enable LDAP repositories.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MONGODB (MongoProperties)</span></span><br><span class="line"><span class="meta">spring.data.mongodb.authentication-database</span>= <span class="string"># Authentication database name.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.database</span>=<span class="string">test # Database name.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.field-naming-strategy</span>= <span class="string"># Fully qualified name of the FieldNamingStrategy to use.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.grid-fs-database</span>= <span class="string"># GridFS database name.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.host</span>=<span class="string">localhost # Mongo server host. Cannot be set with uri.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.password</span>= <span class="string"># Login password of the mongo server. Cannot be set with uri.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.port</span>=<span class="string">27017 # Mongo server port. Cannot be set with uri.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.reactive-repositories.enabled</span>=<span class="string">true # Enable Mongo reactive repositories.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.repositories.enabled</span>=<span class="string">true # Enable Mongo repositories.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.uri</span>=<span class="string">mongodb://localhost/test # Mongo database URI. Cannot be set with host, port and credentials.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.username</span>= <span class="string"># Login user of the mongo server. Cannot be set with uri.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DATA REDIS</span></span><br><span class="line"><span class="meta">spring.data.redis.repositories.enabled</span>=<span class="string">true # Enable Redis repositories.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NEO4J (Neo4jProperties)</span></span><br><span class="line"><span class="meta">spring.data.neo4j.auto-index</span>=<span class="string">none # Auto index mode.</span></span><br><span class="line"><span class="meta">spring.data.neo4j.embedded.enabled</span>=<span class="string">true # Enable embedded mode if the embedded driver is available.</span></span><br><span class="line"><span class="meta">spring.data.neo4j.open-in-view</span>=<span class="string">false # Register OpenSessionInViewInterceptor. Binds a Neo4j Session to the thread for the entire processing of the request.</span></span><br><span class="line"><span class="meta">spring.data.neo4j.password</span>= <span class="string"># Login password of the server.</span></span><br><span class="line"><span class="meta">spring.data.neo4j.repositories.enabled</span>=<span class="string">true # Enable Neo4j repositories.</span></span><br><span class="line"><span class="meta">spring.data.neo4j.uri</span>= <span class="string"># URI used by the driver. Auto-detected by default.</span></span><br><span class="line"><span class="meta">spring.data.neo4j.username</span>= <span class="string"># Login user of the server.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DATA REST (RepositoryRestProperties)</span></span><br><span class="line"><span class="meta">spring.data.rest.base-path</span>= <span class="string"># Base path to be used by Spring Data REST to expose repository resources.</span></span><br><span class="line"><span class="meta">spring.data.rest.default-page-size</span>= <span class="string"># Default size of pages.</span></span><br><span class="line"><span class="meta">spring.data.rest.detection-strategy</span>=<span class="string">default # Strategy to use to determine which repositories get exposed.</span></span><br><span class="line"><span class="meta">spring.data.rest.enable-enum-translation</span>= <span class="string"># Enable enum value translation via the Spring Data REST default resource bundle.</span></span><br><span class="line"><span class="meta">spring.data.rest.limit-param-name</span>= <span class="string"># Name of the URL query string parameter that indicates how many results to return at once.</span></span><br><span class="line"><span class="meta">spring.data.rest.max-page-size</span>= <span class="string"># Maximum size of pages.</span></span><br><span class="line"><span class="meta">spring.data.rest.page-param-name</span>= <span class="string"># Name of the URL query string parameter that indicates what page to return.</span></span><br><span class="line"><span class="meta">spring.data.rest.return-body-on-create</span>= <span class="string"># Return a response body after creating an entity.</span></span><br><span class="line"><span class="meta">spring.data.rest.return-body-on-update</span>= <span class="string"># Return a response body after updating an entity.</span></span><br><span class="line"><span class="meta">spring.data.rest.sort-param-name</span>= <span class="string"># Name of the URL query string parameter that indicates what direction to sort results.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SOLR (SolrProperties)</span></span><br><span class="line"><span class="meta">spring.data.solr.host</span>=<span class="string">http://127.0.0.1:8983/solr # Solr host. Ignored if &quot;zk-host&quot; is set.</span></span><br><span class="line"><span class="meta">spring.data.solr.repositories.enabled</span>=<span class="string">true # Enable Solr repositories.</span></span><br><span class="line"><span class="meta">spring.data.solr.zk-host</span>= <span class="string"># ZooKeeper host address in the form HOST:PORT.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DATA WEB (SpringDataWebProperties)</span></span><br><span class="line"><span class="meta">spring.data.web.pageable.default-page-size</span>=<span class="string">20 # Default page size.</span></span><br><span class="line"><span class="meta">spring.data.web.pageable.page-parameter</span>=<span class="string">page # Page index parameter name.</span></span><br><span class="line"><span class="meta">spring.data.web.pageable.size-parameter</span>=<span class="string">size # Page size parameter name.</span></span><br><span class="line"><span class="meta">spring.data.web.sort.sort-parameter</span>=<span class="string">sort # Sort parameter name.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)</span></span><br><span class="line"><span class="meta">spring.datasource.continue-on-error</span>=<span class="string">false # Do not stop if an error occurs while initializing the database.</span></span><br><span class="line"><span class="meta">spring.datasource.data</span>= <span class="string"># Data (DML) script resource references.</span></span><br><span class="line"><span class="meta">spring.datasource.data-username</span>= <span class="string"># User of the database to execute DML scripts (if different).</span></span><br><span class="line"><span class="meta">spring.datasource.data-password</span>= <span class="string"># Password of the database to execute DML scripts (if different).</span></span><br><span class="line"><span class="meta">spring.datasource.dbcp2.*</span>= <span class="string"># Commons DBCP2 specific settings</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>= <span class="string"># Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.</span></span><br><span class="line"><span class="meta">spring.datasource.generate-unique-name</span>=<span class="string">false # Generate a random datasource name.</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.*</span>= <span class="string"># Hikari specific settings</span></span><br><span class="line"><span class="meta">spring.datasource.initialize</span>=<span class="string">true # Populate the database using &#x27;data.sql&#x27;.</span></span><br><span class="line"><span class="meta">spring.datasource.jmx-enabled</span>=<span class="string">false # Enable JMX support (if provided by the underlying pool).</span></span><br><span class="line"><span class="meta">spring.datasource.jndi-name</span>= <span class="string"># JNDI location of the datasource. Class, url, username &amp; password are ignored when set.</span></span><br><span class="line"><span class="meta">spring.datasource.name</span>=<span class="string">testdb # Name of the datasource.</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>= <span class="string"># Login password of the database.</span></span><br><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">all # Platform to use in the DDL or DML scripts (e.g. schema-$&#123;platform&#125;.sql or data-$&#123;platform&#125;.sql).</span></span><br><span class="line"><span class="meta">spring.datasource.schema</span>= <span class="string"># Schema (DDL) script resource references.</span></span><br><span class="line"><span class="meta">spring.datasource.schema-username</span>= <span class="string"># User of the database to execute DDL scripts (if different).</span></span><br><span class="line"><span class="meta">spring.datasource.schema-password</span>= <span class="string"># Password of the database to execute DDL scripts (if different).</span></span><br><span class="line"><span class="meta">spring.datasource.separator</span>=<span class="string">; # Statement separator in SQL initialization scripts.</span></span><br><span class="line"><span class="meta">spring.datasource.sql-script-encoding</span>= <span class="string"># SQL scripts encoding.</span></span><br><span class="line"><span class="meta">spring.datasource.tomcat.*</span>= <span class="string"># Tomcat datasource specific settings</span></span><br><span class="line"><span class="meta">spring.datasource.type</span>= <span class="string"># Fully qualified name of the connection pool implementation to use. By default, it is auto-detected from the classpath.</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>= <span class="string"># JDBC url of the database.</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>= <span class="string"># Login user of the database.</span></span><br><span class="line"><span class="meta">spring.datasource.xa.data-source-class-name</span>= <span class="string"># XA datasource fully qualified name.</span></span><br><span class="line">   <span class="meta">spring.datasource.xa.properties</span>= <span class="string"># Properties to pass to the XA data source.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JEST (Elasticsearch HTTP client) (JestProperties)</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.connection-timeout</span>=<span class="string">3000 # Connection timeout in milliseconds.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.multi-threaded</span>=<span class="string">true # Enable connection requests from multiple execution threads.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.password</span>= <span class="string"># Login password.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.proxy.host</span>= <span class="string"># Proxy host the HTTP client should use.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.proxy.port</span>= <span class="string"># Proxy port the HTTP client should use.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.read-timeout</span>=<span class="string">3000 # Read timeout in milliseconds.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.uris</span>=<span class="string">http://localhost:9200 # Comma-separated list of the Elasticsearch instances to use.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.username</span>= <span class="string"># Login user.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># H2 Web Console (H2ConsoleProperties)</span></span><br><span class="line"><span class="meta">spring.h2.console.enabled</span>=<span class="string">false # Enable the console.</span></span><br><span class="line"><span class="meta">spring.h2.console.path</span>=<span class="string">/h2-console # Path at which the console will be available.</span></span><br><span class="line"><span class="meta">spring.h2.console.settings.trace</span>=<span class="string">false # Enable trace output.</span></span><br><span class="line"><span class="meta">spring.h2.console.settings.web-allow-others</span>=<span class="string">false # Enable remote access.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># InfluxDB (InfluxDbProperties)</span></span><br><span class="line"><span class="meta">spring.influx.password</span>= <span class="string"># Login password.</span></span><br><span class="line"><span class="meta">spring.influx.url</span>= <span class="string"># Url of the InfluxDB instance to connect to.</span></span><br><span class="line"><span class="meta">spring.influx.user</span>= <span class="string"># Login user.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JOOQ (JooqAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.jooq.sql-dialect</span>= <span class="string"># Sql dialect to use, auto-detected by default.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JDBC (JdbcProperties)</span></span><br><span class="line"><span class="meta">spring.jdbc.template.fetch-size</span>=<span class="string">-1 # Number of rows that should be fetched from the database when more rows are needed.</span></span><br><span class="line"><span class="meta">spring.jdbc.template.max-rows</span>=<span class="string">-1 # Maximum number of rows.</span></span><br><span class="line"><span class="meta">spring.jdbc.template.query-timeout</span>=<span class="string">-1 # Query timeout in seconds.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.data.jpa.repositories.enabled</span>=<span class="string">true # Enable JPA repositories.</span></span><br><span class="line"><span class="meta">spring.jpa.database</span>= <span class="string"># Target database to operate on, auto-detected by default. Can be alternatively set using the &quot;databasePlatform&quot; property.</span></span><br><span class="line"><span class="meta">spring.jpa.database-platform</span>= <span class="string"># Name of the target database to operate on, auto-detected by default. Can be alternatively set using the &quot;Database&quot; enum.</span></span><br><span class="line"><span class="meta">spring.jpa.generate-ddl</span>=<span class="string">false # Initialize the schema on startup.</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.ddl-auto</span>= <span class="string"># DDL mode. This is actually a shortcut for the &quot;hibernate.hbm2ddl.auto&quot; property. Default to &quot;create-drop&quot; when using an embedded database and no schema manager was detected, &quot;none&quot; otherwise.</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.naming.implicit-strategy</span>= <span class="string"># Hibernate 5 implicit naming strategy fully qualified name.</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.naming.physical-strategy</span>= <span class="string"># Hibernate 5 physical naming strategy fully qualified name.</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.use-new-id-generator-mappings</span>= <span class="string"># Use Hibernate&#x27;s newer IdentifierGenerator for AUTO, TABLE and SEQUENCE.</span></span><br><span class="line"><span class="meta">spring.jpa.open-in-view</span>=<span class="string">true # Register OpenEntityManagerInViewInterceptor. Binds a JPA EntityManager to the thread for the entire processing of the request.</span></span><br><span class="line"><span class="meta">spring.jpa.properties.*</span>= <span class="string"># Additional native properties to set on the JPA provider.</span></span><br><span class="line"><span class="meta">spring.jpa.show-sql</span>=<span class="string">false # Enable logging of SQL statements.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JTA (JtaAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.jta.enabled</span>=<span class="string">true # Enable JTA support.</span></span><br><span class="line"><span class="meta">spring.jta.log-dir</span>= <span class="string"># Transaction logs directory.</span></span><br><span class="line"><span class="meta">spring.jta.transaction-manager-id</span>= <span class="string"># Transaction manager unique identifier.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ATOMIKOS (AtomikosProperties)</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.borrow-connection-timeout</span>=<span class="string">30 # Timeout, in seconds, for borrowing connections from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.ignore-session-transacted-flag</span>=<span class="string">true # Whether or not to ignore the transacted flag when creating session.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.local-transaction-mode</span>=<span class="string">false # Whether or not local transactions are desired.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.maintenance-interval</span>=<span class="string">60 # The time, in seconds, between runs of the pool&#x27;s maintenance thread.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.max-idle-time</span>=<span class="string">60 # The time, in seconds, after which connections are cleaned up from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.max-lifetime</span>=<span class="string">0 # The time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.max-pool-size</span>=<span class="string">1 # The maximum size of the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.min-pool-size</span>=<span class="string">1 # The minimum size of the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.reap-timeout</span>=<span class="string">0 # The reap timeout, in seconds, for borrowed connections. 0 denotes no limit.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.unique-resource-name</span>=<span class="string">jmsConnectionFactory # The unique name used to identify the resource during recovery.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.borrow-connection-timeout</span>=<span class="string">30 # Timeout, in seconds, for borrowing connections from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.default-isolation-level</span>= <span class="string"># Default isolation level of connections provided by the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.login-timeout</span>= <span class="string"># Timeout, in seconds, for establishing a database connection.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.maintenance-interval</span>=<span class="string">60 # The time, in seconds, between runs of the pool&#x27;s maintenance thread.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.max-idle-time</span>=<span class="string">60 # The time, in seconds, after which connections are cleaned up from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.max-lifetime</span>=<span class="string">0 # The time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.max-pool-size</span>=<span class="string">1 # The maximum size of the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.min-pool-size</span>=<span class="string">1 # The minimum size of the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.reap-timeout</span>=<span class="string">0 # The reap timeout, in seconds, for borrowed connections. 0 denotes no limit.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.test-query</span>= <span class="string"># SQL query or statement used to validate a connection before returning it.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.unique-resource-name</span>=<span class="string">dataSource # The unique name used to identify the resource during recovery.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.allow-sub-transactions</span>=<span class="string">true # Specify if sub-transactions are allowed.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.checkpoint-interval</span>=<span class="string">500 # Interval between checkpoints.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.default-jta-timeout</span>=<span class="string">10000 # Default timeout for JTA transactions.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.enable-logging</span>=<span class="string">true # Enable disk logging.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.force-shutdown-on-vm-exit</span>=<span class="string">false # Specify if a VM shutdown should trigger forced shutdown of the transaction core.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.log-base-dir</span>= <span class="string"># Directory in which the log files should be stored.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.log-base-name</span>=<span class="string">tmlog # Transactions log file base name.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.max-actives</span>=<span class="string">50 # Maximum number of active transactions.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.max-timeout</span>=<span class="string">300000 # Maximum timeout (in milliseconds) that can be allowed for transactions.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.recovery.delay</span>=<span class="string">10000 # Delay between two recovery scans.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.recovery.forget-orphaned-log-entries-delay</span>=<span class="string">86400000 # Delay after which recovery can cleanup pending (&#x27;orphaned&#x27;) log entries.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.recovery.max-retries</span>=<span class="string">5 # Number of retry attempts to commit the transaction before throwing an exception.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.recovery.retry-interval</span>=<span class="string">10000 # Delay between retry attempts.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.serial-jta-transactions</span>=<span class="string">true # Specify if sub-transactions should be joined when possible.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.service</span>= <span class="string"># Transaction manager implementation that should be started.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.threaded-two-phase-commit</span>=<span class="string">false # Use different (and concurrent) threads for two-phase commit on the participating resources.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.transaction-manager-unique-name</span>= <span class="string"># Transaction manager&#x27;s unique name.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BITRONIX</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.acquire-increment</span>=<span class="string">1 # Number of connections to create when growing the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.acquisition-interval</span>=<span class="string">1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.acquisition-timeout</span>=<span class="string">30 # Timeout, in seconds, for acquiring connections from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.allow-local-transactions</span>=<span class="string">true # Whether or not the transaction manager should allow mixing XA and non-XA transactions.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.apply-transaction-timeout</span>=<span class="string">false # Whether or not the transaction timeout should be set on the XAResource when it is enlisted.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.automatic-enlisting-enabled</span>=<span class="string">true # Whether or not resources should be enlisted and delisted automatically.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.cache-producers-consumers</span>=<span class="string">true # Whether or not produces and consumers should be cached.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.defer-connection-release</span>=<span class="string">true # Whether or not the provider can run many transactions on the same connection and supports transaction interleaving.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.ignore-recovery-failures</span>=<span class="string">false # Whether or not recovery failures should be ignored.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.max-idle-time</span>=<span class="string">60 # The time, in seconds, after which connections are cleaned up from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.max-pool-size</span>=<span class="string">10 # The maximum size of the pool. 0 denotes no limit.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.min-pool-size</span>=<span class="string">0 # The minimum size of the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.password</span>= <span class="string"># The password to use to connect to the JMS provider.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.share-transaction-connections</span>=<span class="string">false #  Whether or not connections in the ACCESSIBLE state can be shared within the context of a transaction.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.test-connections</span>=<span class="string">true # Whether or not connections should be tested when acquired from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.two-pc-ordering-position</span>=<span class="string">1 # The position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, always last is Integer.MAX_VALUE).</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.unique-name</span>=<span class="string">jmsConnectionFactory # The unique name used to identify the resource during recovery.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.use-tm-join</span>=<span class="string">true Whether or not TMJOIN should be used when starting XAResources.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.user</span>= <span class="string"># The user to use to connect to the JMS provider.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.acquire-increment</span>=<span class="string">1 # Number of connections to create when growing the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.acquisition-interval</span>=<span class="string">1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.acquisition-timeout</span>=<span class="string">30 # Timeout, in seconds, for acquiring connections from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.allow-local-transactions</span>=<span class="string">true # Whether or not the transaction manager should allow mixing XA and non-XA transactions.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.apply-transaction-timeout</span>=<span class="string">false # Whether or not the transaction timeout should be set on the XAResource when it is enlisted.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.automatic-enlisting-enabled</span>=<span class="string">true # Whether or not resources should be enlisted and delisted automatically.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.cursor-holdability</span>= <span class="string"># The default cursor holdability for connections.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.defer-connection-release</span>=<span class="string">true # Whether or not the database can run many transactions on the same connection and supports transaction interleaving.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.enable-jdbc4-connection-test</span>= <span class="string"># Whether or not Connection.isValid() is called when acquiring a connection from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.ignore-recovery-failures</span>=<span class="string">false # Whether or not recovery failures should be ignored.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.isolation-level</span>= <span class="string"># The default isolation level for connections.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.local-auto-commit</span>= <span class="string"># The default auto-commit mode for local transactions.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.login-timeout</span>= <span class="string"># Timeout, in seconds, for establishing a database connection.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.max-idle-time</span>=<span class="string">60 # The time, in seconds, after which connections are cleaned up from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.max-pool-size</span>=<span class="string">10 # The maximum size of the pool. 0 denotes no limit.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.min-pool-size</span>=<span class="string">0 # The minimum size of the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.prepared-statement-cache-size</span>=<span class="string">0 # The target size of the prepared statement cache. 0 disables the cache.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.share-transaction-connections</span>=<span class="string">false #  Whether or not connections in the ACCESSIBLE state can be shared within the context of a transaction.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.test-query</span>= <span class="string"># SQL query or statement used to validate a connection before returning it.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.two-pc-ordering-position</span>=<span class="string">1 # The position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, always last is Integer.MAX_VALUE).</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.unique-name</span>=<span class="string">dataSource # The unique name used to identify the resource during recovery.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.use-tm-join</span>=<span class="string">true Whether or not TMJOIN should be used when starting XAResources.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.allow-multiple-lrc</span>=<span class="string">false # Allow multiple LRC resources to be enlisted into the same transaction.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.asynchronous2-pc</span>=<span class="string">false # Enable asynchronously execution of two phase commit.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.background-recovery-interval-seconds</span>=<span class="string">60 # Interval in seconds at which to run the recovery process in the background.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.current-node-only-recovery</span>=<span class="string">true # Recover only the current node.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.debug-zero-resource-transaction</span>=<span class="string">false # Log the creation and commit call stacks of transactions executed without a single enlisted resource.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.default-transaction-timeout</span>=<span class="string">60 # Default transaction timeout in seconds.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.disable-jmx</span>=<span class="string">false # Enable JMX support.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.exception-analyzer</span>= <span class="string"># Set the fully qualified name of the exception analyzer implementation to use.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.filter-log-status</span>=<span class="string">false # Enable filtering of logs so that only mandatory logs are written.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.force-batching-enabled</span>=<span class="string">true #  Set if disk forces are batched.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.forced-write-enabled</span>=<span class="string">true # Set if logs are forced to disk.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.graceful-shutdown-interval</span>=<span class="string">60 # Maximum amount of seconds the TM will wait for transactions to get done before aborting them at shutdown time.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.jndi-transaction-synchronization-registry-name</span>= <span class="string"># JNDI name of the TransactionSynchronizationRegistry.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.jndi-user-transaction-name</span>= <span class="string"># JNDI name of the UserTransaction.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.journal</span>=<span class="string">disk # Name of the journal. Can be &#x27;disk&#x27;, &#x27;null&#x27; or a class name.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.log-part1-filename</span>=<span class="string">btm1.tlog # Name of the first fragment of the journal.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.log-part2-filename</span>=<span class="string">btm2.tlog # Name of the second fragment of the journal.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.max-log-size-in-mb</span>=<span class="string">2 # Maximum size in megabytes of the journal fragments.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.resource-configuration-filename</span>= <span class="string"># ResourceLoader configuration file name.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.server-id</span>= <span class="string"># ASCII ID that must uniquely identify this TM instance. Default to the machine&#x27;s IP address.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.skip-corrupted-logs</span>=<span class="string">false # Skip corrupted transactions log entries.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.warn-about-zero-resource-transaction</span>=<span class="string">true # Log a warning for transactions executed without a single enlisted resource.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NARAYANA (NarayanaProperties)</span></span><br><span class="line"><span class="meta">spring.jta.narayana.default-timeout</span>=<span class="string">60 # Transaction timeout in seconds.</span></span><br><span class="line"><span class="meta">spring.jta.narayana.expiry-scanners</span>=<span class="string">com.arjuna.ats.internal.arjuna.recovery.ExpiredTransactionStatusManagerScanner # Comma-separated list of expiry scanners.</span></span><br><span class="line"><span class="meta">spring.jta.narayana.log-dir</span>= <span class="string"># Transaction object store directory.</span></span><br><span class="line"><span class="meta">spring.jta.narayana.one-phase-commit</span>=<span class="string">true # Enable one phase commit optimisation.</span></span><br><span class="line"><span class="meta">spring.jta.narayana.periodic-recovery-period</span>=<span class="string">120 # Interval in which periodic recovery scans are performed in seconds.</span></span><br><span class="line"><span class="meta">spring.jta.narayana.recovery-backoff-period</span>=<span class="string">10 # Back off period between first and second phases of the recovery scan in seconds.</span></span><br><span class="line"><span class="meta">spring.jta.narayana.recovery-db-pass</span>= <span class="string"># Database password to be used by recovery manager.</span></span><br><span class="line"><span class="meta">spring.jta.narayana.recovery-db-user</span>= <span class="string"># Database username to be used by recovery manager.</span></span><br><span class="line"><span class="meta">spring.jta.narayana.recovery-jms-pass</span>= <span class="string"># JMS password to be used by recovery manager.</span></span><br><span class="line"><span class="meta">spring.jta.narayana.recovery-jms-user</span>= <span class="string"># JMS username to be used by recovery manager.</span></span><br><span class="line"><span class="meta">spring.jta.narayana.recovery-modules</span>= <span class="string"># Comma-separated list of recovery modules.</span></span><br><span class="line"><span class="meta">spring.jta.narayana.transaction-manager-id</span>=<span class="string">1 # Unique transaction manager id.</span></span><br><span class="line"><span class="meta">spring.jta.narayana.xa-resource-orphan-filters</span>= <span class="string"># Comma-separated list of orphan filters.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># EMBEDDED MONGODB (EmbeddedMongoProperties)</span></span><br><span class="line"><span class="meta">spring.mongodb.embedded.features</span>=<span class="string">SYNC_DELAY # Comma-separated list of features to enable.</span></span><br><span class="line"><span class="meta">spring.mongodb.embedded.storage.database-dir</span>= <span class="string"># Directory used for data storage.</span></span><br><span class="line"><span class="meta">spring.mongodb.embedded.storage.oplog-size</span>= <span class="string"># Maximum size of the oplog in megabytes.</span></span><br><span class="line"><span class="meta">spring.mongodb.embedded.storage.repl-set-name</span>= <span class="string"># Name of the replica set.</span></span><br><span class="line"><span class="meta">spring.mongodb.embedded.version</span>=<span class="string">2.6.10 # Version of Mongo to use.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># REDIS (RedisProperties)</span></span><br><span class="line"><span class="meta">spring.redis.cluster.max-redirects</span>= <span class="string"># Maximum number of redirects to follow when executing commands across the cluster.</span></span><br><span class="line"><span class="meta">spring.redis.cluster.nodes</span>= <span class="string"># Comma-separated list of &quot;host:port&quot; pairs to bootstrap from.</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0 # Database index used by the connection factory.</span></span><br><span class="line"><span class="meta">spring.redis.url</span>= <span class="string"># Connection URL, will override host, port and password (user will be ignored), e.g. redis://user:password@example.com:6379</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">localhost # Redis server host.</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-active</span>=<span class="string">8 # Max number of connections that can be allocated by the pool at a given time. Use a negative value for no limit.</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-idle</span>=<span class="string">8 # Max number of &quot;idle&quot; connections in the pool. Use a negative value to indicate an unlimited number of idle connections.</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-wait</span>=<span class="string">-1 # Maximum amount of time (in milliseconds) a connection allocation should block before throwing an exception when the pool is exhausted. Use a negative value to block indefinitely.</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.min-idle</span>=<span class="string">0 # Target for the minimum number of idle connections to maintain in the pool. This setting only has an effect if it is positive.</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">8 # Max number of connections that can be allocated by the pool at a given time. Use a negative value for no limit.</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span>=<span class="string">8 # Max number of &quot;idle&quot; connections in the pool. Use a negative value to indicate an unlimited number of idle connections.</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1 # Maximum amount of time (in milliseconds) a connection allocation should block before throwing an exception when the pool is exhausted. Use a negative value to block indefinitely.</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0 # Target for the minimum number of idle connections to maintain in the pool. This setting only has an effect if it is positive.</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.shutdown-timeout</span>=<span class="string">100 # Shutdown timeout in milliseconds.</span></span><br><span class="line"><span class="meta">spring.redis.password</span>= <span class="string"># Login password of the redis server.</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379 # Redis server port.</span></span><br><span class="line"><span class="meta">spring.redis.sentinel.master</span>= <span class="string"># Name of Redis server.</span></span><br><span class="line"><span class="meta">spring.redis.sentinel.nodes</span>= <span class="string"># Comma-separated list of host:port pairs.</span></span><br><span class="line"><span class="meta">spring.redis.ssl</span>=<span class="string">false # Enable SSL support.</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">0 # Connection timeout in milliseconds.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TRANSACTION (TransactionProperties)</span></span><br><span class="line"><span class="meta">spring.transaction.default-timeout</span>= <span class="string"># Default transaction timeout in seconds.</span></span><br><span class="line"><span class="meta">spring.transaction.rollback-on-commit-failure</span>= <span class="string"># Perform the rollback on commit failures.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># INTEGRATION PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ACTIVEMQ (ActiveMQProperties)</span></span><br><span class="line"><span class="meta">spring.activemq.broker-url</span>= <span class="string"># URL of the ActiveMQ broker. Auto-generated by default.</span></span><br><span class="line"><span class="meta">spring.activemq.close-timeout</span>=<span class="string">15000 # Time to wait, in milliseconds, before considering a close complete.</span></span><br><span class="line"><span class="meta">spring.activemq.in-memory</span>=<span class="string">true # Specify if the default broker URL should be in memory. Ignored if an explicit broker has been specified.</span></span><br><span class="line"><span class="meta">spring.activemq.non-blocking-redelivery</span>=<span class="string">false # Do not stop message delivery before re-delivering messages from a rolled back transaction. This implies that message order will not be preserved when this is enabled.</span></span><br><span class="line"><span class="meta">spring.activemq.password</span>= <span class="string"># Login password of the broker.</span></span><br><span class="line"><span class="meta">spring.activemq.send-timeout</span>=<span class="string">0 # Time to wait, in milliseconds, on Message sends for a response. Set it to 0 to indicate to wait forever.</span></span><br><span class="line"><span class="meta">spring.activemq.user</span>= <span class="string"># Login user of the broker.</span></span><br><span class="line"><span class="meta">spring.activemq.packages.trust-all</span>= <span class="string"># Trust all packages.</span></span><br><span class="line"><span class="meta">spring.activemq.packages.trusted</span>= <span class="string"># Comma-separated list of specific packages to trust (when not trusting all packages).</span></span><br><span class="line"><span class="meta">spring.activemq.pool.block-if-full</span>=<span class="string">true # Block when a connection is requested and the pool is full. Set it to false to throw a &quot;JMSException&quot; instead.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.block-if-full-timeout</span>=<span class="string">-1 # Blocking period, in milliseconds, before throwing an exception if the pool is still full.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.create-connection-on-startup</span>=<span class="string">true # Create a connection on startup. Can be used to warm-up the pool on startup.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.enabled</span>=<span class="string">false # Whether a PooledConnectionFactory should be created instead of a regular ConnectionFactory.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.expiry-timeout</span>=<span class="string">0 # Connection expiration timeout in milliseconds.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.idle-timeout</span>=<span class="string">30000 # Connection idle timeout in milliseconds.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.max-connections</span>=<span class="string">1 # Maximum number of pooled connections.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.maximum-active-session-per-connection</span>=<span class="string">500 # Maximum number of active sessions per connection.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.reconnect-on-exception</span>=<span class="string">true # Reset the connection when a &quot;JMSException&quot; occurs.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.time-between-expiration-check</span>=<span class="string">-1 # Time to sleep, in milliseconds, between runs of the idle connection eviction thread. When negative, no idle connection eviction thread runs.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.use-anonymous-producers</span>=<span class="string">true # Use only one anonymous &quot;MessageProducer&quot; instance. Set it to false to create one &quot;MessageProducer&quot; every time one is required.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ARTEMIS (ArtemisProperties)</span></span><br><span class="line"><span class="meta">spring.artemis.embedded.cluster-password</span>= <span class="string"># Cluster password. Randomly generated on startup by default.</span></span><br><span class="line"><span class="meta">spring.artemis.embedded.data-directory</span>= <span class="string"># Journal file directory. Not necessary if persistence is turned off.</span></span><br><span class="line"><span class="meta">spring.artemis.embedded.enabled</span>=<span class="string">true # Enable embedded mode if the Artemis server APIs are available.</span></span><br><span class="line"><span class="meta">spring.artemis.embedded.persistent</span>=<span class="string">false # Enable persistent store.</span></span><br><span class="line"><span class="meta">spring.artemis.embedded.queues</span>= <span class="string"># Comma-separated list of queues to create on startup.</span></span><br><span class="line"><span class="meta">spring.artemis.embedded.server-id</span>= <span class="string"># Server id. By default, an auto-incremented counter is used.</span></span><br><span class="line"><span class="meta">spring.artemis.embedded.topics</span>= <span class="string"># Comma-separated list of topics to create on startup.</span></span><br><span class="line"><span class="meta">spring.artemis.host</span>=<span class="string">localhost # Artemis broker host.</span></span><br><span class="line"><span class="meta">spring.artemis.mode</span>= <span class="string"># Artemis deployment mode, auto-detected by default.</span></span><br><span class="line"><span class="meta">spring.artemis.password</span>= <span class="string"># Login password of the broker.</span></span><br><span class="line"><span class="meta">spring.artemis.port</span>=<span class="string">61616 # Artemis broker port.</span></span><br><span class="line"><span class="meta">spring.artemis.user</span>= <span class="string"># Login user of the broker.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING BATCH (BatchProperties)</span></span><br><span class="line"><span class="meta">spring.batch.initialize-schema</span>=<span class="string">embedded # Database schema initialization mode.</span></span><br><span class="line"><span class="meta">spring.batch.job.enabled</span>=<span class="string">true # Execute all Spring Batch jobs in the context on startup.</span></span><br><span class="line"><span class="meta">spring.batch.job.names</span>= <span class="string"># Comma-separated list of job names to execute on startup (For instance `job1,job2`). By default, all Jobs found in the context are executed.</span></span><br><span class="line"><span class="meta">spring.batch.schema</span>=<span class="string">classpath:org/springframework/batch/core/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.</span></span><br><span class="line"><span class="meta">spring.batch.table-prefix</span>= <span class="string"># Table prefix for all the batch meta-data tables.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING INTEGRATION (IntegrationProperties)</span></span><br><span class="line"><span class="meta">spring.integration.jdbc.initialize-schema</span>=<span class="string">embedded # Database schema initialization mode.</span></span><br><span class="line"><span class="meta">spring.integration.jdbc.schema</span>=<span class="string">classpath:org/springframework/integration/jdbc/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JMS (JmsProperties)</span></span><br><span class="line"><span class="meta">spring.jms.jndi-name</span>= <span class="string"># Connection factory JNDI name. When set, takes precedence to others connection factory auto-configurations.</span></span><br><span class="line"><span class="meta">spring.jms.listener.acknowledge-mode</span>= <span class="string"># Acknowledge mode of the container. By default, the listener is transacted with automatic acknowledgment.</span></span><br><span class="line"><span class="meta">spring.jms.listener.auto-startup</span>=<span class="string">true # Start the container automatically on startup.</span></span><br><span class="line"><span class="meta">spring.jms.listener.concurrency</span>= <span class="string"># Minimum number of concurrent consumers.</span></span><br><span class="line"><span class="meta">spring.jms.listener.max-concurrency</span>= <span class="string"># Maximum number of concurrent consumers.</span></span><br><span class="line"><span class="meta">spring.jms.pub-sub-domain</span>=<span class="string">false # Specify if the default destination type is topic.</span></span><br><span class="line"><span class="meta">spring.jms.template.default-destination</span>= <span class="string"># Default destination to use on send/receive operations that do not have a destination parameter.</span></span><br><span class="line"><span class="meta">spring.jms.template.delivery-delay</span>= <span class="string"># Delivery delay to use for send calls in milliseconds.</span></span><br><span class="line"><span class="meta">spring.jms.template.delivery-mode</span>= <span class="string"># Delivery mode. Enable QoS when set.</span></span><br><span class="line"><span class="meta">spring.jms.template.priority</span>= <span class="string"># Priority of a message when sending. Enable QoS when set.</span></span><br><span class="line"><span class="meta">spring.jms.template.qos-enabled</span>= <span class="string"># Enable explicit QoS when sending a message.</span></span><br><span class="line"><span class="meta">spring.jms.template.receive-timeout</span>= <span class="string"># Timeout to use for receive calls in milliseconds.</span></span><br><span class="line"><span class="meta">spring.jms.template.time-to-live</span>= <span class="string"># Time-to-live of a message when sending in milliseconds. Enable QoS when set.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># APACHE KAFKA (KafkaProperties)</span></span><br><span class="line"><span class="meta">spring.kafka.admin.client-id</span>= <span class="string"># Id to pass to the server when making requests; used for server-side logging.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.fail-fast</span>=<span class="string">false # Fail fast if the broker is not available on startup.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.properties.*</span>= <span class="string"># Additional admin-specific properties used to configure the client.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.ssl.key-password</span>= <span class="string"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.ssl.keystore-location</span>= <span class="string"># Location of the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.ssl.keystore-password</span>= <span class="string"># Store password for the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.ssl.truststore-location</span>= <span class="string"># Location of the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.ssl.truststore-password</span>= <span class="string"># Store password for the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.bootstrap-servers</span>= <span class="string"># Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.</span></span><br><span class="line"><span class="meta">spring.kafka.client-id</span>= <span class="string"># Id to pass to the server when making requests; used for server-side logging.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.auto-commit-interval</span>= <span class="string"># Frequency in milliseconds that the consumer offsets are auto-committed to Kafka if &#x27;enable.auto.commit&#x27; true.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.auto-offset-reset</span>= <span class="string"># What to do when there is no initial offset in Kafka or if the current offset does not exist any more on the server.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.bootstrap-servers</span>= <span class="string"># Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.client-id</span>= <span class="string"># Id to pass to the server when making requests; used for server-side logging.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.enable-auto-commit</span>= <span class="string"># If true the consumer&#x27;s offset will be periodically committed in the background.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.fetch-max-wait</span>= <span class="string"># Maximum amount of time in milliseconds the server will block before answering the fetch request if there isn&#x27;t sufficient data to immediately satisfy the requirement given by &quot;fetch.min.bytes&quot;.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.fetch-min-size</span>= <span class="string"># Minimum amount of data the server should return for a fetch request in bytes.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.group-id</span>= <span class="string"># Unique string that identifies the consumer group this consumer belongs to.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.heartbeat-interval</span>= <span class="string"># Expected time in milliseconds between heartbeats to the consumer coordinator.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.key-deserializer</span>= <span class="string"># Deserializer class for keys.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.max-poll-records</span>= <span class="string"># Maximum number of records returned in a single call to poll().</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.properties.*</span>= <span class="string"># Additional consumer-specific properties used to configure the client.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.ssl.key-password</span>= <span class="string"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.ssl.keystore-location</span>= <span class="string"># Location of the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.ssl.keystore-password</span>= <span class="string"># Store password for the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.ssl.truststore-location</span>= <span class="string"># Location of the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.ssl.truststore-password</span>= <span class="string"># Store password for the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.value-deserializer</span>= <span class="string"># Deserializer class for values.</span></span><br><span class="line"><span class="meta">spring.kafka.jaas.control-flag</span>=<span class="string">required # Control flag for login configuration.</span></span><br><span class="line"><span class="meta">spring.kafka.jaas.enabled</span>= <span class="string"># Enable JAAS configuration.</span></span><br><span class="line"><span class="meta">spring.kafka.jaas.login-module</span>=<span class="string">com.sun.security.auth.module.Krb5LoginModule # Login module.</span></span><br><span class="line"><span class="meta">spring.kafka.jaas.options</span>= <span class="string"># Additional JAAS options.</span></span><br><span class="line"><span class="meta">spring.kafka.listener.ack-count</span>= <span class="string"># Number of records between offset commits when ackMode is &quot;COUNT&quot; or &quot;COUNT_TIME&quot;.</span></span><br><span class="line"><span class="meta">spring.kafka.listener.ack-mode</span>= <span class="string"># Listener AckMode; see the spring-kafka documentation.</span></span><br><span class="line"><span class="meta">spring.kafka.listener.ack-time</span>= <span class="string"># Time in milliseconds between offset commits when ackMode is &quot;TIME&quot; or &quot;COUNT_TIME&quot;.</span></span><br><span class="line"><span class="meta">spring.kafka.listener.concurrency</span>= <span class="string"># Number of threads to run in the listener containers.</span></span><br><span class="line"><span class="meta">spring.kafka.listener.poll-timeout</span>= <span class="string"># Timeout in milliseconds to use when polling the consumer.</span></span><br><span class="line"><span class="meta">spring.kafka.listener.type</span>=<span class="string">single # Listener type.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.acks</span>= <span class="string"># Number of acknowledgments the producer requires the leader to have received before considering a request complete.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.batch-size</span>= <span class="string"># Number of records to batch before sending.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.bootstrap-servers</span>= <span class="string"># Comma-delimited list of host:port pairs to use for establishing the initial connection to the Kafka cluster.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.buffer-memory</span>= <span class="string"># Total bytes of memory the producer can use to buffer records waiting to be sent to the server.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.client-id</span>= <span class="string"># Id to pass to the server when making requests; used for server-side logging.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.compression-type</span>= <span class="string"># Compression type for all data generated by the producer.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.key-serializer</span>= <span class="string"># Serializer class for keys.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.properties.*</span>= <span class="string"># Additional producer-specific properties used to configure the client.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.retries</span>= <span class="string"># When greater than zero, enables retrying of failed sends.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.ssl.key-password</span>= <span class="string"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.ssl.keystore-location</span>= <span class="string"># Location of the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.ssl.keystore-password</span>= <span class="string"># Store password for the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.ssl.truststore-location</span>= <span class="string"># Location of the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.ssl.truststore-password</span>= <span class="string"># Store password for the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.value-serializer</span>= <span class="string"># Serializer class for values.</span></span><br><span class="line"><span class="meta">spring.kafka.properties.*</span>= <span class="string"># Additional properties, common to producers and consumers, used to configure the client.</span></span><br><span class="line"><span class="meta">spring.kafka.ssl.key-password</span>= <span class="string"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.ssl.keystore-location</span>= <span class="string"># Location of the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.ssl.keystore-password</span>= <span class="string"># Store password for the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.ssl.truststore-location</span>= <span class="string"># Location of the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.ssl.truststore-password</span>= <span class="string"># Store password for the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.template.default-topic</span>= <span class="string"># Default topic to which messages will be sent.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RABBIT (RabbitProperties)</span></span><br><span class="line"><span class="meta">spring.rabbitmq.addresses</span>= <span class="string"># Comma-separated list of addresses to which the client should connect.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.cache.channel.checkout-timeout</span>= <span class="string"># Number of milliseconds to wait to obtain a channel if the cache size has been reached.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.cache.channel.size</span>= <span class="string"># Number of channels to retain in the cache.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.cache.connection.mode</span>=<span class="string">channel # Connection factory cache mode.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.cache.connection.size</span>= <span class="string"># Number of connections to cache.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.connection-timeout</span>= <span class="string"># Connection timeout, in milliseconds; zero for infinite.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.dynamic</span>=<span class="string">true # Create an AmqpAdmin bean.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost # RabbitMQ host.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.acknowledge-mode</span>= <span class="string"># Acknowledge mode of container.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.auto-startup</span>=<span class="string">true # Start the container automatically on startup.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.consumers-per-queue</span>= <span class="string"># Number of consumers per queue.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.default-requeue-rejected</span>= <span class="string"># Whether rejected deliveries are requeued by default; default true.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.idle-event-interval</span>= <span class="string"># How often idle container events should be published in milliseconds.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.prefetch</span>= <span class="string"># Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.retry.enabled</span>=<span class="string">false # Whether or not publishing retries are enabled.</span></span><br><span class="line">   <span class="meta">spring.rabbitmq.listener.direct.retry.initial-interval</span>=<span class="string">1000 # Interval between the first and second attempt to publish or deliver a message.</span></span><br><span class="line">   <span class="meta">spring.rabbitmq.listener.direct.retry.max-attempts</span>=<span class="string">3 # Maximum number of attempts to publish or deliver a message.</span></span><br><span class="line">   <span class="meta">spring.rabbitmq.listener.direct.retry.max-interval</span>=<span class="string">10000 # Maximum interval between attempts.</span></span><br><span class="line">   <span class="meta">spring.rabbitmq.listener.direct.retry.multiplier</span>=<span class="string">1 # A multiplier to apply to the previous retry interval.</span></span><br><span class="line">   <span class="meta">spring.rabbitmq.listener.direct.retry.stateless</span>=<span class="string">true # Whether or not retries are stateless or stateful.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.acknowledge-mode</span>= <span class="string"># Acknowledge mode of container.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.auto-startup</span>=<span class="string">true # Start the container automatically on startup.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.concurrency</span>= <span class="string"># Minimum number of listener invoker threads.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.default-requeue-rejected</span>= <span class="string"># Whether or not to requeue delivery failures.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.idle-event-interval</span>= <span class="string"># How often idle container events should be published in milliseconds.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.max-concurrency</span>= <span class="string"># Maximum number of listener invoker.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.prefetch</span>= <span class="string"># Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.enabled</span>=<span class="string">false # Whether or not publishing retries are enabled.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.initial-interval</span>=<span class="string">1000 # Interval between the first and second attempt to deliver a message.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.max-attempts</span>=<span class="string">3 # Maximum number of attempts to deliver a message.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.max-interval</span>=<span class="string">10000 # Maximum interval between attempts.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.multiplier</span>=<span class="string">1.0 # A multiplier to apply to the previous delivery retry interval.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.stateless</span>=<span class="string">true # Whether or not retry is stateless or stateful.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.transaction-size</span>= <span class="string"># Number of messages to be processed in a transaction; number of messages between acks. For best results it should be less than or equal to the prefetch count.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.type</span>=<span class="string">simple # Listener container type.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>= <span class="string"># Login to authenticate against the broker.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672 # RabbitMQ port.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirms</span>=<span class="string">false # Enable publisher confirms.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">false # Enable publisher returns.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.requested-heartbeat</span>= <span class="string"># Requested heartbeat timeout, in seconds; zero for none.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.enabled</span>=<span class="string">false # Enable SSL support.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.key-store</span>= <span class="string"># Path to the key store that holds the SSL certificate.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.key-store-password</span>= <span class="string"># Password used to access the key store.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.key-store-type</span>=<span class="string">PKCS12 # Key store type.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.trust-store</span>= <span class="string"># Trust store that holds SSL certificates.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.trust-store-password</span>= <span class="string"># Password used to access the trust store.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.trust-store-type</span>=<span class="string">JKS # Trust store type.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.algorithm</span>= <span class="string"># SSL algorithm to use. By default configure by the rabbit client library.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.mandatory</span>=<span class="string">false # Enable mandatory messages.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.receive-timeout</span>=<span class="string">0 # Timeout for `receive()` methods.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.reply-timeout</span>=<span class="string">5000 # Timeout for `sendAndReceive()` methods.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.enabled</span>=<span class="string">false # Set to true to enable retries in the `RabbitTemplate`.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.initial-interval</span>=<span class="string">1000 # Interval between the first and second attempt to publish a message.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.max-attempts</span>=<span class="string">3 # Maximum number of attempts to publish a message.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.max-interval</span>=<span class="string">10000 # Maximum number of attempts to publish a message.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.multiplier</span>=<span class="string">1.0 # A multiplier to apply to the previous publishing retry interval.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>= <span class="string"># Login user to authenticate to the broker.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.virtual-host</span>= <span class="string"># Virtual host to use when connecting to the broker.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># ACTUATOR PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AUDIT EVENTS ENDPOINT (AuditEventsEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.auditevents.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.auditevents.enabled</span>= <span class="string"># Enable the auditevents endpoint.</span></span><br><span class="line"><span class="meta">endpoints.auditevents.jmx.enabled</span>= <span class="string"># Expose the auditevents endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.auditevents.web.enabled</span>= <span class="string"># Expose the auditevents endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AUTO-CONFIGURATION REPORT ENDPOINT (AutoConfigurationReportEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.autoconfig.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.autoconfig.enabled</span>= <span class="string"># Enable the autoconfig endpoint.</span></span><br><span class="line"><span class="meta">endpoints.autoconfig.jmx.enabled</span>= <span class="string"># Expose the autoconfig endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.autoconfig.web.enabled</span>= <span class="string"># Expose the autoconfig endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BEANS ENDPOINT (BeansEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.beans.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.beans.enabled</span>= <span class="string"># Enable the beans endpoint.</span></span><br><span class="line"><span class="meta">endpoints.beans.jmx.enabled</span>= <span class="string"># Expose the beans endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.beans.web.enabled</span>= <span class="string"># Expose the beans endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CONFIGURATION PROPERTIES REPORT ENDPOINT (ConfigurationPropertiesReportEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.configprops.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.configprops.enabled</span>= <span class="string"># Enable the configprops endpoint.</span></span><br><span class="line"><span class="meta">endpoints.configprops.jmx.enabled</span>= <span class="string"># Expose the configprops endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.configprops.keys-to-sanitize</span>=<span class="string">password,secret,key,token,.*credentials.*,vcap_services # Keys that should be sanitized. Keys can be simple strings that the property ends with or regular expressions.</span></span><br><span class="line"><span class="meta">endpoints.configprops.web.enabled</span>= <span class="string"># Expose the configprops endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ENDPOINT DEFAULT SETTINGS</span></span><br><span class="line"><span class="meta">endpoints.default.enabled</span>=<span class="string">true # Enable all endpoints by default.</span></span><br><span class="line"><span class="meta">endpoints.default.jmx.enabled</span>=<span class="string">true # Enable all endpoints as JMX MBeans by default.</span></span><br><span class="line"><span class="meta">endpoints.default.web.enabled</span>=<span class="string">false # Enable all endpoints as Web endpoints by default.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ENVIRONMENT ENDPOINT  (EnvironmentEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.env.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.env.enabled</span>= <span class="string"># Enable the env endpoint.</span></span><br><span class="line"><span class="meta">endpoints.env.jmx.enabled</span>= <span class="string"># Expose the env endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.env.keys-to-sanitize</span>=<span class="string">password,secret,key,token,.*credentials.*,vcap_services # Keys that should be sanitized. Keys can be simple strings that the property ends with or regular expressions.</span></span><br><span class="line"><span class="meta">endpoints.env.web.enabled</span>= <span class="string"># Expose the env endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FLYWAY ENDPOINT (FlywayEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.flyway.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.flyway.enabled</span>= <span class="string"># Enable the flyway endpoint.</span></span><br><span class="line"><span class="meta">endpoints.flyway.jmx.enabled</span>= <span class="string"># Expose the flyway endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.flyway.web.enabled</span>= <span class="string"># Expose the flyway endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HEALTH ENDPOINT (HealthEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.health.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.health.enabled</span>= <span class="string"># Enable the health endpoint.</span></span><br><span class="line"><span class="meta">endpoints.health.jmx.enabled</span>= <span class="string"># Expose the health endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.health.web.enabled</span>= <span class="string"># Expose the health endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HEAP DUMP ENDPOINT (HeapDumpWebEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.heapdump.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.heapdump.enabled</span>= <span class="string"># Enable the heapdump endpoint.</span></span><br><span class="line"><span class="meta">endpoints.heapdump.web.enabled</span>= <span class="string"># Expose the heapdump endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># INFO ENDPOINT (InfoEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.info.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.info.enabled</span>=<span class="string">true # Enable the info endpoint.</span></span><br><span class="line"><span class="meta">endpoints.info.jmx.enabled</span>=<span class="string">true # Expose the info endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.info.web.enabled</span>=<span class="string">true # Expose the info endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LIQUIBASE ENDPOINT (LiquibaseEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.liquibase.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.liquibase.enabled</span>= <span class="string"># Enable the liquibase endpoint.</span></span><br><span class="line"><span class="meta">endpoints.liquibase.jmx.enabled</span>= <span class="string"># Expose the liquibase endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.liquibase.web.enabled</span>= <span class="string"># Expose the liquibase endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LOG FILE ENDPOINT (LogFileWebEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.logfile.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.logfile.enabled</span>= <span class="string"># Enable the logfile endpoint.</span></span><br><span class="line"><span class="meta">endpoints.logfile.external-file</span>= <span class="string"># External Logfile to be accessed. Can be used if the logfile is written by output redirect and not by the logging system itself.</span></span><br><span class="line"><span class="meta">endpoints.logfile.web.enabled</span>= <span class="string"># Expose the logfile endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LOGGERS ENDPOINT (LoggersEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.loggers.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.loggers.enabled</span>= <span class="string"># Enable the loggers endpoint.</span></span><br><span class="line"><span class="meta">endpoints.loggers.jmx.enabled</span>= <span class="string"># Expose the loggers endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.loggers.web.enabled</span>= <span class="string"># Expose the loggers endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># REQUEST MAPPING ENDPOINT  (RequestMappingEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.mappings.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.mappings.enabled</span>= <span class="string"># Enable the mappings endpoint.</span></span><br><span class="line"><span class="meta">endpoints.mappings.jmx.enabled</span>= <span class="string"># Expose the mappings endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.mappings.web.enabled</span>= <span class="string"># Expose the mappings endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># METRICS ENDPOINT (MetricsEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.metrics.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.metrics.enabled</span>= <span class="string"># Enable the metrics endpoint.</span></span><br><span class="line"><span class="meta">endpoints.metrics.jmx.enabled</span>= <span class="string"># Expose the metrics endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.metrics.web.enabled</span>= <span class="string"># Expose the metrics endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PROMETHEUS ENDPOINT (PrometheusScrapeEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.prometheus.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.prometheus.enabled</span>= <span class="string"># Enable the metrics endpoint.</span></span><br><span class="line"><span class="meta">endpoints.prometheus.web.enabled</span>= <span class="string"># Expose the metrics endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SESSIONS ENDPOINT (SessionsEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.sessions.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.sessions.enabled</span>= <span class="string"># Enable the sessions endpoint.</span></span><br><span class="line"><span class="meta">endpoints.sessions.jmx.enabled</span>= <span class="string"># Expose the sessions endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.sessions.web.enabled</span>= <span class="string"># Expose the sessions endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SHUTDOWN ENDPOINT (ShutdownEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.shutdown.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.shutdown.enabled</span>=<span class="string">false # Enable the shutdown endpoint.</span></span><br><span class="line"><span class="meta">endpoints.shutdown.jmx.enabled</span>=<span class="string">false # Expose the shutdown endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.shutdown.web.enabled</span>=<span class="string">false # Expose the shutdown endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># STATUS ENDPOINT (StatusEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.status.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.status.enabled</span>=<span class="string">true # Enable the status endpoint.</span></span><br><span class="line"><span class="meta">endpoints.status.jmx.enabled</span>=<span class="string">true # Expose the status endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.status.web.enabled</span>=<span class="string">true # Expose the status endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># THREAD DUMP ENDPOINT (ThreadDumpEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.threaddump.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.threaddump.enabled</span>= <span class="string"># Enable the threaddump endpoint.</span></span><br><span class="line"><span class="meta">endpoints.threaddump.jmx.enabled</span>= <span class="string"># Expose the threaddump endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.threaddump.web.enabled</span>= <span class="string"># Expose the threaddump endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TRACE ENDPOINT (TraceEndpoint)</span></span><br><span class="line"><span class="meta">endpoints.trace.cache.time-to-live</span>=<span class="string">0 # Maximum time in milliseconds that a response can be cached.</span></span><br><span class="line"><span class="meta">endpoints.trace.enabled</span>= <span class="string"># Enable the trace endpoint.</span></span><br><span class="line"><span class="meta">endpoints.trace.jmx.enabled</span>= <span class="string"># Expose the trace endpoint as a JMX MBean.</span></span><br><span class="line"><span class="meta">endpoints.trace.web.enabled</span>= <span class="string"># Expose the trace endpoint as a Web endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MANAGEMENT HTTP SERVER (ManagementServerProperties)</span></span><br><span class="line"><span class="meta">management.add-application-context-header</span>=<span class="string">false # Add the &quot;X-Application-Context&quot; HTTP header in each response.</span></span><br><span class="line"><span class="meta">management.address</span>= <span class="string"># Network address that the management endpoints should bind to.</span></span><br><span class="line"><span class="meta">management.context-path</span>= <span class="string"># Management endpoint context-path. For instance `/actuator`</span></span><br><span class="line"><span class="meta">management.port</span>= <span class="string"># Management endpoint HTTP port. Uses the same port as the application by default. Configure a different port to use management-specific SSL.</span></span><br><span class="line"><span class="meta">management.ssl.ciphers</span>= <span class="string"># Supported SSL ciphers. Requires a custom management.port.</span></span><br><span class="line"><span class="meta">management.ssl.client-auth</span>= <span class="string"># Whether client authentication is wanted (&quot;want&quot;) or needed (&quot;need&quot;). Requires a trust store. Requires a custom management.port.</span></span><br><span class="line"><span class="meta">management.ssl.enabled</span>= <span class="string"># Enable SSL support. Requires a custom management.port.</span></span><br><span class="line"><span class="meta">management.ssl.enabled-protocols</span>= <span class="string"># Enabled SSL protocols. Requires a custom management.port.</span></span><br><span class="line"><span class="meta">management.ssl.key-alias</span>= <span class="string"># Alias that identifies the key in the key store. Requires a custom management.port.</span></span><br><span class="line"><span class="meta">management.ssl.key-password</span>= <span class="string"># Password used to access the key in the key store. Requires a custom management.port.</span></span><br><span class="line"><span class="meta">management.ssl.key-store</span>= <span class="string"># Path to the key store that holds the SSL certificate (typically a jks file). Requires a custom management.port.</span></span><br><span class="line"><span class="meta">management.ssl.key-store-password</span>= <span class="string"># Password used to access the key store. Requires a custom management.port.</span></span><br><span class="line"><span class="meta">management.ssl.key-store-provider</span>= <span class="string"># Provider for the key store. Requires a custom management.port.</span></span><br><span class="line"><span class="meta">management.ssl.key-store-type</span>= <span class="string"># Type of the key store. Requires a custom management.port.</span></span><br><span class="line"><span class="meta">management.ssl.protocol</span>=<span class="string">TLS # SSL protocol to use. Requires a custom management.port.</span></span><br><span class="line"><span class="meta">management.ssl.trust-store</span>= <span class="string"># Trust store that holds SSL certificates. Requires a custom management.port.</span></span><br><span class="line"><span class="meta">management.ssl.trust-store-password</span>= <span class="string"># Password used to access the trust store. Requires a custom management.port.</span></span><br><span class="line"><span class="meta">management.ssl.trust-store-provider</span>= <span class="string"># Provider for the trust store. Requires a custom management.port.</span></span><br><span class="line"><span class="meta">management.ssl.trust-store-type</span>= <span class="string"># Type of the trust store. Requires a custom management.port.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CLOUDFOUNDRY</span></span><br><span class="line"><span class="meta">management.cloudfoundry.enabled</span>=<span class="string">true # Enable extended Cloud Foundry actuator endpoints.</span></span><br><span class="line">   <span class="meta">management.cloudfoundry.skip-ssl-validation</span>=<span class="string">false # Skip SSL verification for Cloud Foundry actuator endpoint security calls.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ENDPOINTS CORS CONFIGURATION (CorsEndpointProperties)</span></span><br><span class="line"><span class="meta">management.endpoints.cors.allow-credentials</span>= <span class="string"># Set whether credentials are supported. When not set, credentials are not supported.</span></span><br><span class="line"><span class="meta">management.endpoints.cors.allowed-headers</span>= <span class="string"># Comma-separated list of headers to allow in a request. &#x27;*&#x27; allows all headers.</span></span><br><span class="line"><span class="meta">management.endpoints.cors.allowed-methods</span>= <span class="string"># Comma-separated list of methods to allow. &#x27;*&#x27; allows all methods. When not set, defaults to GET.</span></span><br><span class="line"><span class="meta">management.endpoints.cors.allowed-origins</span>= <span class="string"># Comma-separated list of origins to allow. &#x27;*&#x27; allows all origins. When not set, CORS support is disabled.</span></span><br><span class="line"><span class="meta">management.endpoints.cors.exposed-headers</span>= <span class="string"># Comma-separated list of headers to include in a response.</span></span><br><span class="line"><span class="meta">management.endpoints.cors.max-age</span>=<span class="string">1800 # How long, in seconds, the response from a pre-flight request can be cached by clients.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ENDPOINTS JMX CONFIGURATION (JmxEndpointExporterProperties)</span></span><br><span class="line"><span class="meta">management.endpoints.jmx.domain</span>=<span class="string">org.springframework.boot # Endpoints JMX domain name. Fallback to &#x27;spring.jmx.default-domain&#x27; if set.</span></span><br><span class="line"><span class="meta">management.endpoints.jmx.static-names</span>=<span class="string">false # Additional static properties to append to all ObjectNames of MBeans representing Endpoints.</span></span><br><span class="line"><span class="meta">management.endpoints.jmx.unique-names</span>=<span class="string">false # Ensure that ObjectNames are modified in case of conflict.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HEALTH INDICATORS</span></span><br><span class="line"><span class="meta">management.health.db.enabled</span>=<span class="string">true # Enable database health check.</span></span><br><span class="line"><span class="meta">management.health.cassandra.enabled</span>=<span class="string">true # Enable cassandra health check.</span></span><br><span class="line"><span class="meta">management.health.couchbase.enabled</span>=<span class="string">true # Enable couchbase health check.</span></span><br><span class="line"><span class="meta">management.health.defaults.enabled</span>=<span class="string">true # Enable default health indicators.</span></span><br><span class="line"><span class="meta">management.health.diskspace.enabled</span>=<span class="string">true # Enable disk space health check.</span></span><br><span class="line"><span class="meta">management.health.diskspace.path</span>= <span class="string"># Path used to compute the available disk space.</span></span><br><span class="line"><span class="meta">management.health.diskspace.threshold</span>=<span class="string">0 # Minimum disk space that should be available, in bytes.</span></span><br><span class="line"><span class="meta">management.health.elasticsearch.enabled</span>=<span class="string">true # Enable elasticsearch health check.</span></span><br><span class="line"><span class="meta">management.health.elasticsearch.indices</span>= <span class="string"># Comma-separated index names.</span></span><br><span class="line"><span class="meta">management.health.elasticsearch.response-timeout</span>=<span class="string">100 # The time, in milliseconds, to wait for a response from the cluster.</span></span><br><span class="line"><span class="meta">management.health.jms.enabled</span>=<span class="string">true # Enable JMS health check.</span></span><br><span class="line"><span class="meta">management.health.ldap.enabled</span>=<span class="string">true # Enable LDAP health check.</span></span><br><span class="line"><span class="meta">management.health.mail.enabled</span>=<span class="string">true # Enable Mail health check.</span></span><br><span class="line"><span class="meta">management.health.mongo.enabled</span>=<span class="string">true # Enable MongoDB health check.</span></span><br><span class="line"><span class="meta">management.health.neo4j.enabled</span>=<span class="string">true # Enable Neo4j health check.</span></span><br><span class="line"><span class="meta">management.health.rabbit.enabled</span>=<span class="string">true # Enable RabbitMQ health check.</span></span><br><span class="line"><span class="meta">management.health.redis.enabled</span>=<span class="string">true # Enable Redis health check.</span></span><br><span class="line"><span class="meta">management.health.solr.enabled</span>=<span class="string">true # Enable Solr health check.</span></span><br><span class="line"><span class="meta">management.health.status.http-mapping</span>= <span class="string"># Mapping of health statuses to HTTP status codes. By default, registered health statuses map to sensible defaults (i.e. UP maps to 200).</span></span><br><span class="line"><span class="meta">management.health.status.order</span>=<span class="string">DOWN, OUT_OF_SERVICE, UP, UNKNOWN # Comma-separated list of health statuses in order of severity.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># INFO CONTRIBUTORS (InfoContributorProperties)</span></span><br><span class="line"><span class="meta">management.info.build.enabled</span>=<span class="string">true # Enable build info.</span></span><br><span class="line"><span class="meta">management.info.defaults.enabled</span>=<span class="string">true # Enable default info contributors.</span></span><br><span class="line"><span class="meta">management.info.env.enabled</span>=<span class="string">true # Enable environment info.</span></span><br><span class="line"><span class="meta">management.info.git.enabled</span>=<span class="string">true # Enable git info.</span></span><br><span class="line"><span class="meta">management.info.git.mode</span>=<span class="string">simple # Mode to use to expose git information.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JOLOKIA (JolokiaProperties)</span></span><br><span class="line"><span class="meta">management.jolokia.config.*</span>= <span class="string"># Jolokia settings. See the Jolokia manual for details.</span></span><br><span class="line"><span class="meta">management.jolokia.enabled</span>=<span class="string">false # Enable Jolokia.</span></span><br><span class="line"><span class="meta">management.jolokia.path</span>=<span class="string">/jolokia # Path at which Jolokia will be available.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TRACING (TraceProperties)</span></span><br><span class="line"><span class="meta">management.trace.filter.enabled</span>=<span class="string">true # Enable the trace servlet filter.</span></span><br><span class="line"><span class="meta">management.trace.include</span>=<span class="string">request-headers,response-headers,cookies,errors # Items to be included in the trace.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># METRICS</span></span><br><span class="line"><span class="meta">spring.metrics.atlas.enabled</span>=<span class="string">true # Whether not exporting of metrics to Atlas is enabled.</span></span><br><span class="line"><span class="meta">spring.metrics.ganglia.enabled</span>=<span class="string">true # Whether not exporting of metrics to Ganglia is enabled.</span></span><br><span class="line"><span class="meta">spring.metrics.graphite.enabled</span>=<span class="string">true # Whether not exporting of metrics to Graphite is enabled.</span></span><br><span class="line"><span class="meta">spring.metrics.influx.enabled</span>=<span class="string">true # Whether not exporting of metrics to InfluxDB is enabled.</span></span><br><span class="line"><span class="meta">spring.metrics.jmx.enabled</span>=<span class="string">true # Whether not exporting of metrics to JMX is enabled.</span></span><br><span class="line"><span class="meta">spring.metrics.prometheus.enabled</span>=<span class="string">true # Whether not exporting of metrics to Prometheus is enabled.</span></span><br><span class="line"><span class="meta">spring.metrics.simple.enabled</span>=<span class="string">true # Whether not exporting of metrics to a simple in-memory store is enabled.</span></span><br><span class="line"><span class="meta">spring.metrics.use-global-registry</span>=<span class="string">true # Whether or not auto-configured MeterRegistry implementations should be bound to the global static registry on Metrics</span></span><br><span class="line"><span class="meta">spring.metrics.web.client.record-request-percentiles</span>=<span class="string">false # Whether or not instrumented requests record percentiles histogram buckets by default.</span></span><br><span class="line"><span class="meta">spring.metrics.web.client.requests-metric-name</span>=<span class="string">http.client.requests # Name of the metric for sent requests.</span></span><br><span class="line"><span class="meta">spring.metrics.web.server.auto-time-requests</span>=<span class="string">true Whether or not requests handled by Spring MVC or WebFlux should be automatically timed.</span></span><br><span class="line"><span class="meta">spring.metrics.web.server.record-request-percentiles</span>=<span class="string">false # Whether or not instrumented requests record percentiles histogram buckets by default.</span></span><br><span class="line"><span class="meta">spring.metrics.web.server.requests-metric-name</span>=<span class="string">http.server.requests # Name of the metric for received requests.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># DEVTOOLS PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DEVTOOLS (DevToolsProperties)</span></span><br><span class="line"><span class="meta">spring.devtools.livereload.enabled</span>=<span class="string">true # Enable a livereload.com compatible server.</span></span><br><span class="line"><span class="meta">spring.devtools.livereload.port</span>=<span class="string">35729 # Server port.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.additional-exclude</span>= <span class="string"># Additional patterns that should be excluded from triggering a full restart.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.additional-paths</span>= <span class="string"># Additional paths to watch for changes.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.enabled</span>=<span class="string">true # Enable automatic restart.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.exclude</span>=<span class="string">META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties # Patterns that should be excluded from triggering a full restart.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.poll-interval</span>=<span class="string">1000 # Amount of time (in milliseconds) to wait between polling for classpath changes.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.quiet-period</span>=<span class="string">400 # Amount of quiet time (in milliseconds) required without any classpath changes before a restart is triggered.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.trigger-file</span>= <span class="string"># Name of a specific file that when changed will trigger the restart check. If not specified any classpath file change will trigger the restart.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># REMOTE DEVTOOLS (RemoteDevToolsProperties)</span></span><br><span class="line"><span class="meta">spring.devtools.remote.context-path</span>=<span class="string">/.~~spring-boot!~ # Context path used to handle the remote connection.</span></span><br><span class="line"><span class="meta">spring.devtools.remote.proxy.host</span>= <span class="string"># The host of the proxy to use to connect to the remote application.</span></span><br><span class="line"><span class="meta">spring.devtools.remote.proxy.port</span>= <span class="string"># The port of the proxy to use to connect to the remote application.</span></span><br><span class="line"><span class="meta">spring.devtools.remote.restart.enabled</span>=<span class="string">true # Enable remote restart.</span></span><br><span class="line"><span class="meta">spring.devtools.remote.secret</span>= <span class="string"># A shared secret required to establish a connection (required to enable remote support).</span></span><br><span class="line"><span class="meta">spring.devtools.remote.secret-header-name</span>=<span class="string">X-AUTH-TOKEN # HTTP header used to transfer the shared secret.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># TESTING PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.test.database.replace</span>=<span class="string">any # Type of existing DataSource to replace.</span></span><br><span class="line"><span class="meta">spring.test.mockmvc.print</span>=<span class="string">default # MVC Print option.</span></span><br></pre></td></tr></table></figure><h2 id="附录-B-配置元数据"><a href="#附录-B-配置元数据" class="headerlink" title="附录 B.配置元数据"></a>附录 B.配置元数据</h2><p>Spring Boot jar附带元数据文件，提供所有支持的配置属性的详细信息。这些文件旨在允许IDE开发人员在用户使用<code>application.properties</code>或<code>application.yml</code>文件时提供上下文帮助和“代码补全”。</p><p>大部分元数据文件是在编译时自动生成的，处理所有用<code>@ConfigurationProperties</code>注解的项目。 但是，可以<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#configuration-metadata-additional-metadata">手动编写部分元数据</a>用于特殊情况或更高级的用法。</p><h3 id="B-1-元数据格式"><a href="#B-1-元数据格式" class="headerlink" title="B.1 元数据格式"></a>B.1 元数据格式</h3><p>配置元数据文件位于jar文件内部<code>META-INF / spring-configuration-metadata.json</code>中。它们使用简单的JSON格式，其中的项目分为“组”或“属性”，附加值提示归类为“提示”。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;groups&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;server&quot;</span>,</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;org.springframework.boot.autoconfigure.web.ServerProperties&quot;</span>,</span><br><span class="line"><span class="attr">&quot;sourceType&quot;</span>: <span class="string">&quot;org.springframework.boot.autoconfigure.web.ServerProperties&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;spring.jpa.hibernate&quot;</span>,</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;org.springframework.boot.autoconfigure.orm.jpa.JpaProperties$Hibernate&quot;</span>,</span><br><span class="line"><span class="attr">&quot;sourceType&quot;</span>: <span class="string">&quot;org.springframework.boot.autoconfigure.orm.jpa.JpaProperties&quot;</span>,</span><br><span class="line"><span class="attr">&quot;sourceMethod&quot;</span>: <span class="string">&quot;getHibernate()&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">],<span class="attr">&quot;properties&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;server.port&quot;</span>,</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;java.lang.Integer&quot;</span>,</span><br><span class="line"><span class="attr">&quot;sourceType&quot;</span>: <span class="string">&quot;org.springframework.boot.autoconfigure.web.ServerProperties&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;server.servlet.path&quot;</span>,</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;java.lang.String&quot;</span>,</span><br><span class="line"><span class="attr">&quot;sourceType&quot;</span>: <span class="string">&quot;org.springframework.boot.autoconfigure.web.ServerProperties&quot;</span>,</span><br><span class="line"><span class="attr">&quot;defaultValue&quot;</span>: <span class="string">&quot;/&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;spring.jpa.hibernate.ddl-auto&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;java.lang.String&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;DDL mode. This is actually a shortcut for the \&quot;hibernate.hbm2ddl.auto\&quot; property.&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;sourceType&quot;</span>: <span class="string">&quot;org.springframework.boot.autoconfigure.orm.jpa.JpaProperties$Hibernate&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">],<span class="attr">&quot;hints&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;spring.jpa.hibernate.ddl-auto&quot;</span>,</span><br><span class="line"><span class="attr">&quot;values&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Disable DDL handling.&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;validate&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Validate the schema, make no changes to the database.&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;update&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Update the schema if necessary.&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;create&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Create the schema and destroy previous data.&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;create-drop&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Create and then destroy the schema at the end of the session.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><p>每个“属性”是用户用给定值指定的配置项目。例如，<code>server.port</code>和<code>server.servlet.path</code>可以在<code>application.properties</code>中指定，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.port&#x3D;9090</span><br><span class="line">server.servlet.path&#x3D;&#x2F;home</span><br></pre></td></tr></table></figure><p>“组”是较高级别的项目，本身并不指定值，而是为属性提供上下文分组。 例如，<code>server.port</code>和<code>server.servlet.path</code>属性是<code>server</code>组的一部分。</p><blockquote><p>并不要求每一个“属性”都有一个“组”，有些属性可能就存在于自己的right之中。</p></blockquote><p>最后，“提示”是用于帮助用户配置给定属性的附加信息。当配置<code>spring.jpa.hibernate.ddl-auto</code>属性时，一个工具可以使用它来为<code>none</code>，<code>validate</code>，<code>update</code>，<code>create</code>和<code>create-drop</code>值提供一些自动完成的帮助。</p><h4 id="B-1-1-组的属性"><a href="#B-1-1-组的属性" class="headerlink" title="B.1.1 组的属性"></a>B.1.1 组的属性</h4><p><code>groups</code>数组中的JSON对象可以包含以下属性：</p><table><thead><tr><th>名称</th><th>类型</th><th>目的</th></tr></thead><tbody><tr><td><code>name</code></td><td>String</td><td>组的全名。 该属性是强制性的。</td></tr><tr><td><code>type</code></td><td>String</td><td>组的数据类型的类名称。例如，如果该组基于使用<code>@ConfigurationProperties</code>注解的类，则该属性将包含该类的完全限定名称。 如果它是基于<code>@Bean</code>方法，那将是该方法的返回类型。如果类型未知，则属性可以省略。</td></tr><tr><td><code>description</code></td><td>String</td><td>可以向用户显示的组的简短说明。如果没有可用的描述，可以省略。 建议描述是一个简短的段落，第一行提供一个简明的总结。描述的最后一行应以句点（<code>.</code>）结尾。</td></tr><tr><td><code>sourceType</code></td><td>String</td><td>贡献此组的源的类名称。例如，如果组基于<code>@ConfigurationProperties</code>注解的<code>@Bean</code>方法，则此属性将包含此方法的<code>@Configuration类的</code>完全限定名称。 如果源类型未知，则该属性可以省略。</td></tr><tr><td><code>sourceMethod</code></td><td>String</td><td>贡献该组的方法的全名（包括括号和参数类型）。例如，<code>@ConfigurationProperties</code>注释的<code>@Bean</code>方法的名称。如果源方法未知，可以省略。</td></tr></tbody></table><h4 id="B-1-2-Properties的属性"><a href="#B-1-2-Properties的属性" class="headerlink" title="B.1.2 Properties的属性"></a>B.1.2 Properties的属性</h4><p><code>properties</code>数组中的JSON对象可以包含以下属性：</p><table><thead><tr><th>名称</th><th>类型</th><th>目的</th></tr></thead><tbody><tr><td><code>name</code></td><td>String</td><td>属性的全名。名称以小写的虚线形式（例如<code>server.servlet.path</code>）。 该属性是强制性的。</td></tr><tr><td><code>type</code></td><td>String</td><td>该属性的数据类型的完整签名。例如，<code>java.lang.String</code>，也是一个完整的泛型类型，比如<code>java.util.Map &lt;java.util.String，acme.MyEnum&gt;</code>。这个属性可以用来指导用户可以输入的值的类型。 为了一致性，基本类型使用它的包装对象来指定，即布尔类型变成<code>java.lang.Boolean</code>。 请注意，这个类可能是一个复杂的类型，当值被绑定时，它会从字符串转换而来。 如果类型未知，可以省略。</td></tr><tr><td><code>description</code></td><td>String</td><td>可以向用户显示的组的简短说明。如果没有可用的描述，可以省略。 建议描述是一个简短的段落，第一行提供一个简明的总结。描述的最后一行应以句点（<code>.</code>）结尾。</td></tr><tr><td><code>sourceType</code></td><td>String</td><td>贡献此属性的源的类名称。例如，如果属性来自使用<code>@ConfigurationProperties</code>注解的类，则此属性将包含该类的完全限定名称。如果源类型未知，可以省略。</td></tr><tr><td><code>defaultValue</code></td><td>Object</td><td>如果未指定属性，将使用默认值。如果属性的类型是一个数组，也可以是一个值的数组。 如果默认值未知，可以省略。</td></tr><tr><td><code>deprecation</code></td><td>Deprecation</td><td>指定该属性是否被弃用。如果该字段未被弃用，或者该信息未知，则可以省略。 请参阅下面的更多细节。</td></tr></tbody></table><p>包含在每个属性元素的<code>deprecation</code>属性中的JSON对象可以包含以下属性：</p><table><thead><tr><th>名称</th><th>类型</th><th>目的</th></tr></thead><tbody><tr><td><code>level</code></td><td>String</td><td>弃用级别可以是<code>warning</code>（默认）或<code>error</code>。当一个属性具有<code>warning</code>弃用级别时，它应该仍然被绑定在环境中。但是，如果它具有<code>error</code>弃用级别，则不再管理该属性，也不会被绑定。</td></tr><tr><td><code>reason</code></td><td>String</td><td>属性被弃用原因的简短描述。 如果没有原因可以省略。建议描述是一个简短的段落，第一行提供一个简明的总结。 描述的最后一行应以句点（<code>.</code>）结尾。</td></tr><tr><td><code>replacement</code></td><td>String</td><td>替换此弃用属性的属性的全名。如果没有这个属性的替换属性，可以省略。</td></tr></tbody></table><blockquote><p>在Spring Boot 1.3之前，可以使用一个废弃的布尔属性来代替<code>deprecation</code>元素。 这仍被支持，不应再使用。如果没有原因和替换属性，则应该设置一个空的<code>deprecation</code>对象。</p></blockquote><p>也可以在代码中明确指定弃用，方法是将<code>@DeprecatedConfigurationProperty</code>注释添加到属性的getter方法中。例如，假设<code>app.foo.target</code>属性很混乱，并被重命名为<code>app.foo.name</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.foo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeprecatedConfigurationProperty(replacement = &quot;app.foo.name&quot;)</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(String target)</span> </span>&#123;</span><br><span class="line">setName(target);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于代码仍在处理属性，因此无法设置<code>level</code>，因为总是假设<code>warning</code>。</p></blockquote><p>上面的代码确保不推荐使用的属性仍然有效（委托给后台的<code>name</code>属性）。 一旦<code>getTarget</code>和<code>setTarget</code>方法可以从公共API中删除，元数据中的自动弃用提示也将消失。 如果要保留提示，添加具有<code>error</code>弃用级别的手动元数据可确保用户仍被通知该属性，并且在提供<code>replacement</code>时特别有用。</p><h4 id="B-1-3-提示属性"><a href="#B-1-3-提示属性" class="headerlink" title="B.1.3 提示属性"></a>B.1.3 提示属性</h4><p><code>hints</code>数组中的JSON对象可以包含以下属性：</p><table><thead><tr><th>名称</th><th>类型</th><th>目的</th></tr></thead><tbody><tr><td><code>name</code></td><td>String</td><td>这个提示引用的属性的全名。名称以小写的虚线形式（例如<code>server.servlet.path</code>）。 如果该属性引用一个map（例如<code>system.contexts</code>），则该提示要么应用于map的<em>keys</em>（<code>system.context.keys</code>），要么应用于values（<code>system.context.values</code>）。 该属性是强制性的。</td></tr><tr><td><code>values</code></td><td>ValueHint[]</td><td><code>ValueHint</code>对象定义的有效值列表（请参见下文）。 每个条目定义了这个值，并可能有描述信息。</td></tr><tr><td><code>providers</code></td><td>ValueProvider[]</td><td>由<code>ValueProvider</code>对象定义的提供者列表（见下文）。 每个条目定义提供者的名称及其参数（如果有的话）。</td></tr></tbody></table><p>包含在每个<code>hint</code>元素的<code>values</code>属性中的JSON对象可以包含以下属性：</p><table><thead><tr><th>名称</th><th>类型</th><th>目的</th></tr></thead><tbody><tr><td><code>value</code></td><td>Object</td><td>提示引用的元素的有效值。如果属性的类型是一个数组，也可以是一个值的数组。 该属性是强制性的。</td></tr><tr><td><code>description</code></td><td>String</td><td>可以向用户显示的值的简短说明。如果没有可用的描述，可以省略。 建议描述是一个简短的段落，第一行提供一个简明的总结。描述的最后一行应以句点（<code>.</code>）结尾。</td></tr></tbody></table><p>包含在每个<code>hint</code>元素的<code>providers</code>属性中的JSON对象可以包含以下属性：<br>名称|类型|目的<br>–|–|–<br><code>name</code>|String|提供者的名称，用于为提示引用的元素提供其他帮助。<br><code>parameters</code>|JSON object|提供者支持的任何其他参数（有关更多详细信息，请参阅提供者的文档）。</p><h4 id="B-1-4-重复的元数据项目"><a href="#B-1-4-重复的元数据项目" class="headerlink" title="B.1.4 重复的元数据项目"></a>B.1.4 重复的元数据项目</h4><p>具有相同名称的“属性”和“组”对象在元数据文件内出现多次是完全可以接受的。例如，你可以将两个单独的类绑定到相同的前缀，每个类都可能提供重复的属性名称。 尽管这不常见，但是元数据的使用者应该注意确保他们支持这种情况。</p><h3 id="B-2-提供手动提示"><a href="#B-2-提供手动提示" class="headerlink" title="B.2 提供手动提示"></a>B.2 提供手动提示</h3><p>为了改善用户体验并进一步帮助用户配置给定属性，可以提供以下元数据：</p><ul><li>描述一个属性的取值的列表。</li><li>关联一个提供者将一个明确定义的语义附加到属性上，以便工具可以根据该项目的上下文发现取值的列表。</li></ul><h4 id="B-2-1-值提示"><a href="#B-2-1-值提示" class="headerlink" title="B.2.1 值提示"></a>B.2.1 值提示</h4><p>每个提示的<code>name</code>属性引用的是一个属性的<code>name</code>。在上面的例子中，我们为<code>spring.jpa.hibernate.ddl-auto</code>属性提供了5个值：<code>none</code>，<code>validate</code>，<code>update</code>，<code>create</code>和<code>create-drop</code>。 每个值也可以有一个描述。</p><p>如果你的属性是<code>Map</code>类型，则可以为键和值提供提示（但不能为map本身提供）。 必须使用特殊的<code>.keys</code>和<code>.values</code>后缀分别表示键和值。</p><p>让我们假设一个<code>foo.contexts</code>将魔术字符串映射到一个整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;foo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,Integer&gt; contexts;</span><br><span class="line"><span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>魔术值是foo和bar。 为了为keys提供额外的内容帮助，你可以将以下内容添加到<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#configuration-metadata-additional-metadata">模块的手动元数据</a>中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;hints&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;foo.contexts.keys&quot;</span>,</span><br><span class="line"><span class="attr">&quot;values&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然，你应该用<code>Enum</code>来代替这两个值。如果你的IDE支持，这是迄今为止最有效的自动完成方法。</p></blockquote><h4 id="B-2-2-值提供者"><a href="#B-2-2-值提供者" class="headerlink" title="B.2.2 值提供者"></a>B.2.2 值提供者</h4><p>提供者是将语义附加到属性的有效方式。我们在下面的部分定义了官方提供者。但是请记住，你最喜欢的IDE可能会实现其中的一些，或者一个都没有。 它也可以提供它自己的。</p><blockquote><p>由于这是一个新功能，IDE开发商将不得不加上这个新功能。</p></blockquote><p>下表总结了支持的提供者列表：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code>any</code></td><td>允许提供任何额外的值。</td></tr><tr><td><code>class-reference</code></td><td>自动完成项目中可用的类。通常受到通过<code>target</code>参数指定的基类的约束。</td></tr><tr><td><code>handle-as</code></td><td>处理该属性，就好像它是通过强制的<code>target</code>参数定义的类型定义的一样。</td></tr><tr><td><code>logger-name</code></td><td>自动完成有效的日志记录器名称。通常当前项目中可用的包和类名称都可以自动完成。</td></tr><tr><td><code>spring-bean-reference</code></td><td>自动完成当前项目中的可用bean名称。通常受到通过<code>target</code>参数指定的基类的约束。</td></tr><tr><td><code>spring-profile-name</code></td><td>自动完成项目中可用的Spring profile名称。</td></tr></tbody></table><blockquote><p>对于给定的属性，只能有一个提供者处于活动状态，但是如果它们可以通过某种方式来管理属性，则可以指定多个提供者。确保首先放置最强大的提供者，因为IDE必须使用它可以处理的JSON部分中的第一个提供者。如果不支持给定属性的提供者，那么不会提供特别的内容帮助。</p></blockquote><h5 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h5><p><em>any</em>提供者允许提供任何额外的值。如果支持的话，则应该应用基于属性类型的常规值校验。</p><p>如果你有一个值列表，那么通常会使用这个提供者，并且任何额外的值仍将被视为有效的。</p><p>以下示例为<code>system.state</code>的自动完成提供了<code>on</code>和<code>off</code>值;其他的任何值也是允许的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;hints&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;system.state&quot;</span>,</span><br><span class="line"><span class="attr">&quot;values&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;on&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;off&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;providers&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;any&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><h5 id="Class-reference"><a href="#Class-reference" class="headerlink" title="Class reference"></a>Class reference</h5><p><strong>class-reference</strong>提供者自动完成项目中可用的类。这个提供者支持下面这些参数：</p><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>target</code></td><td><code>String</code> (<code>Class</code>)</td><td><em>none</em></td><td>应该分配给所选值的类的完全限定名称。通常用于过滤非候选类。请注意，这些信息可以由类型本身通过暴露具有适当上限的类来提供。</td></tr><tr><td><code>concrete</code></td><td><code>boolean</code></td><td>true</td><td>指定是否只有具体的类被视为有效的候选者。</td></tr></tbody></table><p>下面的元数据片段对应于标准的<code>server.servlet.jsp.class-name</code>属性，该属性定义了要使用的<code>JspServlet</code>类名称：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;hints&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;server.servlet.jsp.class-name&quot;</span>,</span><br><span class="line"><span class="attr">&quot;providers&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;class-reference&quot;</span>,</span><br><span class="line"><span class="attr">&quot;parameters&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;target&quot;</span>: <span class="string">&quot;javax.servlet.http.HttpServlet&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><h5 id="Handle-As"><a href="#Handle-As" class="headerlink" title="Handle As"></a>Handle As</h5><p><strong>handle-as</strong>提供者允许你将属性的类型替换为更高级的类型。当属性具有<code>java.lang.String</code>类型时，通常会发生这种情况，因为你不希望配置类依赖可能不在类路径中的类。 这个提供者支持这些参数：</p><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>target</code></td><td>String (Class)</td><td><em>none</em></td><td>要考虑的属性类型的完全限定名称。该参数是强制性的。</td></tr></tbody></table><p>可以使用以下类型：</p><ul><li>列出属性任何可能值的<code>java.lang.Enum</code>（尝试使用<code>Enum</code>类型定义属性，而不要求IDE自动完成值的进一步提示）。</li><li><code>java.nio.charset.Charset</code>：字符集/编码值的自动完成（例如<code>UTF-8</code>）</li><li><code>java.util.Locale</code>：自动完成语言环境（例如<code>en_US</code>）</li><li><code>org.springframework.util.MimeType</code>：内容类型的自动完成（例如<code>text/plain</code>）</li><li><code>org.springframework.core.io.Resource</code>：自动完成Spring的资源抽象来引用文件系统或类路径上的文件。（例如<code>classpath:/foo.properties</code>）</li></ul><blockquote><p>如果可以提供多个值，请使用<code>Collection</code>或<em>Array</em>类型告诉IDE。</p></blockquote><p>下面的元数据片段对应于标准的<code>spring.liquibase.change-log</code>属性，该属性定义了要使用的更改日志的路径。它实际上是作为<code>org.springframework.core.io.Resource</code>在内部使用的，但是不能被公开，因为我们需要保留原来的String值来传递给Liquibase API。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;hints&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;spring.liquibase.change-log&quot;</span>,</span><br><span class="line"><span class="attr">&quot;providers&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;handle-as&quot;</span>,</span><br><span class="line"><span class="attr">&quot;parameters&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;target&quot;</span>: <span class="string">&quot;org.springframework.core.io.Resource&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><h5 id="Logger-name"><a href="#Logger-name" class="headerlink" title="Logger name"></a>Logger name</h5><p><strong>logger-name</strong>提供者会自动完成有效的日志记录器名称。通常，当前项目中可用的包和类名称都可以自动完成。具体的框架可能会有额外的魔术日志记录器名称，也可以支持。</p><p>由于日志记录器名称可以是任意名称，实际上，此提供者应该允许任何值，但可以突出显示项目类路径中不可用的有效包和类名称。</p><p>下面的元数据片段对应于标准的<code>logging.level</code>属性，keys是<em>日志记录器名称</em>和values对应于标准日志级别或任何自定义级别：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;hints&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;logging.level.keys&quot;</span>,</span><br><span class="line"><span class="attr">&quot;values&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Root logger used to assign the default logging level.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;providers&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;logger-name&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;logging.level.values&quot;</span>,</span><br><span class="line"><span class="attr">&quot;values&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;trace&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;debug&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;info&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;warn&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;error&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;fatal&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="string">&quot;off&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;providers&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;any&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><h5 id="Spring-bean-reference"><a href="#Spring-bean-reference" class="headerlink" title="Spring bean reference"></a>Spring bean reference</h5><p><strong>spring-bean-reference</strong>提供者自动完成在当前项目的配置中定义的bean。这个提供者支持这些参数：</p><table><thead><tr><th>参数</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>target</code></td><td>String (Class)</td><td><em>none</em></td><td>应该可分配给候选者的bean类的完全限定名称。通常用于过滤非候选bean。</td></tr></tbody></table><p>下面的元数据片段对应于定义要使用的<code>MBeanServer</code> bean名称的标准<code>spring.jmx.server</code>属性：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;hints&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;spring.jmx.server&quot;</span>,</span><br><span class="line"><span class="attr">&quot;providers&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;spring-bean-reference&quot;</span>,</span><br><span class="line"><span class="attr">&quot;parameters&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;target&quot;</span>: <span class="string">&quot;javax.management.MBeanServer&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><blockquote><p>绑定器无法感知元数据，所以如果你提供了这个提示，你仍然需要使用<code>ApplicationContext</code>将bean的名字转换成实际的Bean引用。</p></blockquote><h5 id="Spring-profile-name"><a href="#Spring-profile-name" class="headerlink" title="Spring profile name"></a>Spring profile name</h5><p><code>spring-profile-name</code>提供者自动完成在当前项目的配置中定义的Spring profie。</p><p>下面的元数据片段对应于标准<code>spring.profiles.active</code>属性，该属性定义了要启用的Spring profile的名称：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;hints&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;spring.profiles.active&quot;</span>,</span><br><span class="line"><span class="attr">&quot;providers&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;spring-profile-name&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><h3 id="B-3-使用注解处理器生成你自己的元数据"><a href="#B-3-使用注解处理器生成你自己的元数据" class="headerlink" title="B.3 使用注解处理器生成你自己的元数据"></a>B.3 使用注解处理器生成你自己的元数据</h3><p>你可以通过使用<code>spring-boot-configuration-processor</code>jar，轻松地从带有<code>@ConfigurationProperties</code>的项目中生成自己的配置元数据文件。这个jar包括一个Java注解处理器，它在你的项目编译时调用。要使用这个处理器，只需将<code>spring-boot-configuration-processor</code>作为一个可选的依赖项，例如，你可以在Maven中添加:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Gradle中你可以使用<a href="https://github.com/spring-gradle-plugins/propdeps-plugin">propdeps-plugin</a>，并指定:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">optional &quot;org.springframework.boot:spring-boot-configuration-processor&quot;</span><br><span class="line">&#125;</span><br><span class="line">compileJava.dependsOn(processResources)</span><br></pre></td></tr></table></figure><blockquote><p>你需要向构建添加<code>compileJava.dependsOn(processResources)</code>，以确保在编译代码之前处理资源。没有这个指令，任何<code>additional-spring-configuration-metadata.json</code>文件都不会被处理。</p></blockquote><p>处理器将会选择带有<code>@ConfigurationProperties</code>的类和方法。配置类中用于字段的Javadoc将用于填充<code>description</code>属性。</p><blockquote><p>你应该只使用带有<code>@ConfigurationProperties</code>字段Javadoc的简单文本，因为它们在被添加到JSON之前不会被处理。</p></blockquote><p>属性是通过标准的getter和setter方法而发现的，这些设置对于集合类型有特殊的处理(即使只有一个getter存在，也会被检测到)。注解处理器还支持使用<code>@Data</code>、<code>@Getter</code>和<code>@Setter</code> lombok注解。</p><blockquote><p>如果你在项目中使用了AspectJ，则需要确保注解处理器只运行一次。有几种方法可以做到这一点:使用Maven时，你可以显式地配置<code>maven-apt-plugin</code>，并且只在这里添加注解处理器依赖。你还可以在<code>maven-compiler-plugin</code>配置AspectJ插件运行所有处理和禁用注解处理:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">proc</span>&gt;</span>none<span class="tag">&lt;/<span class="name">proc</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="B-3-1-内部属性"><a href="#B-3-1-内部属性" class="headerlink" title="B.3.1 内部属性"></a>B.3.1 内部属性</h4><p>注解处理器会自动将内部类视为嵌套的属性。例如下面的类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;server&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Host host;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... getter and setters</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... getter and setters</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码将为<code>server.name</code>、<code>server.host.ip</code>、<code>server.host.port</code>属性生成元数据信息。你可以使用<code>@NestedConfigurationProperty</code>注解字段表明这个常规(non-inner)类应该被视为嵌套类。</p><blockquote><p>这对集合和map没有影响，因为这些类型是自动识别的，并且为每个类型生成一个元数据属性。</p></blockquote><h4 id="B-3-2-添加额外的元数据"><a href="#B-3-2-添加额外的元数据" class="headerlink" title="B.3.2 添加额外的元数据"></a>B.3.2 添加额外的元数据</h4><p>Spring Boot的配置文件处理非常灵活;而且通常情况下属性可能存在不绑定到<code>@ConfigurationProperties</code> bean的情况。你可能还需要调整现有key的某些属性。为了支持这种情况，并允许你提供自定义的“提示”，注解处理器将自动地将来自<code>META-INF/additional-spring-configuration-metadata.json</code>的项目合并到主元数据文件中。</p><p>如果你引用了自动检测到的属性，则会在指定时重写说明，默认值和弃用信息。如果在当前模块中没有识别手动属性声明，则将其添加为新的属性。</p><p><code>additional-spring-configuration-metadata.json</code>文件的格式与常规的<code>spring-configuration-metadata.json</code>完全相同。额外的属性文件是可选的，如果你没有任何额外的属性，不要添加它。</p><h2 id="附录-C-自动配置类"><a href="#附录-C-自动配置类" class="headerlink" title="附录 C. 自动配置类"></a>附录 C. 自动配置类</h2><p>以下是Spring Boot提供的所有自动配置类的列表，包含文档和源代码的链接。请记住在应用程序中查看autoconfig报告，了解哪些功能可以打开。（使用<code>--debug</code>或<code>-Ddebug</code>启动应用程序，或者在Actuator应用程序中使用<code>autoconfig</code>端点）。</p><h3 id="C-1-来自“spring-boot-autoconfigure”模块"><a href="#C-1-来自“spring-boot-autoconfigure”模块" class="headerlink" title="C.1 来自“spring-boot-autoconfigure”模块"></a>C.1 来自“spring-boot-autoconfigure”模块</h3><p>以下自动配置类来自<code>spring-boot-autoconfigure</code>模块：</p><table><thead><tr><th>配置类</th><th>链接</th></tr></thead><tbody><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQAutoConfiguration.java"><code>ActiveMQAutoConfiguration</code></a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/aop/AopAutoConfiguration.java"><code>AopAutoConfiguration</code></a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/aop/AopAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisAutoConfiguration.java"><code>ArtemisAutoConfiguration</code></a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/jms/artemis/ArtemisAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/BatchAutoConfiguration.java"><code>BatchAutoConfiguration</code></a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/batch/BatchAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/cache/CacheAutoConfiguration.java"><code>CacheAutoConfiguration</code></a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/cache/CacheAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/cassandra/CassandraAutoConfiguration.java"><code>CassandraAutoConfiguration</code></a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/cassandra/CassandraAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/cassandra/CassandraDataAutoConfiguration.java">CassandraDataAutoConfiguration</a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/data/cassandra/CassandraDataAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/cassandra/CassandraReactiveDataAutoConfiguration.java">CassandraReactiveDataAutoConfiguration</a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/data/cassandra/CassandraReactiveDataAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/cassandra/CassandraReactiveRepositoriesAutoConfiguration.java">CassandraReactiveRepositoriesAutoConfiguration</a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/data/cassandra/CassandraReactiveRepositoriesAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/cassandra/CassandraRepositoriesAutoConfiguration.java">CassandraRepositoriesAutoConfiguration</a><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/data/cassandra/CassandraRepositoriesAutoConfiguration.html">javadoc</a></td><td></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/cloud/CloudAutoConfiguration.java">CloudAutoConfiguration</a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/cloud/CloudAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/http/codec/CodecsAutoConfiguration.java">CodecsAutoConfiguration</a><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/http/codec/CodecsAutoConfiguration.html">javadoc</a></td><td></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/ConfigurationPropertiesAutoConfiguration.java">ConfigurationPropertiesAutoConfiguration</a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/context/ConfigurationPropertiesAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/couchbase/CouchbaseAutoConfiguration.java">CouchbaseAutoConfiguration</a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/couchbase/CouchbaseAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/couchbase/CouchbaseDataAutoConfiguration.java">CouchbaseDataAutoConfiguration</a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/data/couchbase/CouchbaseDataAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/data/couchbase/CouchbaseRepositoriesAutoConfiguration.java">CouchbaseRepositoriesAutoConfiguration</a><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/data/couchbase/CouchbaseRepositoriesAutoConfiguration.html">javadoc</a></td><td></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java">DataSourceAutoConfiguration</a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceTransactionManagerAutoConfiguration.java">DataSourceTransactionManagerAutoConfiguration</a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/jdbc/DataSourceTransactionManagerAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mobile/DeviceDelegatingViewResolverAutoConfiguration.java">DeviceDelegatingViewResolverAutoConfiguration</a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/mobile/DeviceDelegatingViewResolverAutoConfiguration.html">javadoc</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mobile/DeviceResolverAutoConfiguration.java">DeviceResolverAutoConfiguration</a></td><td><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/autoconfigure/mobile/DeviceResolverAutoConfiguration.html">javadoc</a></td></tr></tbody></table><p><a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#auto-configuration-classes-from-autoconfigure-module">更多查看</a></p><h3 id="C-2-来自“spring-boot-actuator-autoconfigure”模块"><a href="#C-2-来自“spring-boot-actuator-autoconfigure”模块" class="headerlink" title="C.2 来自“spring-boot-actuator-autoconfigure”模块"></a>C.2 来自“spring-boot-actuator-autoconfigure”模块</h3><p>以下自动配置类来自<code>spring-boot-actuator-autoconfigure</code>模块：</p><h2 id="附录-D-测试自动配置注解"><a href="#附录-D-测试自动配置注解" class="headerlink" title="附录 D. 测试自动配置注解"></a>附录 D. 测试自动配置注解</h2><p>以下是各种<code>@...Test</code>注解的表格，可用于测试应用程序以及默认导入的自动配置：</p><h2 id="附录-E-可执行的jar格式"><a href="#附录-E-可执行的jar格式" class="headerlink" title="附录 E. 可执行的jar格式"></a>附录 E. 可执行的jar格式</h2><p><code>Spring-Boot-loader</code>模块允许Spring Boot支持可执行的jar和war文件。如果你使用的是Maven或Gradle插件，会自动生成可执行jar，你通常不需要知道它们的工作细节。</p><p>如果你需要从不同的构建系统创建可执行的JAR，或者你只是对底层技术感兴趣，本节将提供一些背景知识。</p><h3 id="E-1-内部jar"><a href="#E-1-内部jar" class="headerlink" title="E.1 内部jar"></a>E.1 内部jar</h3><p>Java不提供任何标准的方法来加载嵌套的jar文件（即jar文件本身包含在jar中）。 如果你想分发一个自包含的应用程序，可以从命令行运行而不需要解压，这可能会有问题。</p><p>为了解决这个问题，许多开发者使用“shaded”jar。shaded jar简单地把所有的类从所有的jar中包装成一个“超级jar”。shaded jar的问题在于，很难在应用程序中看到实际使用的库。如果在多个jar中使用相同的文件名（但是具有不同的内容），则有可能是有问题的。 Spring Boot采用了不同的方法，可以直接嵌入jar。</p><h4 id="E-1-1-可执行的jar文件结构"><a href="#E-1-1-可执行的jar文件结构" class="headerlink" title="E.1.1 可执行的jar文件结构"></a>E.1.1 可执行的jar文件结构</h4><p>Spring Boot Loader兼容的jar文件应该按照以下方式构建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example.jar</span><br><span class="line"> |</span><br><span class="line"> +-META-INF</span><br><span class="line"> |  +-MANIFEST.MF</span><br><span class="line"> +-org</span><br><span class="line"> |  +-springframework</span><br><span class="line"> |     +-boot</span><br><span class="line"> |        +-loader</span><br><span class="line"> |           +-&lt;spring boot loader classes&gt;</span><br><span class="line"> +-BOOT-INF</span><br><span class="line">    +-classes</span><br><span class="line">    |  +-mycompany</span><br><span class="line">    |     +-project</span><br><span class="line">    |        +-YourClasses.class</span><br><span class="line">    +-lib</span><br><span class="line">       +-dependency1.jar</span><br><span class="line">       +-dependency2.jar</span><br></pre></td></tr></table></figure><p>应用程序类应放置在嵌套的<code>BOOT-INF/classes</code>目录中。依赖应该放在一个嵌套的<code>BOOT-INF/lib</code>目录中。</p><h4 id="E-1-2-可执行的war文件结构"><a href="#E-1-2-可执行的war文件结构" class="headerlink" title="E.1.2 可执行的war文件结构"></a>E.1.2 可执行的war文件结构</h4><p>Spring Boot Loader兼容的war文件应该按以下方式构建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">example.war</span><br><span class="line"> |</span><br><span class="line"> +-META-INF</span><br><span class="line"> |  +-MANIFEST.MF</span><br><span class="line"> +-org</span><br><span class="line"> |  +-springframework</span><br><span class="line"> |     +-boot</span><br><span class="line"> |        +-loader</span><br><span class="line"> |           +-&lt;spring boot loader classes&gt;</span><br><span class="line"> +-WEB-INF</span><br><span class="line">    +-classes</span><br><span class="line">    |  +-com</span><br><span class="line">    |     +-mycompany</span><br><span class="line">    |        +-project</span><br><span class="line">    |           +-YourClasses.class</span><br><span class="line">    +-lib</span><br><span class="line">    |  +-dependency1.jar</span><br><span class="line">    |  +-dependency2.jar</span><br><span class="line">    +-lib-provided</span><br><span class="line">       +-servlet-api.jar</span><br><span class="line">       +-dependency3.jar</span><br></pre></td></tr></table></figure><p>依赖应放置在嵌套的<code>WEB-INF/lib</code>目录中。运行时所需的任何嵌入式，但在部署到传统Web容器时不需要的依赖，则应放在<code>WEB-INF/lib-provided</code>目录。</p><h3 id="E-2-Spring-Boot的“JarFile”类"><a href="#E-2-Spring-Boot的“JarFile”类" class="headerlink" title="E.2 Spring Boot的“JarFile”类"></a>E.2 Spring Boot的“JarFile”类</h3><p>用于支持加载嵌套jar的核心类是<code>org.springframework.boot.loader.jar.JarFile</code>。 它允许你从标准的jar文件或嵌套的子jar数据中加载jar内容。第一次加载时，每个<code>JarEntry</code>的位置都会映射到外部jar的物理文件偏移量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myapp.jar</span><br><span class="line">+-------------------+-------------------------+</span><br><span class="line">| &#x2F;BOOT-INF&#x2F;classes | &#x2F;BOOT-INF&#x2F;lib&#x2F;mylib.jar |</span><br><span class="line">|+-----------------+||+-----------+----------+|</span><br><span class="line">||     A.class      |||  B.class  |  C.class ||</span><br><span class="line">|+-----------------+||+-----------+----------+|</span><br><span class="line">+-------------------+-------------------------+</span><br><span class="line"> ^                    ^           ^</span><br><span class="line"> 0063                 3452        3980</span><br></pre></td></tr></table></figure><p> 上面的例子显示了如何在<code>myapp.jar</code>的<code>0063</code>位置的<code>/BOOT-INF/classes</code>中找到<code>A.class</code>。嵌套jar中的<code>B.class</code>实际上可以在<code>myapp.jar</code>中<code>3452</code>位置找到，而<code>C.class</code>位于<code>3980</code>。</p><p> 有了这些信息，我们可以通过简单地寻找外部jar的适当部分来加载特定的嵌套条目。 我们不需要解压，也不需要把所有的录入数据读入内存。</p><h4 id="E-2-1-与标准Java“JarFile”兼容"><a href="#E-2-1-与标准Java“JarFile”兼容" class="headerlink" title="E.2.1 与标准Java“JarFile”兼容"></a>E.2.1 与标准Java“JarFile”兼容</h4><p>Spring Boot Loader努力与现有的代码和库保持兼容。<code>org.springframework.boot.loader.jar.JarFile</code>继承自<code>java.util.jar.JarFile</code>，应该首先考虑。<code>getURL()</code>方法将返回一个<code>URL</code>，该URL打开一个与<code>java.net.JarURLConnection</code>兼容的连接，并可以与Java的<code>URLClassLoader</code>一起使用。</p><h3 id="E-3-启动可执行文件"><a href="#E-3-启动可执行文件" class="headerlink" title="E.3 启动可执行文件"></a>E.3 启动可执行文件</h3><p><code>org.springframework.boot.loader.Launcher</code>类是一个特殊的引导类，它被用作可执行jar的主入口点。它是jar文件中实际的<code>Main-Class</code>，它用于设置一个合适的<code>URLClassLoader</code>并最终调用你的<code>main()</code>方法。</p><p>有3个子类启动器(<code>JarLauncher</code>、<code>WarLauncher</code>和<code>PropertiesLauncher</code>)。它们的目的是加载来自内部的jar文件中的资源(<code>.class</code>文件等)或目录中的war文件(类路径上)。在<code>JarLauncher</code>和<code>WarLauncher</code>的情况下，内部的路径是固定的。<code>JarLauncher</code>在<code>BOOT-INF/lib/</code>中查找，而<code>WarLauncher</code>在<code>WEB-INF/lib</code>和<code>/和WEB-INF/lib-provided/</code>中查找，所以如果需要更多的话，只需在这些位置添加额外的jar文件。默认情况下，<code>PropertiesLauncher</code>在你的应用程序包<code>BOOT-INF/lib/</code>中查找文件，但是你可以通过设置一个环境变量<code>LOADER_PATH</code>或在<code>loader.properties</code>中设置<code>loader.path</code>属性来添加额外的位置(逗号分隔的目录，档案或档案中的目录的列表)。</p><h4 id="E-3-1-启动程序清单"><a href="#E-3-1-启动程序清单" class="headerlink" title="E.3.1 启动程序清单"></a>E.3.1 启动程序清单</h4><p>你需要指定一个适当的<code>Launcher</code>作为<code>META-INF/MANIFEST.MF</code>中的<code>Main-Class</code>属性。 应该在<code>Start-Class</code>属性中指定要启动的实际类（即，你编写的包含<code>main</code>方法的类）。</p><p>例如，以下是可执行jar文件的一个典型<code>MANIFEST.MF</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br><span class="line">Start-Class: com.mycompany.project.MyApplication</span><br></pre></td></tr></table></figure><p>对于war文件，这将是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main-Class: org.springframework.boot.loader.WarLauncher</span><br><span class="line">Start-Class: com.mycompany.project.MyApplication</span><br></pre></td></tr></table></figure><blockquote><p>你不需要在清单文件中指定<code>Class-Path</code>项，类路径将从嵌套的jar文件中推导出来。</p></blockquote><h4 id="E-3-2-解压包"><a href="#E-3-2-解压包" class="headerlink" title="E.3.2 解压包"></a>E.3.2 解压包</h4><p>某些PaaS实现可能会选择在运行之前解压包文件。 例如，Cloud Foundry就是以这种方式运行的。你可以通过简单地启动适当的启动程序运行一个解压的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ unzip -q myapp.jar</span><br><span class="line">$ java org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure><h3 id="E-4-PropertiesLauncher特性"><a href="#E-4-PropertiesLauncher特性" class="headerlink" title="E.4 PropertiesLauncher特性"></a>E.4 PropertiesLauncher特性</h3><p><code>PropertiesLauncher</code>具有一些可以使用外部属性（系统属性，环境变量，清单条目或<code>loader.properties</code>）启用的特殊功能。</p><table><thead><tr><th>Key</th><th>目的</th></tr></thead><tbody><tr><td><code>loader.path</code></td><td>逗号分隔的类路径，例如<code>lib,$&#123;HOME&#125;/app/lib</code>。 前面的项目优先，就像<code>javac</code>命令行上的常规<code>-classpath</code>参数一样。</td></tr><tr><td><code>loader.home</code></td><td>用于解析<code>loader.path</code>中的相对路径。例如<code>loader.path=lib</code>然后<code>$&#123;loader.home&#125;/lib</code>是一个类路径位置（以及该目录中的所有jar文件）。还用于查找<code>loader.properties</code>文件。例如<code>/opt/app</code>（默认为<code>$&#123;user.dir&#125;</code>）。</td></tr><tr><td><code>loader.args</code></td><td>main方法的默认参数（空格分隔）</td></tr><tr><td><code>loader.main</code></td><td>要启动的主类的名称<code>com.app.Application</code></td></tr><tr><td><code>loader.config.name</code></td><td>属性文件的名称，例如 <code>launcher</code>（默认为<code>loader</code>）。</td></tr><tr><td><code>loader.config.location</code></td><td>属性文件的路径，例如<code>classpath:loader.properties</code>（默认为<code>loader.properties</code>）。</td></tr><tr><td><code>loader.system</code></td><td>布尔标志，指示应将所有属性添加到系统属性（默认为<code>false</code>）</td></tr></tbody></table><p>当指定为环境变量或清单项时，应使用以下名称：</p><table><thead><tr><th>Key</th><th>Manifest 项</th><th>环境变量</th></tr></thead><tbody><tr><td><code>loader.path</code></td><td><code>Loader-Path</code></td><td><code>LOADER_PATH</code></td></tr><tr><td><code>loader.home</code></td><td><code>Loader-Home</code></td><td><code>LOADER_HOME</code></td></tr><tr><td><code>loader.args</code></td><td><code>Loader-Args</code></td><td><code>LOADER_ARGS</code></td></tr><tr><td><code>loader.main</code></td><td><code>Start-Class</code></td><td><code>LOADER_MAIN</code></td></tr><tr><td><code>loader.config.location</code></td><td><code>Loader-Config-Location</code></td><td><code>LOADER_CONFIG_LOCATION</code></td></tr><tr><td><code>loader.system</code></td><td><code>Loader-System</code></td><td><code>LOADER_SYSTEM</code></td></tr></tbody></table><blockquote><p>构建fat jar时，构建插件会自动将<code>Main-Class</code>属性移动到<code>Start-Class</code>。如果你正在使用它，请使用<code>Main-Class</code>属性指定要启动的类的名称，并省略<code>Start-Class</code>.</p></blockquote><ul><li>首先在<code>loader.home</code>中搜索<code>loader.properties</code>，然后在类路径的根目录中，然后在<code>classpath:/BOOT-INF/classes</code>中搜索。会使用找到的第一个目录中的文件。</li><li><code>loader.home</code> 只要<code>loader.config.location</code>没有指定, <code>loader.home</code> 只是一个额外的属性文件的目录位置（覆盖默认值）。</li><li><code>loader.path</code>可以包含目录（递归扫描jar和zip文件），归档路径，扫描jar文件（例如<code>dependencies.jar!/lib</code>）的归档文件中的目录，或者通配符（用于默认JVM行为）。归档路径可以相对于<code>loader.home</code>或文件系统中具有<code>jar:file:</code>前缀的任何位置。</li><li><code>loader.path</code>（如果为空）默认为<code>BOOT-INF/lib</code>（表示本地目录或从存档运行的嵌套目录）。正因为如此，在没有提供额外的配置时，<code>PropertiesLauncher</code>与<code>JarLauncher</code>的行为相同。</li><li><code>loader.path</code>不能用于配置<code>loader.properties</code>的位置（用于搜索后者的类路径是启动<code>PropertiesLauncher</code>时的JVM类路径）。</li><li>占位符替换是在使用前从系统和环境变量加上属性文件本身对所有值进行的。</li><li>属性的搜索顺序（在多个地方查找是有意义的）是环境变量，系统属性，<code>loader.properties</code>，展开的归档清单，归档清单。</li></ul><h3 id="E-5-可执行的jar限制"><a href="#E-5-可执行的jar限制" class="headerlink" title="E.5 可执行的jar限制"></a>E.5 可执行的jar限制</h3><p>在使用Spring Boot Loader打包的应用程序时，需要考虑许多限制。</p><h4 id="E-5-1-Zip压缩"><a href="#E-5-1-Zip压缩" class="headerlink" title="E.5.1 Zip压缩"></a>E.5.1 Zip压缩</h4><p>必须使用<code>ZipEntry.STORED</code>方法保存嵌套jar的<code>ZipEntry</code>。这是必需的，以便我们可以直接查找嵌套jar中的单个内容。嵌套的jar文件本身的内容仍然可以被压缩，外层jar中的任何其他条目也可以被压缩。</p><h4 id="E-5-2-System-ClassLoader"><a href="#E-5-2-System-ClassLoader" class="headerlink" title="E.5.2 System ClassLoader"></a>E.5.2 System ClassLoader</h4><p>启动的应用程序应该在加载类时使用<code>Thread.getContextClassLoader()</code>（大多数库和框架默认会这样做）。尝试通过<code>ClassLoader.getSystemClassLoader()</code>加载嵌套的jar类将会失败。 请注意，<code>java.util.Logging</code>总是使用系统类加载器，因此你应该考虑使用不同的日志记录实现。</p><h3 id="E-6-单jar替代方案"><a href="#E-6-单jar替代方案" class="headerlink" title="E.6 单jar替代方案"></a>E.6 单jar替代方案</h3><p>如果上面的限制意味着你不能使用Spring Boot Loader，可以考虑下面的选择：</p><ul><li><a href="http://maven.apache.org/plugins/maven-shade-plugin/">Maven Shade Plugin</a></li><li><a href="http://www.jdotsoft.com/JarClassLoader.php">JarClassLoader</a></li><li><a href="http://one-jar.sourceforge.net/">OneJar</a></li></ul><h2 id="附录-F-依赖版本"><a href="#附录-F-依赖版本" class="headerlink" title="附录 F. 依赖版本"></a>附录 F. 依赖版本</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> 附录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 九 - “How-to” 指南</title>
      <link href="/post/6b4e/"/>
      <url>/post/6b4e/</url>
      
        <content type="html"><![CDATA[<p>本节提供了一些常见的“如何做…”类型的问题的答案，这些问题在使用Spring Boot时经常出现。 这绝对不是详尽的列表，但它确实涵盖了很多。</p><p>如果你有一个我们没在这里介绍的特定问题，你可能需要访问 <a href="http://stackoverflow.com/tags/spring-boot">stackoverflow.com</a> 来查看是否有其他人已经提供了答案; 这也是提出新问题的好地方（请使用<code>spring-boot</code>标签）。</p><p>我们也很乐意扩展这一节;如果你想添加一个“操作指南”，你可以向我们发送一个<a href="https://github.com/spring-projects/spring-boot/tree/master">pull request</a>。</p><h2 id="Spring-Boot-应用"><a href="#Spring-Boot-应用" class="headerlink" title="Spring Boot 应用"></a>Spring Boot 应用</h2><h3 id="创建自己的FailureAnalyzer"><a href="#创建自己的FailureAnalyzer" class="headerlink" title="创建自己的FailureAnalyzer"></a>创建自己的FailureAnalyzer</h3><p><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/diagnostics/FailureAnalyzer.html">FailureAnalyzer``</a>是在启动时拦截异常的好方法，并将其转换为可读的消息，将其封装到<a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/diagnostics/FailureAnalysis.html"><code>FailureAnalysis</code></a>中。Spring Boot为应用程序上下文相关的异常、jsr-303验证等提供了这样的分析器。实际上，也很容易创建自己的分析器。</p><p><code>AbstractFailureAnalyzer</code>是<code>FailureAnalyzer</code>的一个方便的扩展，它检查异常中指定的异常类型的存在。你可以从它扩展，以便你的实现只有在实际存在时才有机会处理异常。如果出于某种原因，你无法处理异常，则返回<code>null</code>以给另一个实现一个处理异常的机会。</p><p><code>FailureAnalyzer</code>的实现可以注册到<code>META-INF/spring.factories</code>，例如：<code>ProjectConstraintViolationFailureAnalyzer</code>: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.diagnostics.FailureAnalyzer&#x3D;\</span><br><span class="line">com.example.ProjectConstraintViolationFailureAnalyzer</span><br></pre></td></tr></table></figure><h3 id="排除自动配置故障"><a href="#排除自动配置故障" class="headerlink" title="排除自动配置故障"></a>排除自动配置故障</h3><p>Spring Boot 自动配置尽可能做“正确的事情”，但是有时候失败了并且很难告知为何失败。</p><p>在任何 Spring Boot <code>ApplicationContext</code>中有一个非常有用的<code>ConditionEvaluationReport</code>。如果启用了<code>DEBUG</code>日志输出，你将看到它。如果你使用<code>spring-boot-actuator</code>，也有一个<code>autoconfig</code>端点，该端点以JSON的格式呈现报表。使用它来调试应用程序，并查看Spring Boot 在运行时添加了哪些特性(没有哪些特性)。</p><p>可以通过查看源代码和Javadoc来回答更多的问题。下面是一些经验法则:</p><ul><li>查找名为<code>*AutoConfiguration</code>的类，并读取它们的源代码，特别是<code>@Conditional*</code>，以找出它们启用和何时启用的功能。添加<code>-debug</code>到命令行或系统属性<code>-Ddebug</code>，这样可以在控制台上打印应用程序中所做的所有自动配置决策的日志。在运行的Actuator 应用程序中，可以查看<code>autoconfig</code>端点(<code>/application/autoconfig</code>或类似的JMX的端点)获取相同的信息。</li><li>寻找<code>@ConfigurationProperties</code>(例如<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java"><code>ServerProperties</code></a>)类，并从那里读取可用的外部配置选项。<code>@ConfigurationProperties</code>有一个<code>name</code>属性，它充当外部属性的前缀，因此<code>ServerProperties</code>有<code>prefix=&quot;server&quot;</code>，其配置属性是<code>server.port</code>, <code>server.address</code>等。在一个运行的 Actuator 应用程序中，可以查看<code>configprops</code>端点。</li><li>查找<code>Binder</code>的<code>bind</code>方法的用法，来以一种轻松的方式从<code>Environment</code>中明确地拉出配置值。它经常被用作前缀。</li><li>查找直接绑定到<code>Environment</code>的<code>@Value</code>注解。</li><li>查找<code>@ConditionalOnExpression</code>注释，它在SpEL表达式中有开关的功能，通常使用从<code>Environment</code>中解析的占位符来进行计算。</li></ul><h3 id="在开始之前自定义Environment或ApplicationContext"><a href="#在开始之前自定义Environment或ApplicationContext" class="headerlink" title="在开始之前自定义Environment或ApplicationContext"></a>在开始之前自定义Environment或ApplicationContext</h3><p><code>SpringApplication</code>拥有 <code>ApplicationListeners</code>和<code>ApplicationContextInitializers</code>，用于定制上下文或环境。Spring Boot 从<code>META-INF/spring.factories</code>加载了许多这样的内部使用的自定义。有不止一种方法可以注册额外的:</p><ul><li>在运行之前，通过在<code>SpringApplication</code>上以编程的方式调用<code>addListeners</code>和<code>addInitializers</code>方法。</li><li>通过设置<code>context.initializer.classes</code>或<code>context.listener.classes</code>来声明。</li><li>通过添加<code>META-INF/spring.factories</code>来声明并打包成一个jar文件，所有应用程序都将其作为一个库使用。</li></ul><p><code>SpringApplication</code>向监听器发送一些特殊的<code>ApplicationEvents</code>(有些甚至在创建上下文之前)，然后注册<code>ApplicationContext</code>所发布的事件的监听器。请参阅“Spring Boot特性”小节中的“<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-application-events-and-listeners">应用程序事件和监听器</a>”部分以获得完整的列表。</p><p>也可以在使用<code>EnvironmentPostProcessor</code>刷新应用程序上下文之前自定义<code>Environment</code>。每个实现都应该在<code>META-INF/spring.factories</code>中注册:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.env.EnvironmentPostProcessor&#x3D;com.example.YourEnvironmentPostProcessor</span><br></pre></td></tr></table></figure><p>该实现可以加载任意文件并将其添加到<code>Environment</code>中。例如，下面这个例子从类路径加载一个YAML配置文件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvironmentPostProcessorExample</span> <span class="keyword">implements</span> <span class="title">EnvironmentPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> YamlPropertySourceLoader loader = <span class="keyword">new</span> YamlPropertySourceLoader();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessEnvironment</span><span class="params">(ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="function"><span class="params">SpringApplication application)</span> </span>&#123;</span><br><span class="line">Resource path = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;com/example/myapp/config.yml&quot;</span>);</span><br><span class="line">PropertySource&lt;?&gt; propertySource = loadYaml(path);</span><br><span class="line">environment.getPropertySources().addLast(propertySource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> PropertySource&lt;?&gt; loadYaml(Resource path) &#123;</span><br><span class="line"><span class="keyword">if</span> (!path.exists()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Resource &quot;</span> + path + <span class="string">&quot; does not exist&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.loader.load(<span class="string">&quot;custom-resource&quot;</span>, path, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">&quot;Failed to load yaml configuration from &quot;</span> + path, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在默认情况下，<code>Environment</code>已经准备好了所有常见的Spring Boot 加载的属性。因此，可以从环境中获取文件的位置。这个例子在列表的末尾添加了<code>custom-resource</code>属性源，因此在其他任何位置中定义的键都是有优先级的。自定义的实现可以明确地定义其他顺序。</p></blockquote><blockquote><p>虽然在你的<code>@SpringBootApplication</code>上使用<code>@PropertySource</code>似乎很方便，而且很容易在<code>Environment</code>中加载自定义资源，但是我们并不推荐它，因为Spring Boot 会在<code>ApplicationContext</code>刷新之前准备好<code>Environment</code>。通过<code>@PropertySource</code>定义的任何key 都将被加载得太晚以至于不会对自动配置产生任何影响。</p></blockquote><h3 id="构建ApplicationContext层次结构（添加父或上下文）"><a href="#构建ApplicationContext层次结构（添加父或上下文）" class="headerlink" title="构建ApplicationContext层次结构（添加父或上下文）"></a>构建ApplicationContext层次结构（添加父或上下文）</h3><p>你可以使用<code>ApplicationBuilder</code>类来创建父/子<code>ApplicationContext</code>层次结构。参见“Spring Boot 功能”部分的“<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-fluent-builder-api">流式构建器API</a>”部分，了解更多信息。</p><h3 id="创建非web应用"><a href="#创建非web应用" class="headerlink" title="创建非web应用"></a>创建非web应用</h3><p>并非所有Spring 应用程序都必须是web应用程序(或web服务)。如果你想要在<code>main</code>方法中执行一些代码，但是也要启动一个Spring应用程序来设置要使用的基础组件，那么使用Spring Boot的<code>SpringSpringApplication</code>特性这事就很容易了。一个<code>SpringApplication</code>根据它是否需要一个web应用程序来更改它的<code>ApplicationContext</code>类。你可以做的第一件事就是将servlet API依赖从类路径中去除。如果你不能这样做(例如，你从相同的代码库运行两个应用程序)，那么你可以在你的<code>SpringApplication</code>实例上显式地调用<code>setWebEnvironment(false)</code>方法，或者设置<code>applicationContextClass</code>属性(通过Java API或外部属性)。你希望作为业务逻辑运行的应用程序代码可以作为<code>CommandLineRunner</code>实现，并作为一个<code>@Bean</code>定义注入上下文中。</p><h2 id="属性和配置"><a href="#属性和配置" class="headerlink" title="属性和配置"></a>属性和配置</h2><h3 id="在构建时自动展开属性"><a href="#在构建时自动展开属性" class="headerlink" title="在构建时自动展开属性"></a>在构建时自动展开属性</h3><p>你可以使用现有的构建配置自动地扩展它们，而不是在你的项目的构建配置中硬编码指定的一些属性。这在Maven和Gradle中都是可能的。</p><h4 id="使用Maven自动展开属性"><a href="#使用Maven自动展开属性" class="headerlink" title="使用Maven自动展开属性"></a>使用Maven自动展开属性</h4><p>你可以使用资源过滤来自动展开Maven项目中的属性。如果你使用了<code>spring-boot-starter-parent</code>，那么你可以通过<code>@..@</code>占位符访问Maven项目属性。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.encoding&#x3D;@project.build.sourceEncoding@</span><br><span class="line">app.java.version&#x3D;@java.version@</span><br></pre></td></tr></table></figure><blockquote><p>只有生产配置才能通过这种方式过滤（比如<code>src/test/resources</code>中不会过滤）。</p></blockquote><blockquote><p>如果你启用了<code>addResources</code>标志，<code>spring-boot:run</code>可以将<code>src/main/resources</code>直接添加到classpath中(出去热加载的目的)。这将绕过资源过滤和这个功能。你可以使用<code>exec:java</code> goal或者自定义这个插件的配置，查看<a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/maven-plugin//usage.html">插件使用页面</a>获取更多细节。</p></blockquote><p>如果你没有使用starter parent，你需要在<code>pom.xml</code>(在<code>&lt;build/&gt;元素中</code>)加入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;</span><br><span class="line">&lt;filtering&gt;true&lt;&#x2F;filtering&gt;</span><br><span class="line">&lt;&#x2F;resource&gt;</span><br><span class="line">&lt;&#x2F;resources&gt;</span><br></pre></td></tr></table></figure><p>和(<code>&lt;plugins/&gt;</code>中)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-resources-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.7&lt;&#x2F;version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;delimiters&gt;</span><br><span class="line">&lt;delimiter&gt;@&lt;&#x2F;delimiter&gt;</span><br><span class="line">&lt;&#x2F;delimiters&gt;</span><br><span class="line">&lt;useDefaultDelimiters&gt;false&lt;&#x2F;useDefaultDelimiters&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果你在配置中使用了标准的Spring占位符(例如：<code>$&#123;foo&#125;</code>)，<code>useDefaultDelimiters</code>属性非常重要。如果没有设置为<code>false</code>，这些也将会被展开。</p></blockquote><h4 id="使用Gradle自动展开属性"><a href="#使用Gradle自动展开属性" class="headerlink" title="使用Gradle自动展开属性"></a>使用Gradle自动展开属性</h4><p>你可以通过配置Java插件的<code>processResources</code>任务来自动展开Gradle项目的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">processResources &#123;</span><br><span class="line">expand(project.properties)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以通过占位符引用Gradle项目属性，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.name&#x3D;$&#123;name&#125;</span><br><span class="line">app.description&#x3D;$&#123;description&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Gradle的<code>expand</code>方法使用Groovy的<code>SimpleTemplateEngine</code>,它将转换<code>$&#123;...&#125;</code>标志。<code>$&#123;..&#125;</code>样式与Spring自己的属性占位符技术有冲突。为了一起使用Spring的属性占位符和自动展开，你需要转义<code>\$&#123;..&#125;</code>Spring 的属性占位符。</p></blockquote><h3 id="外部化SpringApplication的配置"><a href="#外部化SpringApplication的配置" class="headerlink" title="外部化SpringApplication的配置"></a>外部化SpringApplication的配置</h3><p>一个<code>SpringApplication</code>具有bean属性(主要是setter方法)，因此当你创建应用程序时你可以使用它的Java API来修改其行为。或者你可以使用<code>spring.main.*</code>中的属性对配置进行外部化。例如,在<code>application.properties</code>中你可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.main.web-environment&#x3D;false</span><br><span class="line">spring.main.banner-mode&#x3D;off</span><br></pre></td></tr></table></figure><p>然后Spring Boot banner 将不会在启动时打印出来，并且这个应用将不会是web应用。</p><blockquote><p>上面的例子还演示了允许在属性名中使用下划线(_)和斜杠(-)是多么的灵活。</p></blockquote><p>定义在外部配置的属性将会覆盖通过Java API指定的值，除了用来创建<code>ApplicationContext</code>的sources。让我们看下面的应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new SpringApplicationBuilder()</span><br><span class="line">.bannerMode(Banner.Mode.OFF)</span><br><span class="line">.sources(demo.MyApp.class)</span><br><span class="line">.run(args);</span><br></pre></td></tr></table></figure><p>使用了下面的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.main.sources&#x3D;com.acme.Config,com.acme.ExtraConfig</span><br><span class="line">spring.main.banner-mode&#x3D;console</span><br></pre></td></tr></table></figure><p>实际的应用将会显示出banner（因为被配置覆盖了）并且·<code>ApplicationContext</code>使用3个source(以下面的顺序)：<code>demo.MyApp</code>, <code>com.acme.Config</code>, <code>com.acme.ExtraConfig</code>。</p><h3 id="更改应用程序的外部属性的位置"><a href="#更改应用程序的外部属性的位置" class="headerlink" title="更改应用程序的外部属性的位置"></a>更改应用程序的外部属性的位置</h3><p>默认情况下不同的source是以定义好的顺序（查看“Spring Boot特性”一节中<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-external-config">外部配置</a>了解确切的顺序）添加到Spring<code>Environment</code>的。</p><p>增强和修改这一功能的一个很好的方法是将@propertysource注解添加到你的应用程序sources。传递给<code>SpringApplication</code>静态方法，并使用<code>setSources()</code>添加的这些类将被检查是否有<code>PropertySources</code>，如果它们有，那么这些属性将被尽早添加到<code>Environment</code>中，以便在<code>ApplicationContext</code>生命周期的所有阶段中使用。以这种方式添加的属性比使用默认位置(如application.Properties)、系统属性、环境变量或命令行添加的任何属性优先级都要低。</p><p>你也可以提供系统属性（或环境变量）来改变这一行为：</p><ul><li><code>spring.config.name</code> (<code>SPRING_CONFIG_NAME</code>),默认<code>application</code>为这个文件名的根。</li><li><code>spring.config.location</code> (<code>SPRING_CONFIG_LOCATION</code>) 是要加载的文件（例如classpath资源或URL）。为这个文档设置了一个单独的<code>Environment</code>属性并且它可以被系统属性，环境变量或者命令行参数覆盖。</li></ul><p>无论你设置了什么环境变量，Spring Boot都会加载<code>application.properties</code>。如果使用了YAML那么以“.yml”结尾的文件默认也会被添加到列表中去。</p><p>Spring Boot 在<code>DEBUG</code>级别将会打印出加载的配置文件，并在<code>TRACE</code>级别打印出没有找到的备选文件。</p><p>查看<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/config/ConfigFileApplicationListener.java">ConfigFileApplicationListener</a>了解更多细节。</p><h3 id="使用’短’命令行参数"><a href="#使用’短’命令行参数" class="headerlink" title="使用’短’命令行参数"></a>使用’短’命令行参数</h3><p>有些人喜欢用（例如）<code>--port=9000</code>而不用<code>--server.port=9000</code>在命令行设置配置属性。你可以很容易地通过在<code>application.properties</code>中使用占位符来启用这个功能，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port &#x3D; $&#123;port:8080&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你从<code>spring-boot-starter-parent</code>POM继承而来，<code>maven-resources-plugins</code>默认的过滤标记从<code>$&#123;*&#125;</code>修改为<code>@</code>(例如<code>@maven.token@</code>代替<code>$&#123;maven.token&#125;</code>)来避免与Spring风格的占位符冲突。如果你直接为<code>application.properties</code>启用了maven的过滤，你可能也需要修改默认的过滤符为其他的分隔符。</p></blockquote><blockquote><p>在这种特定情况下端口绑定可以在Heroku和Clound Foundry这样的PaaS环境中生效，因为这两个平台<code>PORT</code>环境变量是自动设置的，并且Spring 可以绑定到<code>Environment</code>属性的大写的同义词属性。</p></blockquote><h3 id="使用YAML外部属性"><a href="#使用YAML外部属性" class="headerlink" title="使用YAML外部属性"></a>使用YAML外部属性</h3><p>YAML是JSON的一个超集，并且方便以层次格式存储外部属性。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">application:</span><br><span class="line">name: cruncher</span><br><span class="line">datasource:</span><br><span class="line">driverClassName: com.mysql.jdbc.Driver</span><br><span class="line">url: jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;test</span><br><span class="line">server:</span><br><span class="line">port: 9000</span><br></pre></td></tr></table></figure><p>创建一个名为<code>application.yml</code>的文件并放在classpath根目录，也需要将<code>snakeyaml</code>添加到依赖中(maven坐标为<code>org.yaml:snakeyaml</code>,如果你使用<code>spring-boot-starter</code>将会自动包含进来)。YAML文件将会解析为Java <code>Map&lt;String,Object&gt;</code>(就像一个JSON对象)，并且Spring Boot使这个map变扁平，这样它具有一层深度并且拥有句号分隔的key，有点儿像java中常常使用的<code>Properties</code>文件。</p><p>上面的YAML例子对应到<code>applicatoin.properties</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name&#x3D;cruncher</span><br><span class="line">spring.datasource.driverClassName&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;test</span><br><span class="line">server.port&#x3D;9000</span><br></pre></td></tr></table></figure><p>在“Spring Boot特性”一节中查看“<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-external-config-yaml">使用YAML代替Properties</a>”了解更多细节。</p><h3 id="设置激活的Spring-profile"><a href="#设置激活的Spring-profile" class="headerlink" title="设置激活的Spring profile"></a>设置激活的Spring profile</h3><p>Spring <code>Environment</code> 有一个针对此的API，但是通常你应该设置一个系统属性(<code>spring.profiles.active</code>)或者一个OS环境变量(<code>SPRING_PROFILES_ACTIVE</code>)。例如通过一个<code>-D</code>参数（记住把它放在main 类或者jar包前）来启动你的应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar -Dspring.profiles.active&#x3D;production demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>在Spring Boot中你也可以在<code>application.properties</code>中设置激活的profile。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active&#x3D;production</span><br></pre></td></tr></table></figure><p>通过这种方式设置的值可以被系统属性或者环境变量设置替代，但是<code>SpringApplicationBuilder.profiles()</code>方法不会。因此后面的Java API 可以用来参数化profile而不改变默认的。</p><p>查看“Spring Boot特性”一节中<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-profiles">Profiles</a>了解更多细节。</p><h3 id="根据环境改变配置"><a href="#根据环境改变配置" class="headerlink" title="根据环境改变配置"></a>根据环境改变配置</h3><p>YAML文件实际上是一系列以<code>---</code>线分隔的文档，并且每个文档都被解析成独立的扁平map。</p><p>如果一个YAML文档包含了<code>spring.profiles</code> key, 那么这个profiles的值（逗号隔开的列表）将会传入Spring <code>Environment.acceptsProfiles()</code> 并且如果其中的任何profile激活了，那么这个文档将会包含到最终的合并结果中（否则不会）。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">port: 9000</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">profiles: development</span><br><span class="line">server:</span><br><span class="line">port: 9001</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">profiles: production</span><br><span class="line">server:</span><br><span class="line">port: 0</span><br></pre></td></tr></table></figure><p>在这个例子中，默认的端口号是9000，但是如果Spring “development” profile激活了，那么端口号会是9001，如果”production” 激活了，那么它将是0。</p><h3 id="发现外部属性的内置选项"><a href="#发现外部属性的内置选项" class="headerlink" title="发现外部属性的内置选项"></a>发现外部属性的内置选项</h3><p>Spring Boot 在运行时从<code>application.properties</code>(或<code>.yml</code>)(和其他位置)绑定外部属性到应用程序中。在一个位置上没有(而且技术上不可能是)所有受支持的属性的详尽列表，因为属性可以来自类路径上的附加jar文件。</p><p>具有Actuator 功能的运行中的应用程序有一个<code>configprops</code>端点，它显示了通过<code>@ConfigurationProperties</code>可获得的所有绑定和可绑定属性。</p><p>附录包括一个<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#common-application-properties"><code>application.properties</code></a>示例,包含了Spring Boot所支持的最常见属性的列表。最终的列表来自搜索<code>@ConfigurationProperties</code>和<code>@Value</code>注解，以及偶尔使用<code>Binder</code>的源代码。</p><h2 id="嵌入式Web服务器"><a href="#嵌入式Web服务器" class="headerlink" title="嵌入式Web服务器"></a>嵌入式Web服务器</h2><h3 id="使用其它Web服务器"><a href="#使用其它Web服务器" class="headerlink" title="使用其它Web服务器"></a>使用其它Web服务器</h3><p>下面的Spring Boot starters 为我们带来了一个默认的容器：</p><ul><li><code>spring-boot-starter-web</code>和<code>spring-boot-starter-tomcat</code>一起带来了tomcat，<br>但可以使用<code>spring-boot-starter-jetty</code> 和 <code>spring-boot-starter-undertow</code>替代。</li><li><code>spring-boot-starter-webflux</code>和<code>spring-boot-starter-reactor-netty</code>带来了Reactor Netty，但是可以使用<code>spring-boot-starter-tomcat, spring-boot-starter-jetty</code> 和 <code>spring-boot-starter-undertow</code>替代。</li></ul><blockquote><p>许多starter 只支持Spring MVC,因此它们传递地带来了<code>spring-boot-starter-web</code>。</p></blockquote><p>如果你选择使用不同的HTTP服务器，你需要排除那些依赖并且引入你选择的。Spring Boot为HTTP 服务器提供了独立的starter来使这个过程尽可能简单。</p><p>下面是一个Maven 的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Exclude the Tomcat dependency --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Use Jetty instead --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Gradle:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">&#x2F;&#x2F; exclude Reactor Netty</span><br><span class="line">compile.exclude module: &#39;spring-boot-starter-reactor-netty&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">compile &#39;org.springframework.boot:spring-boot-starter-webflux&#39;</span><br><span class="line">&#x2F;&#x2F; Use Undertow instead</span><br><span class="line">compile &#39;org.springframework.boot:spring-boot-starter-undertow&#39;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>WebClient</code>需要<code>spring-boot-starter-reactor-netty</code>,因此如果你需要使用其他的HTTP服务器，你需要排除它。</p></blockquote><h3 id="配置Jetty"><a href="#配置Jetty" class="headerlink" title="配置Jetty"></a>配置Jetty</h3><p>一般可以按照<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-discover-build-in-options-for-external-properties">“发现内置外部属性”</a>对<code>@ConfigurationProperties</code>(<code>ServerProperties</code>是主要的一个)的建议,但也看看<code>ServletWebServerFactoryCustomizer</code>。Jetty api非常丰富,所以一旦你可以访问<code>JettyServletWebServerFactory</code>你可以以多种方式修改它。或者是添加自己的<code>JettyServletWebServerFactory</code>。</p><h3 id="添加Servlet-Filter-或-Listener"><a href="#添加Servlet-Filter-或-Listener" class="headerlink" title="添加Servlet, Filter 或 Listener"></a>添加Servlet, Filter 或 Listener</h3><p>有两种方法可以添加<code>Servlet</code>、<code>Filter</code>、<code>ServletContextListener</code>和其他受Servlet规范支持的<code>Listener</code>。你可以为它们提供Spring bean，也可以启用Servlet组件扫描。</p><h4 id="使用Spring-Bean添加Servlet，Filter和Listener"><a href="#使用Spring-Bean添加Servlet，Filter和Listener" class="headerlink" title="使用Spring Bean添加Servlet，Filter和Listener"></a>使用Spring Bean添加Servlet，Filter和Listener</h4><p>要添加Servlet、Filter或Servlet<code>*Listener</code>，可以为其提供一个<code>@Bean</code>定义。当你想要注入配置或依赖项时，这可能非常有用。但是，你必须非常小心，它们不会引起太多其他bean的热切初始化，因为它们必须在应用程序生命周期的早期就被安装在容器中(例如，让它们依赖于你的<code>DataSource</code>或JPA配置不是一个好主意)。你可以通过在第一次使用时懒加载而不是初始化时来解决这些限制。</p><p>对于<code>Filters</code>和<code>Servlet</code>，你还可以通过添加<code>FilterRegistrationBean</code>或<code>ServletRegistrationBean</code>来添加映射和初始化参数而不是使用底层组件。</p><blockquote><p>如果在过滤器注册中没有指定<code>dispatcherType</code>，它将匹配<code>FORWARD</code>，<code>INCLUDE</code>和<code>REQUEST</code>。 如果已启用异步，则它也将匹配<code>ASYNC</code>。<br>如果要迁移<code>web.xml</code>中没有<code>dispatcher</code>元素的过滤器，则需要自行指定<code>dispatcherType</code>：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public  FilterRegistrationBean myFilterRegistration() &#123;</span><br><span class="line">FilterRegistrationBean registration &#x3D; new FilterRegistrationBean();</span><br><span class="line">registration.setDispatcherTypes(DispatcherType.REQUEST);</span><br><span class="line">....</span><br><span class="line">return registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="禁止注册Servlet-或-Filter"><a href="#禁止注册Servlet-或-Filter" class="headerlink" title="禁止注册Servlet 或 Filter"></a>禁止注册Servlet 或 Filter</h5><p>如上所述，任何<code>Servlet</code>或<code>Filter</code> bean将自动注册到servlet容器。 要禁用特定的<code>Filter</code>或<code>Servlet</code> bean的注册，请为其创建一个注册 bean并将其标记为禁用。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">registration</span><span class="params">(MyFilter filter)</span> </span>&#123;</span><br><span class="line">FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean(filter);</span><br><span class="line">registration.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用类路径扫描添加Servlet，Filter和Listener"><a href="#使用类路径扫描添加Servlet，Filter和Listener" class="headerlink" title="使用类路径扫描添加Servlet，Filter和Listener"></a>使用类路径扫描添加Servlet，Filter和Listener</h4><p><code>@WebServlet</code>、<code>@WebFilter</code>和<code>@WebListener</code>注解类可以自动注册一个嵌入的servlet容器，通过使用<code>@ServletComponentScan</code>注解<code>@Configuration</code>类，并指定包含你想要注册的组件的包(s)。默认情况下，<code>@ServletComponentScan</code>将从带注解的类的包中进行扫描。</p><h3 id="修改HTTP端口"><a href="#修改HTTP端口" class="headerlink" title="修改HTTP端口"></a>修改HTTP端口</h3><p>在独立应用程序中，主HTTP端口默认为<code>8080</code>，但可以使用<code>server.port</code>（例如在<code>application.properties</code>或系统属性中）进行设置。 由于<code>Environment</code>值的松散绑定，你还可以使用<code>SERVER_PORT</code>（例如作为OS环境变量）。</p><p>要完全关闭HTTP端点，但仍然创建<code>WebApplicationContext</code>，请使用<code>server.port = -1</code>（这对于测试有时很有用）。</p><p>有关更多详细信息，请参阅“Spring Boot功能”部分中的<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-customizing-embedded-containers">“定制嵌入式Servlet容器”</a>或<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java"><code>ServerProperties</code></a>源代码。</p><h3 id="使用随机未分配的HTTP端口"><a href="#使用随机未分配的HTTP端口" class="headerlink" title="使用随机未分配的HTTP端口"></a>使用随机未分配的HTTP端口</h3><p>要扫描一个空闲端口（使用OS本机来防止冲突），请使用<code>server.port = 0</code>。</p><h3 id="在运行时发现HTTP端口"><a href="#在运行时发现HTTP端口" class="headerlink" title="在运行时发现HTTP端口"></a>在运行时发现HTTP端口</h3><p>你可以从日志输出中访问运行服务器的端口，也可以通过<code>ServletWebServerApplicationContext</code>的<code>EmbeddedWebServer</code>访问。最好的办法来获取和确保它已经初始化了，就是添加一个<code>ApplicationListener&lt;ServletWebServerInitializedEvent&gt;</code>类型的<code>@Bean</code>，并在容器发布的时候将其从容器中取出。</p><p>使用<code>@SpringBootTest（webEnvironment = WebEnvironment.RANDOM_PORT）</code>的测试用例也可以使用<code>@LocalServerPort</code>注解将实际的端口注入到字段中。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringBootTest(webEnvironment&#x3D;WebEnvironment.RANDOM_PORT)</span><br><span class="line">public class MyWebIntegrationTests &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">ServletWebServerApplicationContext server;</span><br><span class="line"></span><br><span class="line">@LocalServerPort</span><br><span class="line">int port;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@LocalServerPort</code>是<code>@Value（“$ &#123;local.server.port&#125;”）</code>的元注解。不要试图在普通应用程序中注入端口。 正如我们刚刚看到的，只有在容器初始化后才会设置该值。 与测试相反，应用程序代码回调会被提前处理（即在值实际可用之前）。</p></blockquote><h3 id="配置SSL"><a href="#配置SSL" class="headerlink" title="配置SSL"></a>配置SSL</h3><p>可以通过设置各种<code>server.ssl.*</code>属性（通常在<code>application.properties</code>或<code>application.yml</code>中）声明性地配置SSL。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.port&#x3D;8443</span><br><span class="line">server.ssl.key-store&#x3D;classpath:keystore.jks</span><br><span class="line">server.ssl.key-store-password&#x3D;secret</span><br><span class="line">server.ssl.key-password&#x3D;another-secret</span><br></pre></td></tr></table></figure><p>请参阅<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/web/server/Ssl.java"><code>Ssl</code></a>了解所有支持的属性的详细信息。</p><p>使用类似上例的配置意味着应用程序将不再支持8080端口上的普通HTTP连接器。Spring Boot不支持通过<code>application.properties</code>配置HTTP和HTTPS两个连接器。如果你想有两个，那么你需要以编程方式配置其中之一。建议使用<code>application.properties</code>配置HTTPS，因为HTTP连接器以编程方式更容易配置。有关示例，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-tomcat-multi-connectors"><code>spring-boot-sample-tomcat-multi-connectors</code></a>示例项目。</p><h3 id="配置访问日志"><a href="#配置访问日志" class="headerlink" title="配置访问日志"></a>配置访问日志</h3><p>可以通过各自的命名空间为Tomcat，Undertow和Jetty配置访问日志。</p><p>例如，以下以<a href="https://tomcat.apache.org/tomcat-8.5-doc/config/valve.html#Access_Logging">自定义模式</a>配置Tomcat访问日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.basedir&#x3D;my-tomcat</span><br><span class="line">server.tomcat.accesslog.enabled&#x3D;true</span><br><span class="line">server.tomcat.accesslog.pattern&#x3D;%t %a &quot;%r&quot; %s (%D ms)</span><br></pre></td></tr></table></figure><blockquote><p>日志的默认位置是相对于tomcat基本目录的<code>logs</code>目录，默认情况下该目录是临时目录，因此你可能需要修复Tomcat的基本目录或使用日志的绝对路径。在上面的示例中，日志将在相对于应用程序的工作目录的<code>my-tomcat/logs</code>目录中。</p></blockquote><p>undertow 访问日志可以用类似的方式进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.undertow.accesslog.enabled&#x3D;true</span><br><span class="line">server.undertow.accesslog.pattern&#x3D;%t %a &quot;%r&quot; %s (%D ms)</span><br></pre></td></tr></table></figure><p>日志存储在相对于应用程序的工作目录的<code>logs</code>目录中。这可以通过<code>server.undertow.accesslog.directory</code>进行自定义。</p><p>最后，jetty的访问日志也可以这样配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.jetty.accesslog.enabled&#x3D;true</span><br><span class="line">server.jetty.accesslog.filename&#x3D;&#x2F;var&#x2F;log&#x2F;jetty-access.log</span><br></pre></td></tr></table></figure><p>默认情况下，日志将被重定向到<code>System.err</code>。 有关更多详细信息，请参阅<a href="https://www.eclipse.org/jetty/documentation/9.4.x/configuring-jetty-request-logs.html">文档</a>。</p><h3 id="使用前端代理服务器"><a href="#使用前端代理服务器" class="headerlink" title="使用前端代理服务器"></a>使用前端代理服务器</h3><p>你的应用程序可能需要发送<code>302</code>重定向或使用绝对链接呈现内容。在代理之后运行时，调用者需要链接到代理，而不是托管应用的机器的物理地址。通常情况下，这种情况是通过与代理的约定来处理的，代理将添加头来告诉后端如何构建到自己的链接。</p><p>如果代理添加了常规的<code>X-Forwarded-For</code>和<code>X-Forwarded-Proto</code>头（大部分是开箱即用的），只要在你的<code>application.properties</code>中设置<code>server.use-forward-headers</code>为<code>true</code>的,那么服务器就可以正确地呈现绝对链接。</p><blockquote><p>如果你的应用程序正在Cloud Foundry 或 Heroku 中运行，那么<code>server.use-forward-headers</code>属性将默认为<code>true</code>（如果未指定）。 在所有其他情况下，它默认为<code>false</code>。</p></blockquote><h4 id="自定义Tomcat的代理配置"><a href="#自定义Tomcat的代理配置" class="headerlink" title="自定义Tomcat的代理配置"></a>自定义Tomcat的代理配置</h4><p>如果你正在使用Tomcat，则可以另外配置用于携带“转发”信息的头的名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.remote-ip-header&#x3D;x-your-remote-ip-header</span><br><span class="line">server.tomcat.protocol-header&#x3D;x-your-protocol-header</span><br></pre></td></tr></table></figure><p>Tomcat也配置了一个默认的正则表达式来匹配要被信任的内部代理。默认情况下，<code>10/8</code>, <code>192.168/16</code>, <code>169.254/16</code> 和 <code>127/8</code>中的IP地址是可信的。你可以通过向<code>application.properties</code>添加条目来自定义阀的配置。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.internal-proxies&#x3D;192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只有在使用属性文件进行配置时才需要双反斜杠。如果你使用的是YAML，则单个反斜杠就足够了，并且与上面显示的相同的值将是<code>192\.168\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;</code>。</p></blockquote><blockquote><p>你可以通过将<code>internal-proxies</code>设置为空来信任所有代理（但不要在生产中这样做）。</p></blockquote><p>通过切换自动关闭（即设置 <code>server.use-forward-headers = false</code>）并在<code>TomcatServletWebServerFactory</code> bean中添加一个新的阀实例，可以完全控制Tomcat的<code>RemoteIpValve</code>配置。</p><h3 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h3><p>通常，你可以按照<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-discover-build-in-options-for-external-properties">“发现外部属性的内置选项”</a>中有关<code>@ConfigurationProperties</code>（<code>ServerProperties</code>是此处的主要内容）的建议，还可以查看<code>ServletWebServerFactoryCustomizer</code>和各种可以添加到Tomcat特定的<code>*Customizers</code>。 Tomcat的API相当丰富，所以一旦你可以访问<code>TomcatServletWebServerFactory</code>，你可以通过多种方式对其进行修改。或者是添加自己的<code>TomcatServletWebServerFactory</code>。</p><h3 id="启用Tomcat多Connector功能"><a href="#启用Tomcat多Connector功能" class="headerlink" title="启用Tomcat多Connector功能"></a>启用Tomcat多Connector功能</h3><p>将<code>org.apache.catalina.connector.Connector</code>添加到<code>TomcatServletWebServerFactory</code>，该<code>TomcatServletWebServerFactory</code>可以允许多个连接器，例如， HTTP和HTTPS连接器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ServletWebServerFactory servletContainer() &#123;</span><br><span class="line">TomcatServletWebServerFactory tomcat &#x3D; new TomcatServletWebServerFactory();</span><br><span class="line">tomcat.addAdditionalTomcatConnectors(createSslConnector());</span><br><span class="line">return tomcat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Connector createSslConnector() &#123;</span><br><span class="line">Connector connector &#x3D; new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);</span><br><span class="line">Http11NioProtocol protocol &#x3D; (Http11NioProtocol) connector.getProtocolHandler();</span><br><span class="line">try &#123;</span><br><span class="line">File keystore &#x3D; new ClassPathResource(&quot;keystore&quot;).getFile();</span><br><span class="line">File truststore &#x3D; new ClassPathResource(&quot;keystore&quot;).getFile();</span><br><span class="line">connector.setScheme(&quot;https&quot;);</span><br><span class="line">connector.setSecure(true);</span><br><span class="line">connector.setPort(8443);</span><br><span class="line">protocol.setSSLEnabled(true);</span><br><span class="line">protocol.setKeystoreFile(keystore.getAbsolutePath());</span><br><span class="line">protocol.setKeystorePass(&quot;changeit&quot;);</span><br><span class="line">protocol.setTruststoreFile(truststore.getAbsolutePath());</span><br><span class="line">protocol.setTruststorePass(&quot;changeit&quot;);</span><br><span class="line">protocol.setKeyAlias(&quot;apitester&quot;);</span><br><span class="line">return connector;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException ex) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;can&#39;t access keystore: [&quot; + &quot;keystore&quot;</span><br><span class="line">+ &quot;] or truststore: [&quot; + &quot;keystore&quot; + &quot;]&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Tomcat的-LegacyCookieProcessor"><a href="#使用-Tomcat的-LegacyCookieProcessor" class="headerlink" title="使用 Tomcat的 LegacyCookieProcessor"></a>使用 Tomcat的 LegacyCookieProcessor</h3><p>Spring Boot使用的嵌入式Tomcat不支持开箱即用的Cookie格式的“Version 0”，你可能会看到以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: An invalid character [32] was present in the Cookie value</span><br></pre></td></tr></table></figure><p>如果可能的话，你应该考虑更新你的代码，只存储符合新Cookie规范的值。但是，如果你无法更改cookie的写入方式，则可以将Tomcat配置为使用<code>LegacyCookieProcessor</code>。 要切换到<code>LegacyCookieProcessor</code>，请使用添加<code>TomcatContextCustomizer</code>的<code>ServletWebServerFactoryCustomizer</code> bean：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; cookieProcessorCustomizer() &#123;</span><br><span class="line">return (serverFactory) -&gt; serverFactory.addContextCustomizers(</span><br><span class="line">(context) -&gt; context.setCookieProcessor(new LegacyCookieProcessor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置Undertow"><a href="#配置Undertow" class="headerlink" title="配置Undertow"></a>配置Undertow</h3><h3 id="启用-Undertow-多Listener功能"><a href="#启用-Undertow-多Listener功能" class="headerlink" title="启用 Undertow 多Listener功能"></a>启用 Undertow 多Listener功能</h3><h3 id="使用-ServerEndpoint创建WebSocket端点"><a href="#使用-ServerEndpoint创建WebSocket端点" class="headerlink" title="使用@ServerEndpoint创建WebSocket端点"></a>使用@ServerEndpoint创建WebSocket端点</h3><p>如果要在使用嵌入式容器的Spring Boot应用程序中使用<code>@ServerEndpoint</code>，则必须声明一个<code>ServerEndpointExporter </code> <code>@Bean</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ServerEndpointExporter serverEndpointExporter() &#123;</span><br><span class="line">return new ServerEndpointExporter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个bean将用底层的WebSocket容器注册任何<code>ServerEndpoint</code>注解的bean。当部署到一个独立的servlet容器时，这个角色由servlet容器初始化器执行，而<code>ServerEndpointExporter</code> bean是不需要的。</p><h3 id="启用HTTP响应压缩"><a href="#启用HTTP响应压缩" class="headerlink" title="启用HTTP响应压缩"></a>启用HTTP响应压缩</h3><p>Jetty,Tomcat和Undertow都支持HTTP响应压缩。可以通过<code>application.properties</code>启用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.compression.enabled&#x3D;true</span><br></pre></td></tr></table></figure><p>默认情况下，响应的长度必须至少达到2048个字节，以便进行压缩。可以使用<code>server.compression.min-response-size</code>属性进行配置。</p><p>默认情况下，只有当内容类型为以下内容时，响应才会被压缩:</p><ul><li>text/html</li><li>text/xml</li><li>text/plain</li><li>text/css</li></ul><p>可以使用<code>server.compression.mime-types</code>属性进行配置。</p><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="编写JSON-REST-服务"><a href="#编写JSON-REST-服务" class="headerlink" title="编写JSON REST 服务"></a>编写JSON REST 服务</h3><p>在Spring Boot应用程序中，只要Jackson2位于类路径上, 任何Spring <code>@RestController</code>都应该在默认情况下呈现JSON响应。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class MyController &#123;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;&#x2F;thing&quot;)</span><br><span class="line">public MyThing thing() &#123;</span><br><span class="line">return new MyThing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要<code>MyThing</code>可以由Jackson2(例如普通的POJO或Groovy对象)序列化，那么<code>localhost:8080/thing</code>将默认返回JSON。有时在浏览器中，你可能会看到XML响应，因为浏览器倾向于发送XML优先的accept头。</p><h3 id="编写XML-REST-服务"><a href="#编写XML-REST-服务" class="headerlink" title="编写XML REST 服务"></a>编写XML REST 服务</h3><p>如果在类路径中有Jackson XML扩展(<code>jackson-dataformat-xml</code>)，它将被用于呈现XML响应，而与我们使用的JSON相同的示例也会起作用。要使用它，请在你的项目中添加以下依赖项:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可能还想添加对Woodstox的依赖。它比JDK提供的默认StAX实现快得多，而且还增加了美化的打印支持和改进的命名空间处理:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.woodstox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>woodstox-core-asl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果不能使用杰克逊的XML扩展，那么将使用JAXB(默认为JDK提供)，并附加要求将<code>MyThing</code>注解<code>@XmlRootElement</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThing</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">// .. getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让服务器呈现XML而不是JSON，你可能需要发送一个<code>Accept:text/XML</code>头(或使用浏览器)。</p><h3 id="自定义Jackson-ObjectMapper"><a href="#自定义Jackson-ObjectMapper" class="headerlink" title="自定义Jackson ObjectMapper"></a>自定义Jackson ObjectMapper</h3><p>Spring MVC(客户端和服务器端)使用<code>HttpMessageConverters</code>在HTTP交互中协商内容转换。如果Jackson 在类路径中,你已经得到了<code>Jackson2ObjectMapperBuilder</code>提供的默认的转换器(s),这是自动配置的一个实例。</p><p>默认创建的<code>ObjectMapper</code>(或用于JacksonXML转换器的<code>XmlMapper</code>)实例具有以下自定义属性:</p><ul><li><code>MapperFeature.DEFAULT_VIEW_INCLUSION</code>是禁用的</li><li><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>是禁用的</li></ul><p>Spring Boot也有一些特性，可以使定制这个行为变得更加容易。</p><p>你可以使用环境配置<code>ObjectMapper</code>和<code>XmlMapper</code>实例。Jackson提供了一套广泛的简单的开关特性，可用于配置其处理的各个方面。这些特性是在Jackson的六个枚举中描述的，这些枚举映射到环境中的属性:</p><table><thead><tr><th>Jackson 枚举</th><th>环境属性</th></tr></thead><tbody><tr><td><code>com.fasterxml.jackson.databind.DeserializationFeature</code></td><td>`spring.jackson.deserialization.<feature_name>=true</feature_name></td></tr><tr><td><code>com.fasterxml.jackson.core.JsonGenerator.Feature</code></td><td>`spring.jackson.generator.<feature_name>=true</feature_name></td></tr><tr><td><code>com.fasterxml.jackson.databind.MapperFeature</code></td><td>`spring.jackson.mapper.<feature_name>=true</feature_name></td></tr><tr><td><code>com.fasterxml.jackson.core.JsonParser.Feature</code></td><td>`spring.jackson.parser.<feature_name>=true</feature_name></td></tr><tr><td><code>com.fasterxml.jackson.databind.SerializationFeature</code></td><td>`spring.jackson.serialization.<feature_name>=true</feature_name></td></tr><tr><td><code>com.fasterxml.jackson.annotation.JsonInclude.Include</code></td><td>`spring.jackson.default-property-inclusion=always</td></tr></tbody></table><p>例如,设置<code>spring.jackson.serialization.indent_output = true</code>启用美化打印。注意，由于使用了<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/html/boot-features-external-config.html#boot-features-external-config-relaxed-binding">松散绑定</a>，<code>indent_output</code>的情况不必与对应的枚举常量相匹配，后者是<code>INDENT_OUTPUT</code>。</p><p>这种基于环境的配置应用于自动配置<code>Jackson2ObjectMapperBuilder</code> bean,并将适用于任何使用这个builder创建的mappers ,包括自动配置<code>ObjectMapper</code> bean。</p><p>上下文的<code>Jackson2ObjectMapperBuilder</code>可以由一个或多个<code>Jackson2ObjectMapperBuilderCustomizer</code> bean定制。这种定制的bean可以被排序，而Boot自己的定制器的顺序是0，允许在Boot的定制之前和之后进行额外的定制。</p><p>任何<code>com.fasterxml.jackson.databind.Module</code>类型的bean将自动注册自动配置的<code>Jackson2ObjectMapperBuilder</code>和应用于任何它创建的<code>ObjectMapper</code>实例。当向你的应用程序添加新特性时，这提供了一种用于定制模块的全局机制。</p><p>如果你想完全替换默认<code>ObjectMapper</code>,要么定义一个这种类型的<code>@ bean</code>并将其标记为<code>@Primary</code>,或者,如果你喜欢builder方式,可以定义一个<code>Jackson2ObjectMapperBuilder</code>  的<code>@Bean</code>。注意，在这两种情况下，这将禁用<code>ObjectMapper</code>的所有自动配置。</p><p>如果你提供任何<code>MappingJackson2HttpMessageConverter</code>类型的<code>@ Beans</code>然后他们将取代MVC的默认配置。另外，还提供了一种<code>HttpMessageConverters</code>类型的bean(如果使用默认的MVC配置的话，总是可用的)，它提供了一些有用的方法来访问默认的和用户增强的消息转换器。</p><p>请参阅<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/html/howto-spring-mvc.html#howto-customize-the-responsebody-rendering">“定制<code>@ResponseBody</code>渲染”</a>部分和<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java"><code>WebMvcAutoConfiguration</code></a>源代码以获得更多详细信息。</p><h3 id="自定义-ResponseBody渲染"><a href="#自定义-ResponseBody渲染" class="headerlink" title="自定义@ResponseBody渲染"></a>自定义@ResponseBody渲染</h3><p>Spring使用<code>HttpMessageConverters</code>来渲染<code>@ResponseBody</code>(或来自<code>@RestController</code>的响应)。只需在Spring Boot 上下文中添加这种类型的bean，就可以提供额外的转换器。如果添加的bean是默认包含的类型(例如<code>MappingJackson2HttpMessageConverter</code> JSON转换),那么它将取代默认值。提供了一种<code>HttpMessageConverters</code>类型的bean(如果使用默认的MVC配置的话，总是可用的)，它提供了一些有用的方法来访问默认的和用户增强的消息转换器(例如，如果你想手动将它们注入到一个定制的<code>RestTemplate</code>中)。</p><p>在正常使用MVC时,任何提供的<code>WebMvcConfigurer</code> bean通过重写<code>configureMessageConverters</code>方法也可以贡献转换器,但与正常MVC不一样的是,你只能供应你需要的额外的转换器(因为 Spring Boot 使用相同的机制提供它默认的)。最后,如果你选择通过提供自己的<code>@EnableWebMvc</code>配置退出Spring Boot默认的MVC配置,然后你可以完全控制,并使用<code>WebMvcConfigurationSupport</code> 到<code>getMessageConverters</code>来手动做任何事。</p><p>更多细节请参见<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java"><code>WebMvcAutoConfiguration</code></a>源代码。</p><h3 id="处理文件上传"><a href="#处理文件上传" class="headerlink" title="处理文件上传"></a>处理文件上传</h3><p>Spring Boot包含Servlet 3 <code>javax.servlet.http.Part</code>API来支持上传文件。在默认情况下，Spring Boot配置Spring MVC，每个文件最大为1MB，在单个请求中最多可达到10MB的文件数据。你可以覆盖这些值，以及存储中间数据的位置(例如，存储到<code>/tmp</code>目录)，以及通过使用在<code>MultipartProperties</code>类中公开的属性将数据刷新到磁盘的阈值。如果你想指定文件是无限的,例如,设置<code>spring.servlet.multipart.max-file-size</code>属性为<code>-1</code>。</p><p>当你希望在Spring MVC控制器处理程序方法中作为<code>@RequestParam</code>注解的<code>MultipartFile</code>类型参数来接收multipart编码的文件数据时，multipart的支持是很有帮助的。</p><p>查看<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/MultipartAutoConfiguration.java"><code>MultipartAutoConfiguration</code></a>源代码获取更多的细节。</p><h3 id="关闭Spring-MVC-DispatcherServlet"><a href="#关闭Spring-MVC-DispatcherServlet" class="headerlink" title="关闭Spring MVC DispatcherServlet"></a>关闭Spring MVC DispatcherServlet</h3><p>Spring Boot希望从应用程序的<code>/</code>提供所有内容。如果你更愿意将自己的servlet映射到该URL，你可以这样做，但是你可能会丢失一些其他的Boot MVC 特性。添加自己的servlet并将其映射到根资源只需声明一个<code>Servlet</code>类型的<code>@ Bean</code>并且给它特殊的bean名称-<code>dispatcherServlet</code>(如果你想关掉它,而不是取代它,你还可以创建一个不同类型同名称的bean)。</p><h3 id="关闭默认MVC配置"><a href="#关闭默认MVC配置" class="headerlink" title="关闭默认MVC配置"></a>关闭默认MVC配置</h3><p>对MVC配置进行完全控制的最简单方法是，提供你自己的<code>@Configuration</code>，并使用<code>@EnableWebMvc</code>注解。这将把所有MVC配置掌握在你的手中。</p><h3 id="自定义ViewResolver"><a href="#自定义ViewResolver" class="headerlink" title="自定义ViewResolver"></a>自定义ViewResolver</h3><p><code>ViewResolver</code>是Spring MVC的核心组件，将<code>@Controller</code>中的视图名转换为实际的<code>View</code>实现。请注意，<code>ViewResolvers</code>主要用于UI应用程序，而不是REST风格的服务(<code>View</code>不用于渲染<code>@ResponseBody</code>)。有许多<code>ViewResolver</code>的实现可供选择，而Spring本身并不建议你应该使用哪一个。另一方面，Spring Boot根据它在类路径和应用程序上下文中找到的内容，为你安装一个或两个。<code>DispatcherServlet</code>使用它在应用程序上下文中找到的所有解析器，依次尝试每一个解析器，直到得到一个结果，因此，如果你要添加自己的解析器，那么你必须了解该顺序，并在其中添加你的解析器。</p><p><code>WebMvcAutoConfiguration</code>为您的上下文添加了以下<code>ViewResolvers</code>:</p><ul><li>一个<code>InternalResourceViewResolver</code> bean，id 为“defaultViewResolver”。这一项定位了可以使用<code>DefaultServlet</code>来渲染的物理资源(例如，如果你使用的是静态资源和JSP页面)。它在视图名中应用一个前缀和一个后缀，然后在servlet上下文中查找带有该路径的物理资源(默认值都是空的，但是通过<code>spring.mvc.view.prefix</code>和<code>spring.mvc.view.suffix</code>可以访问外部配置)。可以通过提供相同类型的bean来覆盖它。</li><li>一个id为“BeanNameViewResolver”的<code>BeanNameViewResolver</code>。这是视图解析器链中的一个有用的成员，它将使用与正在解析的<code>View</code>相同的名称来获取任何bean。不应该重写或替换它。</li><li>一个id 为“viewResolver”的<code>ContentNegotiatingViewResolver</code> 实际上只有存在实际的<code>View</code>类型的bean时才会被添加。这是一个“主”解析器，委托给其他解析器，并试图找到一个匹配客户端发送的“Accept”HTTP头的匹配项。有一个<a href="https://spring.io/blog/2013/06/03/content-negotiation-using-views">关于<code>ContentNegotiatingViewResolver</code>有用的博客</a>,你可能更喜欢研究学习,可以查看源代码了解更多。你可以通过定义一个bean名为“viewResolver”关掉自动配置<code>ContentNegotiatingViewResolver</code>。</li><li>如果你用的是Thymeleaf，也会有一个id为“thymeleafViewResolver”的<code>ThymeleafViewResolver</code>。它通过使用前缀和后缀包围视图名来查找资源(<code>spring.thymeleaf.prefix</code>和<code>spring.thymeleaf.suffix</code>，默认分别为”classpath:/templates/“和”.html”的)。可以通过提供相同名称的bean来覆盖它。</li><li>如果你使用FreeMarker，也会有一个id为“freeMarkerViewResolver”的<code>FreeMarkerViewResolver</code>。它在围绕视图名称的前缀和后缀(<code>spring.freemarker.prefix</code>和 <code>spring.freemarker.suffix</code>)的加载路径(<code>spring.freemarker.templateLoaderPath</code>,默认分别为“classpath:/templates/”和”.tpl”)中查找资源。可以通过提供相同名称的bean来覆盖它。</li><li>如果您使用的是Groovy模板(实际上，如果你的类路径上有Groovy模板)，那么也会有一个id为’groovyMarkupViewResolver’的<code>GroovyMarkupViewResolver</code>。它在围绕视图名称的前缀和后缀(<code>spring.groovy.template.prefix</code>和 <code>spring.groovy.template.suffix</code>)的加载路径(<code>spring.freemarker.templateLoaderPath</code>,默认分另为“classpath:/templates/”和”.tpl”)中查找资源。可以通过提供相同名称的bean来覆盖它。</li></ul><p>查看<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java"><code>WebMvcAutoConfiguration</code></a>、<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/thymeleaf/ThymeleafAutoConfiguration.java"><code>ThymeleafAutoConfiguration</code></a>，<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/freemarker/FreeMarkerAutoConfiguration.java"><code>FreeMarkerAutoConfiguration</code></a>，<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/groovy/template/GroovyTemplateAutoConfiguration.java"><code>GroovyTemplateAutoConfiguration</code></a>了解更多。</p><h2 id="HTTP-客户端"><a href="#HTTP-客户端" class="headerlink" title="HTTP 客户端"></a>HTTP 客户端</h2><h3 id="配置RestTemplate使用代理"><a href="#配置RestTemplate使用代理" class="headerlink" title="配置RestTemplate使用代理"></a>配置RestTemplate使用代理</h3><p>正如<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/html/boot-features-resttemplate.html#boot-features-resttemplate-customization">“RestTemplate定制”</a>中所描述的那样，<code>RestTemplateCustomizer</code>可以使用<code>RestTemplateBuilder</code>来构建一个定制的<code>RestTemplate</code>。这是创建配置使用代理的<code>RestTemplate</code>的推荐方法。</p><p>代理配置的具体细节取决于正在使用的底层客户端请求工厂。这里有一个例子配置<code>HttpComponentsClientRequestFactory</code>,包含了一个 <code>HttpClient</code>,除了<code>192.168.0.5</code>以外，它为其他的主机都使用一个代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCustomizer</span> <span class="keyword">implements</span> <span class="title">RestTemplateCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">HttpHost proxy = <span class="keyword">new</span> HttpHost(<span class="string">&quot;proxy.example.com&quot;</span>);</span><br><span class="line">HttpClient httpClient = HttpClientBuilder.create()</span><br><span class="line">.setRoutePlanner(<span class="keyword">new</span> DefaultProxyRoutePlanner(proxy) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpHost <span class="title">determineProxy</span><span class="params">(HttpHost target,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpRequest request, HttpContext context)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> HttpException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (target.getHostName().equals(<span class="string">&quot;192.168.0.5&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.determineProxy(target, request, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;).build();</span><br><span class="line">restTemplate.setRequestFactory(</span><br><span class="line"><span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>除了Commons Logging API，Spring Boot没有强制的日志记录依赖，其中有许多实现可供选择。要使用<a href="http://logback.qos.ch/">Logback</a>，你需要在引入它和<code>jcl-over-slf4j</code>(它实现了公共资源日志API)。最简单的方法是通过starter，这些启动器都依赖于<code>spring-boot-starter-logging</code>。对于一个web应用程序，你只需要<code>spring-boot-starter-web</code>，因为它依赖于日志starter。例如在Maven中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Boot有一个<code>LoggingSystem</code>抽象，它试图根据类路径的内容来配置日志记录。如果可以使用Logback，这是第一选择。</p><p>如果你需要对日志进行的惟一更改是设置不同记录器的级别，那么你可以在<code>application.properties</code>中使用”logging.level” 前缀来执行此操作,,如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.level.org.springframework.web&#x3D;DEBUG</span><br><span class="line">logging.level.org.hibernate&#x3D;ERROR</span><br></pre></td></tr></table></figure><p>你还可以使用“logg.file”设置文件的位置(除控制台之外)。</p><p>要更细粒度的设置日志系统，你需要使用由<code>LoggingSystem</code>支持的原生配置格式。默认情况下，Spring Boot从系统的默认位置获取原生配置(例如:Logback的<code>classpath:logback.xml</code>)，但是你可以使用”logging.config”属性设置配置文件的位置。</p><h3 id="配置Logback进行日志记录"><a href="#配置Logback进行日志记录" class="headerlink" title="配置Logback进行日志记录"></a>配置Logback进行日志记录</h3><p>如果你放了一个<code>logback.xml</code>文件在类路径的根目录中，它将从那里获取(或者是<code>logback-spring.xml</code>以利用Boot 提供的模板特性)。Spring Boot提供了一个默认的基本配置，如果你只想设置级别，你可以包括它。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/base.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework.web&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你看过spring-boot jar中的<code>base.xml</code>，你将看到它使用了一些有用的系统属性，<code>LoggingSystem</code>为你创建了这些属性。它们是:</p><ul><li><code>$&#123;PID&#125;</code>当前的进程ID。</li><li><code>$&#123;LOG_FILE&#125;</code> 如果在Boot的外部配置中设置了<code>logging.file</code>。</li><li><code>$&#123;LOG_PATH&#125;</code> 如果设置了<code>logging.path</code>(表示一个用于存放日志文件的目录)。</li><li><code>$&#123;LOG_EXCEPTION_CONVERSION_WORD&#125;</code> 如果在Boot 的外部配置中设置了<code>logging.exception-conversion-word</code>。</li></ul><p>Spring Boot还使用自定义的Logback转换器在控制台(但不是在日志文件中)提供了一些漂亮的ANSI颜色终端输出。查看默认的<code>base.xml</code>配置了解更多细节。</p><p>如果Groovy在类路径上，你应该也能够用<code>logback.groovy</code>来配置Logback(如果有的话，它将会被优先考虑)。</p><h4 id="配置logback只以文件输出"><a href="#配置logback只以文件输出" class="headerlink" title="配置logback只以文件输出"></a>配置logback只以文件输出</h4><p>如果你想要禁用控制台日志记录，并且只将输出写入文件，那么你需要一个自定义的<code>logback-spring.xml</code>文件,它引入<code>file-appender.xml</code>而不引入<code>console-appender.xml</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_FILE&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;/&#125;spring.log&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/file-appender.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你还需要在<code>application.properties</code>中加入<code>logging.file</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.file&#x3D;myapplication.log</span><br></pre></td></tr></table></figure><h3 id="配置Log4j进行日志记录"><a href="#配置Log4j进行日志记录" class="headerlink" title="配置Log4j进行日志记录"></a>配置Log4j进行日志记录</h3><p>如果在类路径上存在<a href="http://logging.apache.org/log4j/2.x">Log4j 2</a>，Spring Boot 将支持Log4j 2进行日志配置。如果你正在使用starter来收集依赖关系，这意味着你必须排除Logback，然后将log4j 2包含在内。如果你没有使用starter，那么除了Log4j 2之外，你还需要提供<code>jcl-over-slf4j</code>(至少)。</p><p>最简单的方式可能是通过starter，尽管它需要配置一些不包含，例如在Maven中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Log4j starter的使用聚集了对常见日志必要的依赖项(例如，包括Tomcat使用的<code>java.util.logging</code>但是配置使用Log4j 2进行日志记录）。请参阅Actuator Log4j 2的示例以获得更多细节，并在实际操作中查看。</p></blockquote><h4 id="使用YAML或JSON来配置Log4j-2"><a href="#使用YAML或JSON来配置Log4j-2" class="headerlink" title="使用YAML或JSON来配置Log4j 2"></a>使用YAML或JSON来配置Log4j 2</h4><p>除了默认的XML配置格式之外，Log4j 2还支持YAML和JSON配置文件。要配置Log4j 2以使用另一种配置文件格式，将适当的依赖项添加到类路径，并命名配置文件以匹配你所选择的文件格式:</p><table><thead><tr><th>格式</th><th>依赖</th><th>文件名</th></tr></thead><tbody><tr><td>YAML</td><td>com.fasterxml.jackson.core:jackson-databind    com.fasterxml.jackson.dataformat:jackson-dataformat-yaml</td><td>log4j2.yaml log4j2.yml</td></tr><tr><td>JSON</td><td>com.fasterxml.jackson.core:jackson-databind</td><td>log4j2.json   log4j2.jsn</td></tr></tbody></table><h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><h3 id="配置自定义数据源"><a href="#配置自定义数据源" class="headerlink" title="配置自定义数据源"></a>配置自定义数据源</h3><p>要配置你自己的<code>DataSource</code>，请在你的配置中定义该类型的<code>@Bean</code>。 Spring Boot会在需要的地方重复使用你的<code>DataSource</code>，包括数据库初始化。 如果你需要将某些设置外部化，则可以轻松地将<code>DataSource</code>绑定到环境（请参阅<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/html/boot-features-external-config.html#boot-features-external-config-3rd-party-configuration">第24.7.1节“第三方配置”</a>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;app.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FancyDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.datasource.url&#x3D;jdbc:h2:mem:mydb</span><br><span class="line">app.datasource.username&#x3D;sa</span><br><span class="line">app.datasource.pool-size&#x3D;30</span><br></pre></td></tr></table></figure><p>假设你的<code>FancyDataSource</code>具有常规的JavaBean属性,包括url，用户名和池大小，那么在<code>DataSource</code>可用于其他组件之前，将自动绑定这些设置。 常规的<a href="http://www.docsh.site/docs/spring-boot/spring-boot-docs/current/en/reference/html/howto-database-initialization.html#howto-initialize-a-database-using-spring-jdbc">数据库初始化</a>也会发生（所以<code>spring.datasource.*</code>的相关子集仍然可以与你的自定义配置一起使用）。</p><p>如果你正在配置自定义的JNDI<code>DataSource</code>，则可以应用相同的原则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(destroyMethod=&quot;&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;app.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">JndiDataSourceLookup dataSourceLookup = <span class="keyword">new</span> JndiDataSourceLookup();</span><br><span class="line"><span class="keyword">return</span> dataSourceLookup.getDataSource(<span class="string">&quot;java:comp/env/jdbc/YourDS&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Boot还提供了一个实用的构造器类<code>DataSourceBuilder</code>，可用于创建其中一个标准数据源（如果它在类路径上）。构造器可以根据类路径上的可用内容来检测要使用的类。 它也会根据JDBC URL自动检测驱动程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用该<code>DataSource</code>运行应用程序，所需要的只是连接信息; 还可以提供特定于池的设置，请检查将在运行时使用的具体实现以获取更多详细信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;test</span><br><span class="line">app.datasource.username&#x3D;dbuser</span><br><span class="line">app.datasource.password&#x3D;dbpass</span><br><span class="line">app.datasource.pool-size&#x3D;30</span><br></pre></td></tr></table></figure><p>但有一个问题。 由于连接池的实际类型未公开，所以在你的自定义<code>DataSource</code>的元数据中不会生成任何键，并且你的IDE中没有自动提示功能（<code>DataSource</code>接口不公开任何属性）。 另外，如果你碰巧在类路径上有Hikari，这个基本的设置将不起作用，因为Hikari没有<code>url</code>属性（而是一个<code>jdbcUrl</code>属性）。 你将不得不重写你的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.datasource.jdbc-url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;test</span><br><span class="line">app.datasource.username&#x3D;dbuser</span><br><span class="line">app.datasource.password&#x3D;dbpass</span><br><span class="line">app.datasource.maximum-pool-size&#x3D;30</span><br></pre></td></tr></table></figure><p>你可以通过强制连接池使用并返回一个专门的实现，而不是<code>DataSource</code>来解决这个问题。 你将无法在运行时更改实现，但选项列表将是显式的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HikariDataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> DataSourceBuilder.create().type(HikariDataSource.class).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你甚至可以进一步利用<code>DataSourceProperties</code>为你做的事情，即如果没有提供一个合理的用户名和密码的URL,则提供一个默认的嵌入式数据库。 你可以很容易地从任何<code>DataSourceProperties</code>的状态初始化一个<code>DataSourceBuilder</code>，所以你可以注入Spring Boot自动创建的那个。 但是，这会将你的配置拆分为两个命名空间：url，用户名，密码，类型和驱动在<code>spring.datasource</code>上，其他的在自定义命名空间（<code>app.datasource</code>）上。为了避免这种情况，你可以在自定义命名空间上重新定义自定义的<code>DataSourceProperties</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">dataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HikariDataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> properties.initializeDataSourceBuilder().type(HikariDataSource.class)</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了选择了一个专用的连接池（在代码中）并且它的设置暴露在相同的命名空间，这个设置使你与默认情况下的Spring Boot配合。 由于<code>DataSourceProperties</code>为你处理<code>url</code>/<code>jdbcUrl</code>转义，因此可以像这样配置它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;test</span><br><span class="line">app.datasource.username&#x3D;dbuser</span><br><span class="line">app.datasource.password&#x3D;dbpass</span><br><span class="line">app.datasource.maximum-pool-size&#x3D;30</span><br></pre></td></tr></table></figure><blockquote><p>由于你的自定义配置选择Hikari，<code>app.datasource.type</code>将不起作用。 在实践中，构造器将被初始化为设置的任何可能的值，然后被对<code>.type()</code>的调用覆盖。</p></blockquote><p>更多详细信息请参见“Spring Boot功能”部分的<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/html/boot-features-sql.html#boot-features-configure-datasource">第29.1节“配置数据源”</a>和<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java"><code>DataSourceAutoConfiguration</code></a>类源代码。</p><h3 id="配置两个数据源"><a href="#配置两个数据源" class="headerlink" title="配置两个数据源"></a>配置两个数据源</h3><p>如果你需要配置多个数据源，则可以应用上一节中所述的相同技巧。 但是，你必须标记一个<code>DataSource``@Primary</code>，因为各种自动配置都希望能够按类型获得一个。</p><p>如果您创建自己的<code>DataSource</code>，则自动配置将退出。在下面的示例中，我们提供了与在主数据源上自动配置提供的完全相同的功能集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource.foo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">fooDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource.foo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">fooDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fooDataSourceProperties().initializeDataSourceBuilder().build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource.bar&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BasicDataSource <span class="title">barDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> DataSourceBuilder.create().type(BasicDataSource.class).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>必须将<code>fooDataSourceProperties</code>标记为<code>@Primary</code>，以便数据库初始化程序功能使用你的副本（如果使用的话）。</p></blockquote><p>这两个数据源也都是用于高级自定义的。 例如，你可以如下配置它们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.datasource.foo.type&#x3D;com.zaxxer.hikari.HikariDataSource</span><br><span class="line">app.datasource.foo.maximum-pool-size&#x3D;30</span><br><span class="line"></span><br><span class="line">app.datasource.bar.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;test</span><br><span class="line">app.datasource.bar.username&#x3D;dbuser</span><br><span class="line">app.datasource.bar.password&#x3D;dbpass</span><br><span class="line">app.datasource.bar.max-total&#x3D;30</span><br></pre></td></tr></table></figure><p>当然，你也可以将相同的概念应用于辅助<code>DataSource</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource.foo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">fooDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource.foo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">fooDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fooDataSourceProperties().initializeDataSourceBuilder().build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource.bar&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">barDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.datasource.bar&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">barDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> barDataSourceProperties().initializeDataSourceBuilder().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的这个例子在自定义命名空间上配置了两个数据源，这与Spring Boot在自动配置中做了相同的逻辑。</p><h3 id="使用Spring-Data仓库"><a href="#使用Spring-Data仓库" class="headerlink" title="使用Spring Data仓库"></a>使用Spring Data仓库</h3><p>Spring Data可以为你创建各种风格的<code>@Repository</code>接口。只要这些<code>@Repositories</code>包含在<code>@EnableAutoConfiguration</code>类的相同包（或子包）中，Spring Boot将为你处理所有这些接口。</p><p>对于许多应用程序来说，你需要的所有东西是把正确的Spring Data依赖关系放到你的类路径中（JPA有一个<code>spring-boot-starter-data-jpa</code>和一个Mongodb的<code>spring-boot-starter-data-mongodb</code>），创建一些仓库接口来处理你的<code>@Entity</code>对象。 有两个示例<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-data-jpa">JPA示例</a>和<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-data-mongodb">Mongodb示例</a>。</p><p>Spring Boot尝试根据找到的<code>@EnableAutoConfiguration</code>来猜测<code>@Repository</code>定义的位置。 为了更好的控制，可以使用<code>@EnableJpaRepositories</code>注解（来自Spring Data JPA）。</p><h3 id="从Spring配置中分离-Entity定义"><a href="#从Spring配置中分离-Entity定义" class="headerlink" title="从Spring配置中分离@Entity定义"></a>从Spring配置中分离@Entity定义</h3><p>Spring Boot尝试根据找到的<code>@EnableAutoConfiguration</code>来猜测你的<code>@Entity</code>定义的位置。 为了获得更多控制权，你可以使用<code>@EntityScan</code>注解，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@EntityScan(basePackageClasses=City.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置JPA属性"><a href="#配置JPA属性" class="headerlink" title="配置JPA属性"></a>配置JPA属性</h3><p>Spring Data JPA已经提供了一些与供应商无关的配置选项（例如用于SQL日志记录），Spring Boot公开了这些，还有一些作为hibernate的外部配置属性。 其中一些是根据上下文自动检测，所以你不应该设置它们。</p><p><code>spring.jpa.hibernate.ddl-auto</code>是一个特殊情况，因为它具有不同的默认值，这取决于运行时的条件。 如果使用嵌入式数据库，并且没有像Liquibase或Flyway这样的schema管理器处理<code>DataSource</code>，那么它将默认使用<code>create-drop</code>。 在其他情况下，它默认为<code>none</code>。</p><p>使用的方言也是根据当前的<code>DataSource</code>自动检测的，但是如果你想明确地使用方言，你可以自己设置<code>spring.jpa.database</code>，并绕过启动时的检查。</p><blockquote><p>指定一个<code>database</code>将导致定义良好的Hibernate方言的配置。一些数据库有不止一个<code>Dialect</code>，这有可能不适合你的需要。在这种情况下，你可以将<code>spring.jpa.database</code>设置为默认值，让Hibernate自己解决，或使用<code>spring.jpa.database-platform</code>属性设置方言。</p></blockquote><p>最常见的选项是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.hibernate.naming.physical-strategy&#x3D;com.example.MyPhysicalNamingStrategy</span><br><span class="line">spring.jpa.show-sql&#x3D;true</span><br></pre></td></tr></table></figure><p>另外，在创建本地<code>EntityManagerFactory</code>时，<code>spring.jpa.properties.*</code>中的所有属性都作为普通的JPA属性（去掉了前缀）传递。</p><h3 id="配置Hibernate命名策略"><a href="#配置Hibernate命名策略" class="headerlink" title="配置Hibernate命名策略"></a>配置Hibernate命名策略</h3><p>Hibernate使用<a href="http://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#naming">两种不同的命名策略</a>来将名称从对象模型映射到相应的数据库名称。物理和隐式策略实现的完全限定类名称可分别使用<code>spring.jpa.hibernate.naming.physical-strategy</code>和<code>spring.jpa.hibernate.naming.implicit-strategy</code>属性进行配置。</p><p>Spring Boot默认使用<code>SpringPhysicalNamingStrategy</code>配置物理命名策略。这个实现提供了与Hibernate 4相同的表结构：所有的点都被下划线替换，而且驼峰也被下划线替换。 默认情况下，所有表名都以小写形式生成，但如果你的schema 需要，则可以覆盖该标志。</p><p>具体来说，<code>TelephoneNumber</code>实体将被映射到<code>telephone_number</code>表。</p><p>如果你更喜欢使用Hibernate 5的默认值，请设置以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.hibernate.naming.physical-strategy&#x3D;org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</span><br></pre></td></tr></table></figure><p>有关更多详细信息，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaAutoConfiguration.java"><code>HibernateJpaAutoConfiguration</code></a>和<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/JpaBaseConfiguration.java"><code>JpaBaseConfiguration</code></a>。</p><h3 id="使用自定义EntityManagerFactory"><a href="#使用自定义EntityManagerFactory" class="headerlink" title="使用自定义EntityManagerFactory"></a>使用自定义EntityManagerFactory</h3><p>要完全控制<code>EntityManagerFactory</code>的配置，你需要添加一个名为“entityManagerFactory”的<code>@Bean</code>。 Spring Boot的自动配置基于该类型的bean的存在与否关闭其实体管理器。</p><h3 id="使用两个实体管理器"><a href="#使用两个实体管理器" class="headerlink" title="使用两个实体管理器"></a>使用两个实体管理器</h3><p>即使默认的<code>EntityManagerFactory</code>工作正常，你也需要定义一个新的，否则该类型的第二个bean的存在将关闭默认的这个。 为了简化操作，你可以使用Spring Boot提供的方便的<code>EntityManagerBuilder</code>，或者如果你愿意，可以直接使用Spring ORM中的<code>LocalContainerEntityManagerFactoryBean</code>。<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add two data sources configured as above</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">customerEntityManagerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> builder</span><br><span class="line">.dataSource(customerDataSource())</span><br><span class="line">.packages(Customer.class)</span><br><span class="line">.persistenceUnit(<span class="string">&quot;customers&quot;</span>)</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">orderEntityManagerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> builder</span><br><span class="line">.dataSource(orderDataSource())</span><br><span class="line">.packages(Order.class)</span><br><span class="line">.persistenceUnit(<span class="string">&quot;orders&quot;</span>)</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置几乎可以自行完成。要完成整个过程，你还需要为两个<code>EntityManagers</code>配置<code>TransactionManagers</code>。 如果你把其中一个标记为@Primary，它可以被Spring Boot中默认的<code>JpaTransactionManager</code>支持，另一个必须明确地注入一个新的实例。 或者你也可以使用跨越两者的JTA事务管理器。</p><p>如果你使用Spring Data，则需要相应地配置<code>@EnableJpaRepositories</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(basePackageClasses = Customer.class,</span></span><br><span class="line"><span class="meta">entityManagerFactoryRef = &quot;customerEntityManagerFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerConfiguration</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(basePackageClasses = Order.class,</span></span><br><span class="line"><span class="meta">entityManagerFactoryRef = &quot;orderEntityManagerFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderConfiguration</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用传统的persistence-xml"><a href="#使用传统的persistence-xml" class="headerlink" title="使用传统的persistence.xml"></a>使用传统的persistence.xml</h3><p>Spring不需要使用XML来配置JPA提供程序，并且Spring Boot假定你想要利用该功能。如果你喜欢使用<code>persistence.xml</code>，那么你需要定义自己的<code>LocalEntityManagerFactoryBean</code>（id为’entityManagerFactory’)类型的<code>@Bean</code>，并设置持久化单元名称。</p><p>有关默认设置，请参阅<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/JpaBaseConfiguration.java"><code>JpaBaseConfiguration</code></a>。</p><h3 id="使用Spring-Data-JPA和Mongo仓库"><a href="#使用Spring-Data-JPA和Mongo仓库" class="headerlink" title="使用Spring Data JPA和Mongo仓库"></a>使用Spring Data JPA和Mongo仓库</h3><p>Spring Data JPA和Spring Data Mongo可以自动为你创建<code>Repository</code>实现。 如果它们都出现在类路径中，那么可能需要做一些额外的配置来告诉Spring Boot你为哪一个（或两者）创建存储库。 最明显的方法是使用标准的Spring Data <code>@Enable*Repositories</code>，并告诉它你的<code>Repository</code>接口的位置（其中’*’是’Jpa’或’Mongo’或是两者）。</p><p>还有一些<code>spring.data.*.repositories.enabled</code>标志，你可以使用它们在外部配置中打开和关闭自动配置的存储库。例如，如果你想要关闭Mongo仓库并且仍然使用自动配置的<code>MongoTemplate</code>，这很有用。</p><p>其他自动配置的Spring Data  存储库类型（Elasticsearch，Solr）也存在同样的障碍和相同的功能。只需分别更改注解和标志的名称。</p><h3 id="暴露Spring数据仓库为REST端点"><a href="#暴露Spring数据仓库为REST端点" class="headerlink" title="暴露Spring数据仓库为REST端点"></a>暴露Spring数据仓库为REST端点</h3><p>Spring Data REST只要为应用程序启用了Spring MVC，就可以将<code>Repository</code>实现公开为REST端点。</p><p>Spring Boot公开了一些自定义<code>RepositoryRestConfiguration</code>的<code>spring.data.rest</code>命名空间的有用属性。如果你需要提供额外的定制，你应该使用<code>RepositoryRestConfigurer</code> bean。</p><blockquote><p>如果你没有在你自定义的<code>RepositoryRestConfigurer</code>中指定任何顺序，它将在Spring Boot在内部使用的那个后运行。 如果你需要指定顺序，请确保它大于0。</p></blockquote><h3 id="配置JPA使用的组件"><a href="#配置JPA使用的组件" class="headerlink" title="配置JPA使用的组件"></a>配置JPA使用的组件</h3><p>如果你想配置一个将被JPA使用的组件，那么你需要确保组件在JPA之前被初始化。 如果组件是自动配置的，Spring Boot将为你处理这个问题。例如，当Flyway自动配置时，Hibernate被配置为依赖于Flyway，这样后者有机会在Hibernate尝试使用它之前初始化数据库。</p><p>如果你自己配置组件，则可以使用<code>EntityManagerFactoryDependsOnPostProcessor</code>子类作为设置必需依赖项的便捷方式。例如，如果你使用Elasticsearch作为Hibernate Search的索引管理器，那么任何<code>EntityManagerFactory</code> bean都必须配置为依赖于<code>elasticsearchClient</code> bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> EntityManagerFactoryDependsOnPostProcessor&#125; that ensures that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> EntityManagerFactory&#125; beans depend on the &#123;<span class="doctag">@code</span> elasticsearchClient&#125; bean.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchJpaDependencyConfiguration</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">EntityManagerFactoryDependsOnPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ElasticsearchJpaDependencyConfiguration() &#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="string">&quot;elasticsearchClient&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据库初始化"><a href="#数据库初始化" class="headerlink" title="数据库初始化"></a>数据库初始化</h2><p>SQL数据库可以用不同的方式初始化，这取决于你选择的是什么技术。当然，只要数据库是一个独立的进程，你也可以手动完成。</p><h3 id="使用JPA初始化数据库"><a href="#使用JPA初始化数据库" class="headerlink" title="使用JPA初始化数据库"></a>使用JPA初始化数据库</h3><p>JPA具有用于生成DDL的功能，可以将这些功能设置为在启动时运行。 这是通过两个外部属性来控制的：</p><ul><li><code>spring.jpa.generate-ddl</code>（boolean）打开和关闭该功能，并且独立于供应商。</li><li><code>spring.jpa.hibernate.ddl-auto</code>（enum）是一个Hibernate特性，以更细粒度的方式控制该行为。</li></ul><h3 id="使用Hibernate初始化数据库"><a href="#使用Hibernate初始化数据库" class="headerlink" title="使用Hibernate初始化数据库"></a>使用Hibernate初始化数据库</h3><p>你可以显式设置<code>spring.jpa.hibernate.ddl-auto</code>，标准Hibernate属性值为<code>none</code>，<code>validate</code>，<code>update</code>，<code>create</code>，<code>create-drop</code>。 Spring Boot根据数据库是否为嵌入式的为你选择一个默认值：如果没有检测到schema管理器，则默认为<code>create-drop</code>，在其他所有情况下均设置为<code>none</code>。通过查看<code>Connection</code>类型来检测嵌入式数据库：<code>hsqldb</code>，<code>h2</code>和<code>derby</code>是嵌入式的，其余不是。从内存数据库切换到“真实”数据库时请小心，不要假定新平台中存在表和数据。 你必须显式设置<code>ddl-auto</code>，或使用其他机制来初始化数据库。</p><blockquote><p>你可以通过启用<code>org.hibernate.SQL</code>日志记录器来输出schema创建的过程。如果启用调试模式，将自动完成。</p></blockquote><p>另外，如果Hibernate从头开始创建schema（即，如果<code>ddl-auto</code>属性设置为<code>create</code>或<code>create-drop</code>），那么在启动时将执行类路径根目录中名为<code>import.sql</code>的文件。 这对于演示和测试是非常有用的。 这是一个Hibernate功能（与Spring无关）。</p><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><p>Spring Boot可以自动创建<code>DataSource</code>的schema（DDL脚本）并对其进行初始化（DML脚本）：它分别从标准根类路径位置<code>schema.sql</code>和<code>data.sql</code>中加载SQL。 另外，Spring Boot将处理<code>schema-$&#123;platform&#125;.sql</code>和<code>data-$&#123;platform&#125;.sql</code>文件（如果存在），其中<code>platform</code>是<code>spring.datasource.platform</code>的值。这允许你在必要时切换到数据库特定的脚本，例如你可以选择将其设置为数据库的供应商名称（<code>hsqldb</code>，<code>h2</code>，<code>oracle</code>，<code>mysql</code>，<code>postgresql</code>等）。</p><p>Spring Boot默认启用Spring JDBC初始化程序的快速失败功能，所以如果脚本导致异常，应用程序将无法启动。 你可以使用<code>spring.datasource.continue-on-error</code>来调整它。</p><blockquote><p>在基于JPA的应用程序中，可以选择让Hibernate创建schema或使用<code>schema.sql</code>，但不能两者同时使用。如果你选择了后者，请确保禁用<code>spring.jpa.hibernate.ddl-auto</code>。</p></blockquote><p>你也可以通过将<code>spring.datasource.initialize</code>设置为<code>false</code>来禁用初始化。</p><h3 id="初始化一个Spring-Batch数据库"><a href="#初始化一个Spring-Batch数据库" class="headerlink" title="初始化一个Spring Batch数据库"></a>初始化一个Spring Batch数据库</h3><p>如果你使用的是Spring Batch，那么它将为大多数流行的数据库平台预先打包SQL初始化脚本。 Spring Boot可以检测你的数据库类型并在启动时执行这些脚本。如果你使用嵌入式数据库，则默认情况下会发生这种情况。你也可以为任何数据库类型启用这个功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.batch.initialize-schema&#x3D;always</span><br></pre></td></tr></table></figure><p>你也可以使用<code>spring.batch.initialize-schema = never</code>显式地关闭初始化功能。</p><h3 id="使用更高级别的数据库迁移工具"><a href="#使用更高级别的数据库迁移工具" class="headerlink" title="使用更高级别的数据库迁移工具"></a>使用更高级别的数据库迁移工具</h3><p>Spring Boot支持两种更高级的迁移工具：<a href="http://flywaydb.org/">Flyway</a>和<a href="http://www.liquibase.org/">Liquibase</a>。</p><h4 id="启动时执行Flyway数据库迁移"><a href="#启动时执行Flyway数据库迁移" class="headerlink" title="启动时执行Flyway数据库迁移"></a>启动时执行Flyway数据库迁移</h4><p>要在启动时自动运行Flyway数据库迁移，请将<code>org.flywaydb:flyway-core</code>添加到类路径中。</p><p>迁移是以<code>V&lt;VERSION&gt;__&lt;NAME&gt;.sql</code>格式（带有<code>&lt;VERSION&gt;</code>下划线分隔的版本，例如’1’或’2_1’）的脚本。默认情况下，它们位于文件夹<code>classpath:db/migration</code>中，但是可以使用<code>spring.flyway.locations</code>修改它。你还可以添加特殊的<code>&#123;vendor&#125;</code>占位符来使用供应商特定的脚本。 假设：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.flyway.locations&#x3D;db&#x2F;migration&#x2F;&#123;vendor&#125;</span><br></pre></td></tr></table></figure><p>这个配置不是使用<code>db/migration</code>，而是根据数据库的类型（对于Mysql来说即<code>db/migration/mysql</code>）来设置使用的文件夹。可以在<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jdbc/DatabaseDriver.java"><code>DatabaseDriver</code></a>中查看受支持的数据库列表。</p><p>另请参阅flyway-core的Flyway类以了解可用设置（如模式等）的详细信息。另外，Spring Boot在<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/flyway/FlywayProperties.java"><code>FlywayProperties</code></a>中提供了一组属性，可用于禁用迁移或关闭位置检查。 Spring Boot将调用<code>Flyway.migrate（）</code>来执行数据库迁移。 如果你想要更多的控制，提供一个实现了<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/flyway/FlywayMigrationStrategy.java"><code>FlywayMigrationStrategy</code></a>的<code>@Bean</code>。</p><p>Flyway支持SQL和Java<a href="http://flywaydb.org/documentation/callbacks.html">回调</a>。 要使用基于SQL的回调，请将回调脚本放在<code>classpath:db/migration</code>文件夹中。 要使用基于Java的回调，创建一个或多个实现了<code>FlywayCallback</code>的Bean，或者最好是继承<code>BaseFlywayCallback</code>。 任何这样的bean将自动注册到<code>Flyway</code>。 他们可以通过使用<code>@Order</code>或实现<code>Ordered</code>来指定顺序。</p><p>默认情况下，Flyway将在你的上下文中自动装配（<code>@Primary</code>）<code>DataSource</code>，并将其用于迁移。 如果你喜欢使用不同的<code>DataSource</code>，你可以创建一个<code>@Bean</code>标记为<code>@FlywayDataSource</code> - 如果你这样做，记得创建另一个数据源,如果你需要两个数据源记得把它标记为<code>@Primary</code>。 或者，你可以通过在外部属性中设置<code>spring.flyway.[url，user，password]</code>来使用Flyway的原生<code>DataSource</code>。</p><p>这里有一个<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-flyway">Flyway示例</a>，你可以看到如何设置这些东西。</p><p>你也可以使用Flyway为特定场景提供数据。例如，你可以将测试专用的迁移脚本放在<code>src/test/resources</code>中，并且只有在你的应用程序开始测试时才会运行它们。 如果你想更复杂一点，可以使用特定profile的配置来自定义<code>spring.flyway.locations</code>，以便某些迁移脚本只在特定profile激活时运行。 例如，在<code>application-dev.properties</code>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.flyway.locations&#x3D;classpath:&#x2F;db&#x2F;migration,classpath:&#x2F;dev&#x2F;db&#x2F;migration</span><br></pre></td></tr></table></figure><p>使用该设置，<code>dev/db/migration</code>中的迁移脚本将仅在<code>dev</code> profile激活时运行。</p><h4 id="启动时执行Liquibase数据库迁移"><a href="#启动时执行Liquibase数据库迁移" class="headerlink" title="启动时执行Liquibase数据库迁移"></a>启动时执行Liquibase数据库迁移</h4><p>要在启动时自动运行Liquibase数据库迁移，请将<code>org.liquibase:liquibase-core</code>添加到你的类路径中。</p><p>主要的更改日志默认从<code>db/changelog/db.changelog-master.yaml</code>中读取，但可以设置使用<code>spring.liquibase.change-log</code>。除了YAML，Liquibase还支持JSON，XML和SQL更改日志格式。</p><p>默认情况下，Liquibase会在你的上下文中自动装载（<code>@Primary</code>）<code>DataSource</code>，并用它来进行迁移。 如果你喜欢使用不同的<code>DataSource</code>，你可以创建一个<code>@Bean</code>标记为<code>@LiquibaseDataSource</code> - 如果你这样做的话，记得创建另一个数据源，如果你想要两个数据源，就把它标记为<code>@Primary</code>。 或者，你可以通过在外部属性中设置<code>spring.liquibase.[url，user，password]</code>来使用Liquibase的原生<code>DataSource</code>。</p><p>有关上下文，默认模式等可用设置的详细信息，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/liquibase/LiquibaseProperties.java"><code>LiquibaseProperties</code></a>。</p><p>有一个<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-liquibase">Liquibase示例</a>，你可以看到如何设置。</p><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><h3 id="禁用事务的JMS会话"><a href="#禁用事务的JMS会话" class="headerlink" title="禁用事务的JMS会话"></a>禁用事务的JMS会话</h3><p>如果你的JMS代理不支持事务会话，则必须完全禁用事务支持。如果你创建自己的<code>JmsListenerContainerFactory</code>，则无需执行任何操作，因为默认情况下不会进行事务处理。 如果你想使用<code>DefaultJmsListenerContainerFactoryConfigurer</code>来重用Spring Boot的默认设置，可以按如下所示禁用事务性会话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactory <span class="title">jmsListenerContainerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ConnectionFactory connectionFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">DefaultJmsListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">DefaultJmsListenerContainerFactory listenerFactory =</span><br><span class="line"><span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">configurer.configure(listenerFactory, connectionFactory);</span><br><span class="line">listenerFactory.setTransactionManager(<span class="keyword">null</span>);</span><br><span class="line">listenerFactory.setSessionTransacted(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">return</span> listenerFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里覆盖了默认的工厂，并且它应该被应用到你的应用程序定义的任何其他工厂（如果有的话）。</p><h2 id="批处理应用"><a href="#批处理应用" class="headerlink" title="批处理应用"></a>批处理应用</h2><blockquote><p>默认情况下，批处理应用程序需要一个<code>DataSource</code>来存储作业详细信息。如果你不要这么做，你需要实现<code>BatchConfigurer</code>，请参阅<a href="http://docs.spring.io/spring-batch/apidocs/org/springframework/batch/core/configuration/annotation/EnableBatchProcessing.html"><code>@EnableBatchProcessing</code>的Javadoc</a>获取更多细节。</p></blockquote><h3 id="启动时执行Spring-Batch作业"><a href="#启动时执行Spring-Batch作业" class="headerlink" title="启动时执行Spring Batch作业"></a>启动时执行Spring Batch作业</h3><p>Spring Batch自动配置是通过在你的上下文中添加<code>@EnableBatchProcessing</code>（从Spring Batch）来实现的。</p><p>默认情况下，它会在启动时执行应用程序上下文中的<strong>所有</strong><code>Jobs</code>（有关详细信息，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/JobLauncherCommandLineRunner.java">JobLauncherCommandLineRunner</a>）。 你可以通过指定<code>spring.batch.job.names</code>（逗号分隔的作业名称模式）来限制到特定作业或作业的范围。</p><p>如果应用程序上下文包含<code>JobRegistry</code>，则在注册信息中查找<code>spring.batch.job.names</code>中的作业，而不是从上下文自动装配。 这是一个常见的模式，其中有更复杂的系统，在这个系统中多个作业在子环境中定义并集中注册。</p><p>有关更多详细信息，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/BatchAutoConfiguration.java">BatchAutoConfiguration</a>和<a href="https://github.com/spring-projects/spring-batch/blob/master/spring-batch-core/src/main/java/org/springframework/batch/core/configuration/annotation/EnableBatchProcessing.java">@EnableBatchProcessing</a>。</p><h2 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h2><h3 id="更改actuator端点的HTTP端口或地址"><a href="#更改actuator端点的HTTP端口或地址" class="headerlink" title="更改actuator端点的HTTP端口或地址"></a>更改actuator端点的HTTP端口或地址</h3><p>在独立应用程序中，Actuator HTTP端口默认与主HTTP端口相同。为了让应用程序在不同的端口上监听，可以设置外部属性<code>management.port</code>。要监听一个完全不同的网络地址（例如，如果你有一个用于管理的内部网络和一个用于外部用户应用的网络），你还可以将<code>management.address</code>设置为服务器能够绑定的有效IP地址。</p><p>有关更多详细信息，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/web/ManagementServerProperties.java"><code>ManagementServerProperties</code></a>源代码以及“Production-ready功能”部分中的<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#production-ready-customizing-management-server-port">第50.2节“自定义管理服务器端口”</a>。</p><h3 id="自定义“whitelabel”错误页面"><a href="#自定义“whitelabel”错误页面" class="headerlink" title="自定义“whitelabel”错误页面"></a>自定义“whitelabel”错误页面</h3><p>如果你遇到服务器错误（使用JSON和其他媒体类型的计算机客户端应该看到具有正确错误代码的合理响应），Spring Boot将安装一个“whitelabel”错误页面。</p><blockquote><p>设置<code>server.error.whitelabel.enabled = false</code>将关闭默认错误页面并恢复为你正在使用的servlet容器的默认值。请注意，Spring Boot仍然会尝试解决错误视图，所以你可能会添加你自己的错误页面，而不是完全禁用它。</p></blockquote><p>用你自己的覆盖错误页面取决于你正在使用的模板技术。例如，如果你使用的是Thymeleaf，则可以添加一个<code>error.html</code>模板，如果你使用的是FreeMarker，则可以添加一个<code>error.ftl</code>模板。一般来说，你需要的是一个用错误名称解析的<code>View</code>，和/或处理<code>/error</code>路径的<code>@Controller</code>。除非你替换了一些默认配置，否则你应该在你的<code>ApplicationContext</code>中找到一个<code>BeanNameViewResolver</code>，所以带有id<code>error</code>的<code>@Bean</code>将是一个简单的方法。查看<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/error/ErrorMvcAutoConfiguration.java"><code>ErrorMvcAutoConfiguration</code></a>以获取更多详情。</p><p>有关如何在servlet容器中注册处理程序的详细信息，另请参阅<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-error-handling">错误处理</a>一节。</p><h3 id="Actuator-和-Jersey"><a href="#Actuator-和-Jersey" class="headerlink" title="Actuator 和 Jersey"></a>Actuator 和 Jersey</h3><p>Actuator HTTP端点仅适用于基于Spring MVC的应用程序。如果你想使用Jersey并仍然使用Actuator，则需要启用Spring MVC（例如，依赖于<code>spring-boot-starter-web</code>）。默认情况下，Jersey和Spring MVC调度程序servlet都映射到相同的路径（<code>/</code>）。你将需要更改其中一个的路径（通过为Spring MVC配置<code>server.servlet.path</code>或为Jersey配置<code>spring.jersey.application-path</code>）。 例如，如果将<code>server.servlet.path = / system</code>添加到<code>application.properties</code>中，则actuator HTTP端点将可以在<code>/ system</code>下使用。</p><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><h3 id="关闭Spring-Boot-安全配置"><a href="#关闭Spring-Boot-安全配置" class="headerlink" title="关闭Spring Boot 安全配置"></a>关闭Spring Boot 安全配置</h3><p>如果你在应用程序中的任何位置使用<code>@EnableWebSecurity</code>定义<code>@Configuration</code>，它将关闭Spring Boot中的默认Web应用程序安全设置（但保留Actuator的安全配置）。 要调整默认值，请尝试设置<code>security.*</code>（请参阅<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/SecurityProperties.java"><code>SecurityProperties</code></a>以获取可用设置的详细信息）以及<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#common-application-properties-security">Common应用程序属性</a>的<code>SECURITY</code>部分。</p><h3 id="更改AuthenticationManager并添加用户帐户"><a href="#更改AuthenticationManager并添加用户帐户" class="headerlink" title="更改AuthenticationManager并添加用户帐户"></a>更改AuthenticationManager并添加用户帐户</h3><p>如果你提供了一个类型为<code>AuthenticationManager</code>的<code>@Bean</code>，那么将不会创建默认的，所以你可以使用Spring Security的全部功能（例如<a href="http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#jc-authentication">各种认证选项</a>）。</p><p>Spring Security还提供了一个方便的<code>AuthenticationManagerBuilder</code>，它可以用来构建一个带有通用选项的<code>AuthenticationManager</code>。在webapp中使用这种方法的推荐方法是将其注入<code>WebSecurityConfigurerAdapter</code>中的void方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfiguration</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureGlobal</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">auth.inMemoryAuthentication()</span><br><span class="line">.withUser(<span class="string">&quot;barry&quot;</span>).password(<span class="string">&quot;password&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>); <span class="comment">// ... etc.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... other stuff for application security</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将其放在嵌套类或独立类中（即不会混入大量可能影响实例化顺序的其他<code>@Beans</code>），你将获得最佳结果。 <a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-web-secure">安全的Web示例</a>是一个有用的模板。</p><p>如果遇到实例化问题（例如，对用户详细信息存储使用JDBC或JPA），将<code>AuthenticationManagerBuilder</code>回调提取到<code>GlobalAuthenticationConfigurerAdapter</code>中（在<code>init()</code>方法中，以便在其他地方需要身份验证管理器之前进行）有可能是值得。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationManagerConfiguration</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class"><span class="title">GlobalAuthenticationConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(AuthenticationManagerBuilder auth)</span> </span>&#123;</span><br><span class="line">auth.inMemoryAuthentication() <span class="comment">// ... etc.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用代理服务器时启用HTTPS"><a href="#使用代理服务器时启用HTTPS" class="headerlink" title="使用代理服务器时启用HTTPS"></a>使用代理服务器时启用HTTPS</h3><p>确保你的所有主要端点只能通过HTTPS使用，这对于任何应用程序来说都是非常重要的任务。 如果你使用Tomcat作为servlet容器，那么Spring Boot会在检测到某些环境设置时自动添加Tomcat自己的<code>RemoteIpValve</code>，并且你应该能够依赖<code>HttpServletRequest</code>来报告它是否安全（即使是代理的下游 服务器处理真正的SSL终端）。标准行为是由是否存在某些请求头（<code>x-forwarded-for</code>和<code>x-forwarded-proto</code>）来决定的，它们的名字是常规的，所以它应该可以与大多数前端代理一起工作。你可以通过在<code>application.properties</code>中添加一些条目来打开阀门,例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.remote-ip-header&#x3D;x-forwarded-for</span><br><span class="line">server.tomcat.protocol-header&#x3D;x-forwarded-proto</span><br></pre></td></tr></table></figure><p>（任何一个属性的存在都会打开阀门，或者你可以通过添加<code>TomcatServletWebServerFactory</code> bean来自行添加<code>RemoteIpValve</code>。）</p><p>Spring Security也可以被配置为需要所有（或某些请求）的安全通道。 要在Spring Boot应用程序中切换，只需在<code>application.properties</code>中将<code>security.require_ssl</code>设置为<code>true</code>即可。</p><h2 id="热加载"><a href="#热加载" class="headerlink" title="热加载"></a>热加载</h2><h3 id="刷新静态内容"><a href="#刷新静态内容" class="headerlink" title="刷新静态内容"></a>刷新静态内容</h3><p>有几个热加载的选项。推荐的方法是使用<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#using-boot-devtools"><code>spring-boot-devtools</code></a>，因为它提供了额外的开发期间的功能，如支持快速应用程序重启和LiveReload以及合理的开发期间的配置（例如模板缓存）。Devtools通过监视类路径的变化来工作。这意味着静态资源的变化必须“构建”，以使变更生效。默认情况下，当你保存更改时，这会在Eclipse中自动发生。在IntelliJ IDEA中，Make Project将触发必要的构建。由于<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#using-boot-devtools-restart-exclude">默认的重新启动排除</a>，对静态资源的更改不会触发应用程序的重新启动。但是，他们会触发一个实时的重新加载。</p><p>另外，在IDE中运行（特别是在调试时）是一种很好的开发方式（所有的现代IDE都允许重新加载静态资源，并且通常也可以热加载Java类的变化）。</p><p>最后，可以配置Maven和Gradle插件（请参阅<code>addResources</code>属性）以支持从命令行直接从源文件重新加载静态文件。如果你使用更高级别的工具编写代码，则可以将其用于外部css/js编译。</p><h3 id="不重启容器刷新模板"><a href="#不重启容器刷新模板" class="headerlink" title="不重启容器刷新模板"></a>不重启容器刷新模板</h3><p>Spring Boot支持的大部分模板技术都包含禁用缓存的配置选项（请参阅下面的详细信息）。 如果你使用的是<code>spring-boot-devtools</code>模块，则在开发时将<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#using-boot-devtools-property-defaults">自动为你配置</a>这些属性。</p><h4 id="Thymeleaf-模板"><a href="#Thymeleaf-模板" class="headerlink" title="Thymeleaf 模板"></a>Thymeleaf 模板</h4><p>如果你使用的是Thymeleaf，则将<code>spring.thymeleaf.cache</code>设置为<code>false</code>。 有关其他Thymeleaf自定义选项，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/thymeleaf/ThymeleafAutoConfiguration.java"><code>ThymeleafAutoConfiguration</code></a>。</p><h4 id="FreeMarker-模板"><a href="#FreeMarker-模板" class="headerlink" title="FreeMarker 模板"></a>FreeMarker 模板</h4><p>如果你正在使用FreeMarker，则将<code>spring.freemarker.cache</code>设置为<code>false</code>。 有关其他FreeMarker自定义选项，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/freemarker/FreeMarkerAutoConfiguration.java"><code>FreeMarkerAutoConfiguration</code></a>。</p><h4 id="Groovy-模板"><a href="#Groovy-模板" class="headerlink" title="Groovy 模板"></a>Groovy 模板</h4><p>如果你正在使用Groovy模板，则将<code>spring.groovy.template.cache</code>设置为<code>false</code>。 有关其他Groovy自定义选项，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/groovy/template/GroovyTemplateAutoConfiguration.java"><code>GroovyTemplateAutoConfiguration</code></a>。</p><h3 id="快速重启"><a href="#快速重启" class="headerlink" title="快速重启"></a>快速重启</h3><p><code>spring-boot-devtools</code>模块支持应用程序自动重新启动。虽然速度不如JRebel这样的技术，但通常比“冷启动”要快得多。在调查下面讨论的一些更复杂的重新加载选项之前，你应该尝试一下。</p><p>有关更多详细信息，请参阅<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#using-boot-devtools">第20章开发人员工具</a>部分。</p><h3 id="不重启容器重新加载Java类"><a href="#不重启容器重新加载Java类" class="headerlink" title="不重启容器重新加载Java类"></a>不重启容器重新加载Java类</h3><p>现代的IDE（Eclipse，IDEA等）都支持字节码的热交换，所以如果你做了一个不影响类或方法签名的改变，它应该利索地重新加载，没有副作用。</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><h3 id="生成构建信息"><a href="#生成构建信息" class="headerlink" title="生成构建信息"></a>生成构建信息</h3><p>Maven和Gradle插件都允许生成包含项目坐标，名称和版本的构建信息。该插件也可以配置为通过配置添加其他属性。 当这个文件出现时，Spring Boot会自动配置一个<code>BuildProperties</code> bean。</p><p>要使用Maven生成构建信息，请为<code>build-info</code> goal添加一个execution：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.BUILD-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>build-info<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>查看<a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/maven-plugin//">Spring Boot Maven Plugin文档</a>以获取更多详细信息。</p></blockquote><p>Gradle一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">springBoot &#123;</span><br><span class="line">buildInfo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用DSL添加其他属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">springBoot  &#123;</span><br><span class="line">buildInfo &#123;</span><br><span class="line">additionalProperties &#x3D; [</span><br><span class="line">&#39;foo&#39;: &#39;bar&#39;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成git信息"><a href="#生成git信息" class="headerlink" title="生成git信息"></a>生成git信息</h3><p>Maven和Gradle都允许在构建项目时生成一个<code>git.properties</code>文件，其中包含有关<code>git</code>源代码库状态的信息。</p><p>对于Maven用户来说，<code>spring-boot-starter-parent</code> POM包含一个预先配置的插件来生成一个<code>git.properties</code>文件。 只需将以下声明添加到你的POM：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>pl.project13.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>git-commit-id-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Gradle用户可以使用<a href="https://plugins.gradle.org/plugin/com.gorylenko.gradle-git-properties"><code>gradle-git-properties</code></a>插件获得相同的结果:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">id <span class="string">&quot;com.gorylenko.gradle-git-properties&quot;</span> version <span class="string">&quot;1.4.17&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>git.properties</code>中的提交时间预计与<code>yyyy-MM-dd’T’HH:mm:ssZ</code>格式匹配。这是上面列出的两个插件的默认格式。使用这种格式可以将时间解析成<code>Date</code>，并在序列化为JSON时由Jackson的日期序列化配置设置控制它的格式。</p></blockquote><h3 id="自定义依赖版本"><a href="#自定义依赖版本" class="headerlink" title="自定义依赖版本"></a>自定义依赖版本</h3><p>如果你使用直接或间接从<code>spring-boot-dependencies</code>（例如<code>spring-boot-starter-parent</code>）继承的Maven构建，但是你想重写特定的第三方依赖项，则可以添加适当的<code>&lt;properties&gt;</code>元素。浏览<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-dependencies/pom.xml"><code>spring-boot-dependencies</code></a> POM以获取完整的属性列表。 例如，要选择一个不同的slf4j版本，你可以添加以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.7.5<span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这只适用于你的Maven项目是从<code>spring-boot-dependencies</code>继承（直接或间接）下来的。 如果你在你的<code>dependencyManagement</code>部分中用<code>&lt;scope&gt;import&lt;/scope&gt;</code>添加了<code>spring-boot-dependencies</code>，那么你必须自己重新定义这个artifact，而不是重写属性。</p></blockquote><blockquote><p>每个Spring Boot版本都是针对特定的第三方依赖进行设计和测试的。覆盖版本可能会导致兼容性问题。</p></blockquote><h3 id="使用Maven创建可执行jar"><a href="#使用Maven创建可执行jar" class="headerlink" title="使用Maven创建可执行jar"></a>使用Maven创建可执行jar</h3><p><code>spring-boot-maven-plugin</code>可以用来创建一个可执行的“fat”JAR。如果你使用的是<code>spring-boot-starter-parent</code> POM，则可以简单地声明该插件，并将你的jar包重新打包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你不使用父POM，你仍然可以使用这个插件，但是你必须另外添加一个<code>&lt;executions&gt;</code>部分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.BUILD-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有关完整的使用详细信息，请参阅<a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/maven-plugin//usage.html">插件文档</a>。</p><h3 id="使用Spring-Boot应用程序作为依赖"><a href="#使用Spring-Boot应用程序作为依赖" class="headerlink" title="使用Spring Boot应用程序作为依赖"></a>使用Spring Boot应用程序作为依赖</h3><p>像war文件一样，Spring Boot应用程序并不打算用作依赖项。如果你的应用程序包含要与其他项目共享的类，则推荐的方法是将该代码移动到单独的模块中。你的应用程序和其他项目可以依靠这个单独的模块。</p><p>如果你不能按照上面的建议重新调整你的代码，那么Spring Boot的Maven和Gradle插件必须被配置为产生一个适合用作依赖项的独立的组件。可执行文件不能用作依赖项，因为<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#executable-jar-jar-file-structure">可执行的jar格式</a>在<code>BOOT-INF/classes</code>中打包应用程序类。这意味着当可执行jar被用作依赖时，它们不能被找到。</p><p>为了生成两个组件，一个可以用作依赖关系，一个可执行，必须指定一个分类器。此分类器应用于可执行文件的名称，保留用作依赖项的默认文件。</p><p>要在Maven中配置<code>exec</code>的分类器，可以使用以下配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;classifier&gt;exec&lt;/classifier&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><h3 id="当可执行的jar运行时，提取特定的库"><a href="#当可执行的jar运行时，提取特定的库" class="headerlink" title="当可执行的jar运行时，提取特定的库"></a>当可执行的jar运行时，提取特定的库</h3><p>可执行jar中的大多数内部库不需要解压来运行，但某些库可能会有问题。例如，JRuby包含自己的内部jar支持，它假设<code>jruby-complete.jar</code>总是直接作为一个文件直接使用。</p><p>为了处理任何有问题的库，可以标记特定的内部jar应该在可执行jar第一次运行时自动解压到“temp文件夹”。</p><p>例如，为了说明JRuby应该被标记为使用Maven Plugin解压，你可以添加以下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">requiresUnpack</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jruby<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jruby-complete<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">requiresUnpack</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用exclusions-创建不可执行的JAR"><a href="#使用exclusions-创建不可执行的JAR" class="headerlink" title="使用exclusions 创建不可执行的JAR"></a>使用exclusions 创建不可执行的JAR</h3><p>通常，如果你将可执行文件和不可执行的jar作为构建产品，则可执行文件版本将具有作为库的jar中不需要的其他配置文件。 例如,不可执行的JAR中可能会排除<code>application.yml</code>配置文件。</p><p><code>maven-jar-plugin</code>用来暴露一个<code>forceCreation</code>属性，允许你在<code>repackage</code> goal 运行后<em>再次</em>创建jar。可以说，由于它依赖于插件执行的顺序，所以它有点脆弱。 在Maven中，可执行的jar文件必须是主要的工件，你可以为库添加一个分类的jar：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>lib<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">classifier</span>&gt;</span>lib<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="远程调试Maven启动的Spring-Boot应用程序"><a href="#远程调试Maven启动的Spring-Boot应用程序" class="headerlink" title="远程调试Maven启动的Spring Boot应用程序"></a>远程调试Maven启动的Spring Boot应用程序</h3><p>要将一个远程调试器连接到一个使用Maven启动的Spring Boot应用程序，你可以使用<a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/maven-plugin//">maven插件</a>的<code>jvmArguments</code>属性。</p><p>查看<a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/maven-plugin//examples/run-debug.html">这个例子</a>了解更多细节。</p><h3 id="用Ant构建可执行存档时不使用spring-boot-antlib"><a href="#用Ant构建可执行存档时不使用spring-boot-antlib" class="headerlink" title="用Ant构建可执行存档时不使用spring-boot-antlib"></a>用Ant构建可执行存档时不使用spring-boot-antlib</h3><h2 id="传统部署方式"><a href="#传统部署方式" class="headerlink" title="传统部署方式"></a>传统部署方式</h2><h3 id="创建可部署的war文件"><a href="#创建可部署的war文件" class="headerlink" title="创建可部署的war文件"></a>创建可部署的war文件</h3><p>生成可部署的war文件的第一步是提供一个<code>SpringBootServletInitializer</code>子类并覆盖其<code>configure</code>方法。 这将使用Spring框架的Servlet 3.0支持功能，并当它由servlet容器启动时允许你配置你的应用程序。通常，你更新你的应用程序的主类来继承<code>SpringBootServletInitializer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> application.sources(Application.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步是更新你的构建配置，以便你的项目生成一个war文件，而不是一个jar文件。 如果你使用的是Maven，并使用<code>spring-boot-starter-parent</code>（会为你配置Maven的war插件），你只需修改<code>pom.xml</code>将 packaging 更改为war：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;packaging&gt;war&lt;&#x2F;packaging&gt;</span><br></pre></td></tr></table></figure><p>如果你使用的是Gradle，则需要修改<code>build.gradle</code>启用war插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;war&#39;</span><br></pre></td></tr></table></figure><p>这个过程的最后一步是确保嵌入的servlet容器不会干扰要部署war文件的servlet容器。 为此，你需要标记嵌入式servlet容器依赖项为provided。</p><p>在Maven中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- … --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- … --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Gradle中：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">providedRuntime <span class="string">&#x27;org.springframework.boot:spring-boot-starter-tomcat&#x27;</span></span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>providedRuntime</code>比Gradle的<code>compileOnly</code>配置更受欢迎，因为在其他限制中，<code>compileOnly</code>依赖不在测试类路径上，因此任何基于Web的集成测试都将失败。</p></blockquote><p>如果你使用的是<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#build-tool-plugins">Spring Boot构建工具</a>，则标记嵌入的Servlet容器依赖项为provided将生成一个可执行的war文件，其中提供的依赖项打包在<code>lib-provided</code>的目录中。这意味着，除了可以部署到servlet容器之外，还可以在命令行上使用<code>java -jar</code>运行应用程序。</p><blockquote><p>查看Spring Boot的示例应用程序，可以找到上述配置的<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-traditional/pom.xml">基于Maven的示例</a>。</p></blockquote><h3 id="为老版本servlet容器创建可部署war文件"><a href="#为老版本servlet容器创建可部署war文件" class="headerlink" title="为老版本servlet容器创建可部署war文件"></a>为老版本servlet容器创建可部署war文件</h3><p>较老的Servlet容器不支持Servlet 3.0中使用的<code>ServletContextInitializer</code>引导进程。你仍然可以在这些容器中使用Spring和Spring Boot，但是你将需要将<code>web.xml</code>添加到你的应用程序，并将其配置为通过<code>DispatcherServlet</code>加载<code>ApplicationContext</code>。</p><h3 id="将现有应用转换为Spring-Boot应用"><a href="#将现有应用转换为Spring-Boot应用" class="headerlink" title="将现有应用转换为Spring Boot应用"></a>将现有应用转换为Spring Boot应用</h3><p>对于非Web应用程序来说，应该很简单（丢弃创建<code>ApplicationContext</code>的代码并将其替换为对<code>SpringApplication</code>或<code>SpringApplicationBuilder</code>的调用）。 Spring MVC Web应用程序通常可以首先创建可部署的war应用程序，然后稍后将其迁移到可执行的war和/或jar。 <a href="http://spring.io/guides/gs/convert-jar-to-war/">“将jar转换为war的入门指南”</a>可能对你非常有用。</p><p>通过扩展<code>SpringBootServletInitializer</code>（例如，在一个名为<code>Application</code>的类）中创建一个可部署的war，并添加Spring Boot <code>@SpringBootApplication</code>注解。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Customize the application or call application.sources(...) to add sources</span></span><br><span class="line"><span class="comment">// Since our example is itself a @Configuration class (via @SpringBootApplication)</span></span><br><span class="line"><span class="comment">// we actually don&#x27;t need to override this method.</span></span><br><span class="line"><span class="keyword">return</span> application;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请记住，无论你放在源代码中的是什么，只是一个Spring <code>ApplicationContext</code>，通常任何已经工作的东西都应该在这里工作。可能稍后会删除一些bean，并让Spring Boot 为它们提供自己的默认值，但应该可以先做一些工作。</p><p>可以将静态资源移动到类路径根中的<code>/public</code>（或<code>/static</code>或<code>/resources</code>或/ <code>META-INF/resources</code>）。<code>messages.properties</code>也是如此。（Spring Boot会在类路径的根目录中自动检测到这个）。</p><p>Spring <code>DispatcherServlet</code>和Spring Security的使用不需要进一步的修改。如果你的应用程序中有其他功能，例如使用其他servlet或过滤器，那么你可能需要在<code>Application</code>上下文中添加一些配置，从<code>web.xml</code>中替换这些元素，如下所示：</p><ul><li><p><code>Servlet</code>或<code>ServletRegistrationBean</code>类型的<code>@Bean</code>将该bean安装到容器中，就好像它是<code>web.xml</code>中的<code>&lt;servlet /&gt;</code>和<code>&lt;servlet-mapping /&gt;</code>一样。</p></li><li><p>类型为<code>Filter</code>或<code>FilterRegistrationBean</code>的<code>@Bean</code>的行为类似（如<code>&lt;filter /&gt;</code>和<code>&lt;filter-mapping /&gt;</code>）。</p></li><li><p>XML文件中的<code>ApplicationContext</code>可以通过<code>Application</code>中的<code>@ImportResource</code>添加。 或者注解配置大量使用的简单情况已经可以作为<code>@Bean</code>定义在几行代码中重新创建。</p><p>一旦war 生效，我们通过向我们的<code>Application</code>添加<code>main</code>方法来使其可以执行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>如果你打算将应用作为war或可执行应用程序启动，则需要在<code>SpringBootServletInitializer</code>回调和<code>main</code>方法都可用的方法中共享构建器的自定义设置，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;@SpringBootApplication</span><br><span class="line">&gt;public class Application extends SpringBootServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;</span><br><span class="line">return configureApplication(builder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">configureApplication(new SpringApplicationBuilder()).run(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static SpringApplicationBuilder configureApplication(SpringApplicationBuilder builder) &#123;</span><br><span class="line">return builder.sources(Application.class).bannerMode(Banner.Mode.OFF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><p>应用程序可以分为多个类别：</p><ul><li>没有<code>web.xml</code>的Servlet 3.0+应用程序。</li><li>带有<code>web.xml</code>的应用程序.</li><li>具有上下文层次的应用程序.</li><li>没有上下文层次的应用程序.</li></ul><p>所有这些都应该适合转换，但每个可能需要稍微不同的技巧。</p><p>如果Servlet 3.0+应用程序已经使用Spring Servlet 3.0+初始化程序支持类，那么它们可能会非常容易转换。通常，来自现有<code>WebApplicationInitializer</code>的所有代码都可以移入<code>SpringBootServletInitializer</code>。如果你现有的应用程序有多个<code>ApplicationContext</code>（例如，如果它使用<code>AbstractDispatcherServletInitializer</code>），那么你可能能够将所有上下文源压缩到一个<code>SpringApplication</code>中。你可能遇到的主要难题是如果这不起作用，你需要维护上下文层次结构。请参阅<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-build-an-application-context-hierarchy">构建层次结构的示例</a>。现有的包含Web特定功能父上下文通常需要分解，以便所有<code>ServletContextAware</code>组件都在子上下文中。</p><p>不是Spring应用的应用程序可能会转换成Spring Boot应用程序，上面的指导可能会有帮助，但是你的路可能会有所不同。</p><h3 id="部署WAR到WebLogic"><a href="#部署WAR到WebLogic" class="headerlink" title="部署WAR到WebLogic"></a>部署WAR到WebLogic</h3><p>要将Spring Boot应用程序部署到WebLogic，必须确保servlet初始化程序直接实现<code>WebApplicationInitializer</code>（即使从已经实现它的基类中进行继承）。</p><p>一个典型的WebLogic初始化器是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.web.SpringBootServletInitializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.WebApplicationInitializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用logback，则还需要告知WebLogic更喜欢打包的版本，而不是预装在服务器上的版本。 你可以通过添加具有以下内容的<code>WEB-INF/weblogic.xml</code>文件来执行此操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wls:weblogic-web-app</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:wls</span>=<span class="string">&quot;http://xmlns.oracle.com/weblogic/weblogic-web-app&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">http://java.sun.com/xml/ns/javaee/ejb-jar_3_0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://xmlns.oracle.com/weblogic/weblogic-web-app</span></span></span><br><span class="line"><span class="tag"><span class="string">http://xmlns.oracle.com/weblogic/weblogic-web-app/1.4/weblogic-web-app.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wls:container-descriptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wls:prefer-application-packages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wls:package-name</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">wls:package-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">wls:prefer-application-packages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">wls:container-descriptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">wls:weblogic-web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在老版本容器-Servlet-2-5-中部署WAR"><a href="#在老版本容器-Servlet-2-5-中部署WAR" class="headerlink" title="在老版本容器(Servlet 2.5)中部署WAR"></a>在老版本容器(Servlet 2.5)中部署WAR</h3><p>Spring Boot使用Servlet 3.0 API来初始化<code>ServletContext</code>（注册<code>Servlets</code>等），所以不能在Servlet 2.5容器中使用相同的应用程序。然而，使用一些特殊的工具可以在一个较老的容器上运行Spring Boot应用程序。 如果你依赖了<code>org.springframework.boot:spring-boot-legacy</code>（<a href="https://github.com/scratches/spring-boot-legacy">独立</a>于Spring Boot的核心并且目前在1.0.2.RELEASE上提供），那么你只需要创建一个<code>web.xml</code>并 声明一个上下文监听器来创建应用程序上下文以及你的过滤器和servlet。上下文监听器是Spring Boot的特殊用途，但其余部分对于Servlet 2.5中的Spring应用程序来说是正常的。 例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">&quot;2.5&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>demo.Application<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.boot.legacy.context.web.SpringBootContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>metricsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>metricsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextAttribute<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.springframework.web.context.WebApplicationContext.ROOT<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用一个应用程序上下文（由上下文监听器创建的上下文），并使用init参数将其附加到<code>DispatcherServlet</code>。 这在Spring Boot应用程序中是正常的（通常你只有一个应用程序上下文）。</p><h3 id="使用Jedis-代替Lettuce"><a href="#使用Jedis-代替Lettuce" class="headerlink" title="使用Jedis 代替Lettuce"></a>使用Jedis 代替Lettuce</h3><p>Spring Boot starter（<code>spring-boot-starter-data-redis</code>）默认使用<a href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a>。 你需要排除该依赖关系，并包含<a href="https://github.com/xetorthio/jedis/">Jedis</a>。 Spring Boot管理这些依赖关系，以使这个过程尽可能简单。<br>在Maven中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Gradle中：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configurations</span> &#123;</span><br><span class="line"><span class="keyword">compile</span>.<span class="keyword">exclude</span> module: <span class="string">&quot;lettuce&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line"><span class="keyword">compile</span>(<span class="string">&quot;redis.clients:jedis&quot;</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> How to </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 八- 构建工具插件</title>
      <link href="/post/4406/"/>
      <url>/post/4406/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot提供Maven和Gradle的构建工具插件。插件提供了各种功能，包括可执行jar的打包。 本节提供有关这两个插件的更多详细信息，以及如果需要扩展不受支持的构建系统的一些帮助。 如果你刚刚开始，你可能需要先阅读<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#using-boot">第三部分“使用Spring Boot”</a>一节中的<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#using-boot-build-systems">“第13章，构建系统”</a>。</p><h2 id="Spring-Boot-Maven-plugin"><a href="#Spring-Boot-Maven-plugin" class="headerlink" title="Spring Boot Maven plugin"></a>Spring Boot Maven plugin</h2><p>Spring Boot Maven插件在Maven中提供Spring Boot支持，允许你打包可执行的jar或war包并可以直接运行应用程序。要使用它，你必须使用Maven 3.2（或更高版本）。</p><blockquote><p>有关完整的插件文档，请参阅Spring Boot Maven插件网站。</p></blockquote><h3 id="引入插件"><a href="#引入插件" class="headerlink" title="引入插件"></a>引入插件</h3><p>要使用Spring Boot Maven Plugin，只需在<code>pom.xml</code>的<code>plugins</code>部分包含相应的XML</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.BUILD-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此配置将重新打包在Maven生命周期的<code>package</code>阶段期间构建的jar或war。 以下示例展示了<code>target</code>目录中的重新打包的jar以及原始jar：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mvn package</span><br><span class="line">$ ls target&#x2F;*.jar</span><br><span class="line">target&#x2F;myproject-1.0.0.jar target&#x2F;myproject-1.0.0.jar.original</span><br></pre></td></tr></table></figure><p>如果你没有包含上述的<code>&lt;execution /&gt;</code>配置，你可以自行运行该插件（但是仅当使用package目标时）。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mvn package spring-boot:repackage</span><br><span class="line">$ ls target&#x2F;*.jar</span><br><span class="line">target&#x2F;myproject-1.0.0.jar target&#x2F;myproject-1.0.0.jar.original</span><br></pre></td></tr></table></figure><p>如果你正在使用里程碑或快照版本，还需要添加适当的<code>pluginRepository</code>元素：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.spring.io/snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="打包可执行jar的war文件"><a href="#打包可执行jar的war文件" class="headerlink" title="打包可执行jar的war文件"></a>打包可执行jar的war文件</h3><p>一旦你的pom.xml中包含了<code>spring-boot-maven-plugin</code>，它将自动尝试重写包，使其可以使用<code>spring-boot:repackage</code>目标来执行。你应该使用常规的<code>packaging</code>元素配置你的项目来构建jar或war（如适用）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- ... --&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line">    &lt;!-- ... --&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>你的现有包将在<code>package</code>阶段由Spring Boot增强。 你要启动的主类可以使用配置选项指定，也可以以常规方式向清单添加<code>Main-Class</code>属性。 如果你没有指定一个主类，那么插件将搜索一个带有<code>public static void main(String[] args)</code>方法的类。</p><p>要构建和运行项目artifact，可以输入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mvn package</span><br><span class="line">$ java -jar target&#x2F;mymodule-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>要构建可执行并可部署到外部容器的war文件，你需要将嵌入式容器依赖项标记为“provided”，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>有关如何创建可部署的war文件的更多详细信息，请参阅”<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-create-a-deployable-war-file">第86.1节”创建可部署的war文件”</a>“部分。</p></blockquote><p><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/maven-plugin//">插件信息页面</a>中提供了高级配置选项和示例。</p><h2 id="Spring-Boot-Gradle-plugin"><a href="#Spring-Boot-Gradle-plugin" class="headerlink" title="Spring Boot Gradle plugin"></a>Spring Boot Gradle plugin</h2><p>Spring Boot Gradle插件在Gradle中提供Spring Boot支持，允许你打包可执行的jar或war 包，运行Spring Boot应用程序并使用<code>spring-boot-dependencies</code>提供的依赖关系管理。 它需要Gradle 3.4级或更高版本。 请参阅插件的文档了解更多信息：</p><ul><li>Reference (<a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/gradle-plugin//reference/html">HTML</a> and <a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/gradle-plugin//reference/pdf/spring-boot-gradle-plugin-reference.pdf">PDF</a>)</li><li><a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/gradle-plugin//api">API</a></li></ul><h2 id="Spring-Boot-AntLib-模块"><a href="#Spring-Boot-AntLib-模块" class="headerlink" title="Spring Boot AntLib 模块"></a>Spring Boot AntLib 模块</h2><h3 id="Spring-Boot-Ant-任务"><a href="#Spring-Boot-Ant-任务" class="headerlink" title="Spring Boot Ant 任务"></a>Spring Boot Ant 任务</h3><h4 id="spring-boot-exejar"><a href="#spring-boot-exejar" class="headerlink" title="spring-boot:exejar"></a>spring-boot:exejar</h4><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h3 id="spring-boot-findmainclass"><a href="#spring-boot-findmainclass" class="headerlink" title="spring-boot:findmainclass"></a>spring-boot:findmainclass</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><h2 id="其他构建系统支持"><a href="#其他构建系统支持" class="headerlink" title="其他构建系统支持"></a>其他构建系统支持</h2><p>如果要使用除Maven，Gradle或Ant之外的构建工具，则可能需要开发自己的插件。 可执行的jar需要遵循特定格式，某些条目需要以未压缩的形式写入（有关详细信息，请参阅附录中的<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#executable-jar"><em>可执行jar格式</em></a>部分）。</p><p>Spring Boot Maven和Gradle插件都使用<code>spring-boot-loader-tools</code>来实际生成jar。 如果需要，你也可以直接使用这个库。</p><h3 id="重新打包"><a href="#重新打包" class="headerlink" title="重新打包"></a>重新打包</h3><p>要重新打包现有的包，以便它成为一个独立的可执行包，请使用<code>org.springframework.boot.loader.tools.Repackager</code>。<code>Repackager</code>类接受一个引用现有jar或war包的构造函数参数。 使用两个可用的<code>repackage()</code>方法之一替换原始文件或写入新的目录。 在重新打包运行之前，也可以配置各种设置。</p><h3 id="内部库"><a href="#内部库" class="headerlink" title="内部库"></a>内部库</h3><p>在重新打包时，可以使用<code>org.springframework.boot.loader.tools.Libraries</code>接口来引用依赖关系文件。我们不提供这里的库的任何具体实现，因为它们通常是构建系统特定的。</p><p>如果你的包已经包含库，你可以使用<code>Libraries.NONE</code>。</p><h3 id="查询main-类"><a href="#查询main-类" class="headerlink" title="查询main 类"></a>查询main 类</h3><p>如果不使用<code>Repackager.setMainClass()</code>来指定主类，则重新打包程序将使用<code>ASM</code>读取类文件，并尝试找到拥有<code>public static void main（String [] args）</code>方法的合适的类。 如果找到多个候选者，则抛出异常。</p><h3 id="重新打包实现示例"><a href="#重新打包实现示例" class="headerlink" title="重新打包实现示例"></a>重新打包实现示例</h3><p>这是一个典型的重新打包例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Repackager repackager &#x3D; new Repackager(sourceJarFile);</span><br><span class="line">repackager.setBackupSource(false);</span><br><span class="line">repackager.repackage(new Libraries() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void doWithLibraries(LibraryCallback callback) throws IOException &#123;</span><br><span class="line">                &#x2F;&#x2F; Build system specific implementation, callback for each dependency</span><br><span class="line">                &#x2F;&#x2F; callback.library(new Library(nestedFile, LibraryScope.COMPILE));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><p>如果你对构建工具插件的工作原理感兴趣，可以在GitHub上查看<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-tools"><code>spring-boot-tools</code></a>模块。 <a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#executable-jar">可执行jar格式</a>的更多技术细节在附录中有所描述。</p><p>如果你有特殊的构建问题，可以查看“<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto">how-to</a>”指南。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> build tool plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编绎Spring Boot源码</title>
      <link href="/post/977d/"/>
      <url>/post/977d/</url>
      
        <content type="html"><![CDATA[<ol><li>在spring-boot 根目录执行<code>./mvnw clean install -DskipTests </code> </li><li>cd 到<code>spring-boot-projects</code>目录，执行<code>../mvnw clean install -pl spring-boot-tools/spring-boot-maven-plugin -Pdefault,full -DskipTests</code></li><li><code>../mvnw clean prepare-package -pl spring-boot-docs -Pdefault,full -DskipTests</code> 生成文档，在<code>spring-boot-docs/target/contents/reference</code>目录</li></ol><p><strong><code>-DskipTests</code> 跳过单元测试，不然各种莫名其妙的错误。</strong></p><p><strong>不用mvnw包装器也是可以的，用自己安装的mvn来执行</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 七 - Spring Boot CLI</title>
      <link href="/post/29bc/"/>
      <url>/post/29bc/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot CLI是一个命令行工具，可以使用Spring来快速开发。它允许你运行Groovy脚本，这意味着你具有熟悉的类似Java的语法，没有太多的样板代码。您还可以引导新项目或为其编写自己的命令。</p><h2 id="安装CLI"><a href="#安装CLI" class="headerlink" title="安装CLI"></a>安装CLI</h2><p>可以手动安装Spring Boot CLI; 如果你是OSX用户可以使用SDKMAN！（SDK Manager）或使用Homebrew或MacPorts。有关全面的安装说明，请参见“入门”部分中的<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#getting-started-installing-the-cli">第10.2节“安装弹簧启动CLI”</a>。</p><h2 id="使用CLI"><a href="#使用CLI" class="headerlink" title="使用CLI"></a>使用CLI</h2><p>一旦你安装了CLI，你可以通过输入<code>spring</code>来运行它。 如果没有使用任何参数运行<code>spring</code>，将显示一个简单的帮助屏幕：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ spring</span><br><span class="line">usage: spring [--help] [--version]</span><br><span class="line">       &lt;command&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">Available commands are:</span><br><span class="line"></span><br><span class="line">  run [options] &lt;files&gt; [--] [args]</span><br><span class="line">    Run a spring groovy script</span><br><span class="line"></span><br><span class="line">  ... more command help is shown here</span><br></pre></td></tr></table></figure><p>你可以使用<code>help</code>来获取有关任何支持的命令的更多详细信息。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ spring help run</span><br><span class="line">spring run - Run a spring groovy script</span><br><span class="line"></span><br><span class="line">usage: spring run [options] &lt;files&gt; [--] [args]</span><br><span class="line"></span><br><span class="line">Option                     Description</span><br><span class="line">------                     -----------</span><br><span class="line">--autoconfigure [Boolean]  Add autoconfigure compiler</span><br><span class="line">                             transformations (default: true)</span><br><span class="line">--classpath, -cp           Additional classpath entries</span><br><span class="line">-e, --edit                 Open the file with the default system</span><br><span class="line">                             editor</span><br><span class="line">--no-guess-dependencies    Do not attempt to guess dependencies</span><br><span class="line">--no-guess-imports         Do not attempt to guess imports</span><br><span class="line">-q, --quiet                Quiet logging</span><br><span class="line">-v, --verbose              Verbose logging of dependency</span><br><span class="line">                             resolution</span><br><span class="line">--watch                    Watch the specified file for changes</span><br></pre></td></tr></table></figure><p><code>version</code>命令提供了一个快速的方法来检查你正在使用哪个版本的Spring Boot。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ spring version</span><br><span class="line">Spring CLI v2.0.0.BUILD-SNAPSHOT</span><br></pre></td></tr></table></figure><h3 id="使用CLI运行应用"><a href="#使用CLI运行应用" class="headerlink" title="使用CLI运行应用"></a>使用CLI运行应用</h3><p>你可以使用<code>run</code>命令编译和运行Groovy源代码。 Spring Boot CLI是完全独立的，因此你不需要任何额外安装Groovy。</p><p>下面是一个使用Groovy编写的“hello world” Web应用程序示例：<br><strong>hello.proovy</strong>:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebApplication</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    String home() &#123;</span><br><span class="line">        <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行应用程序输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ spring run hello.groovy</span><br></pre></td></tr></table></figure><p>要将命令行参数传递给应用程序，你需要使用 <code>--</code>将它们与“spring”命令参数分开，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ spring run hello.groovy -- --server.port&#x3D;9000</span><br></pre></td></tr></table></figure><p>要设置JVM命令行参数，你可以使用<code>JAVA_OPTS</code>环境变量，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ JAVA_OPTS&#x3D;-Xmx1024m spring run hello.groovy</span><br></pre></td></tr></table></figure><h4 id="推断的“抓取”-依赖"><a href="#推断的“抓取”-依赖" class="headerlink" title="推断的“抓取” 依赖"></a>推断的“抓取” 依赖</h4><p>标准Groovy包括一个@Grab注释，允许你声明第三方依赖库。这种有用的技术允许Groovy以与Maven或Gradle相同的方式下载jar，但不需要使用构建工具。</p><p>Spring Boot进一步扩展了这种技术，并将尝试根据你的代码推导出“抓取”哪些库。例如，由于上面的<code>WebApplication</code>代码使用<code>@RestController</code>注解，“Tomcat”和“Spring MVC”将会被抓取。</p><p>以下项目被用作“抓取提示”：</p><table><thead><tr><th>项目</th><th>抓取对象</th></tr></thead><tbody><tr><td><code>JdbcTemplate</code>, <code>NamedParameterJdbcTemplate</code>, <code>DataSource</code></td><td>JDBC 应用.</td></tr><tr><td><code>@EnableJms</code></td><td>JMS 应用.</td></tr><tr><td><code>@EnableCaching</code></td><td>Caching 抽象.</td></tr><tr><td><code>@Test</code></td><td>JUnit.</td></tr><tr><td><code>@EnableRabbit</code></td><td>RabbitMQ.</td></tr><tr><td><code>@EnableReactor</code></td><td>Project Reactor.</td></tr><tr><td>extends <code>Specification</code></td><td>Spock 测试.</td></tr><tr><td><code>@EnableBatchProcessing</code></td><td>Spring Batch.</td></tr><tr><td><code>@MessageEndpoint</code> <code>@EnableIntegrationPatterns</code></td><td>Spring Integration.</td></tr><tr><td><code>@EnableDeviceResolver</code></td><td>Spring Mobile.</td></tr><tr><td><code>@Controller</code> <code>@RestController</code> <code>@EnableWebMvc</code></td><td>Spring MVC + Embedded Tomcat.</td></tr><tr><td><code>@EnableWebSecurity</code></td><td>Spring Security.</td></tr><tr><td><code>@EnableTransactionManagement</code></td><td>Spring Transaction Management.</td></tr></tbody></table><blockquote><p>请参阅Spring Boot CLI 源代码中<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-cli/src/main/java/org/springframework/boot/cli/compiler/CompilerAutoConfiguration.java"><code>CompilerAutoConfiguration</code></a>的子类，以准确了解自定义是如何应用的。</p></blockquote><h4 id="推断的“抓取”-坐标"><a href="#推断的“抓取”-坐标" class="headerlink" title="推断的“抓取” 坐标"></a>推断的“抓取” 坐标</h4><p>Spring Boot通过允许你指定不带group或version的依赖关系来扩展Groovy的标准<code>@Grab</code>支持，例如<code>@Grab（&#39;freemarker&#39;）</code>。 这将参考Spring Boot 的默认依赖关系元数据来推断该artifact的group和version。请注意，默认元数据与你正在使用的CLI版本相关联 - 仅当你迁移到新版本的CLI时才会更改，让你控制依赖关系的版本何时更改。可在<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#appendix-dependency-versions">附录</a>中找到显示默认元数据中包含的依赖关系及其版本的表格。</p><h4 id="默认导入语句"><a href="#默认导入语句" class="headerlink" title="默认导入语句"></a>默认导入语句</h4><p>为了减少Groovy代码的大小，将自动包含多个<code>import</code>语句。 请注意上述示例如何引用<code>@Component</code>，<code>@RestController</code>和<code>@RequestMapping</code>，而不需要使用完全限定名称或<code>import</code>语句。</p><blockquote><p>许多Spring注解将在不使用<code>import</code>语句的情况下工作。尝试运行应用程序以查看在添加导入之前失败的内容。</p></blockquote><h4 id="自动的main方法"><a href="#自动的main方法" class="headerlink" title="自动的main方法"></a>自动的main方法</h4><p>不是相当于Java应用，在你的<code>Groovy</code>脚本中你不需要包含一个<code>public static void main(String[] args)</code>方法。在你的编绎后的代码之上会自动创建一个<code>SpringApplication</code>,它们充当了<code>source</code>。</p><h4 id="自定义依赖管理"><a href="#自定义依赖管理" class="headerlink" title="自定义依赖管理"></a>自定义依赖管理</h4><p>默认情况下，CLI在解析<code>@Grab</code>依赖关系时使用在<code>spring-boot-dependencies</code>中声明的依赖关系管理。可以使用<code>@DependencyManagementBom</code>注解来配置附加依赖关系管理，这将覆盖默认依赖关系管理。 注解的值应指定一个或多个Maven BOM的坐标（<code>groupId：artifactId：version</code>）。</p><p>例如，以下声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@DependencyManagementBom(&quot;com.example.custom-bom:1.0.0&quot;)</span><br></pre></td></tr></table></figure><p>将在Maven仓库中<code>com/example/custom-versions/1.0.0/</code>下获取<code>custom-bom-1.0.0.pom</code>。</p><p>当指定了多个BOM时，它们按照它们被声明的顺序应用。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@DependencyManagementBom([&quot;com.example.custom-bom:1.0.0&quot;,</span><br><span class="line">        &quot;com.example.another-bom:1.0.0&quot;])</span><br></pre></td></tr></table></figure><p>表示<code>another-bom</code>中的依赖关系管理将覆盖<code>custom-bom</code>中的依赖关系管理。</p><p>你可以在可以使用<code>@Grab</code>的任何地方使用<code>@DependencyManagementBom</code>，但是为了确保依赖关系管理的顺序一致，你最多只能在应用程序中使用<code>@DependencyManagementBom</code>。 一个有用的依赖关系源（即Spring Boot的依赖关系管理的超集）就是<a href="http://platform.spring.io/">Spring IO Platform</a>。<code>@DependencyManagementBom（ &#39;io.spring.platform:platform-bom:1.1.2.RELEASE&#39;）</code>。</p><h3 id="具有多个源文件的应用"><a href="#具有多个源文件的应用" class="headerlink" title="具有多个源文件的应用"></a>具有多个源文件的应用</h3><p>你可以使用所有接受文件输入命令的“shell globbing”。 这允许你轻松地使用单个目录中的多个文件，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ spring run *.groovy</span><br></pre></td></tr></table></figure><h3 id="打包应用"><a href="#打包应用" class="headerlink" title="打包应用"></a>打包应用</h3><p>你可以使用<code>jar</code>命令将应用程序打包成一个独立的可执行jar文件。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ spring jar my-app.jar *.groovy</span><br></pre></td></tr></table></figure><p>生成的jar将包含通过编译应用程序和所有应用程序的依赖关系生成的类，以便可以使用<code>java -jar</code>来运行。jar文件还将包含应用程序类路径中的内容。 你可以使用<code>--include</code>和<code>--exclude</code>（两者都以逗号分隔，并且两者接受值“+”和“ - ”的前缀来表示它们应该从默认值中删除）来添加显式路径。默认包含</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public&#x2F;**, resources&#x2F;**, static&#x2F;**, templates&#x2F;**, META-INF&#x2F;**, *</span><br></pre></td></tr></table></figure><p>默认排除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.*, repository&#x2F;**, build&#x2F;**, target&#x2F;**, **&#x2F;*.jar, **&#x2F;*.groovy</span><br></pre></td></tr></table></figure><p>有关更多信息，请参阅<code>spring help jar</code>的输出信息。</p><h3 id="初始化新项目"><a href="#初始化新项目" class="headerlink" title="初始化新项目"></a>初始化新项目</h3><p><code>init</code>命令允许你使用<a href="https://start.spring.io/">start.spring.io</a>创建一个新的项目，而不需要离开shell。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ spring init --dependencies&#x3D;web,data-jpa my-project</span><br><span class="line">Using service at https:&#x2F;&#x2F;start.spring.io</span><br><span class="line">Project extracted to &#39;&#x2F;Users&#x2F;developer&#x2F;example&#x2F;my-project&#39;</span><br></pre></td></tr></table></figure><p>这将使用<code>spring-boot-starter-web</code>和<code>spring-boot-starter-data-jpa</code>创建一个基于Maven的项目的<code>my-project</code>目录。你可以使用<code>--list</code>标志列出这个服务的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ spring init --list</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Capabilities of https:&#x2F;&#x2F;start.spring.io</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Available dependencies:</span><br><span class="line">-----------------------</span><br><span class="line">actuator - Actuator: Production ready features to help you monitor and manage your application</span><br><span class="line">...</span><br><span class="line">web - Web: Support for full-stack web development, including Tomcat and spring-webmvc</span><br><span class="line">websocket - Websocket: Support for WebSocket development</span><br><span class="line">ws - WS: Support for Spring Web Services</span><br><span class="line"></span><br><span class="line">Available project types:</span><br><span class="line">------------------------</span><br><span class="line">gradle-build -  Gradle Config [format:build, build:gradle]</span><br><span class="line">gradle-project -  Gradle Project [format:project, build:gradle]</span><br><span class="line">maven-build -  Maven POM [format:build, build:maven]</span><br><span class="line">maven-project -  Maven Project [format:project, build:maven] (default)</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>init</code>命令支持许多选项，请查看<code>help</code>输出信息以了解更多详细信息。例如，以下命令使用Java 8和<code>war</code>包创建一个gradle项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ spring init --build&#x3D;gradle --java-version&#x3D;1.8 --dependencies&#x3D;websocket --packaging&#x3D;war sample-app.zip</span><br><span class="line">Using service at https:&#x2F;&#x2F;start.spring.io</span><br><span class="line">Content saved to &#39;sample-app.zip&#39;</span><br></pre></td></tr></table></figure><h3 id="使用嵌入式脚本"><a href="#使用嵌入式脚本" class="headerlink" title="使用嵌入式脚本"></a>使用嵌入式脚本</h3><p>Spring Boot包括BASH和zsh shell的命令行完成（提示功能）脚本。 如果你不使用任何一个shell（也许你是Windows用户），则可以使用<code>shell</code>命令启动集成的shell。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ spring shell</span><br><span class="line">Spring Boot (v2.0.0.BUILD-SNAPSHOT)</span><br><span class="line">Hit TAB to complete. Type \&#39;help&#39; and hit RETURN for help, and \&#39;exit&#39; to quit.</span><br></pre></td></tr></table></figure><p>在嵌入式shell中可以直接运行其他命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ version</span><br><span class="line">Spring CLI v2.0.0.BUILD-SNAPSHOT</span><br></pre></td></tr></table></figure><p>嵌入式shell支持ANSI颜色输出以及<code>tab</code>完成。如果需要运行本地命令，可以使用<code>!</code>前缀。 输入<code>ctrl-c</code>将退出嵌入式shell。</p><h3 id="添加CLI扩展"><a href="#添加CLI扩展" class="headerlink" title="添加CLI扩展"></a>添加CLI扩展</h3><p>你可以使用<code>install</code>命令为CLI添加扩展。该命令在一组或多组<code>group:artifact:version</code>格式中提取组件坐标。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ spring install com.example:spring-boot-cli-extension:1.0.0.RELEASE</span><br></pre></td></tr></table></figure><p>除了安装由你提供的坐标识别的组件之外，还将安装所有组件的依赖项。</p><p>要卸载依赖关系，请使用<code>uninstall</code>命令。与<code>install</code>命令一样，它在一组或多组<code>group:artifact:version</code>格式中提取组件坐标。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ spring uninstall com.example:spring-boot-cli-extension:1.0.0.RELEASE</span><br></pre></td></tr></table></figure><p>它将卸载由你提供的坐标及其依赖关系识别的组件。</p><p>要卸载所有其他依赖关系，你可以使用<code>--all</code>选项。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ spring uninstall --all</span><br></pre></td></tr></table></figure><h2 id="使用Groovey-beans-DSL-开发应用"><a href="#使用Groovey-beans-DSL-开发应用" class="headerlink" title="使用Groovey beans DSL 开发应用"></a>使用Groovey beans DSL 开发应用</h2><p>Spring Framework 4.0原生支持<code>Bean &#123;&#125;</code>“DSL”（借鉴于Grails），你可以在你的Groovy应用程序脚本中嵌入使用相同的格式的bean定义。 这有时是包含外部功能（如声明中间件）的好方法。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">class Application implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    SharedService service</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void run(String... args) &#123;</span><br><span class="line">        println service.message</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import my.company.SharedService</span><br><span class="line"></span><br><span class="line">beans &#123;</span><br><span class="line">    service(SharedService) &#123;</span><br><span class="line">        message &#x3D; &quot;Hello World&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以将类声明与<code>beans &#123;&#125;</code>混合在同一个文件中，只要它们保持在顶层，或者你可以将bean DSL放在单独的文件中。</p><h2 id="使用settings-xml配置CLI"><a href="#使用settings-xml配置CLI" class="headerlink" title="使用settings.xml配置CLI"></a>使用settings.xml配置CLI</h2><p>Spring Boot CLI使用Aether（Maven的依赖关系解析引擎）来解析依赖关系。CLI使用<code>~/.m2/settings.xml</code>中的Maven配置来配置Aether。 以下配置设置由CLI使用：</p><ul><li>Offline</li><li>Mirrors</li><li>Servers</li><li>Proxies</li><li>Profiles<ul><li>Activation</li><li>Repositories</li></ul></li><li>Active profiles</li></ul><p>有关更多信息，请参阅<a href="https://maven.apache.org/settings.html">Maven的设置文档</a>。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><p>GitHub仓库中有一些<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-cli/samples">示例groovy脚本</a>，你可以使用它来尝试Spring Boot CLI。 整个<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-cli/src/main/java/org/springframework/boot/cli">源代码</a>中也有大量的Javadoc。</p><p>如果你发现你达到CLI工具的极限，你可能需要考虑将应用程序转换为完整的Gradle或Maven构建的“groovy项目”。 下一节将介绍可以用于Gradle或Maven的Spring Boot的<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#build-tool-plugins">Build工具插件</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Spring Boot CLI </tag>
            
            <tag> CLI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 六 - 部署Spring Boot应用</title>
      <link href="/post/64fe/"/>
      <url>/post/64fe/</url>
      
        <content type="html"><![CDATA[<p>在部署应用时，Spring Boot 灵活的打包选项提供了大量的选择。你可以轻松地将Spring Boot 应用部署到各种云平台、容器镜像(例如Docker)或虚拟/真实机器上。</p><p>本节将介绍一些更常见的部署场景。</p><h2 id="部署到云上"><a href="#部署到云上" class="headerlink" title="部署到云上"></a>部署到云上</h2><p>Spring Boot的可执行jar对于大多数流行的云PaaS(平台即服务)提供者都是直接可用的。这些提供者往往要求你“自带容器”;它们管理应用程序进程程(不是专门针对Java应用程序的)，因此它们需要一些中间层，以使应用程序适应云的运行过程的概念。</p><p>两家受欢迎的云服务提供商，Heroku和Cloud Foundry，采用了一种“buildpack”的方式。buildpack将你部署的代码封装在<em>启动应用程序</em>所需的任何东西中:它可能是一个JDK和对<code>java</code>的调用，它可能是一个嵌入式web服务器，或者它可能是一个成熟的应用程序服务器。buildpack是可插拔的，但理想情况下，你应该能够尽可能少地定制它。这减少了不受你控制的功能的占用。它最小化了开发和生产环境之间的差异。</p><p>理想情况下，你的应用程序，就像一个Spring Boot 的可执行jar一样，拥有它需要在其中运行的所有东西。</p><p>在本节中，我们将看看在“入门”部分中<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#getting-started-first-application">开发的简单应用程序</a>在云中运行所需的功能。</p><h3 id="Cloud-Foundry"><a href="#Cloud-Foundry" class="headerlink" title="Cloud Foundry"></a>Cloud Foundry</h3><p>如果没有指定其他buildpack ，则Cloud Foundry提供了默认的buildpack 。Cloud Foundry <a href="https://github.com/cloudfoundry/java-buildpack">Java buildpack</a>为Spring应用程序提供了极好的支持，包括Spring Boot。你可以部署独立的可执行jar应用程序，以及传统的<code>.war</code>包应用程序。</p><p>构建应用程序（使用例如<code>mvn clean package</code>）并<a href="http://docs.cloudfoundry.org/devguide/installcf/install-go-cli.html">安装<code>cf</code>命令行工具后</a>，只需像下面这样使用<code>cf push</code>命令部署应用程序，将其中的路径替换为你自己编译好的<code>.jar</code>路径。在推送应用之前，一定要使用<a href="http://docs.cloudfoundry.org/devguide/installcf/whats-new-v6.html#login">你的<code>cf</code>命令行客户端登录</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cf push acloudyspringtime -p target&#x2F;demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>有关更多选项，请参阅<a href="http://docs.cloudfoundry.org/devguide/installcf/whats-new-v6.html#push"><code>cf push</code>文档</a>。 如果在同一目录中存在Cloud Foundry <a href="http://docs.cloudfoundry.org/devguide/deploy-apps/manifest.html"><code>manifest.yml</code></a>文件，则会参考这个文件。</p><blockquote><p>这里我们用<code>acloudyspringtime</code>代替你给cf的任何值，该值作为你的应用程序的名称。</p></blockquote><p>此时，<code>cf</code>将开始上传你的应用程序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Uploading acloudyspringtime... OK</span><br><span class="line">Preparing to start acloudyspringtime... OK</span><br><span class="line">-----&gt; Downloaded app package (8.9M)</span><br><span class="line">-----&gt; Java Buildpack Version: v3.12 (offline) | https:&#x2F;&#x2F;github.com&#x2F;cloudfoundry&#x2F;java-buildpack.git#6f25b7e</span><br><span class="line">-----&gt; Downloading Open Jdk JRE 1.8.0_121 from https:&#x2F;&#x2F;java-buildpack.cloudfoundry.org&#x2F;openjdk&#x2F;trusty&#x2F;x86_64&#x2F;openjdk-1.8.0_121.tar.gz (found in cache)</span><br><span class="line">       Expanding Open Jdk JRE to .java-buildpack&#x2F;open_jdk_jre (1.6s)</span><br><span class="line">-----&gt; Downloading Open JDK Like Memory Calculator 2.0.2_RELEASE from https:&#x2F;&#x2F;java-buildpack.cloudfoundry.org&#x2F;memory-calculator&#x2F;trusty&#x2F;x86_64&#x2F;memory-calculator-2.0.2_RELEASE.tar.gz (found in cache)</span><br><span class="line">       Memory Settings: -Xss349K -Xmx681574K -XX:MaxMetaspaceSize&#x3D;104857K -Xms681574K -XX:MetaspaceSize&#x3D;104857K</span><br><span class="line">-----&gt; Downloading Container Certificate Trust Store 1.0.0_RELEASE from https:&#x2F;&#x2F;java-buildpack.cloudfoundry.org&#x2F;container-certificate-trust-store&#x2F;container-certificate-trust-store-1.0.0_RELEASE.jar (found in cache)</span><br><span class="line">       Adding certificates to .java-buildpack&#x2F;container_certificate_trust_store&#x2F;truststore.jks (0.6s)</span><br><span class="line">-----&gt; Downloading Spring Auto Reconfiguration 1.10.0_RELEASE from https:&#x2F;&#x2F;java-buildpack.cloudfoundry.org&#x2F;auto-reconfiguration&#x2F;auto-reconfiguration-1.10.0_RELEASE.jar (found in cache)</span><br><span class="line">Checking status of app &#39;acloudyspringtime&#39;...</span><br><span class="line">  0 of 1 instances running (1 starting)</span><br><span class="line">  ...</span><br><span class="line">  0 of 1 instances running (1 starting)</span><br><span class="line">  ...</span><br><span class="line">  0 of 1 instances running (1 starting)</span><br><span class="line">  ...</span><br><span class="line">  1 of 1 instances running (1 running)</span><br><span class="line"></span><br><span class="line">App started</span><br></pre></td></tr></table></figure><p>祝贺你！应用现在已经运行了！</p><p>很容易验证已部署的应用的状态:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cf apps</span><br><span class="line">Getting applications in ...</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">name                 requested state   instances   memory   disk   urls</span><br><span class="line">...</span><br><span class="line">acloudyspringtime    started           1&#x2F;1         512M     1G     acloudyspringtime.cfapps.io</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一旦Cloud Foundry认为你的应用已经部署,你应该能够访问给定的URI,在这个例子中是<code>http://acloudyspringtime.cfapps.io/</code>。</p><h4 id="绑定到服务"><a href="#绑定到服务" class="headerlink" title="绑定到服务"></a>绑定到服务</h4><p>默认情况下，关于运行应用程序和服务连接信息的元数据将作为环境变量(例如:<code>$VCAP_SERVICES</code>)暴露给应用程序。这个架构决策是由于Cloud Foundry的polyglot(任何语言和平台都可以作为buildpack支持)的特性;进程范围的环境变量是语言无关的。</p><p>环境变量并不总是适合最简单的API，所以Spring Boot 自动提取它们并将数据转化为可以通过Spring的<code>Environment</code>抽象来访问的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String instanceId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.instanceId = environment.getProperty(<span class="string">&quot;vcap.application.instance_id&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的Cloud Foundry属性都是以<code>vcap</code>为前缀的。你可以使用vcap属性来访问应用程序信息(例如应用程序的公共URL)和服务信息(例如数据库凭据)。有关完整的详细信息，请参阅<code>CloudFoundryVcapEnvironmentPostProcessor</code> Javadoc。</p><blockquote><p><a href="http://cloud.spring.io/spring-cloud-connectors/">Spring Cloud Connectors</a>项目更适合配置DataSource等任务。 Spring Boot包括自动配置支持和<code>spring-boot-starter-cloud-connectors</code> starter。</p></blockquote><h3 id="Heroku"><a href="#Heroku" class="headerlink" title="Heroku"></a>Heroku</h3><h3 id="OpenShift"><a href="#OpenShift" class="headerlink" title="OpenShift"></a>OpenShift</h3><p><a href="https://www.openshift.com/">OpenShift</a>是RedHat public(和enterprise)PaaS解决方案。与Heroku一样，它通过运行由git提交的脚本运行，因此，只要Java运行时可用(这是你在OpenShift中可以要求的标准功能)，你可以用任何方式编写Spring Boot 应用程序的启动。要做到这一点，你可以在你的仓库的<code>.openshift/action_hooks</code>下使用<a href="https://www.openshift.com/developers/do-it-yourself">DIY Cartridge </a>和hook。</p><p>基本的模型是:</p><ol><li>确保Java和你的构建工具是远程安装的，例如使用<code>pre_build</code> hook(Java和Maven是默认安装的，而Gradle则不是)。</li><li>使用<code>build</code> hook来构建你的jar(使用Maven 或Gradle )。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">cd $OPENSHIFT_REPO_DIR</span><br><span class="line">mvn package -s .openshift&#x2F;settings.xml -DskipTests&#x3D;true</span><br></pre></td></tr></table></figure></li><li>添加一个调用<code>java-jar ...</code>的<code>start</code> hook<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">cd $OPENSHIFT_REPO_DIR</span><br><span class="line">nohup java -jar target&#x2F;*.jar --server.port&#x3D;$&#123;OPENSHIFT_DIY_PORT&#125; --server.address&#x3D;$&#123;OPENSHIFT_DIY_IP&#125; &amp;</span><br></pre></td></tr></table></figure></li><li>使用一个<code>stop</code> hook(因为start应该干净地返回???)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">source $OPENSHIFT_CARTRIDGE_SDK_BASH</span><br><span class="line">PID&#x3D;$(ps -ef | grep java.*\.jar | grep -v grep | awk &#39;&#123; print $2 &#125;&#39;)</span><br><span class="line">if [ -z &quot;$PID&quot; ]</span><br><span class="line">then</span><br><span class="line">    client_result &quot;Application is already stopped&quot;</span><br><span class="line">else</span><br><span class="line">    kill $PID</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li>在<code>application.properties</code>中由平台提供的环境变量的服务绑定,例如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url&#x3D; jdbc:mysql:&#x2F;&#x2F;$&#123;OPENSHIFT_MYSQL_DB_HOST&#125;:$&#123;OPENSHIFT_MYSQL_DB_PORT&#125;&#x2F;$&#123;OPENSHIFT_APP_NAME&#125;</span><br><span class="line">spring.datasource.username&#x3D; $&#123;OPENSHIFT_MYSQL_DB_USERNAME&#125;</span><br><span class="line">spring.datasource.password&#x3D; $&#123;OPENSHIFT_MYSQL_DB_PASSWORD&#125;</span><br></pre></td></tr></table></figure>在他们的网站上有一个关于在OpenShift上运行Gradle的博客，让你使用gradle来运行你的应用。<h3 id="Amazon-Web-Services-AWS"><a href="#Amazon-Web-Services-AWS" class="headerlink" title="Amazon Web Services (AWS)"></a>Amazon Web Services (AWS)</h3></li></ol><h4 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h3 id="Boxfuse-and-Amazon-Web-Services"><a href="#Boxfuse-and-Amazon-Web-Services" class="headerlink" title="Boxfuse and Amazon Web Services"></a>Boxfuse and Amazon Web Services</h3><h3 id="Google-Cloud"><a href="#Google-Cloud" class="headerlink" title="Google Cloud"></a>Google Cloud</h3><p>Google Cloud有几个选项可以用来启动Spring Boot应用。最容易开始使用的可能是App Engine，但是你也可以找到在容器引擎的容器中运行Spring Boot，或者在虚拟机上使用计算引擎运行Spring Boot的方法。</p><p>要在App Engine中运行，你可以首先在UI中创建一个项目，它为你设置一个惟一的标识符和HTTP路由。将Java应用程序添加到项目中，然后将其清空，然后使用<a href="https://cloud.google.com/sdk/downloads">Google Cloud SDK</a>将你的Spring Boot应用从命令行或CI构建中push到该项目。</p><p>App Engine需要你创建一个<code>app.yaml</code>文件来描述你的应用所需要的资源。通常你把它放在<code>src/min/appengine</code>，它看起来是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">service: default</span><br><span class="line"></span><br><span class="line">runtime: java</span><br><span class="line">env: flex</span><br><span class="line"></span><br><span class="line">runtime_config:</span><br><span class="line">  jdk: openjdk8</span><br><span class="line"></span><br><span class="line">handlers:</span><br><span class="line">- url: &#x2F;.*</span><br><span class="line">  script: this field is required, but ignored</span><br><span class="line"></span><br><span class="line">manual_scaling:</span><br><span class="line">  instances: 1</span><br><span class="line"></span><br><span class="line">health_check:</span><br><span class="line">  enable_health_check: False</span><br><span class="line"></span><br><span class="line">env_variables:</span><br><span class="line">  ENCRYPT_KEY: your_encryption_key_here</span><br></pre></td></tr></table></figure><p>例如，你可以使用Maven插件来部署该应用程序，只需将项目ID添加到构建配置中即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.cloud.tools&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;appengine-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;project&gt;myproject&lt;&#x2F;project&gt;</span><br><span class="line">    &lt;&#x2F;configuration&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure><p>然后使用<code>mvn appengine:deploy</code>(如果你需要先进行身份验证，构建将失败)。</p><blockquote><p>Google App Engine Classic与Servlet 2.5 API绑定住了，因此你不能在没有修改的情况下部署Spring应用。请参阅本指南的<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-servlet-2-5">Servlet 2.5部分</a>。</p></blockquote><h2 id="安装Spring-Boot应用"><a href="#安装Spring-Boot应用" class="headerlink" title="安装Spring Boot应用"></a>安装Spring Boot应用</h2><p>除了使用<code>java -jar</code>运行Spring Boot应用程序外，还可以为Unix系统创建完整的可执行的应用程序。完整可执行的jar可以像任何其他可执行二进制文件一样执行，也可以使用<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#deployment-service"><code>init.d</code>或<code>systemd</code></a>进行注册。这使得在常见的生产环境中安装和管理Spring Boot应用程序非常容易。</p><blockquote><p>完全可执行的jar通过在文件的前面嵌入一个额外的脚本来工作。目前，有些工具不接受这种格式，因此你可能不总是能够使用这种技术。例如，<code>jar -xf</code>可能会在提取出jar或完全可执行的war时失败。如果你打算直接执行它，而不是用<code>java -jar</code>运行它，或者将它部署到servlet容器中，那么建议你仅使你的jar或者war是完全可执行的。</p></blockquote><p>要使用Maven来创建一个“完全可执行”jar，请使用以下插件配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;executable&gt;true&lt;&#x2F;executable&gt;</span><br><span class="line">    &lt;&#x2F;configuration&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure><p>使用Gradle 的配置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">springBoot &#123;</span><br><span class="line">    executable &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，你可以通过键入<code>./my-application.jar</code>（其中<code>my-application</code>是你的artifact的名称）来运行应用程序。 包含jar的目录将被用作应用程序的工作目录。</p><h3 id="支持的操作系统"><a href="#支持的操作系统" class="headerlink" title="支持的操作系统"></a>支持的操作系统</h3><p>默认的脚本支付大多数Linux分发版本并且已经在CentOS和Ubuntu上测试通过。其他的平台比如OS X和FreeBSD，需要 使用自定义的<code>embeddedLaunchScript</code>。</p><h3 id="Unix-Linux服务"><a href="#Unix-Linux服务" class="headerlink" title="Unix/Linux服务"></a>Unix/Linux服务</h3><p>Spring Boot应用可以方便地作为Unix/Linux服务，既可以使用<code>init.d</code>又可以使用<code>systemd</code>。</p><h4 id="安装为init-d服务-System-V"><a href="#安装为init-d服务-System-V" class="headerlink" title="安装为init.d服务(System V)"></a>安装为init.d服务(System V)</h4><p>如果你配置了Spring Boot的Maven或者Gradle插件来生成<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#deployment-install">完全可执行的jar</a>，并且你没有使用自定义的<code>embeddedLaunchScript</code>，那么你的应用可以当作<code>init.d</code>服务来使用。简单地将jar链接到<code>init.d</code>以支持标准的<code>start</code>，<code>stop</code>，<code>restart</code>和<code>status</code>命令。<br>该脚本支持以下功能：</p><ul><li>以拥有该jar文件的用户身份启动服务</li><li>使用<code>/var/run/&lt;appname&gt;/&lt;appname&gt;.pid</code>跟踪应用程序的PID</li><li>将控制台日志写入<code>/var/log/&lt;appname&gt;.log</code></li></ul><p>假设你有一个Spring Boot 应用程序安装在<code>/var/ myapp</code>中，安装Spring Boot 应用程序作为<code>init.d</code>服务只需创建一个符号链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -s &#x2F;var&#x2F;myapp&#x2F;myapp.jar &#x2F;etc&#x2F;init.d&#x2F;myapp</span><br></pre></td></tr></table></figure><p>一旦安装之后 ，你可以按照通常的方式启动和停止服务。例如，在基于Debian的系统上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service myapp start</span><br></pre></td></tr></table></figure><blockquote><p>如果你的应用程序无法启动，请检查写入<code>/var/log/&lt;appname&gt;.log</code>的日志文件是否有错误。</p></blockquote><p>你还可以将应用程序标记为使用标准操作系统工具自动启动。例如，在Debian上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ update-rc.d myapp defaults &lt;priority&gt;</span><br></pre></td></tr></table></figure><h6 id="保护init-d服务"><a href="#保护init-d服务" class="headerlink" title="保护init.d服务"></a>保护init.d服务</h6><blockquote><p>以下是关于如何保护作为init.d服务运行的Spring Boot应用程序的一组指导。 它并不是为了强化应用程序和运行环境而应该做的一切的详尽列表。</p></blockquote><p>当以root身份执行时，在使用root来启动init.d服务的情况下，可执行脚本将默认以拥有该jar文件的用户身份运行应用程序。你不应该以<code>root</code>身份运行Spring Boot 应用程序，因此应用程序的jar文件不应该由root拥有。 相反，创建一个特定的用户来运行应用程序，并使用<code>chown</code>将其作为jar文件的所有者。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chown bootapp:bootapp your-app.jar</span><br></pre></td></tr></table></figure><p>在这种情况下，可执行脚本默认将以<code>bootapp</code>用户运行应用程序。</p><blockquote><p>为了减少应用程序的用户帐户遭到入侵的机会，你应该考虑防止其使用登录shell。例如，将帐户的shell设置为<code>/usr/sbin/nologin</code>。</p></blockquote><p>你还应该采取措施来阻止修改应用程序的jar文件。首先，配置其权限，使其不能被写入，并且只能由其所有者读取或执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 500 your-app.jar</span><br></pre></td></tr></table></figure><p>其次，如果你的应用程序或运行它的帐户遭到破坏，你还应采取措施减少损失。如果攻击者确实获得访问权限，他们可以使jar文件可写，并更改其内容。防止这种情况的一种方法是使用<code>chattr</code>使其变得不可变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chattr +i your-app.jar</span><br></pre></td></tr></table></figure><p>这将阻止任何用户（包括root）修改该jar。</p><p>如果root用于控制应用程序的服务，则使用一个用于自定义启动的<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#deployment-script-customization-conf-file"><code>.conf</code>文件</a>。root用户将会读取和验证<code>.conf</code>文件。它也应该保证相应的安全性。使用<code>chmod</code>使文件只能由所有者读取，并使用<code>chown</code>来使root作为其拥有者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 400 your-app.conf</span><br><span class="line">$ sudo chown root:root your-app.conf</span><br></pre></td></tr></table></figure><h4 id="安装为systemd-服务"><a href="#安装为systemd-服务" class="headerlink" title="安装为systemd 服务"></a>安装为systemd 服务</h4><p>Systemd是System V init系统的后继者，现在被许多现代Linux发行版使用。尽管你可以继续使用<code>systemd</code>的<code>init.d</code>脚本，但也可以使用<code>systemd</code> ‘service’ 脚本启动Spring Boot应用程序。</p><p>假设你在<code>/var/myapp</code>中安装了一个Spring Boot应用程序，要将Spring Boot应用程序安装为系统服务，请创建使用以下示例的名为<code>myapp.service</code>的脚本，并将其放在<code>/etc/systemd/system</code>目录中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=myapp</span><br><span class="line">After=syslog.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=myapp</span><br><span class="line">ExecStart=/var/myapp/myapp.jar</span><br><span class="line">SuccessExitStatus=143</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><blockquote><p>请记住更改应用程序的<code>Description</code>，<code>User</code>和<code>ExecStart</code>字段。</p></blockquote><blockquote><p>请注意，<code>ExecStart</code>字段不声明脚本操作命令，这意味着默认情况下使用<code>run</code>命令。</p></blockquote><p>请注意，与运行<code>init.d</code>服务不同，运行应用程序，PID文件和控制台日志文件的用户由<code>systemd</code>本身管理，因此必须使用’service’脚本中的适当字段进行配置。 有关详细信息，请参阅<a href="http://www.freedesktop.org/software/systemd/man/systemd.service.html">服务单元配置手册页</a>。</p><p>要标记应用程序在系统启动时自动启动，请使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl enable myapp.service</span><br></pre></td></tr></table></figure><p>请参考<code>man systemctl</code>了解更多详情。</p><h4 id="自定义启动脚本"><a href="#自定义启动脚本" class="headerlink" title="自定义启动脚本"></a>自定义启动脚本</h4><p>由Maven或Gradle插件编写的默认嵌入式启动脚本可以通过多种方式进行自定义。对于大多数人来说，使用默认脚本以及一些自定义设置通常就足够了。如果你发现无法自定义需要的内容，则可以随时使用<code>embeddedLaunchScript</code>选项来完全编写自己的文件。</p><h6 id="写脚本时自定义脚本"><a href="#写脚本时自定义脚本" class="headerlink" title="写脚本时自定义脚本"></a>写脚本时自定义脚本</h6><p>在将脚本写入jar文件时，自定义开始脚本的元素通常是有意义的。例如，init.d脚本可以提供一个“描述”，因为你知道这一点（它不会改变），你可以在生成jar时提供它。</p><p>要自定义写入的元素，请使用Spring Boot Maven 或Gradle  插件的<code>embeddedLaunchScriptProperties</code>选项。</p><p>默认脚本支持以下属性替换：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code>mode</code></td><td>脚本模式。 默认为<code>auto</code>。</td></tr><tr><td><code>initInfoProvides</code></td><td>“INIT INFO”的<code>Provides</code>部分。默认为Gradle的<code>spring-boot-application</code>和Maven的 <code>$&#123;project.artifactId&#125;</code>。</td></tr><tr><td><code>initInfoRequiredStart</code></td><td>“INIT INFO”的<code>Required-Start</code>部分。默认为<code>$remote_fs $syslog $network</code>。</td></tr><tr><td><code>initInfoRequiredStop</code></td><td>“INIT INFO”的<code>Required-Stop</code>部分。默认为<code>$remote_fs $syslog $network</code>。</td></tr><tr><td><code>initInfoDefaultStart</code></td><td>“INIT INFO”的<code>Default-Start</code>部分。默认为<code>2 3 4 5</code>。</td></tr><tr><td><code>initInfoDefaultStop</code></td><td>“INIT INFO”的<code>Default-Start</code>部分。默认为<code>0 1 6</code>。</td></tr><tr><td><code>initInfoShortDescription</code></td><td>“INIT INFO”的<code>Short-Description</code>部分。默认为Gradle的<code>Spring Boot Application</code>和Maven的<code>$&#123;project.name&#125;</code>。</td></tr><tr><td><code>initInfoDescription</code></td><td>“INIT INFO”的<code>Description</code>部分。默认为Gradle的<code>Spring Boot Application</code>和Maven的<code>$&#123;project.description&#125;</code>（失败时使用<code>$&#123;project.name&#125;</code>）。</td></tr><tr><td><code>initInfoChkconfig</code></td><td>“INIT INFO”的<code>chkconfig</code>部分。默认为<code>2345 99 01</code>。</td></tr><tr><td><code>confFolder</code></td><td><code>CONF_FOLDER</code>的默认值。 默认为包含该jar的文件夹。</td></tr><tr><td><code>logFolder</code></td><td><code>LOG_FOLDER</code>的默认值。 仅适用于<code>init.d</code>服务。</td></tr><tr><td><code>logFilename</code></td><td><code>LOG_FILENAME</code>的默认值。 仅适用于<code>init.d</code>服务。</td></tr><tr><td><code>pidFolder</code></td><td><code>PID_FOLDER</code>的默认值。 仅适用于<code>init.d</code>服务。</td></tr><tr><td><code>pidFilename</code></td><td><code>PID_FOLDER</code>中pid文件名称的默认值。 仅适用于<code>init.d</code>服务。</td></tr><tr><td><code>useStartStopDaemon</code></td><td>如果<code>start-stop-daemon</code>命令可用，应该用于控制进程。默认为<code>true</code>。</td></tr><tr><td><code>stopWaitTime</code></td><td><code>STOP_WAIT_TIME</code>的默认值。仅适用于<code>init.d</code>服务。默认为60秒。</td></tr></tbody></table><h6 id="在运行时自定义脚本"><a href="#在运行时自定义脚本" class="headerlink" title="在运行时自定义脚本"></a>在运行时自定义脚本</h6><p>对于在写入jar<em>后</em>需要定制的脚本项目，你可以使用环境变量或<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#deployment-script-customization-conf-file">配置文件</a>。</p><p>默认脚本支持以下环境属性：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>MODE</code></td><td>操作模式。默认取决于构建jar的方式，但是通常为<code>auto</code>(<strong>这意味着它会尝试猜测它是否是初始化脚本，通过检查它是否是<code>init.d</code>目录中的符号链接</strong>)。你可以明确地设置它为<code>service</code>，这样就可以使用`stop</td></tr><tr><td><code>USE_START_STOP_DAEMON</code></td><td>如果<code>start-stop-daemon</code>命令可用时，它应该用来控制进程。默认为<code>true</code>。</td></tr><tr><td><code>PID_FOLDER</code></td><td>pid 文件夹的根名称（默认为<code>/var/run</code>）。</td></tr><tr><td><code>LOG_FOLDER</code></td><td>放置日志文件的目录名称（默认为<code>/var/log</code>）。</td></tr><tr><td><code>CONF_FOLDER</code></td><td>读取.conf文件的文件夹名称（默认与jar-file相同的文件夹）。</td></tr><tr><td><code>LOG_FILENAME</code></td><td><code>LOG_FOLDER</code>中的日志文件名称（默认为<code>&lt;appname&gt;.log</code>）。</td></tr><tr><td><code>APP_NAME</code></td><td>应用的名称。如果jar从符号链接运行，这个脚本将会猜测应用的名称，如果不是符号链接，或者你想要明确设置应用的名称，这个将会非常有用。</td></tr><tr><td><code>RUN_ARGS</code></td><td>传递给程序（Spring Boot 应用）的参数。</td></tr><tr><td><code>JAVA_HOME</code></td><td>默认通过使用<code>PATH</code>来发现<code>java</code>可执行程序，但是如果在<code>$JAVA_HOME/bin/java</code>有一个可执行文件，你可以明确地设置它。</td></tr><tr><td><code>JAVA_OPTS</code></td><td>传递给JVM启动时的选项。</td></tr><tr><td><code>JARFILE</code></td><td>在使用脚本来启动不是实际内嵌的jar时，指定jar文件的明确路径。</td></tr><tr><td><code>DEBUG</code></td><td>当不为空时将设置shell进程的<code>-x</code>标志，可以很容易地查看脚本的逻辑。</td></tr><tr><td><code>STOP_WAIT_TIME</code></td><td>在停止应用时在强制退出之前等待的时间秒数（默认为<code>60</code>）。</td></tr></tbody></table><blockquote><p><code>PID_FOLDER</code>,<code>LOG_FOLDER</code>和<code>LOG_FILENAME</code>变量只在<code>init.d</code>服务时可用。<code>systemd</code>时使用’service’脚本来使用等价的自定义变量。查看<a href="http://www.freedesktop.org/software/systemd/man/systemd.service.html">更多细节</a>。</p></blockquote><p>除了<code>JARFILE</code> 和 <code>APP_NAME</code>，上面的设置可用使用一个<code>.conf</code>文件。这个文件在jar文件的相同目录并且有相同的名称，但是后缀为<code>.conf</code>而不是<code>.jar</code>。例如，名为<code>/var/myapp/myapp.jar</code>的jar将会使用名为<code>/var/myapp/myapp.conf</code>的配置文件。</p><p>myapp.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS&#x3D;-Xmx1024M</span><br><span class="line">LOG_FOLDER&#x3D;&#x2F;custom&#x2F;log&#x2F;folder</span><br></pre></td></tr></table></figure><blockquote><p>如果你不想它与jar在同一个目录，你可以使用<code>CONF_FOLDER</code>环境变量来自定义配置文件的位置。</p></blockquote><p>阅读<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#deployment-initd-service-securing">保护init.d服务的指南</a>来学习适当地保护配置文件。</p><h3 id="微软Windows服务"><a href="#微软Windows服务" class="headerlink" title="微软Windows服务"></a>微软Windows服务</h3><p>Spring Boot 应用使用<code>winsw</code>来作为Windows服务启动。</p><p>有个<a href="https://github.com/snicoll-scratches/spring-boot-daemon">单独维护</a>的示例逐步介绍了如何为Spring Boot 应用程序创建Windows服务。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><p>查看<a href="http://www.cloudfoundry.com/">Cloud Foundry</a>，<a href="https://www.heroku.com/">Heroku</a>，<a href="https://www.openshift.com/">OpenShift</a>和<a href="https://boxfuse.com/">Boxfuse</a>网站，了解有关PaaS可提供的各种功能的更多信息。这些只是四个最受欢迎的Java PaaS提供商，因为Spring Boot 非常适合基于云的部署，你可以自由考虑其他提供商。</p><p>下一节将介绍<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#cli">Spring Boot CLI</a>; 或者你可以前往阅读关于<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#build-tool-plugins">构建工具插件</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> 部署 </tag>
            
            <tag> 云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 五-Spring Boot执行器 - 生产就绪特性</title>
      <link href="/post/60cf/"/>
      <url>/post/60cf/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot包括一些额外的功能，可帮助你在应用程序推送到生产时监视和管理它。你可以选择使用HTTP端点或JMX来管理和监视应用程序。审计，健康和指标收集可以自动应用于你的应用程序。</p><p>HTTP执行器端点仅适用于基于Spring MVC的应用程序。特别是，也不适用于Jersey除非你<a href="#howto-use-actuator-with-jersey">启用Spring MVC</a>。</p><h2 id="启用生产就绪功能"><a href="#启用生产就绪功能" class="headerlink" title="启用生产就绪功能"></a>启用生产就绪功能</h2><p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator"><code>spring-boot-actuator</code></a>模块提供了所有Spring Boot的生产就绪特性。启用这些特性的最简单的方法是添加<code>spring-boot-starter-actuator</code> “Starter”。</p><blockquote><p>Actuator 的定义  </p><p>Actuator 是制造术语，指的是用于移动或控制某物的机械装置。 Actuator 可以从小的变化产生大量的运动。</p></blockquote><p>要将 actuator 添加到基于Maven的项目中，添加以下“Starter”依赖项:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p>对于Gradle，使用下面的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(&quot;org.springframework.boot:spring-boot-starter-actuator&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="端点"><a href="#端点" class="headerlink" title="端点"></a>端点</h2><p>Actuator 端点允许你监视和与应用程序进行交互。Spring　Boot包含许多内置端点，你还可以添加自己的端点。例如，<code>health</code>端点提供基本的应用程序健康信息。</p><p>端点公开的方式将取决于你选择的技术类型。大多数应用程序选择HTTP监视，其中端点带有<code>/application</code> 的前缀的ID被映射到一个URL。例如，默认情况下，<code>health </code>端点将被映射到<code>/application/health</code>。</p><p>有下面一些跟其他技术无关的可用的端点：</p><table><thead><tr><th>ID</th><th>描述</th><th>敏感默认值</th></tr></thead><tbody><tr><td><code>actuator</code></td><td>为其他端点提供一个基于多媒体的“发现页面”。需要在类路径上存在Spring HATEOAS。</td><td>true</td></tr><tr><td><code>auditevents</code></td><td>为当前应用程序暴露审计事件信息</td><td>true</td></tr><tr><td><code>autoconfig</code></td><td>显示一个自动配置报告，显示所有自动配置的候选者，以及为什么”是”或”不是”它们被应用的原因。</td><td>true</td></tr><tr><td><code>beans</code></td><td>显示应用程序中所有Spring bean的完整列表。</td><td>true</td></tr><tr><td><code>configprops</code></td><td>显示所有<code>@ConfigurationProperties</code>的整理列表。</td><td>true</td></tr><tr><td><code>dump</code></td><td>执行线程转储。</td><td>true</td></tr><tr><td><code>env</code></td><td>暴露Spring的<code>ConfigurableEnvironment</code>中的属性。</td><td>true</td></tr><tr><td><code>flyway</code></td><td>显示任何已应用的数据库迁移的路径。</td><td>true</td></tr><tr><td><code>health</code></td><td>显示应用程序的健康信息(当应用程序安全时，通过未经身份验证的连接时显示一个简单的“状态”或经过身份验证时显示完整消息细节)。</td><td>false</td></tr><tr><td><code>info</code></td><td>显示任意的应用程序信息。</td><td>false</td></tr><tr><td><code>loggers</code></td><td>在应用程序中显示和修改日志记录器的配置。</td><td>true</td></tr><tr><td><code>liquibase</code></td><td>显示已应用的任何Liquibase 数据库迁移。</td><td>true</td></tr><tr><td><code>metrics</code></td><td>显示当前应用程序的“度量”信息。</td><td>true</td></tr><tr><td><code>mappings</code></td><td>显示所有<code>@RequestMapping</code>路径的排序列表。</td><td>true</td></tr><tr><td><code>shutdown</code></td><td>允许应用程序优雅地关闭(默认情况下不启用)。</td><td>true</td></tr><tr><td><code>trace</code></td><td>显示跟踪信息(默认情况下是最后100个HTTP请求)。</td><td>true</td></tr></tbody></table><p>如果你使用的是Spring MVC，那么还可以使用以下附加的端点:</p><table><thead><tr><th>ID</th><th>描述</th><th>敏感默认值</th></tr></thead><tbody><tr><td><code>docs</code></td><td>显示文档，包括Actuator 的端点的示例请求和响应。要求<code>spring-boot-actuator-docs</code>在类路径中。</td><td>false</td></tr><tr><td><code>heapdump</code></td><td>返回一个GZip压缩的<code>hprof</code>堆转储文件。</td><td>true</td></tr><tr><td><code>jolokia</code></td><td>通过HTTP公开JMX bean（当classpath中存在Jolokia ）</td><td>true</td></tr><tr><td><code>logfile</code></td><td>返回logfile的内容(如果已经设置了<code>logging.file</code>或<code>logging.path</code>属性)。支持使用HTTP <code>Range</code>头来检索日志文件内容的一部分。</td><td>true</td></tr></tbody></table><blockquote><p>根据端点的暴露方式，<code>sensitive</code>属性可以用作安全提示。 例如，敏感端点在通过HTTP访问时将需要用户名/密码（或者如果Web安全性未启用，则简单禁用）。</p></blockquote><h3 id="自定义端点"><a href="#自定义端点" class="headerlink" title="自定义端点"></a>自定义端点</h3><p>端点可以使用Spring属性进行定制。如果<code>enabled</code>了端点，就可以更改，如果它被认为是<code>sensitive </code>，甚至是它的id也可以改变。例如，有<code>application.properties</code>改变<code>bean</code>端点的敏感性和id，也可以启用<code>shutdown</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">endpoints.beans.id&#x3D;springbeans</span><br><span class="line">endpoints.beans.sensitive&#x3D;false</span><br><span class="line">endpoints.shutdown.enabled&#x3D;true</span><br></pre></td></tr></table></figure><blockquote><p>前缀“<code>endpoints</code>+<code>.</code>+<code>name</code>“用于惟一地标识正在配置的端点。</p></blockquote><p>默认情况下，除了<code>shutdown</code>之外的所有端点都启用了。如果你更喜欢指定启用某个端点，那么你可以使用<code>endpoints.enabled</code>属性。例如，以下将禁用除<code>info</code>之外的<em>所有</em>端点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">endpoints.enabled&#x3D;false</span><br><span class="line">endpoints.info.enabled&#x3D;true</span><br></pre></td></tr></table></figure><p>同样，你还可以选择全局设置所有端点的“敏感”标志。 默认情况下，敏感标志取决于端点类型（参见上表）。 例如，要将<em>所有</em>端点标记为敏感，除了<code>info</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">endpoints.sensitive&#x3D;true</span><br><span class="line">endpoints.info.sensitive&#x3D;false</span><br></pre></td></tr></table></figure><h3 id="Actuator-MVC端点的多媒体"><a href="#Actuator-MVC端点的多媒体" class="headerlink" title="Actuator MVC端点的多媒体"></a>Actuator MVC端点的多媒体</h3><p>如果<code>endpoints.hypermedia.enabled</code>设置为<code>true</code>，并且<a href="http://projects.spring.io/spring-hateoas">Spring HATEOAS</a>位于类路径上（例如，通过<code>spring-boot-starter-hateoas</code>或者如果你使用的是<a href="http://projects.spring.io/spring-data-rest">Spring Data REST</a>），那么来自Actuator 的HTTP端点将通过多媒体链接进行增强，并添加了一个“发现页面”，其中包含所有端点的链接。</p><p>默认情况下，“发现页”可用于<code>/application</code>。 它被实现为端点，允许使用属性来配置其路径（<code>endpoints.actuator.path</code>）以及是否启用（<code>endpoints.actuator.enabled</code>）。</p><p>当配置了自定义管理上下文路径时，“发现页面”将自动从<code>/application</code>移动到管理上下文的根目录。 例如，如果管理上下文路径是<code>/management</code> ，则发现页面将出现在<code>/management</code>。</p><p>如果<a href="https://github.com/mikekelly/hal-browser">HAL浏览器</a>通过其webjar（<code>org.webjars:hal-browser</code>）或通过<code>spring-data-rest-hal-browser</code>存在于类路径上，那么也会提供以“HAL浏览器”形式的HTML“发现页面”。</p><h3 id="跨域支持"><a href="#跨域支持" class="headerlink" title="跨域支持"></a>跨域支持</h3><p>跨原始资源共享（CORS）是一种W3C规范，允许你以灵活的方式指定什么样的跨域请求被授权。Actuator的MVC端点可以配置为支持这种情况。</p><p>默认情况下禁用CORS支持，只有在设置<code>endpoints.cors.allowed-origins</code>属性后才能启用。 下面的配置允许来自<code>example.com</code>域的<code>GET</code>和<code>POST</code>调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">endpoints.cors.allowed-origins&#x3D;http:&#x2F;&#x2F;example.com</span><br><span class="line">endpoints.cors.allowed-methods&#x3D;GET,POST</span><br></pre></td></tr></table></figure><blockquote><p>查看<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/EndpointCorsProperties.java"><code>EndpointCorsProperties</code></a>以获取完整的选项列表。</p></blockquote><h3 id="添加自定义端点"><a href="#添加自定义端点" class="headerlink" title="添加自定义端点"></a>添加自定义端点</h3><p>如果添加一个类型为<code>Endpoint</code>的<code>@Bean</code>，那么它将自动通过JMX和HTTP（如果有可用的服务器）暴露出来。 通过创建一个类型为<code>MvcEndpoint</code>的bean，可以进一步定制HTTP端点。 你的<code>MvcEndpoint</code>不是<code>@Controller</code>，但它可以使用<code>@RequestMapping</code>（和<code>@Managed*</code>）来公开资源。</p><blockquote><p>如果你正在将其作为库功能，请考虑将<code>@ManagementContextConfiguration</code>注解的配置类使用key <code>org.springframework.boot.actuate.autoconfigure.ManagementContextConfiguration</code>添加到<code>/META-INF/spring.factories</code>文件中。如果你这样做，则如果你的用户要求单独的管理端口或地址，端点将移动到所有其他MVC端点的子上下文。 如果要将静态资源（例如）添加到管理端点，则以这种方式声明的配置可以是一个<code>WebConfigurerAdapter</code>。</p></blockquote><h3 id="健康信息"><a href="#健康信息" class="headerlink" title="健康信息"></a>健康信息</h3><p>健康信息可用于检查正在运行的应用程序的状态。 如果生产系统出现故障，通常会使用监控软件来警告某人。 <code>health</code>端点公开的默认信息取决于它的访问方式。对于安全应用程序中的未认证连接，将返回简单的“状态”消息，并且对于已认证的连接，还会显示其他详细信息（请参阅<a href="#production-ready-health-access-restrictions">第50.7节“HTTP健康端点格式和访问限制”</a>的HTTP详细信息）。</p><p>健康信息是从你的<code>ApplicationContext</code>中定义的所有<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java"><code>HealthIndicator</code></a> bean收集的。 Spring Boot包括一些自动配置的<code>HealthIndicators</code>，你也可以自己编写。默认情况下，最终的系统状态由<code>HealthAggregator</code>导出，它根据有序的状态列表对来自每个<code>HealthIndicator</code>的状态进行排序。排序列表中的第一个状态用作总体运行状态。 如果没有<code>HealthIndicator</code>返回<code>HealthAggregator</code>已知的状态，则使用<code>UNKNOWN</code>状态。</p><h3 id="HealthIndicators-安全性"><a href="#HealthIndicators-安全性" class="headerlink" title="HealthIndicators 安全性"></a>HealthIndicators 安全性</h3><p><code>HealthIndicators</code>返回的信息本质上往往有些敏感。 例如，你可能不想将数据库服务器的详细信息公开。因此，默认情况下，通过未经身份验证的HTTP连接仅暴露健康状况。 如果你很乐意一直暴露完整的健康信息，你可以设置<code>endpoints.health.sensitive</code>为<code>false</code>。</p><p>健康响应也被缓存，以防止“拒绝服务”攻击。如果要更改1000毫秒的默认缓存期，请使用<code>endpoints.health.time-to-live</code>属性。</p><h4 id="HealthIndicators-自动配置"><a href="#HealthIndicators-自动配置" class="headerlink" title="HealthIndicators 自动配置"></a>HealthIndicators 自动配置</h4><p>以下<code>HealthIndicator</code>在适当时由Spring Boot自动配置：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/CassandraHealthIndicator.java"><code>CassandraHealthIndicator</code></a></td><td>检查Cassandra数据库是否已经启动。</td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/DiskSpaceHealthIndicator.java"><code>DiskSpaceHealthIndicator</code></a></td><td>检查低磁盘空间。</td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/DataSourceHealthIndicator.java"><code>DataSourceHealthIndicator</code></a></td><td>检查与是否可以获取数据源的连接。</td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ElasticsearchHealthIndicator.java"><code>ElasticsearchHealthIndicator</code></a></td><td>检查Elasticsearch 集群是否已经启动。</td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/JmsHealthIndicator.java"><code>JmsHealthIndicator</code></a></td><td>检查JMS代理是否已启动。</td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/MailHealthIndicator.java"><code>MailHealthIndicator</code></a></td><td>检查邮件服务器是否已启动。</td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/MongoHealthIndicator.java"><code>MongoHealthIndicator</code></a></td><td>检查Mongo数据库是否已经启动。</td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/RabbitHealthIndicator.java"><code>RabbitHealthIndicator</code></a></td><td>检查Rabbit 服务器是否已经启动。</td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/RedisHealthIndicator.java"><code>RedisHealthIndicator</code></a></td><td>检查一个Redis服务器是否已经启动。</td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/SolrHealthIndicator.java"><code>SolrHealthIndicator</code></a></td><td>检查Solr服务器是否已经启动。</td></tr></tbody></table><blockquote><p>可以使用<code>management.health.defaults.enabled</code>属性来禁用它们。</p></blockquote><h4 id="编写自定义HealthIndicator"><a href="#编写自定义HealthIndicator" class="headerlink" title="编写自定义HealthIndicator"></a>编写自定义HealthIndicator</h4><p>要提供自定义的健康信息，你可以注册实现<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java"><code>HealthIndicator</code> </a>接口的Spring bean。你需要提供一个<code>health（）</code>方法的实现并返回一个<code>Health</code>响应。 <code>Health</code>响应应包括状态，并且可以选择性地包括要显示的其他细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.Health;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.HealthIndicator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> errorCode = check(); <span class="comment">// perform some specific health check</span></span><br><span class="line">        <span class="keyword">if</span> (errorCode != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.down().withDetail(<span class="string">&quot;Error Code&quot;</span>, errorCode).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Health.up().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>给定<code>HealthIndicator</code>的标识符是没有<code>HealthIndicator</code>后缀（如果存在）的bean的名称。 在上面的示例中，健康信息将出现在名为<code>my</code>的条目中。</p></blockquote><p>除了Spring Boot预定义<code>Status</code>类型之外，<code>Health</code>还可以返回表示新的系统状态的自定义<code>Status</code>。在这种情况下，还需要提供<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthAggregator.java"><code>HealthAggregator</code></a>接口的自定义实现，或者必须使用<code>management.health.status.order</code>配置属性配置默认实现。</p><p>例如，假设在一个<code>HealthIndicator</code>实现中使用了带有代码<code>FATAL</code>的新<code>Status</code>。 要配置严重性顺序，请将以下内容添加到应用程序属性中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.health.status.order&#x3D;FATAL, DOWN, OUT_OF_SERVICE, UNKNOWN, UP</span><br></pre></td></tr></table></figure><p>响应中的HTTP状态码反映了整体运行状况（例如<code>UP</code>映射到200，<code>OUT_OF_SERVICE</code>或<code>DOWN</code>到503）。如果你通过HTTP访问健康端点，你可能还需要注册<code>HealthMvcEndpoint</code>的自定义状态映射。例如，下面的配置映射<code>FATAL</code>到<code>HttpStatus.SERVICE_UNAVAILABLE</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">endpoints.health.mapping.FATAL&#x3D;503</span><br></pre></td></tr></table></figure><p>内置状态的默认状态映射有：</p><table><thead><tr><th>状态</th><th>映射</th></tr></thead><tbody><tr><td>DOWN</td><td>SERVICE_UNAVAILABLE (503)</td></tr><tr><td>OUT_OF_SERVICE</td><td>SERVICE_UNAVAILABLE (503)</td></tr><tr><td>UP</td><td>默认情况下没有映射，所以http状态是200</td></tr><tr><td>UNKNOWN</td><td>默认情况下没有映射，所以http状态是200</td></tr></tbody></table><h3 id="应用程序信息"><a href="#应用程序信息" class="headerlink" title="应用程序信息"></a>应用程序信息</h3><p>应用程序信息显示从<code>ApplicationContext</code>中定义的所有<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java"><code>InfoContributor</code></a> bean收集的各种信息。Spring Boot包括一些自动配置的<code>InfoContributors</code>，你也可以自己编写。</p><h4 id="InfoContributors-自动配置"><a href="#InfoContributors-自动配置" class="headerlink" title="InfoContributors 自动配置"></a>InfoContributors 自动配置</h4><p>以下<code>InfoContributors</code>在适当时由Spring Boot自动配置：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/EnvironmentInfoContributor.java"><code>EnvironmentInfoContributor</code></a></td><td>在<code>info</code> key下显示<code>Environment</code>中的任何 key。</td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/GitInfoContributor.java"><code>GitInfoContributor</code></a></td><td>如果<code>git.properties</code>文件可用，则显示git信息。</td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/BuildInfoContributor.java"><code>BuildInfoContributor</code></a></td><td>如果<code>META-INF / build-info.properties</code>文件可用，则显示构建信息。</td></tr></tbody></table><blockquote><p>可以使用<code>management.info.defaults.enabled</code>属性来禁用它们。</p></blockquote><h4 id="自定义应用程序info的信息"><a href="#自定义应用程序info的信息" class="headerlink" title="自定义应用程序info的信息"></a>自定义应用程序info的信息</h4><p>你可以通过设置<code>info.*</code>Spring属性定制<code>info</code>端点公开的数据。<code>info</code> key 下的所有<code>Environment</code>属性将被自动暴露出来。例如，你可以将以下内容添加到您的<code>application.properties</code>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info.app.encoding&#x3D;UTF-8</span><br><span class="line">info.app.java.source&#x3D;1.8</span><br><span class="line">info.app.java.target&#x3D;1.8</span><br></pre></td></tr></table></figure><p>你可以在构建时扩展信息属性，而不是硬编码这些值。<br>假设你正在使用Maven，你可以如下重写上述示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info.app.encoding&#x3D;@project.build.sourceEncoding@</span><br><span class="line">info.app.java.source&#x3D;@java.version@</span><br><span class="line">info.app.java.target&#x3D;@java.version@</span><br></pre></td></tr></table></figure><h4 id="Git-提交信息"><a href="#Git-提交信息" class="headerlink" title="Git 提交信息"></a>Git 提交信息</h4><p><code>info</code>端点的另一个有用功能是能够在项目构建时发布有关<code>git</code>源代码仓库状态的信息。如果<code>GitProperties</code> bean可用，<code>git.branch</code>，<code>git.commit.id</code>和<code>git.commit.time</code>属性将会暴露出来。</p><blockquote><p>如果类路径的根目录下存在<code>git.properties</code>文件，则会自动配置<code>GitProperties</code> bean。 有关详细信息，请参阅<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-git-info">生成git信息</a>。</p></blockquote><p>如果你想要显示完整的git信息(即<code>git.properties</code>的完整内容)，请使用<code>management.info.git.mode</code>属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.info.git.mode&#x3D;full</span><br></pre></td></tr></table></figure><h4 id="构建信息"><a href="#构建信息" class="headerlink" title="构建信息"></a>构建信息</h4><p>如果<code>BuildProperties</code> bean可用，则<code>info</code>端点还可以发布有关构建的信息。 如果类路径中有<code>META-INF/build-info.properties</code>文件，则会显示构建信息。</p><blockquote><p>Maven和Gradle插件都可以生成该文件，查看<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-build-info">生成的构建信息</a>以获取更多信息。</p></blockquote><h4 id="编写自定义-InfoContributors"><a href="#编写自定义-InfoContributors" class="headerlink" title="编写自定义 InfoContributors"></a>编写自定义 InfoContributors</h4><p>为了提供定制的应用程序信息，你可以注册实现<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java"><code>InfoContributor</code></a>接口的Spring bean。</p><p>下面的例子提供了一个具有单一值的<code>example</code>条目:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.Info;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.InfoContributor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleInfoContributor</span> <span class="keyword">implements</span> <span class="title">InfoContributor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contribute</span><span class="params">(Info.Builder builder)</span> </span>&#123;</span><br><span class="line">        builder.withDetail(<span class="string">&quot;example&quot;</span>,</span><br><span class="line">                Collections.singletonMap(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你点击了<code>info</code>端点，你将看到一个包含以下附加条目的响应:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;example&quot;: &#123;</span><br><span class="line">        &quot;key&quot; : &quot;value&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTP上的监视和管理"><a href="#HTTP上的监视和管理" class="headerlink" title="HTTP上的监视和管理"></a>HTTP上的监视和管理</h2><p>如果你正在开发Spring MVC 应用程序，那么Spring Boot Actuator将自动配置所有启用的端点，并通过HTTP暴露出来。默认的约定是使用端点的<code>id</code>加上<code>/application</code>的前缀作为URL路径。例如，<code>health</code>被暴露为<code>/application/health</code>。</p><h3 id="访问敏感的端点"><a href="#访问敏感的端点" class="headerlink" title="访问敏感的端点"></a>访问敏感的端点</h3><p>默认情况下，所有敏感的HTTP端点都是安全的，只有具有<code>ACTUATOR</code>角色的用户才可以访问它们。使用标准的<code>HttpServletRequest.isUserInRole</code>方法实现安全性。</p><blockquote><p>如果你想要与<code>ACTUATOR</code>不同的内容，请使用<code>management.security.roles</code>属性。</p></blockquote><p>如果你使用了防火墙，则可能希望在不需要身份验证的情况下访问所有actuator 端点。你可以使用<code>management.security.enabled</code>属性来改变这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.security.enabled&#x3D;false</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，actuator 端点暴露在同一端口上，该端口用于常规的HTTP服务。 如果更改<code>manage.security.enabled</code>属性，请小心不要意外暴露敏感信息。</p></blockquote><p>如果你公开部署应用程序，则可能需要添加“Spring Security”来处理用户身份验证。当添加“Spring Security”时，默认情况下将使用用户名<code>user</code>和生成的密码（应用程序启动时在控制台上打印）的“基本”身份验证方式。</p><blockquote><p>生成的密码在应用程序启动时会被记录下来。 可以搜索“Using default security password”。</p></blockquote><p>你可以使用Spring属性更改用户名和密码，并更改访问端点所需的安全角色。例如你可以在<code>application.properties</code>中设置以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">security.user.name&#x3D;admin</span><br><span class="line">security.user.password&#x3D;secret</span><br><span class="line">management.security.roles&#x3D;SUPERUSER</span><br></pre></td></tr></table></figure><p>如果你的应用程序具有自定义的安全配置，并且希望所有actuator 端点都可以在不进行身份验证的情况下访问，则需要在安全配置中显式地进行配置。与此同时，你需要更改<code>management.security.enabled</code>属性为<code>false</code>。</p><p>如果你的自定义安全配置来保护你的 actuator       端点，你还需要确保经过身份验证的用户具有<code>management.security.roles</code>下指定的角色。</p><blockquote><p>如果没有将基本健康信息暴露给未经身份验证的用户的使用场景，并且已使用自定义安全性保护actuator 端点，则可以将<code>management.security.enabled</code>设置为<code>false</code>。 这将通知Spring Boot跳过其他角色检查。</p></blockquote><h3 id="定制管理端点路径"><a href="#定制管理端点路径" class="headerlink" title="定制管理端点路径"></a>定制管理端点路径</h3><p>有时，定制管理端点的前缀是很有用的。 例如，你的应用程序可能已经将<code>/application</code> 用于另一目的。 你可以使用<code>management.context-path</code>属性更改管理端点的前缀：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.context-path&#x3D;&#x2F;manage</span><br></pre></td></tr></table></figure><p>以上的<code>application.properties</code>示例会将端点从<code>/application/&#123;id&#125;</code>更改为<code>/ manage/&#123;id&#125;</code>（例如<code>/manage/info</code>）。</p><p>你还可以更改端点的“路径”（<code>endpoints.&#123;name&#125;.path</code>），然后更改MVC端点的默认资源路径。没有验证这些值（所以你可以使用任何在URL路径中合法的内容）。 例如，要<code>/health</code>端点的位置更改为<code>/ping/me</code>，你可以设置<code>endpoints.health.path=/ping/me</code>。</p><blockquote><p>即使端点路径是单独配置的，它仍然相对于<code>management.context-path</code>路径。</p></blockquote><blockquote><p>如果你提供了自定义的MvcEndpoint，请记住要包含可设置的<code>path</code>属性，如果希望你的代码像标准MVC端点一样运行，则将其默认设置为<code>/&#123;id&#125;</code>。 （学习<code>HealthMvcEndpoint</code>的代码，看看该如何做。）如果你的自定义端点是一个<code>Endpoint</code>（而不是一个<code>MvcEndpoint</code>），那么Spring Boot会管理你的路径。</p></blockquote><h3 id="自定义管理服务器端口"><a href="#自定义管理服务器端口" class="headerlink" title="自定义管理服务器端口"></a>自定义管理服务器端口</h3><p>在基于云的部署情况下，使用默认HTTP端口暴露出管理端点是明智选择。但是，如果你的应用程序在自己的数据中心内运行，则可能更倾向于使用不同的HTTP端口暴露端点。</p><p><code>management.port</code>属性可用于更改HTTP端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.port&#x3D;8081</span><br></pre></td></tr></table></figure><p>由于你的管理端口通常受防火墙保护，并且不会暴露给公众，因此即使你的主应用程序是安全的，也可能不需要管理端点的安全性。在这种情况下，你可能使用了Spring Security，你可以这样禁用管理安全性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.security.enabled&#x3D;false</span><br></pre></td></tr></table></figure><p>(如果你没有使用Spring  Security，则不需要以这种方式明确禁用管理安全性，甚至可能会中断应用程序。)</p><h3 id="配置管理专用SSL"><a href="#配置管理专用SSL" class="headerlink" title="配置管理专用SSL"></a>配置管理专用SSL</h3><p>当配置了使用自定义端口时，管理服务器也可以使用各种<code>management.ssl.*</code>属性配置自己的SSL。 例如，这允许管理服务器使用HTTP，而主应用程序使用HTTPS：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.port&#x3D;8443</span><br><span class="line">server.ssl.enabled&#x3D;true</span><br><span class="line">server.ssl.key-store&#x3D;classpath:store.jks</span><br><span class="line">server.ssl.key-password&#x3D;secret</span><br><span class="line">management.port&#x3D;8080</span><br><span class="line">management.ssl.enabled&#x3D;false</span><br></pre></td></tr></table></figure><p>或者，主服务器和管理服务器都可以使用SSL，但使用不同的key store：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server.port&#x3D;8443</span><br><span class="line">server.ssl.enabled&#x3D;true</span><br><span class="line">server.ssl.key-store&#x3D;classpath:main.jks</span><br><span class="line">server.ssl.key-password&#x3D;secret</span><br><span class="line">management.port&#x3D;8080</span><br><span class="line">management.ssl.enabled&#x3D;true</span><br><span class="line">management.ssl.key-store&#x3D;classpath:management.jks</span><br><span class="line">management.ssl.key-password&#x3D;secret</span><br></pre></td></tr></table></figure><h3 id="定制管理服务器地址"><a href="#定制管理服务器地址" class="headerlink" title="定制管理服务器地址"></a>定制管理服务器地址</h3><p>你可以通过设置<code>management.address</code>属性来自定义管理端点可用的地址。 如果你只想在内部或面向操作系统的网络上侦听，或只监听<code>localhost</code>的连接，这将非常有用。</p><blockquote><p>如果端口与主服务器端口不同，则只能侦听不同的地址。</p></blockquote><p>以下是一个不允许远程管理连接的<code>application.properties</code>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.port&#x3D;8081</span><br><span class="line">management.address&#x3D;127.0.0.1</span><br></pre></td></tr></table></figure><h3 id="禁用HTTP端点"><a href="#禁用HTTP端点" class="headerlink" title="禁用HTTP端点"></a>禁用HTTP端点</h3><p>如果不想通过HTTP暴露端点，可以将管理端口设置为<code>-1</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.port&#x3D;-1</span><br></pre></td></tr></table></figure><h3 id="HTTP健康端点格式和访问限制"><a href="#HTTP健康端点格式和访问限制" class="headerlink" title="HTTP健康端点格式和访问限制"></a>HTTP健康端点格式和访问限制</h3><p>健康端点公开的信息取决于是否是匿名访问，以及封闭应用程序是否安全。默认情况下，当在安全应用程序中匿名访问时，有关服务器运行状况的任何详细信息都将被隐藏，并且端点将简单地显示服务器是否已启动或关闭。此外，可配置响应缓存的时间段，以防止端点被拒绝服务攻击。<code>endpoints.health.time-to-live</code>属性用于配置缓存周期（以毫秒为单位）。它默认为1000，也就是1秒。</p><p>下面的示例汇总了HTTP响应（默认为匿名请求）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i localhost:8080&#x2F;health</span><br><span class="line">HTTP&#x2F;1.1 200</span><br><span class="line">X-Application-Context: application</span><br><span class="line">Content-Type: application&#x2F;vnd.spring-boot.actuator.v2+json;charset&#x3D;UTF-8</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">&#123;&quot;status&quot;:&quot;UP&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面的示例汇总了状态为“DOWN”的HTTP响应(请注意503状态码):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i localhost:8080&#x2F;health</span><br><span class="line">HTTP&#x2F;1.1 503</span><br><span class="line">X-Application-Context: application</span><br><span class="line">Content-Type: application&#x2F;vnd.spring-boot.actuator.v2+json;charset&#x3D;UTF-8</span><br><span class="line">Content-Length: 17</span><br><span class="line"></span><br><span class="line">&#123;&quot;status&quot;:&quot;DOWN&quot;&#125;</span><br></pre></td></tr></table></figure><p>详细的HTTP响应示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i localhost:8080&#x2F;health</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">X-Application-Context: application</span><br><span class="line">Content-Type: application&#x2F;vnd.spring-boot.actuator.v2+json;charset&#x3D;UTF-8</span><br><span class="line">Content-Length: 221</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot; : &quot;UP&quot;,</span><br><span class="line">  &quot;diskSpace&quot; : &#123;</span><br><span class="line">    &quot;status&quot; : &quot;UP&quot;,</span><br><span class="line">    &quot;total&quot; : 63251804160,</span><br><span class="line">    &quot;free&quot; : 31316164608,</span><br><span class="line">    &quot;threshold&quot; : 10485760</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;db&quot; : &#123;</span><br><span class="line">    &quot;status&quot; : &quot;UP&quot;,</span><br><span class="line">    &quot;database&quot; : &quot;H2&quot;,</span><br><span class="line">    &quot;hello&quot; : 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以加强上述限制，从而仅允许经认证的用户在安全应用中完全访问健康端点。为此，请将<code>endpoints.health.sensitive</code>设置为<code>true</code>。以下是属性行为的总结（<code>sensitive </code>标志的默认值为“false”，以粗体表示）：</p><table><thead><tr><th><code>management.security.enabled</code></th><th><code>endpoints.health.sensitive</code></th><th>未授权</th><th>授权（正确的角色）</th></tr></thead><tbody><tr><td>false</td><td>*</td><td>完整的内容</td><td>完整的内容</td></tr><tr><td>true</td><td><em>false</em></td><td>只有状态</td><td>完整的内容</td></tr><tr><td>true</td><td>true</td><td>无内容</td><td>完整的内容</td></tr></tbody></table><h2 id="使用JMX监视和管理"><a href="#使用JMX监视和管理" class="headerlink" title="使用JMX监视和管理"></a>使用JMX监视和管理</h2><p>Java管理扩展（JMX）提供了监视和管理应用程序的标准机制。 默认情况下，Spring Boot将在<code>org.springframework.boot</code>域下将管理端点公开为JMX MBean。</p><h3 id="自定义MBean的名字"><a href="#自定义MBean的名字" class="headerlink" title="自定义MBean的名字"></a>自定义MBean的名字</h3><p>MBean的名称通常是从端点的<code>id</code>生成的。 例如，<code>health</code>端点暴露为<code>org.springframework.boot/Endpoint/healthEndpoint</code>。</p><p>如果你的应用程序包含多个Spring <code>ApplicationContext</code>，你可能会发现名称冲突。要解决此问题，你可以将<code>endpoints.jmx.unique-names</code>属性设置为<code>true</code>，这样MBean名称始终是唯一的。</p><p>你还可以自定义端点暴露的JMX域。 这里有一个<code>application.properties</code>的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">endpoints.jmx.domain&#x3D;myapp</span><br><span class="line">endpoints.jmx.unique-names&#x3D;true</span><br></pre></td></tr></table></figure><h3 id="禁用JMX端点"><a href="#禁用JMX端点" class="headerlink" title="禁用JMX端点"></a>禁用JMX端点</h3><p>如果你不想通过JMX公开端点，你可以将<code>endpoints.jmx.enabled</code>属性设置为<code>false</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">endpoints.jmx.enabled&#x3D;false</span><br></pre></td></tr></table></figure><h3 id="基于HTTP对JMX使用-Jolokia"><a href="#基于HTTP对JMX使用-Jolokia" class="headerlink" title="基于HTTP对JMX使用 Jolokia"></a>基于HTTP对JMX使用 Jolokia</h3><h4 id="定制Jolokia"><a href="#定制Jolokia" class="headerlink" title="定制Jolokia"></a>定制Jolokia</h4><h4 id="禁用Jolokia"><a href="#禁用Jolokia" class="headerlink" title="禁用Jolokia"></a>禁用Jolokia</h4><h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><p>Spring Boot Actuator包括在运行时查看和配置应用程序日志级别的功能。 你可以查看整个列表或单个记录器的配置，该配置由显式配置的日志记录级别以及日志记录框架给出的有效日志记录级别组成。这些级别可以是：</p><ul><li><code>TRACE</code></li><li><code>DEBUG</code></li><li><code>INFO</code></li><li><code>WARN</code></li><li><code>ERROR</code></li><li><code>FATAL</code></li><li><code>OFF</code></li><li><code>null</code><br><code>null</code>表示没有明确的配置</li></ul><h3 id="配置日志记录器"><a href="#配置日志记录器" class="headerlink" title="配置日志记录器"></a>配置日志记录器</h3><p>为了配置给定的记录器，您将部分实体<code>POST</code>到该资源的URI:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configuredLevel&quot;: &quot;DEBUG&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>你还可以传递一个<code>null</code> <code>configuredLevel</code> 来“重置”记录器的特定级别（并使用默认配置）。</p></blockquote><h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p>Spring Boot Actuator包括带有“计量”和“计数器”支持的度量服务。“计量”记录单个值; “计数器”记录增量（增量或减量）。Spring Boot Actuator还提供了一个<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/endpoint/PublicMetrics.java"><code>PublicMetrics</code></a>接口，你可以通过这两种机制之一来实现无法记录的指标。以<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/endpoint/SystemPublicMetrics.java"><code>SystemPublicMetrics</code></a>为例。</p><p>所有HTTP请求的指标都会自动记录下来，因此如果你点击了<code>metrics</code>端点，你应该会看到类似于以下的响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;counter.status.200.root&quot;: 20,</span><br><span class="line">    &quot;counter.status.200.metrics&quot;: 3,</span><br><span class="line">    &quot;counter.status.200.star-star&quot;: 5,</span><br><span class="line">    &quot;counter.status.401.root&quot;: 4,</span><br><span class="line">    &quot;gauge.response.star-star&quot;: 6,</span><br><span class="line">    &quot;gauge.response.root&quot;: 2,</span><br><span class="line">    &quot;gauge.response.metrics&quot;: 3,</span><br><span class="line">    &quot;classes&quot;: 5808,</span><br><span class="line">    &quot;classes.loaded&quot;: 5808,</span><br><span class="line">    &quot;classes.unloaded&quot;: 0,</span><br><span class="line">    &quot;heap&quot;: 3728384,</span><br><span class="line">    &quot;heap.committed&quot;: 986624,</span><br><span class="line">    &quot;heap.init&quot;: 262144,</span><br><span class="line">    &quot;heap.used&quot;: 52765,</span><br><span class="line">    &quot;nonheap&quot;: 0,</span><br><span class="line">    &quot;nonheap.committed&quot;: 77568,</span><br><span class="line">    &quot;nonheap.init&quot;: 2496,</span><br><span class="line">    &quot;nonheap.used&quot;: 75826,</span><br><span class="line">    &quot;mem&quot;: 986624,</span><br><span class="line">    &quot;mem.free&quot;: 933858,</span><br><span class="line">    &quot;processors&quot;: 8,</span><br><span class="line">    &quot;threads&quot;: 15,</span><br><span class="line">    &quot;threads.daemon&quot;: 11,</span><br><span class="line">    &quot;threads.peak&quot;: 15,</span><br><span class="line">    &quot;threads.totalStarted&quot;: 42,</span><br><span class="line">    &quot;uptime&quot;: 494836,</span><br><span class="line">    &quot;instance.uptime&quot;: 489782,</span><br><span class="line">    &quot;datasource.primary.active&quot;: 5,</span><br><span class="line">    &quot;datasource.primary.usage&quot;: 0.25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们可以看到基本的<code>memory</code>，<code>heap</code>，<code>class loading</code>，<code>processor</code>和<code>thread pool</code>信息以及一些HTTP指标。在这个例子中，<code>root</code>（’/‘）和<code>/metrics</code> URL分别返回<code>HTTP 200</code>响应<code>20</code>和<code>3</code>次。同样看来，<code>root</code>URL返回<code>HTTP 401</code>（未经授权）<code>4</code>次。 双星号(<code>star-star</code>)是由Spring MVC与<code>/**</code>(通常是静态资源)匹配的请求而来的。</p><p><code>gauge</code>显示请求的最后响应时间。所以最后一个<code>root</code>的请求需要<code>2ms</code>，最后一个<code>/metrics</code>需要3ms。</p><blockquote><p>在这个例子中，我们实际上是通过使用<code>/metrics</code> URL 访问端点，这就解释了为什么<code>metrics</code>出现在响应中。</p></blockquote><h3 id="系统指标"><a href="#系统指标" class="headerlink" title="系统指标"></a>系统指标</h3><p>Spring Boot会显示以下系统指标：</p><ul><li>系统总内存（KB）(<code>mem</code>)</li><li>可用内存量（KB）（<code>mem.free</code>）</li><li>处理器的数量（<code>processors</code>）</li><li>系统正常运行时间（毫秒）（<code>uptime</code>）</li><li>应用程序上下文的正常运行时间（毫秒）（<code>instance.uptime</code>）</li><li>系统平均负载（<code>systemload.average</code>）</li><li>堆信息（KB）（<code>heap</code>, <code>heap.committed</code>, <code>heap.init</code>, <code>heap.used</code>）</li><li>线程信息（<code>threads</code>, <code>thread.peak</code>, <code>thread.daemon</code>）</li><li>类加载信息（<code>classes</code>, <code>classes.loaded</code>, <code>classes.unloaded</code>）</li><li>垃圾收集信息（<code>gc.xxx.count</code>, <code>gc.xxx.time</code>）</li></ul><h3 id="数据源指标"><a href="#数据源指标" class="headerlink" title="数据源指标"></a>数据源指标</h3><p>为应用程序中定义的每个受支持的数据源暴露下面的指标:</p><ul><li>活动连接数（<code>datasource.xxx.active</code>）</li><li>当前连接池的使用情况（<code>datasource.xxx.usage</code>）</li></ul><p>所有数据源指标都共享<code>datasource.</code>前缀。这个前缀对每个数据源都有进一步的限定:</p><ul><li>如果数据源是主数据源（即现有唯一可用数据源或标记为<code>@Primary</code>的数据源），则前缀为<code>datasource.primary</code>。</li><li>如果数据源bean 名称以<code>DataSource</code>结尾，则前缀是没有<code>DataSource</code>的bean的名称（即<code>batchDataSource</code>的<code>datasource.batch</code>）。</li><li>在所有其他情况下，使用bean的名称。</li></ul><p>可以通过使用定制版本的<code>DataSourcePublicMetrics</code>注册一个bean来覆盖部分或全部默认值。默认情况下，Spring Boot为所有支持的数据源提供元数据; 如果你最喜欢的数据源不支持开箱即用，你可以添加额外的<code>DataSourcePoolMetadataProvider</code> bean。 有关示例，请参阅<code>DataSourcePoolMetadataProvidersConfiguration</code>。</p><h3 id="缓存指标"><a href="#缓存指标" class="headerlink" title="缓存指标"></a>缓存指标</h3><p>为应用程序中定义的每个受支持的缓存暴露下面的指标:</p><ul><li>当前缓存的大小（<code>cache.xxx.size</code>）</li><li>命中率（<code>cache.xxx.hit.ratio</code>）</li><li>失效率（<code>cache.xxx.miss.ratio</code>）</li></ul><blockquote><p>缓存提供者不会以一致的方式暴露命中/失效率。虽然有些公开了一个<em>聚合</em>值（即自上次统计数据被清除以来的命中率），但是其他人暴露了<em>时间</em>值（即最后一秒的命中率）。 查看你的缓存提供者文档以了解更多详细信息。</p></blockquote><p>如果两个不同的缓存管理器碰巧定义相同的缓存，那么缓存的名称将由<code>CacheManager</code> bean的名称预先确定。</p><p>可以通过注册一个自定义的<code>CachePublicMetrics</code> bean 来覆盖部分或全部的默认值。默认情况下，Spring Boot 提供了EhCache、Hazelcast、Infinispan、JCache和Caffeine的缓存统计数据。如果不支持你最喜欢的缓存库，则可以添加额外的<code>CacheStatisticsProvider</code> bean。请参见CacheStatisticsAutoConfiguration`的示例。</p><h3 id="Tomcat-session指标"><a href="#Tomcat-session指标" class="headerlink" title="Tomcat session指标"></a>Tomcat session指标</h3><p>如果你使用Tomcat作为嵌入式servlet容器，会自动暴露会话指标。 <code>httpsessions.active</code>和<code>httpsessions.max</code> key提供活动和最大会话的数量。</p><h3 id="记录自己的指标"><a href="#记录自己的指标" class="headerlink" title="记录自己的指标"></a>记录自己的指标</h3><p>要记录你自己的指标，可以向你的bean中注入一个<code>CounterService</code>和/或<code>GaugeService</code>。<code>CounterService</code>暴露<code>increment</code>、<code>decrement</code>和<code>reset</code>方法;<code>GaugeService</code>提供了一个<code>submit</code>方法。</p><p>下面是一个简单的例子，它计算了一个方法被调用的次数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.metrics.CounterService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CounterService counterService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(CounterService counterService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.counterService = counterService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.counterService.increment(<span class="string">&quot;services.system.myservice.invoked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>你可以使用任何字符串作为一个指标名，但是你应该遵循所选择的store/graphing技术的指导。<a href="http://matt.aimonetti.net/posts/2013/06/26/practical-guide-to-graphite-monitoring/">Matt Aimonetti的博客上</a>有一些关于<code>Graphite</code>的好指导。</p></blockquote><h3 id="添加自己公开的指标"><a href="#添加自己公开的指标" class="headerlink" title="添加自己公开的指标"></a>添加自己公开的指标</h3><p>要添加每次调用指标端点时计算的额外指标，只需注册额外的<code>PublicMetrics</code>实现bean。默认情况下，所有这些bean都是由端点收集的。你可以通过定义自己的<code>MetricsEndpoint</code>来更改。</p><h3 id="指标输出，导出和聚合"><a href="#指标输出，导出和聚合" class="headerlink" title="指标输出，导出和聚合"></a>指标输出，导出和聚合</h3><p>Spring Boot 提供了一些称为<code>Exporter</code>的标记接口的实现，可用于将内存缓冲区中的指标读数复制到可以分析和显示的位置。事实上,如果你提供实现<code>MetricWriter</code>接口(或用于简单使用情况的<code>GaugeWriter</code>)并使用<code>@ExportMetricWriter</code>标记的<code>@Bean</code>,那么它将自动连接到一个<code>Exporter</code>和每5秒更新一次指标(通过<code>spring.metrics.export.delay-millis</code>配置)。此外，你定义和标记为<code>@ExportMetricReader</code>的任何一个<code>MetricReader</code>的值由缺省导出器导出。</p><blockquote><p>如果在你的应用程序中启用调度(<code>@EnableScheduling</code>)并且在自己的计划任务开始时运行集成测试时，这个特性将是一个问题。你可以通过设置<code>spring.metrics.export.enabled</code>为<code>false</code>来禁用此行为。</p></blockquote><p>默认导出器是一个<code>MetricCopyExporter</code>，它尝试通过不复制自上次调用以来没有更改的值来优化自身（可以使用<code>spring.metrics.export.send-latest</code>关闭优化）。还要注意，Dropwizard <code>MetricRegistry</code> 不支持时间戳，因此如果你使用Dropwizard指标（所有指标将在每个刻度上复制），则优化将不可用。</p><p>导出触发器(<code>delay-millis</code>, <code>includes</code>, <code>excludes</code> 和<code>send-latest</code>)的默认值可以通过<code>spring.metrics.export.*</code>设置。特定<code>MetricWriters</code>的值可以通过<code>spring.metrics.export.triggers.&lt;name&gt;.*</code>，其中<code>&lt;name&gt;</code>是一个bean的名称（或匹配bean名称的模式）。</p><blockquote><p>如果你关闭默认的<code>MetricRepository</code>(例如使用Dropwizard指标)，那么将会禁用自动导出指标。你可以重获相同的功能，即声明一个属于你自己的<code>MetricReader</code>类型，并声明它为<code>@ExportMetricReader</code>。 </p></blockquote><h4 id="示例：导出到Redis"><a href="#示例：导出到Redis" class="headerlink" title="示例：导出到Redis"></a>示例：导出到Redis</h4><p>如果你提供一个类型为<code>RedisMetricRepository</code>的<code>@Bean</code>，并将其标记为<code>ExportMetricWriter</code>，则会将指标导出到Redis缓存以进行聚合。<code>RedisMetricRepository</code>有两个重要的参：<code>prefix</code>和<code>key</code>（传入其构造函数）。最好使用应用程序实例唯一的前缀（例如，使用随机值，也可以使用应用程序的逻辑名称使其可以与同一应用程序的其他实例相关联）。“key”用于保存所有指标名称的全局索引，因此它应该是“全局”惟一的，无论对你的系统意味着什么(例如，如果有不同的键，相同系统的两个实例可以共享一个Redis缓存)。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ExportMetricWriter</span></span><br><span class="line"><span class="function">MetricWriter <span class="title">metricWriter</span><span class="params">(MetricExportProperties export)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedisMetricRepository(connectionFactory,</span><br><span class="line">        export.getRedis().getPrefix(), export.getRedis().getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>application.properties</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.metrics.export.redis.prefix&#x3D; metrics.mysystem.$&#123;spring.application.name:application&#125;.$&#123;random.value:0000&#125;</span><br><span class="line">spring.metrics.export.redis.key&#x3D;keys.metrics.mysystem</span><br></pre></td></tr></table></figure><p>前缀是使用应用名称和id结尾构造的，因此可以很容易地使用它来标识具有相同逻辑名称的一组进程。</p><blockquote><p>设置<code>key</code>和<code>prefix</code>是很重要的。key 用于所有仓库操作，并且可以由多个仓库共享。如果多个存储库共享一个key (比如在需要聚合的情况下)，那么通常有一个只读的“master”仓库，它有一个简短但可识别的前缀(比如“metrics.mysystem”)，以及许多只写前缀的仓库，这些前缀都是从主前缀开始的(比如上面例子中的<code>metrics.mysystem.*</code>)。从这样的“主”仓库中读取所有键是很有效的，但是使用较长的前缀(例如，使用一个写库)来读取一个子集的效率是很低的。</p></blockquote><blockquote><p>上面的例子使用了<code>MetricExportProperties</code>来注入和提取key和prefix。这是由Spring Boot提供的，配置有合理的缺省值。没有什么可以阻止你使用你自己的值，只要它们遵循建议。</p></blockquote><h4 id="示例：导出到Open-TSDB"><a href="#示例：导出到Open-TSDB" class="headerlink" title="示例：导出到Open TSDB"></a>示例：导出到Open TSDB</h4><h4 id="示例：导出到Statsd"><a href="#示例：导出到Statsd" class="headerlink" title="示例：导出到Statsd"></a>示例：导出到Statsd</h4><h4 id="示例：导出到JMX"><a href="#示例：导出到JMX" class="headerlink" title="示例：导出到JMX"></a>示例：导出到JMX</h4><p>如果你提供一个使用<code>@ExportMetricWriter</code>的<code>JmxMetricWriter</code>类型的<code>@Bean</code>，则将指标导出为本地服务器的MBean（<code>MBeanExporter</code>由Spring Boot JMX自动配置提供，只要它已打开）。然后可以使用任何连接JMX的工具（例如JConsole或JVisualVM）来检查，绘制图表，提醒等等。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ExportMetricWriter</span></span><br><span class="line"><span class="function">MetricWriter <span class="title">metricWriter</span><span class="params">(MBeanExporter exporter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JmxMetricWriter(exporter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个指标都导出为单独的MBean。<code>ObjectNamingStrategy</code>给出了<code>ObjectNames</code>的格式，可以将其注入到<code>JmxMetricWriter</code>中(缺省情况下，可以将指标名和前两个周期分隔的部分分隔开，从而使指标可以在JVisualVM或JConsole中分组)。</p><h3 id="从多个来源聚合指标"><a href="#从多个来源聚合指标" class="headerlink" title="从多个来源聚合指标"></a>从多个来源聚合指标</h3><p>你可以使用<code>AggregateMetricReader</code>来合并来自不同物理源的指标。相同逻辑指标的源只需要用一个周期分隔的前缀来发布它们，并且reader将聚合(通过截断指标名称，并删除前缀)它们。counter 会相加，并且其他的（即gauge）将取其最新值。</p><p>如果多个应用程序实例从中央(例如Redis)仓库获取并显示结果时，这将是非常有用的。特别推荐结合<code>MetricReaderPublicMetrics</code>连接“/metrics”端点的结果。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MetricExportProperties export;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PublicMetrics <span class="title">metricsAggregate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MetricReaderPublicMetrics(aggregatesMetricReader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> MetricReader <span class="title">globalMetricsForAggregation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedisMetricRepository(<span class="keyword">this</span>.connectionFactory,</span><br><span class="line">        <span class="keyword">this</span>.export.getRedis().getAggregatePrefix(), <span class="keyword">this</span>.export.getRedis().getKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> MetricReader <span class="title">aggregatesMetricReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AggregateMetricReader repository = <span class="keyword">new</span> AggregateMetricReader(</span><br><span class="line">        globalMetricsForAggregation());</span><br><span class="line">    <span class="keyword">return</span> repository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中使用了<code>MetricExportProperties</code>来注入和提取key 和prefix 。这是通过Spring Boot提供的，并且默认设置是合理的。他们在<code>MetricExportAutoConfiguration</code>中进行设置。</p></blockquote><blockquote><p>上面的<code>@MetricReaders</code>不是<code>@Beans</code>，也没有标记<code>@ExportMetricReader</code>，因为他们只是收集和分析来自其他仓库的数据，并且不希望导出他们的值。</p></blockquote><h3 id="Dropwizard指标"><a href="#Dropwizard指标" class="headerlink" title="Dropwizard指标"></a>Dropwizard指标</h3><p>当你声明对<code>io.dropwizard.metrics:metrics-core</code>的依赖时，将创建一个默认的<code>MetricRegistry</code> Spring bean;如果需要定制，还可以注册自己的<code>@Bean</code> 实例。<br>用户<a href="https://dropwizard.github.io/metrics/">Dropwizard “指标” 库</a>的用户会发现Spring  Boot 指标自动发布到<code>com.codahale.metrics.MetricRegistry</code>。来自<code>MetricRegistry </code>的指标也会通过<code>/metrics</code>端点自动暴露出来。</p><p>当使用Dropwizard指标时，默认的<code>CounterService</code>和<code>GaugeService</code>将被替换为<code>DropwizardMetricServices</code>，它是<code>MetricRegistry</code>的包装器（因此你可以<code>@Autowired</code>其中一个服务并正常使用它）。你还可以通过使用适当的类型(例如<code>timer.*</code>，针对gauge的<code>histogram.*</code>，针对counter的<code>meter.*</code>）预先确定你的指标名称来创建“特殊”的Dropwizard 指标。</p><h3 id="消息通道集成"><a href="#消息通道集成" class="headerlink" title="消息通道集成"></a>消息通道集成</h3><p>如果存在一个名为<code>metricsChannel</code>的<code>MessageChannel</code> bean，那么将创建一个将指标写入该通道的<code>MetricWriter</code>。发送到该通道的每个消息都将包含一个<a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/actuate/metrics/writer/Delta.html"><code>Delta</code></a>或<a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/actuate/metrics/Metric.html"><code>Metric</code></a>有效负载，并有一个<code>metricName</code>头。writer自动地连接到一个导出器(对于所有的writer)，所以所有的指标都将出现在通道上，并且订阅者可以采取额外的分析或操作(由你来提供所需要的通道和订阅者)。</p><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>Spring Boot Actuator具有灵活的审计框架，一旦使用了Spring  Security（默认情况下是“认证成功”，“失败”和“拒绝访问”异常），就会发布事件。这对于做报告来说非常有用，也可以实现身份验证失败时的锁定策略。要自定义发布的安全事件，你可以提供自己的<code>AbstractAuthenticationAuditListener</code>和<code>AbstractAuthorizationAuditListener</code>的实现。</p><p>你还可以选择为你自己的业务事件使用审计服务。要这样做可以将现有<code>AuditEventRepository</code>注入自己的组件然后直接使用,或者你以简单地通过Spring <code>ApplicationEventPublisher</code>(使用<code>ApplicationEventPublisherAware</code>)发布<code>AuditApplicationEvent</code>。</p><h2 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h2><p>为所有HTTP请求自动启用跟踪。你可以查看<code>trace</code>端点并获得关于最后100个请求的基本信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    &quot;timestamp&quot;: 1394343677415,</span><br><span class="line">    &quot;info&quot;: &#123;</span><br><span class="line">        &quot;method&quot;: &quot;GET&quot;,</span><br><span class="line">        &quot;path&quot;: &quot;&#x2F;trace&quot;,</span><br><span class="line">        &quot;headers&quot;: &#123;</span><br><span class="line">            &quot;request&quot;: &#123;</span><br><span class="line">                &quot;Accept&quot;: &quot;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8&quot;,</span><br><span class="line">                &quot;Connection&quot;: &quot;keep-alive&quot;,</span><br><span class="line">                &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</span><br><span class="line">                &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 Gecko&#x2F;Firefox&quot;,</span><br><span class="line">                &quot;Accept-Language&quot;: &quot;en-US,en;q&#x3D;0.5&quot;,</span><br><span class="line">                &quot;Cookie&quot;: &quot;_ga&#x3D;GA1.1.827067509.1390890128; ...&quot;</span><br><span class="line">                &quot;Authorization&quot;: &quot;Basic ...&quot;,</span><br><span class="line">                &quot;Host&quot;: &quot;localhost:8080&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;response&quot;: &#123;</span><br><span class="line">                &quot;Strict-Transport-Security&quot;: &quot;max-age&#x3D;31536000 ; includeSubDomains&quot;,</span><br><span class="line">                &quot;X-Application-Context&quot;: &quot;application:8080&quot;,</span><br><span class="line">                &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;,</span><br><span class="line">                &quot;status&quot;: &quot;200&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    &quot;timestamp&quot;: 1394343684465,</span><br><span class="line">    ...</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>以下是默认情况下的跟踪:</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Request Headers</td><td>request头</td></tr><tr><td>Response Headers</td><td>response头</td></tr><tr><td>Cookies</td><td>request头中的<code>Cookie</code>和response头中的<code>Set-Cookie</code></td></tr><tr><td>Errors</td><td>错误属性（若有的话）</td></tr><tr><td>消耗的时间</td><td>请求服务的毫秒时间</td></tr></tbody></table><h3 id="自定义追踪"><a href="#自定义追踪" class="headerlink" title="自定义追踪"></a>自定义追踪</h3><p>如果需要跟踪其他事件，可以将<code>TraceRepository</code>注入到Spring bean中。<code>add</code>方法接受一个单一的<code>Map</code>，该<code>Map</code>将转换为JSON并被记录下来。</p><p>默认情况下，将使用一个<code>InMemoryTraceRepository</code>来存储最后的100个事件。如果需要扩展容量，你可以定义自己的<code>InMemoryTraceRepository</code> bean实例。如果需要，还可以创建自己的<code>TraceRepository</code>实现。</p><h2 id="进程监控"><a href="#进程监控" class="headerlink" title="进程监控"></a>进程监控</h2><p>在Spring Boot Actuator 中，你可以找到几个类用来创建对进程监控有用的文件:</p><ul><li><code>ApplicationPidFileWriter</code>创建一个包含应用程序PID的文件(默认情况下在应用程序目录中, 文件名称<code>application.pid</code>)。</li><li><code>EmbeddedServerPortFileWriter</code>创建一个文件(或多个文件)包含嵌入式服务器的端口(默认情况下在应用程序目录,文件名为<code>application.port</code>)。</li></ul><p>这些writer在默认情况下不会被激活，但是你可以用下面的方法来启用它们。</p><h3 id="扩展配置"><a href="#扩展配置" class="headerlink" title="扩展配置"></a>扩展配置</h3><p>在<code>META-INF/spring.factories</code>文件可以激活写<code>PID</code>文件的监听器。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationListener&#x3D;\</span><br><span class="line">org.springframework.boot.system.ApplicationPidFileWriter,\</span><br><span class="line">org.springframework.boot.actuate.system.EmbeddedServerPortFileWriter</span><br></pre></td></tr></table></figure><h3 id="编程方式"><a href="#编程方式" class="headerlink" title="编程方式"></a>编程方式</h3><p>你也可以通过调用<code>SpringApplication.addListeners(…)</code>方法并传入适当的<code>Writer</code>对象的方式来激活一个监听器。该方法还允许你通过<code>Writer</code>的构造函数来定制文件名和路径。</p><h3 id="禁用扩展的Cloud-Foundry-actuator-支持"><a href="#禁用扩展的Cloud-Foundry-actuator-支持" class="headerlink" title="禁用扩展的Cloud Foundry actuator 支持"></a>禁用扩展的Cloud Foundry actuator 支持</h3><h3 id="Cloud-Foundry自签署证书"><a href="#Cloud-Foundry自签署证书" class="headerlink" title="Cloud Foundry自签署证书"></a>Cloud Foundry自签署证书</h3><h3 id="自定义安全配置"><a href="#自定义安全配置" class="headerlink" title="自定义安全配置"></a>自定义安全配置</h3><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><p>如果你想要探索本章中讨论的一些概念，你可以看看actuator   <a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples">示例程序</a>。你也可能想要了解一些图形化工具，比如<a href="http://graphite.wikidot.com/">Graphite</a>。</p><p>否则，你可以继续阅读有关“<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#deployment">部署选项</a>”的信息，或者提前深入了解一些有关Spring Boot的<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#build-tool-plugins">构建工具插件</a>的信息。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> 生产 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 四-Spring Boot 特性</title>
      <link href="/post/29b6/"/>
      <url>/post/29b6/</url>
      
        <content type="html"><![CDATA[<p>本节将深入介绍Spring Boot的细节。在这里，你可以了解你想要使用和定制的关键特性。如果还没有，你可能需要阅读第2部分，“<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#getting-started">开始</a>”和第3部分，“<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#using-boot">使用Spring引导</a>”部分，这样你就可以很好地了解基础知识。</p><h2 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h2><p><code>SpringApplication</code>类提供了一种方便的方法来引导一个从<code>main()</code>方法启动的Spring应用程序。在许多情况下，你可以将其委托给静态<code>SpringApplication.run</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(MySpringConfiguration.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你的应用程序启动时，你应该会看到类似的东西:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> &#x2F;\\ &#x2F; ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#39;_ | &#39;_| | &#39;_ \&#x2F; _&#96; | \ \ \ \</span><br><span class="line"> \\&#x2F;  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#39;  |____| .__|_| |_|_| |_\__, | &#x2F; &#x2F; &#x2F; &#x2F;</span><br><span class="line"> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|_|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|___&#x2F;&#x3D;&#x2F;_&#x2F;_&#x2F;_&#x2F;</span><br><span class="line"> :: Spring Boot ::   v2.0.0.BUILD-SNAPSHOT</span><br><span class="line"></span><br><span class="line">2013-07-31 00:08:16.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (&#x2F;apps&#x2F;myapp.jar started by pwebb)</span><br><span class="line">2013-07-31 00:08:16.166  INFO 56603 --- [           main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy</span><br><span class="line">2014-03-04 13:09:54.912  INFO 41370 --- [           main] .t.TomcatServletWebServerFactory : Server initialized with port: 8080</span><br><span class="line">2014-03-04 13:09:56.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)</span><br></pre></td></tr></table></figure><p>默认<code>INFO</code>日志信息将显示出来，包括启动应用程序的用户等相关的启动细节。</p><h3 id="启动失败"><a href="#启动失败" class="headerlink" title="启动失败"></a>启动失败</h3><p>如果你的应用程序无法启动，注册的<code>FailureAnalyzers</code>就有机会提供一个专门的错误消息和一个具体的操作来解决这个问题。例如，如果你在端口8080上启动一个web应用程序，并且该端口已经在使用，你应该会看到类似的东西:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Embedded servlet container failed to start. Port 8080 was already in use.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Identify and stop the process that&#39;s listening on port 8080 or configure this application to listen on another port.</span><br></pre></td></tr></table></figure><blockquote><p>Spring Boot提供了无数的<code>FailureAnalyzer</code>实现，并且你可以<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-failure-analyzer">很容易地添加自己</a>的实现。</p></blockquote><p>如果没有失败分析程序能够处理这个异常，你仍然可以显示完整的自动配置报告，以更好地理解出错的地方。所以你需要启用<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-external-config"><code>debug</code>属性</a>或为<code>org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer</code>启用<code>DEBUG</code>日志记录。</p><p>例如，如果你正在使用<code>java-jar</code>运行你的应用程序，你可以启用以下的<code>debug</code>属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug</span><br></pre></td></tr></table></figure><h3 id="自定义Banner"><a href="#自定义Banner" class="headerlink" title="自定义Banner"></a>自定义Banner</h3><p>在启动时打印的banner可以通过添加一个<code>banner.txt</code>文件到类路径或者通过设置<code>banner.location</code>指向该文件的位置来改变。如果这个文件有不同寻常的编码，你可以设置<code>banner.charset</code>(默认为<code>UTF-8</code>)。除了文本文件之外，你还可以添加一个<code>banner.gif</code>,<code>banner.jpg</code>或<code>banner.png</code>图像文件到类路径，或者设置一个<code>banner.image.location</code>属性。图像将被转换成ASCII字符，并在任何文本banner上打印。</p><p>在你的banner.txt文件中你可以使用以下占位符:</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>$&#123;application.version&#125;</code></td><td>在<code>MANIFEST.MF</code>中声明的应用程序的版本号。例如，<code>Implementation-Version: 1.0</code>被打印为<code>1.0</code>。</td></tr><tr><td><code>$&#123;application.formatted-version&#125;</code></td><td>在<code>MANIFEST.MF</code>中声明的应用程序的格式化版本号(用括号括起来，用v作前缀)。例如<code>(v1.0)</code>。</td></tr><tr><td><code>$&#123;spring-boot.version&#125;</code></td><td>你正在使用的Spring Boot版本。例如<code>2.0.0.BUILD-SNAPSHOT</code>。</td></tr><tr><td><code>$&#123;spring-boot.formatted-version&#125;</code></td><td>你正在使用的Spring Boot版本格式化输出形式（用括号括起来，用v作前缀）。例如<code>(v2.0.0.BUILD-SNAPSHOT)</code>。</td></tr><tr><td><code>$&#123;Ansi.NAME&#125;</code> (or <code>$&#123;AnsiColor.NAME&#125;</code>, <code>$&#123;AnsiBackground.NAME&#125;</code>, <code>$&#123;AnsiStyle.NAME&#125;</code>)</td><td><code>NAME</code>是ANSI转义码的名字。有关详细信息,请参阅<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java"><code>AnsiPropertySource</code></a>。</td></tr><tr><td><code>$&#123;application.title&#125;</code></td><td>在<code>MANIFEST.MF</code>中声明的应用程序的标题。例如，<code>Implementation-Title: MyApp</code>被打印为<code>MyApp</code>。</td></tr></tbody></table><blockquote><p><code>SpringApplication.setBanner(…)</code>方法可以用来以编程方式生成一个banner 。使用<code>org.springframework.boot.Banner</code>接口，并实现您自己的<code>printBanner()</code>方法。</p></blockquote><p>你还可以使用<code>spring.main.banner-mode</code>属性，以确定是否必须在<code>System.out</code>（<code>console</code>）打印banner，使用已配置的日志记录器(<code>log</code>)或根本不打印(<code>off</code>)。</p><p>打印的banner将以<code>springBootBanner</code>的名字注册为一个单例bean。</p><blockquote><p>YAML映射<code>off</code>为<code>false</code>，因此如果你想禁用应用程序中的banner，请确保添加引号。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">   <span class="attr">main:</span></span><br><span class="line">      <span class="attr">banner-mode:</span> <span class="string">&quot;off&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="自定义SpringApplication"><a href="#自定义SpringApplication" class="headerlink" title="自定义SpringApplication"></a>自定义SpringApplication</h3><p>如果<code>SpringApplication</code>默认值不符合你的胃口，你可以创建一个本地实例并自定义它。例如，关闭banner:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication app = <span class="keyword">new</span> SpringApplication(MySpringConfiguration.class);</span><br><span class="line">    app.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">    app.run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>传递给<code>SpringApplication</code>的构造函数参数是spring bean 的配置源。在大多数情况下，这些都是对<code>@Configuration</code>类的引用，但是它们也可以是对XML配置的引用，或者是对应该被扫描的包的引用。</p></blockquote><p>还可以使用<code>application.properties</code>文件配置<code>SpringApplication</code>。请参阅<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-external-config">第24章，扩展配置</a>以获得详细信息。</p><p>关于配置选项的完整列表，请参阅<a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/SpringApplication.html"><code>SpringApplication</code> Javadoc</a>。</p><h3 id="流式builder-API"><a href="#流式builder-API" class="headerlink" title="流式builder API"></a>流式builder API</h3><p>如果你需要构建一个<code>ApplicationContext</code>层次结构(具有父/子关系的多个上下文)，或者您更喜欢使用“流式的”构建器API，那么您可以使用<code>SpringApplicationBuilder</code>。</p><p><code>SpringApplicationBuilder</code>允许你将多个方法调用链接在一起，并包含允许你创建层次结构的<code>parent</code>和<code>child</code>方法。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder()</span><br><span class="line">        .sources(Parent.class)</span><br><span class="line">        .child(Application.class)</span><br><span class="line">        .bannerMode(Banner.Mode.OFF)</span><br><span class="line">        .run(args);</span><br></pre></td></tr></table></figure><blockquote><p>在创建<code>ApplicationContext</code>层次结构时，会有一些限制，例如，Web组件必须包含在子上下文中，并且父子上下文将使用相同的环境变量<code>Environment</code>。请参阅<a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/builder/SpringApplicationBuilder.html"><code>SpringApplicationBuilder</code> Javadoc</a>来获得完整的详细信息。</p></blockquote><h3 id="事件和监听器"><a href="#事件和监听器" class="headerlink" title="事件和监听器"></a>事件和监听器</h3><p>除了通常的Spring Framework 事件，如 <a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/event/ContextRefreshedEvent.html"><code>ContextRefreshedEvent</code></a>，一个<code>SpringApplication</code>会发送一些额外的应用事件。</p><blockquote><p>有些事件实际上是在创建<code>ApplicationContext</code>之前触发的，因此你不能将这些监听器注册为一个<code>@Bean</code>。你可以通过<code>SpringApplication.addListeners(…)</code>或<code>SpringApplicationBuilder.listeners(…)</code>方法来注册。如果你希望这些侦听器能自动注册，不管应用程序是如何创建的，可以添加一个<code>META-INF/spring.factories</code>文件到项目中并使用<code>org.springframework.context.ApplicationListener</code> key来引用它们。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationListener&#x3D;com.example.project.MyListener</span><br></pre></td></tr></table></figure><p>应用事件按照以下顺序发送:</p><ol><li>一个<code>ApplicationStartingEvent</code>是在开始运行时发送的，但是在任何处理之前，除了监听器和初始化器的注册。</li><li>在上下文中使用的<code>Environment</code>已知但在创建上下文之前，将发送<code>ApplicationEnvironmentPreparedEvent</code>。</li><li>一个<code>ApplicationPreparedEvent</code>是在刷新启动之前发送的，但是在bean定义被加载之后。</li><li>一个<code>ApplicationReadyEvent</code>是在刷新之后发送的，并且已经处理了任何相关的回调，以表明应用程序已经准备好处理请求。</li><li>如果在启动时出现异常，就会发送<code>ApplicationFailedEvent</code>。</li></ol><blockquote><p>通常不需要使用应用程序事件，但是知道它们的存在可以做到得心应手。在内部，Spring Boot使用事件来处理各种任务。</p></blockquote><h3 id="Web-环境"><a href="#Web-环境" class="headerlink" title="Web 环境"></a>Web 环境</h3><p><code>SpringApplication</code>将尝试为你创建合适的<code>ApplicationContext</code>。默认情况下,将使用一个<code>AnnotationConfigApplicationContext</code>或<code>AnnotationConfigServletWebServerApplicationContext </code>,这取决于你是否正在开发一个web应用程序。</p><p>用于确定“web environment”的算法相当简单(基于是否存在几个类)。如果需要覆盖缺省值，可以使用<code>setWebEnvironment(boolean webEnvironment)</code>。</p><p>也可以完全控制将通过调用<code>setApplicationContextClass（...）</code>使用的<code>ApplicationContext</code>类型。</p><blockquote><p>在JUnit测试中使用<code>SpringApplication</code>时，通常需要调用<code>setWebEnvironment(false)</code>。</p></blockquote><h3 id="访问应用参数"><a href="#访问应用参数" class="headerlink" title="访问应用参数"></a>访问应用参数</h3><p>如果需要访问传递给<code>SpringApplication.run（...）</code>的应用程序参数，则可以注入<code>org.springframework.boot.ApplicationArguments</code> bean。 <code>ApplicationArguments</code>接口提供对原始<code>String []</code>参数以及解析过的<code>option</code>和<code>non-option</code>参数的访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.*</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.*</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> debug = args.containsOption(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">        List&lt;String&gt; files = args.getNonOptionArgs();</span><br><span class="line">        <span class="comment">// if run with &quot;--debug logfile.txt&quot; debug=true, files=[&quot;logfile.txt&quot;]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Spring Boot还将向Spring <code>Environment</code>注册一个<code>CommandLinePropertySource</code>。 这允许你也可以使用<code>@Value</code>注解注入单个应用参数。</p></blockquote><h3 id="使用ApplicationRunner，CommandLineRunner"><a href="#使用ApplicationRunner，CommandLineRunner" class="headerlink" title="使用ApplicationRunner，CommandLineRunner"></a>使用ApplicationRunner，CommandLineRunner</h3><p>当你需要在<code>SpringApplication</code>启动时运行一些特定的代码，你可以实现<code>ApplicationRunner</code>或<code>CommandLineRunner</code>接口。 这两个接口都以相同的方式工作，并提供一个单独的<code>run</code>方法，并在<code>SpringApplication.run（...）</code>完成之前调用。</p><p><code>CommandLineRunner</code>接口提供对应用程序参数的访问，并将参数作为一个简单的字符串数组，而<code>ApplicationRunner</code>使用上述的<code>ApplicationArguments</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.*</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.*</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do something...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果几个<code>CommandLineRunner</code>或<code>ApplicationRunner</code> bean 必须在一个特定的顺序被调用,你可以额外实现<code>org.springframework.core.Ordered</code>接口，也可以使用<code>org.springframework.core.annotation.Order</code>注解。</p><h3 id="应用退出"><a href="#应用退出" class="headerlink" title="应用退出"></a>应用退出</h3><p>每个<code>SpringApplication</code>将在JVM上注册一个关闭钩子，以确保<code>ApplicationContext</code>在退出时优雅地关闭。所有标准的Spring生命周期回调(例如<code>DisposableBean </code>，或者<code>@PreDestroy</code>)都可以使用。</p><p>此外,如果希望在<code>SpringApplication.exit()</code>被调用时返回特定的退出代码,bean 可以实现<code>org.springframework.boot.ExitCodeGenerator</code>接口。这个退出代码可以传递给<code>System.exit()</code>以作为状态代码返回它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExitCodeApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExitCodeGenerator <span class="title">exitCodeGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> () -&gt; <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.exit(SpringApplication</span><br><span class="line">.exit(SpringApplication.run(ExitCodeApplication.class, args)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，异常类可以实现<code>ExitCodeGenerator</code>接口。 遇到这样的异常时，Spring Boot将返回由它实现的<code>getExitCode（）</code>方法提供的退出码。</p><h3 id="管理员功能"><a href="#管理员功能" class="headerlink" title="管理员功能"></a>管理员功能</h3><p>可以通过指定<code>spring.application.admin.enabled</code>属性来为应用程序启用与管理相关的功能。 这会在<code>MBeanServer</code>平台上暴露<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot/src/main/java/org/springframework/boot/admin/SpringApplicationAdminMXBean.java"><code>SpringApplicationAdminMXBean</code></a>。 你可以使用此功能远程管理你的Spring Boot应用程序。 这对于任何服务包装器实现也是有用的。</p><blockquote><p>如果你想知道应用程序在哪个HTTP端口上运行，请使用<code>local.server.port</code> key来获取该属性。</p></blockquote><blockquote><p>启用此功能时请小心，因为MBean公开了关闭应用程序的方法。</p></blockquote><h2 id="扩展配置"><a href="#扩展配置" class="headerlink" title="扩展配置"></a>扩展配置</h2><p>Spring Boot 允许扩展配置，因此我们的应用可以在不同的环境中运行。可以使用properties文件，YAML文件，环境变量和命令行参数来扩展配置。属性值可以通过<code>@Value</code>注解直接注入到bean中，通过Spring环境变量<code>Environment</code>来访问或者通过<code>@ConfigurationProperties</code>注解绑定到结构化对象中。</p><p>Spring Boot用特定的<code>PropertySource</code>顺序来对属性值进行覆盖。顺序如下：</p><ol><li>当开发者工具启用时，开发者工具全局设置（<code>$&#123;home&#125;/.spring-boot-devtools.properties</code>,windows用户在<code>C:\Users\qinzaizhen\</code>目录中，<code>qinzaizhen</code>为用户名）</li><li>测试用例中<code>@TestPropertySource</code>注解添加进来的属性</li><li><code>@SpringBootTest#properties</code>添加的属性</li><li>命令行参数</li><li><code>SPRING_APPLICATION_JSON</code>添加的参数（环境变量或系统属性中嵌入的json）</li><li><code>ServletConfig</code>初始化参数</li><li><code>ServletContext</code>初始化参数</li><li><code>java:comp/env</code> JNDI属性</li><li>Java系统属性<code>System.getProperties()</code></li><li>操作系统环境变量</li><li><code>random.*</code>形式的<code>RandomValuePropertySource</code></li><li>jar包外的<code>application-&#123;profile&#125;.properties</code>和YAML文件</li><li>jar包中的<code>application-&#123;profile&#125;.properties</code>和YAML文件</li><li>jar包外的<code>application.properties</code>和YAML文件</li><li>jar包中的<code>application.properties</code>和YAML文件</li><li><code>@Configuration</code>类上<code>@PropertySource</code>注解指定的文件</li><li>通过<code>SpringApplication.setDefaultProperties</code>指定的默认属性</li></ol><p>例如下面的一个类，需要注入<code>name</code>的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.*</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序的classpath中可以用<code>application.properties</code>文件提供<code>name</code>的默认值。当在新环境中运行时，jar包外的<code>application.properties</code>可以覆盖<code>name</code>的值;在一次性的测试中，可以通过在控制台中指定个一个<code>name</code>的值（如：<code>java -jar app.jar --name=&quot;Spring&quot;</code>）。</p><p><code>SPRING_APPLICATION_JSON</code>可以在控制台输入之后变成一个环境变量，比如在Unix shell中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> SPRING_APPLICATION_JSON=<span class="string">&#x27;&#123;&quot;foo&quot;:&#123;&quot;bar&quot;:&quot;spam&quot;&#125;&#125;&#x27;</span> java -jar myapp.jar</span></span><br></pre></td></tr></table></figure><p>在这个例子中，Spring的<code>Environment</code>中将会是<code>foo.bar=spam</code>。也可以通过设置一个系统属性<code>$ java -Dspring.application.json=&#39;&#123;&quot;foo&quot;:&quot;bar&quot;&#125;&#39; -jar myapp.jar</code>，或者是控制台参数</p><blockquote><p>$ java -jar myapp.jar –spring.application.json=’{“foo”:”bar”}’ 未成功，找不到这个属性，而且会导致上面的<code>SPRING_APPLICATION_JSON</code>环境变量失效</p></blockquote><p>或者通过JNDI变量：<code>java:comp/env/spring.application.json</code>。</p><p>比如环境变量的方式：</p><p>先设置环境变量，然后再运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\springboot-demo\demo4\target&gt;set SPRING_APPLICATION_JSON=&#123;&quot;developer.name&quot;:&quot;a</span><br><span class="line">aaaaaaaaaa&quot;&#125;</span><br><span class="line"></span><br><span class="line">E:\springboot-demo\demo4\target&gt;java -jar springboot.demo4-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>控制台打印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2017-08-08 21:46:24.783 DEBUG 44644 --- [           main] l.q.springboot.demo.domain.AppListener   : 属性值(此处中文有乱码)： aaaaaaaaaaa</span><br></pre></td></tr></table></figure><h3 id="配置随机值"><a href="#配置随机值" class="headerlink" title="配置随机值"></a>配置随机值</h3><p><code>RandomValuePropertySource</code>用来注入随机值非常方便（比如注入到秘钥或测试用例中）。可以产生int,long,uuid和字符串。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my.secret&#x3D;$&#123;random.value&#125;</span><br><span class="line">my.number&#x3D;$&#123;random.int&#125;</span><br><span class="line">my.bignumber&#x3D;$&#123;random.long&#125;</span><br><span class="line">my.uuid&#x3D;$&#123;random.uuid&#125;</span><br><span class="line">my.number.less.than.ten&#x3D;$&#123;random.int(10)&#125;</span><br><span class="line">my.number.in.range&#x3D;$&#123;random.int[1024,65536]&#125;</span><br></pre></td></tr></table></figure><p><code>random.int*</code>格式是<code>OPEN value (,max) CLOSE</code>，这里的<code>OPEN,CLOSE</code>可以是任何的字符，<code>value,max</code>是整数。如果<code>max</code>有值，那么<code>value</code>就是最小值，而<code>max</code>就是最大值（不包括<code>max</code>）。**<code>OPEN</code>,<code>CLOSE</code>可以是任何字符，但是如果是上面一样作为属性值，不可使用<code>&#123;</code>,<code>&#125;</code>。可以是<code>my.number.in.range=$&#123;random.int[1024,65536)&#125;</code>，意义是一样的。如果是<code>my.number.in.range=$&#123;random.int[1024,65536&#125;&#125;</code>，那么传到<code>RandomValuePropertySource</code>中的表达式为<code>random.int[1024,65536</code>，这样在算范围的时候就成了<code>1024,6553</code>**。</p><h3 id="访问控制台参数"><a href="#访问控制台参数" class="headerlink" title="访问控制台参数"></a>访问控制台参数</h3><p><code>SpringApplication</code>默认会将控制台选项参数（以<code>--</code>开头，如：<code>--server.port=9000</code>）转换为一个属性并且将它添加到Spring的环境变量中去。上面提到过控制台参数的优先级比其他的属性源高。<br>如果不想添加控制台属性添加到Spring环境变量中，可以通过<code>SpringApplication.setAddCommandLineProperties(false)</code>来禁用这个功能。</p><h3 id="应用属性文件"><a href="#应用属性文件" class="headerlink" title="应用属性文件"></a>应用属性文件</h3><p><code>SpringApplication</code>会按照以下顺序加载<code>application.properties</code>文件，并且将它他们添加到Spring环境变量中。</p><ol><li>当前目录的<code>/config</code>子目录</li><li>当前目录</li><li>classpath下<code>/config</code>包</li><li>classpath根目录</li></ol><p>如果不想用<code>application.properties</code>作为配置文件名，可以通过配置<code>spring.config.name</code>环境变量来更改。还可以明确通过<code>spring.config.location</code>环境变量指定配置文件的位置（多个目录或者文件路径用<code>,</code>隔开）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar myproject.jar --spring.config.name&#x3D;myproject</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar myproject.jar --spring.config.location&#x3D;classpath:&#x2F;default.properties,classpath:&#x2F;override.properties</span><br></pre></td></tr></table></figure><blockquote><p><code>spring.config.name</code>和<code>spring.config.location</code>在很早的时候用来决定哪些文件需要加载，因此它们必须得在环境变量中声明（常见的是操作系统的环境变量，系统属性或者控制台参数）。</p></blockquote><p>如果<code>spring.config.location</code>包含目录（相对文件来说），需要以<code>/</code>结尾（并且在开始加载之前，会拼接<code>spring.config.name</code>指定的名称，包括特定profile的文件名）。<code>spring.config.location</code>中指定的文件还是跟原来一样，不支持特定profile变体，并且会被任何的特定profile属性覆盖。</p><p>配置文件是按照反方向的顺序查找的。配置文件的位置默认是<code>classpath:/,classpath:/config/,file:./,file:./config/</code>。查找的顺序是反的：</p><ol><li><code>file:./config/</code>：jar包所在目录创建<code>config</code>目录和<code>application.properties</code></li><li><code>file:./</code>：jar目录中创建<code>application.properties</code></li><li><code>classpath:/config/</code>：resources目录中创建<code>config</code>目录和<code>application.properties</code></li><li><code>classpath:/</code>：resources根目录创建<code>application.properties</code></li></ol><blockquote><p>测试<code>file:./config/，file:./</code>这两个时，先打包成jar包，然后再在jar包同目录下创建<code>config</code>目录，里面新建<code>application.properties</code>文件，同理在jar包同目录下新建<code>application.properties</code>文件，两种情况分别测试。跟<code>@SpringBootApplication</code>注解的类放在同目录是无法测试这类情况的。<br>如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myapp.jar</span><br><span class="line">&#x2F;config&#x2F;application.properties</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017-08-12 10:37:45.677  INFO 17459 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@18ef96: startup date [Sat Aug 12 10:37:45 CST 2017]; root of context hierarchy</span><br><span class="line">属性值：current directory &#x2F;config</span><br></pre></td></tr></table></figure><p>当使用自定义位置时，会添加到默认位置中。自定义位置会在默认位置之前查找。例如，如果自定义位置是<code>classpath:/custom-config/,file:./custom-config/</code>，那么查找的顺序是：</p><ol><li><code>file:./custom-config/</code>: 在jar包目录创建对应的目录和文件（成功）</li><li><code>classpath:/custom-config/</code> ：在resources目录创建对应的目录和文件（未成功）</li><li><code>file:./config/</code></li><li><code>file:./</code></li><li><code>classpath:/config/</code></li><li><code>classpath:/</code></li></ol><p>这种查找顺序允许你在某个文件中指定一些默认值，然后有在其他文件中有选择性地覆盖这些值。你可以在其中一个默认位置的<code>application.properties</code>（或者其他通过<code>spring.config.name</code>指定的名称）文件中指定默认值。这些默认值可以在运行的时候被其他任一自定义位置的不同文件覆盖。</p><blockquote><p>如果使用环境变量而不是系统属性，大多数操作系统禁止点分隔的名称，但是可以使用下划线来代替（如：<code>STRING_CONFIG_NAME</code>代替<code>spring.config.name</code> (windows下测试有效)）。</p></blockquote><p><strong>设置环境变量<code>STRING_CONFIG_LOCATION</code>和<code>spring.config.location</code>无效。</strong></p><p>如果在容器中运行，JDNI属性(在<code>java:comp/env</code>中的)或者servlet上下文初始化参数可以代替环境变量或系统属性。</p><h3 id="Profile-specific属性"><a href="#Profile-specific属性" class="headerlink" title="Profile-specific属性"></a>Profile-specific属性</h3><p>除<code>application.properties</code>文件之外，还可以定义<code>application-&#123;profile&#125;.properties</code>格式的特定profile的属性。当没有指定profile时，<code>Environment</code>会使用一些默认的profiles（默认为<code>[default]</code>）,比如没有明确指定profile时，将会加载<code>application-default.properties</code>。</p><p>特定profile的属性和标准的<code>application.properties</code>一样从相同的位置加载进来，同时特定profile会覆盖非特定profile的文件，不管这个特定profile的文件是不是在jar包中。</p><p>如果指定了多个profile，最后一个将会生效。例如：通过<code>spring.profiles.active</code>属性来指定的profile在那些通过<code>SpringApplication</code>API 配置的profile后面被添加进来，因此会获取优先权。</p><blockquote><p>如果在<code>spring.config.location</code>设置的任何文件中的特定profile文件将不会生效。如果<code>spring.profiles.active</code>指定的profile名称和<code>spring.config.location</code>中的profile名称一样，是会生效的，不一样的话则不会生效。<br>比如：<code>spring.profiles.active=dev</code>，则<code>java -jar myapp.jar --spring.config.location=application-dev.properties</code>会生效，但是<code>java -jar myapp.jar --spring.config.location=application-pro.properties</code>则不会生效。<br>如果想让它生效，可以在<code>spring.config.location</code>中使用目录（实验结果如上）。</p></blockquote><h3 id="属性文件中的Placeholders"><a href="#属性文件中的Placeholders" class="headerlink" title="属性文件中的Placeholders"></a>属性文件中的Placeholders</h3><p><code>application.properties</code>文件中的值可以用<code>Environment</code>中存在的值过滤，因此可以引用之前定义过的值（比如：系统属性）。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="meta">app.description</span>=<span class="string">$&#123;app.name&#125; is a Spring Boot application</span></span><br></pre></td></tr></table></figure><blockquote><p>可以使用这个特性来对一些存在的Spring Boot属性定义短变量。<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-use-short-command-line-arguments">具体查看</a>。</p></blockquote><h3 id="YAML-代替属性文件"><a href="#YAML-代替属性文件" class="headerlink" title="YAML 代替属性文件"></a>YAML 代替属性文件</h3><p>YAML是JSON的一个超集，也是一个非常方便设置分层配置数据的格式。当在classpath中发现了<a href="http://www.snakeyaml.org/">Snake YAML</a>包时，<code>SpringApplication</code>类会自动支持YAML作为属性的一种可选方案。</p><blockquote><p>如果使用spring-boot-starter，Snake YAML会自动加载进来。</p></blockquote><h4 id="加载YAML"><a href="#加载YAML" class="headerlink" title="加载YAML"></a>加载YAML</h4><p>Spring Framework 提供了两个方便的类用来加载YAML文档。<code>YamlPropertiesFactoryBean</code>将会把YAML加载为<code>properties</code>，<code>YamlMapFactoryBean</code>将会加载为<code>Map</code>。</p><p>例如下面的YAML文档：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environments:</span></span><br><span class="line">    <span class="attr">dev:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://dev.bar.com</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Developer</span> <span class="string">Setup</span></span><br><span class="line">    <span class="attr">prod:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://foo.bar.com</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">My</span> <span class="string">Cool</span> <span class="string">App</span></span><br></pre></td></tr></table></figure><p>将会被转换成下面的属性：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">environments.dev.url</span>=<span class="string">http://dev.bar.com</span></span><br><span class="line"><span class="meta">environments.dev.name</span>=<span class="string">Developer Setup</span></span><br><span class="line"><span class="meta">environments.prod.url</span>=<span class="string">http://foo.bar.com</span></span><br><span class="line"><span class="meta">environments.prod.name</span>=<span class="string">My Cool App</span></span><br></pre></td></tr></table></figure><p>YAML中的list会表示成带<code>[index]</code>的key，比如这个YAML：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line">   <span class="attr">servers:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">dev.bar.com</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">foo.bar.com</span></span><br></pre></td></tr></table></figure><p>将会被转换成：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">my.servers[0]</span>=<span class="string">dev.bar.com</span></span><br><span class="line"><span class="meta">my.servers[1]</span>=<span class="string">foo.bar.com</span></span><br></pre></td></tr></table></figure><p>使用Spring<code>DataBinder</code>工具（<code>@ConfigurationProperties</code>正好做这个事情）来绑定这样的属性需要在目标对象中定义<code>java.util.List</code>(或<code>Set</code>)属性并且需要提供一个setter方法或者通过一个可变的值实例化它，如下面的例子可以绑定上面的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; servers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.servers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当通过上面的方式配置list覆盖时要格外注意，它不会像预想的那样工作，。在上面的例子中，当<code>my.servers</code>在多个地方重复定义了，每个元素都是被覆盖的对象，而不是该list。为了确保有最高优先级的<code>@PropertySource</code>可以覆盖list，需要将它定义为一个单独的属性。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line">   <span class="attr">servers:</span> <span class="string">dev.bar.com,foo.bar.com</span></span><br></pre></td></tr></table></figure><p>(未明白是什么场景)</p><h4 id="将YMAL作为属性暴露到Spring-环境中"><a href="#将YMAL作为属性暴露到Spring-环境中" class="headerlink" title="将YMAL作为属性暴露到Spring 环境中"></a>将YMAL作为属性暴露到Spring 环境中</h4><p><code>YamlPropertySourceLoader</code>类可以用来暴露YAML，将它作为Spring <code>Environment</code>的一个<code>PropertySource</code>。你可以使用熟悉的<code>@Value</code>注解来访问YAML属性。</p><h4 id="多个profile-的YAML文件"><a href="#多个profile-的YAML文件" class="headerlink" title="多个profile 的YAML文件"></a>多个profile 的YAML文件</h4><p>可以通过<code>spring.profiles</code> key 在一个YAML文档中指定多个特定profile。比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">profiles:</span> <span class="string">development</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">profiles:</span> <span class="string">production</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.120</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，当profile <code>development</code>激活时<code>server.address</code>属性将是<code>127.0.0.1</code>。如果<code>development</code>和<code>production</code> profile未激活时，那么<code>server.address</code>的值将是<code>192.168.1.100</code>。</p><p>在应用上下文启动时，如果没有明显地指定profile时，那么默认的profile将会激活。所以在下面的YAML中我们为<code>security.user.password</code>设置了一个值，<strong>仅在</strong> “default” profile中可用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">weak</span></span><br></pre></td></tr></table></figure><p>然而在下面这个例子中，password一直都有值，因为它不属于任何profile，并且在需要的时候必须得在其他的profile中显示地进行重设。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">weak</span></span><br></pre></td></tr></table></figure><p>Spring profile设计的<code>spring.profiles</code>元素可以使用<code>!</code>字符来否定。如果在一个文档中否定和非否定的profile被指定，至少必须匹配一个非否定的pfofile，否定的profile可以不匹配。</p><h4 id="YAML-缺陷"><a href="#YAML-缺陷" class="headerlink" title="YAML 缺陷"></a>YAML 缺陷</h4><p>YAML文件无法通过<code>@PropertySource</code>注解加载。如果想通过这种方式加载，需要使用properties文件。</p><h4 id="合并YAML列表"><a href="#合并YAML列表" class="headerlink" title="合并YAML列表"></a>合并YAML列表</h4><p>在上面已经知道，YAML中的内容将会完全转换成properties。在profile中覆盖list时这个处理有可能与直觉背道而驰。例如，假设<code>MyPojo</code>对象有<code>name</code>和<code>description</code>两个属性，并且默认为<code>null</code>。从<code>FooProperties</code>对象中暴露出<code>MyPojo</code>的一个list。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;foo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MyPojo&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;MyPojo&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">foo:</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">my</span> <span class="string">description</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">foo:</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my</span> <span class="string">another</span> <span class="string">name</span></span><br></pre></td></tr></table></figure><p>如果<code>dev</code> profile没有激活，那么<code>FooProperties.list</code>将会包含一个<code>MyPojo</code>。然而当<code>dev</code> profile 激活时，这个<code>list</code>仍然只有一个实体（name 为“my another name” ，description 为 <code>null</code>）。这样配置不会为这个list增加第二个<code>MyPojo</code>，而且不会合并元素。</p><p>当在多个pfofile中声明一个集合时，将会使用最高优先级的那个（并且只有这一个）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">foo:</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">my</span> <span class="string">description</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">another</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">another</span> <span class="string">description</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">foo:</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my</span> <span class="string">another</span> <span class="string">name</span></span><br></pre></td></tr></table></figure><p>在这个例子中，考虑到profile <code>dev</code>激活时，<code>FooProperties.list</code>将会包含<em>一</em>个<code>MyPojo</code>实体（name 为“my another name” 并且 description 为<code>null</code>）。</p><h3 id="类型安全的配置属性"><a href="#类型安全的配置属性" class="headerlink" title="类型安全的配置属性"></a>类型安全的配置属性</h3><p>在使用<code>@value(&quot;$&#123;property&#125;&quot;)</code>注解注入配置属性时，有可能会很麻烦，尤其是如果使用多个属性或者数据具有层次性时。Spring Boot 提供了一个可选的方法来处理属性，它允许强类型控制并且校验这些配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;foo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Security security = <span class="keyword">new</span> Security();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetAddress <span class="title">getRemoteAddress</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRemoteAddress</span><span class="params">(InetAddress remoteAddress)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Security <span class="title">getSecurity</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; roles = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.singleton(<span class="string">&quot;USER&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getRoles</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoles</span><span class="params">(List&lt;String&gt; roles)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的POJO定义了下面的这些属性：</p><ul><li><code>foo.enabled</code>，默认为<code>false</code></li><li><code>foo.remote-address</code>，能够从<code>String</code>强转过来。</li><li><code>foo.security.username</code>，一个内部属性，名称由属性的名称决定。特别是返回类型完全不被使用而且可能是<code>SecurityProperties</code></li><li><code>foo.security.password</code></li><li><code>foo.security.roles</code>，<code>String</code>集合</li></ul><blockquote><p>get和set方法通常是必须要有的，因为绑定是通过标准的Java Bean 内省包，就像在Spring MVC里一样。有一些情况下set方法可以省略：</p><ul><li>Maps，只要他们初始化了，需要一个get方法不需要set方法，因为他们可以被binder修改。</li><li>Collections和arrays可以通过下标（尤其是和YAML一起时）或者使用单行逗号分隔的值（属性）。在后一种情况下，set方法必须要有。强烈建议一直添加set方法。如果实例化了一个集合，确保可以修改（如上例）</li><li>如果内部POJO属性初始化了（如上面例子中的<code>Security</code>属性），不需要set方法。如果想要binder通过它的默认构造函数来实例化，需要提供set方法。<br>有人使用Lombok项目来自动生成get和set方法。确保Lombok没有为这些类型生成任何常规的构造方法，因为容器在实例化这种对象时会自动调用构造方法。</li></ul></blockquote><blockquote><p>查看<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-external-config-vs-value"><code>@Value</code>和<code>@ConfigurationProperties</code>之间的区别</a></p></blockquote><p>还需要在<code>@EnableConfigurationProperties</code>注解中进行注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(FooProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当<code>@ConfigurationProperties</code> bean 通过这种方式注册之后，这个bean会有一个方便的名称：<code>&lt;prefix&gt;-&lt;fqn&gt;</code>，这里的<code>&lt;prefix&gt;</code>是<code>@ConfigurationProperties</code>中定义的环境的key 前缀，<code>&lt;fqn&gt;</code>是这个bean的全名称。如果注解没有提供任何的前缀，将会使用这个bean的全名称。上面例子中的bean名称为<code>foo-com.exapmle.FooProperties</code>。</p></blockquote><p>尽管上面的配置将会为<code>FooProperties</code>创建一个常规的bean，但是建议<code>@ConfigurationProperties</code>只处理跟环境相关的，特别是不从上下文中注册其他的bean。之前说过，<code>@EnableConfigurationProperties</code>注解也会自动地应用到项目中，因此任何现存的<code>@ConfigurationProperties</code>注解过的bean将会配置到环境中。可以简配上面的<code>MyConfiguration</code>通过确保<code>FooProperties</code>已经是一个bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;foo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... see above</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种配置方式特别适合<code>@SpringApplication</code>外面YAML配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">foo:</span></span><br><span class="line">    <span class="attr">remote-address:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">security:</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">foo</span></span><br><span class="line">        <span class="attr">roles:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">USER</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ADMIN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># additional configuration as required</span></span><br></pre></td></tr></table></figure><p>要使用<code>@ConfigurationProperties</code>注解的bean，可以直接像其他bean一样将它们注入进来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FooProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(FooProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server(<span class="keyword">this</span>.properties.getRemoteAddress());</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>@ConfigurationProperties</code>还可以生成描述数据文件，这些文件可以被IDE用来自动提示。<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#configuration-metadata">详情查看</a></p></blockquote><h4 id="第三方配置"><a href="#第三方配置" class="headerlink" title="第三方配置"></a>第三方配置</h4><p>除了使用@configurationproperties来注解一个类，还可以在public的@bean方法上使用它。当你想绑定属性到那些不受控制的第三方组件时这将会非常有用。<br>要在bean中使用<code>Environment</code>的属性，需要在bean注册的地方添加<code>@ConfigurationProperties</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;bar&quot;)</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BarComponent <span class="title">barComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何以<code>bar</code>开头的属性都将会绑定到这个<code>BarComponent</code> bean 上，就像上面的<code>FooProperties</code>一样。</p><h4 id="松散绑定"><a href="#松散绑定" class="headerlink" title="松散绑定"></a>松散绑定</h4><p>Spring Boot使用一些松散的规则来绑定<code>Environment</code>属性到<code>@ConfigurationProperties</code> bean上，因此<code>Environment</code>属性名称和bean的属性名称没有必要完全匹配。这些有用的例子包括虚线（如：<code>context-path</code>绑定到<code>contextPath</code>）和大写（如：<code>PORT</code>绑定到<code>port</code>）环境属性。</p><p>例如下面给出的<code>@ConfigurationProperties</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OwnerProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面所有的属性都可以使用：</p><table><thead><tr><th>属性名</th><th>解释</th></tr></thead><tbody><tr><td><code>person.firstName</code></td><td>标准的驼峰形式</td></tr><tr><td><code>person.first-name</code></td><td>短横线隔开，在<code>.properties</code>和<code>.yml</code>文件中推荐使用这种形式</td></tr><tr><td><code>person.first_name</code></td><td>下划线符号，<code>.properties</code>和<code>.yml</code>文件中可选的一种形式</td></tr><tr><td><code>PERSON_FIRSTNAME</code></td><td>大写形式。推荐在系统环境变量中使用</td></tr></tbody></table><blockquote><p>注解的<code>prefix</code>值必须是短横线隔开的形式，如：小写并且以<code>-</code>分隔。这里如果只有<code>person</code>就没有必要隔开了。</p></blockquote><h6>松散绑定规则</h6><table><thead><tr><th>属性来源</th><th>简单值</th><th>List值</th></tr></thead><tbody><tr><td>Properties文件</td><td>驼峰形式，短横线隔开，下划线符号</td><td>用<code>[]</code>的标准list形式或者逗号隔开的值</td></tr><tr><td>YAML文件</td><td>驼峰形式，短横线隔开，下划线符号</td><td>标准的YAML list形式或者逗号隔开的值</td></tr><tr><td>环境变量</td><td>以下划线作为分隔符的大写形式。<code>_</code>不要在属性名中使用</td><td>下划线包围的数字形式。如：<code>MY_FOO_1_BAR = my.foo[1].bar</code></td></tr><tr><td>系统属性</td><td>驼峰形式，短横线隔开，下划线符号</td><td>用<code>[]</code>的标准list形式或者逗号隔开的值</td></tr></tbody></table><blockquote><p>建议尽可能地用小写短横线格式来存储属性。如：<code>my.property-name=foo</code></p></blockquote><h4 id="属性转换"><a href="#属性转换" class="headerlink" title="属性转换"></a>属性转换</h4><p>在属性绑定到<code>@configurationProperties</code> bean的过程中，Spring会尝试强制转换为正确的类型。如果需要自定义类型转换，可以提供一个<code>ConversionService</code> bean（bean的id为<code>conversionService</code>）或者自定义属性编辑器（通过一个<code>CustomEditorConfigurer</code> bean），或者是自定义<code>Converters</code>（通过<code>@ConfigurationPropertiesBinding</code>注解）。</p><blockquote><p>由于<code>ConversionService</code>在应用的生命周期中使用的非常早，因此需要确保减少它的依赖。典型地，你需要的任何依赖可能在创建时间没有完全初始化。如果<code>ConversionService</code>在配置key强转的过程中不需要，并且仅仅依赖于<code>@ConfigurationPropertiesBinding</code>限制的自定义转换器，你有可能想对它重命名。</p></blockquote><h4 id="ConfigurationProperties-校验"><a href="#ConfigurationProperties-校验" class="headerlink" title="@ConfigurationProperties 校验"></a>@ConfigurationProperties 校验</h4><p>Spring Boot会尝试校验那些使用了Spring的<code>@Validated</code>注解的<code>@ConfigurationProperties</code>类。可以直接在配置类上使用JSR-303 <code>javax.validation</code>约束注解。只需要确保在classpath中有一个兼容的JSR-303实现，然后再在类属性上加上约束注解就可以了。</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;foo&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... getters and setters</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了校验内部属性，必须在属性上使用<code>Valid</code>注解来触发校验。例如，下面的<code>FooProperties</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;connection&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Security security = <span class="keyword">new</span> Security();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... getters and setters</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotEmpty</span></span><br><span class="line">        <span class="keyword">public</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... getters and setters</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以通过创建一个bean定义为<code>configurationPropertiesValidator</code>的方式增加一个自定义Spring <code>Validator</code>。<code>@Bean</code>方法应该声明为<code>static</code>。配置属性校验器创建的时机在应用 的生命周期中非常早，因此将<code>@Bean</code>方法声明为static可以让这个bean的创建不需要实例化<code>@Configuration</code>。这避免了饥饿实例化引起的一些问题。 </p><blockquote><p><code>spring-boot-actuator</code>模块包含了一个端点，暴露了所有的<code>@ConfigurationProperties</code> bean。在浏览器中访问<code>/configprops</code>或者使用相同的JSX端点。<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#production-ready-endpoints">详情查看</a></p></blockquote><h4 id="ConfigurationProperties-与-Value对比"><a href="#ConfigurationProperties-与-Value对比" class="headerlink" title="@ConfigurationProperties 与 @Value对比"></a>@ConfigurationProperties 与 @Value对比</h4><p><code>@Value</code>是核心容器的一个功能，不提供<code>@ConfigurationProperties </code>类似的类型安全的功能。下面的表格总结了两个注解支持的功能。</p><table><thead><tr><th>功能</th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>不严格绑定</td><td>支持</td><td>不支持</td></tr><tr><td>元数据支持</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL 表达式</td><td>不支持</td><td>支持</td></tr></tbody></table><p>如果为自己的组件定义了一些配置键值，建议将他们放在一个POJO对象中，并且用<code>@ConfigurationProperties</code>注解。同时要注意由于<code>@Value</code>不支持松散绑定，因此当需要提供环境变量的值时最好不用<code>@Value</code>。</p><p>最后，虽然可以用<code>@Value</code>编写<code>SpEL</code>表达式，但这些从应用程序属性文件中的表达式不会处理。</p><h2 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h2><p>Spring Profile提供了一种隔离部分应用配置的方式，同时使它只在某种确定的环境中可用。任何<code>@Component</code>或<code>@Configuration</code>可以标记<code>@Profile</code>注解来限制它们被加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring常规的方式中，可以使用<code>spring.profile.active</code> <code>Environment</code>属性来指定激活哪个profile。可以在任何常规方式中指定这个属性，比如可以在<code>application.properties</code>文件中指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active&#x3D;dev,hsqldb</span><br></pre></td></tr></table></figure><p>或者在控制台指定：<code>--spring.profiles.active=dev,hsqldb</code>。</p><h3 id="增加激活的profile"><a href="#增加激活的profile" class="headerlink" title="增加激活的profile"></a>增加激活的profile</h3><p><code>spring.profiles.active</code>属性跟其他属性一样遵循相同的顺序规则，最高优先级的将会生效。意思是可以指定在<code>application.properties</code>文件中指定激活的profile，然后在控制台中替换掉它。</p><p>有时增加激活的profile而不是替换掉它们将会对特定profile属性非常有用。<code>spring.profiles.include</code>属性可以用来无条件地增加激活的profile。<code>SpringApplication</code>入口也拥胡一个API来设置附加的profile（如在那些通过<code>spring.profiles.active</code>属性设置的profile之上）：<code>setAdditionalProfiles()</code>方法。</p><p>例如：当一个应用通过<code>--spring.profiles.active=prod</code>开关来运行时，<code>proddb</code>和<code>prodmq</code> profile也会被激活：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">my.property:</span> <span class="string">fromyamlfile</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring.profiles:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">spring.profiles.include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">proddb</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">prodmq</span></span><br></pre></td></tr></table></figure><blockquote><p>记住一点：<code>spring.profiles</code>属性可以定义在YAML文档中，用来决定什么时候这个特殊的文档被包含在配置中。更多查看<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-change-configuration-depending-on-the-environment"> Change configuration depending on the environment</a>。</p></blockquote><h3 id="以编程方式设置profile"><a href="#以编程方式设置profile" class="headerlink" title="以编程方式设置profile"></a>以编程方式设置profile</h3><p>在应用启动之前可以通过调用<code>SpringApplication.setAdditionalProfiles()</code>方法以编程的方式来设置激活的profile。用Spring <code>ConfigurableEnvironment</code>接口也可以激活profile。</p><h3 id="特定Profile配置文件"><a href="#特定Profile配置文件" class="headerlink" title="特定Profile配置文件"></a>特定Profile配置文件</h3><p><code>application.properties</code>（或<code>application.yml</code>）和通过<code>@ConfigurationProperties</code>引用的文件中的特定profile变量都会被加载。详细查看<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-external-config-profile-specific-properties">Section 24.4, “Profile-specific properties”</a></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>Spring Boot 内部使用 <a href="http://commons.apache.org/logging">Commons Log</a>记录日志，但是放开了日志实现。为<a href="http://docs.oracle.com/javase/7/docs/api/java/util/logging/package-summary.html">Java Util Logging</a>，<a href="http://logging.apache.org/log4j/2.x/">Log4J2</a>和<a href="http://logback.qos.ch/">Logback</a>提供了默认的配置。每个logger都预先配置了输出到控制台和选择输出到文件。</p><p>如果使用了”Starters”，默认会使用Logback来记录日志。还包括适当的Logback路由，以确保使用Java Util Logging、Commons Logging、Log4J或SLF4J的依赖库都能正常工作。</p><blockquote><p>Java 有很多日志框架可选。不要对上面的选择很困惑。一般不需要改变日志的依赖，并且Spring Boot 默认就会工作地很好。</p></blockquote><h3 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h3><p>Spring Boot默认的日志输出格式类似下面这种：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2014-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52</span><br><span class="line">2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms</span><br><span class="line">2014-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: &#x27;dispatcherServlet&#x27; to [/]</span><br><span class="line">2014-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: &#x27;hiddenHttpMethodFilter&#x27; to: [/*]</span><br></pre></td></tr></table></figure><p>输出了以下内容：</p><ul><li>日期和时间：毫秒级精度，容易排序</li><li>日志级别-<code>ERROR</code>,<code>WARN</code>,<code>INFO</code>,<code>DEBUG</code>或<code>TRACE</code></li><li>进程ID</li><li>用一个<code>---</code>分隔符来区分真正的日志内容起始</li><li>线程名称- 用方括号包裹起来（在控制台输出时有可能被截断）</li><li>日志记录器名称-这个通常是类名称（通常是短小的）</li><li>日志内容</li></ul><blockquote><p>Logback 没有<code>FATAL</code>这个级别（映射到ERROR）。</p></blockquote><h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><p>默认地的日志配置会将日志打印到控制台。默认会记录<code>ERROR</code>,<code>WARN</code>和<code>INFO</code>级别的日志。可以在启动的时候通过<code>--debug</code>来开启”debug”模式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myapp.jar --debug</span></span><br></pre></td></tr></table></figure><blockquote><p>也可以在<code>application.properties</code>文件指定<code>debug=true</code>。</p></blockquote><p>当debug模式启用时，选择的核心日志记录器（嵌入式容器，Hibernate和Spring Boot）将会记录更多更多信息。启用debug模式并不会配置应用程序以<code>DEBUG</code>级别来记录所有消息。</p><p>可以选择通过<code>--trace</code>标记（或者<code>application.properties</code>文件中<code>trace=true</code>）来启用”trace”模式。这将为选择的核心日志记录器（嵌入式容器，Hibernate schema生成和整个的Spring框架）启用trace日志记录。</p><h4 id="彩色编码输出"><a href="#彩色编码输出" class="headerlink" title="彩色编码输出"></a>彩色编码输出</h4><p>如果终端支持ANSI，将会以彩色输出来帮助阅读。可以设置<code>spring.output.ansi.enabled</code>为一个受支持的值来覆盖自动探测。</p><p>使用<code>%clr</code>转换词来配置彩色编码。在它最简单的形式中，转换器将以日志级别来为输出涂色。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%clr(%5p)</span><br></pre></td></tr></table></figure><p>日志级别对应的颜色如下：</p><table><thead><tr><th>级别</th><th>颜色</th></tr></thead><tbody><tr><td><code>FATAL</code></td><td>Red</td></tr><tr><td><code>ERROR</code></td><td>Red</td></tr><tr><td><code>WARN</code></td><td>Yellow</td></tr><tr><td><code>INFO</code></td><td>Green</td></tr><tr><td><code>DEBUG</code></td><td>Green</td></tr><tr><td><code>TRACE</code></td><td>Green</td></tr></tbody></table><p>或者，可以指定应该使用的颜色或样式，以便将其作为转换的选项。例如，将文字的颜色变为黄色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;yellow&#125;</span><br></pre></td></tr></table></figure><p>支持下面的颜色和样式：</p><ul><li><code>blue</code></li><li><code>cyan</code></li><li><code>faint</code></li><li><code>green</code></li><li><code>magenta</code></li><li><code>red</code></li><li><code>yellow</code></li></ul><h3 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h3><p>Spring Boot 默认只会记录到控制台而不会记录到文件。如果还想记录到文件中需要设置<code>logging.file</code>或者<code>logging.path</code>属性值（例如在<code>application.properties</code>中）。</p><p>下面的表格指出了<code>logging.*</code>属性值是如何一起工作的：<br>日志属性</p><p><code>logging.file</code>|<code>logging.path</code>|示例|描述<br>–|–|–<br>（无）|（无）| |只在控制台记录日志<br>指定文件|（无）|<code>my.log</code>|记录到指定的日志文件。名称可以是一个绝对路径或者相对于现在的目录的路径<br>（无）|指定目录|<code>/var/log</code>|记录日志到指定目录中<code>spring.log</code>文件中。名称可以是绝对路径或者是相对现在目录的路径</p><p>当日志文件达到10MB 时将会被自动切分，并且同控制台输出一样，默认会将<code>ERROR</code>,<code>WARN</code>和<code>INFO</code>级别的日志记录下来。</p><blockquote><p>日志系统在应用的生命周期中初始化的时机比较早，因此不会发现通过<code>@propertySource</code>注解加载的文件中的这些日志属性。</p></blockquote><blockquote><p>日志属性与实际的日志实现相独立的。因此特定的配置属性（例如针对Logback的<code>logback.configurationFile</code>）不归Spring Boot管理。</p></blockquote><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>所有支持的日志系统都可以通过使用<code>logger.level.*=LEVEL</code>在Spring 环境（例如<code>application.properties</code>）中设置日志级别，这里的<code>LEVEL</code>是<code>TRACE</code>,<code>DEBUG</code>,<code>INFO</code>,<code>WARN</code>,<code>ERROR</code>,<code>FATAL</code>,<code>OFF</code>中其中之一。<code>root</code>记录器可以通过<code>logging.level.root</code>来配置。例如<code>application.properties</code>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">logging.level.root</span>=<span class="string">WARN</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.web</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate</span>=<span class="string">ERROR</span></span><br></pre></td></tr></table></figure><blockquote><p>Spring Boot默认会重新映射Thymeleaf <code>INFO</code>日志到<code>DEBUG</code>级别。这个有助于减少标准日志输出的干扰。想要知道如何在自己的配置中应用重新映射可以查看<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot/src/main/java/org/springframework/boot/logging/logback/LevelRemappingAppender.java"><code>LevelRemappingAppender</code></a>了解更多细节。</p></blockquote><h3 id="自定义日志配置"><a href="#自定义日志配置" class="headerlink" title="自定义日志配置"></a>自定义日志配置</h3><p>在classpath中加入适当的依赖包就可以激活不同的日志系统，并且root classpath中提供一个配置文件来进行深度自定义，或者在Spring的<code>Environment</code>中指定<code>logging.config</code>属性。</p><p>可以通过<code>org.springframework.boot.logging.LoggingSystem</code>系统属性来强制Spring Boot使用常规的日志系统。这个值应该是实现了<code>LoggingSystem</code>接口的类的全名称。也可以使用<code>none</code>值来完全禁用掉Spring Boot的日志配置。</p><blockquote><p>由于日志系统在<code>ApplicationContext</code>创建之前实例化，不可能通过Spring <code>@Configuration</code>文件中的<code>@PropertySources</code>来控制日志系统。系统属性和常规的Spring Boot扩展配置文件可以正常工作。</p></blockquote><p>根据日志系统的不同下面的配置文件将会被加载：</p><table><thead><tr><th>日志系统</th><th>自定义</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>,<code>logback-spring.groovy</code>,<code>logback.xml</code>或<code>logback.groovy</code></td></tr><tr><td>Log4j2</td><td><code>log4j2-spring.xml</code>或<code>log4j2.xml</code></td></tr><tr><td>JDK(Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table><blockquote><p>建议尽可能使用<code>-spring</code>变体日志配置文件（比如<code>logback-spring.xml</code>）而不是<code>logback.xml</code>。如果使用标准的配置位置，Spring无法完全控制日志初始化。</p></blockquote><blockquote><p>这里有一些关于Java Util Logging 已知的类加载问题，当使用“可执行jar包” 的时候可能引起问题。建议尽可能避免使用它。</p></blockquote><p>为了帮助自定义，下面是一些其他的从Spring <code>Environment</code>变量转换为系统属性的属性：</p><table><thead><tr><th>Spring Environment</th><th>系统属性</th><th>注释</th></tr></thead><tbody><tr><td><code>logging.exception-conversion-word</code></td><td><code>LOG_EXCEPTION_CONVERSION_WORD</code></td><td>当出现异常时使用的转换词</td></tr><tr><td><code>logging.file</code></td><td><code>LOG_FILE</code></td><td>如果定义了会用在默认的日志配置中</td></tr><tr><td><code>logging.path</code></td><td><code>LOG_PATH</code></td><td>如果定义了会用在默认的日志配置中</td></tr><tr><td><code>logging.pattern.console</code></td><td><code>CONSOLE_LOG_PATTERN</code></td><td>用在控制台中的日志格式（stdout）。（只支持默认的logback设置）</td></tr><tr><td><code>logging.pattern.file</code></td><td><code>FILE_LOG_PATTERN</code></td><td>日志文件中的日志格式（如果<code>LOG_FILE</code>启用了）。（只支持默认的logback设置）</td></tr><tr><td><code>logging.pattern.level</code></td><td><code>LOG_LEVEL_PATTERN</code></td><td>渲染日志级别的格式（默认为<code>%5p</code>）。（只支持默认的logback设置）</td></tr><tr><td><code>PID</code></td><td><code>PID</code></td><td>当前进程的ID（如果可能，并且还没有被定义为操作系统环境变量）</td></tr></tbody></table><p>所有支持的日志系统都可以在解析配置文件时参考系统属性。可以在<code>spring-boot.jar</code>的默认配置中找到例子。（类似的路径<code>spring-boot-2.0.0.BUILD-SNAPSHOT.jar\org\springframework\boot\logging\logback\defaults.xml</code>）</p><blockquote><p>如果想在日志属性中使用placeholder，可以使用<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-external-config-placeholders-in-properties">Spring Boot 的语法</a>而不是底层框架的语法。尤其是使用Logback时，需要使用<code>:</code>作为属性名和默认值之间的分隔符，而不是<code>:-</code>。</p></blockquote><blockquote><p>可以通过覆盖<code>LOG_LEVEL_PATTERN</code>（或<code>logging.pattern.level</code>）来添加MDC和其他专门的内容到日志行中。例如如果使用<code>logging.pattern.level=user:%X&#123;user&#125; %5p</code>，然后如果user存在的话默认的日志格式将会包含一个MDC user 实体，例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-09-30 12:30:04.031 user:juergen INFO 22174 --- [  nio-8080-exec-0] demo.Controller</span><br><span class="line">Handling authenticated request</span><br></pre></td></tr></table></figure><h3 id="Logback扩展"><a href="#Logback扩展" class="headerlink" title="Logback扩展"></a>Logback扩展</h3><p>Spring Boot包含许多对Logback的扩展，可以帮助高级配置。可以在<code>logback-spring.xml</code>文件中使用这些扩展。</p><blockquote><p>不能在标准的<code>logback.xml</code>文件中使用扩展，因为它加载的时机太早。要么使用<code>logback-spring.xml</code>或者定义<code>logging.config</code>属性。</p></blockquote><blockquote><p>这些扩展不能与Logback的<a href="http://logback.qos.ch/manual/configuration.html#autoScan">配置扫描</a>一起使用。如果尝试这么做，修改配置文件会引起下面的类似的问题：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]</span><br><span class="line">ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]]</span><br></pre></td></tr></table></figure><h4 id="特定Profile配置"><a href="#特定Profile配置" class="headerlink" title="特定Profile配置"></a>特定Profile配置</h4><p><code>&lt;springProfile&gt;</code>标签可以通过激活Spring profile来选择性地包含或排除配置块。Profile块在<code>&lt;configuration&gt;</code>元素中w任意位置都受支持。使用<code>name</code>属性来指定哪个profile 接受这个配置。通过逗号分隔的列表可以指定多个profile。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;staging&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev, staging&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;dev&quot; or &quot;staging&quot; profiles are active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;!production&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;production&quot; profile is not active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="环境属性"><a href="#环境属性" class="headerlink" title="环境属性"></a>环境属性</h4><p><code>&lt;pringProperty&gt;</code>标签可以从Spring环境中获得属性，以便在Logback中使用。如果你想在logback的配置中访问<code>application.properties</code>文件中的值这个功能会非常有用。这个标签的工作方式和Logback的标准<code>&lt;property&gt;</code>标签类似，但不是指定一个直接的值，你指定了属性的来源（从<code>Environment</code>中）。如果需要将属性存储在<code>local</code>范围以外的地方，那么可以使用scope属性。如果需要一个后备值以防这个属性没有在<code>Environment</code>中指定，可以使用<code>defaultValue</code>属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fluentHost&quot;</span> <span class="attr">source</span>=<span class="string">&quot;myapp.fluentd.host&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">defaultValue</span>=<span class="string">&quot;localhost&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FLUENT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.more.appenders.DataFluentAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remoteHost</span>&gt;</span>$&#123;fluentHost&#125;<span class="tag">&lt;/<span class="name">remoteHost</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>source</code>值必须通过使用短横线形式（<code>my.property-name</code>）。但是添加到<code>Environment</code>中的属性值可以使用松散绑定的规则。</p></blockquote><h2 id="开发web应用"><a href="#开发web应用" class="headerlink" title="开发web应用"></a>开发web应用</h2><p>Spring Boot非常适合用来开发web应用。通过嵌入的Tomcat，Jetty，Undertow或者Netty，可以轻松地创建一个自包含的HTTP服务器。大多数web应用可以通过使用<code>spring-boot-starter-web</code>模块来建立和快速启动。也可以选择通过<code>spring-boot-starter-webflux</code>模块来创建响应式web应用。</p><p>如果还没有开发过Spring Boot web应用于，可以跟着<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#getting-started-first-application">快速开始</a>章节中的例子学习。</p><h3 id="Spring-Web-MVC-框架"><a href="#Spring-Web-MVC-框架" class="headerlink" title="Spring Web MVC 框架"></a>Spring Web MVC 框架</h3><p>Spring WEB MVC 框架（经常简称为’Spring MVC’）是一个富”model view controller” web框架。Spring MVC 让你创建特殊的<code>@Controller</code>和<code>@RestController</code> bean 来处理到来的HTTP请求。controller中的方法通过<code>@RequestMapping</code>注解映射到HTTP。</p><p>下面是一个典型的产生JSON数据的<code>@RestController</code>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/&#123;user&#125;&quot;, method=RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/&#123;user&#125;/customers&quot;, method=RequestMethod.GET)</span></span><br><span class="line">    <span class="function">List&lt;Customer&gt; <span class="title">getUserCustomers</span><span class="params">(<span class="meta">@PathVariable</span> Long user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/&#123;user&#125;&quot;, method=RequestMethod.DELETE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Spring MVC 是Spring Framework核心的一部分，<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/web.html#mvc">查看详情</a>。这里有一些关于<a href="http://spring.io/guides">Spring MVC的指导</a>。</p><h4 id="Spring-MVC自动配置"><a href="#Spring-MVC自动配置" class="headerlink" title="Spring MVC自动配置"></a>Spring MVC自动配置</h4><p>Spring Boot为Spring MVC提供了自动配置功能，可以和大多数应用工作地很好。</p><p>Spring Boot自动配置在默认的基础上添加了以下功能：</p><ul><li>包括<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResoler</code> bean。</li><li>支持服务静态资源，包括支持WebJars。</li><li>自动注册<code>Converter</code>,<code>GenericConverter</code>,<code>Formatter</code> bean。</li><li><code>HttpMessageConverter</code>支持。</li><li>自动注册<code>MessageCodesResolver</code>。</li><li>静态<code>index.html</code>支持。</li><li>自定义<code>Favicon</code>支持。</li><li>自动使用<code>ConfigurableWebBindingInitializer</code> bean。</li></ul><p>如果想要保持Spring Boot MVC的功能，并且只想要添加额外的MVC 配置（interceptor, formatter, view controller等等），可以添加自己的类型为<code>WebMvcConfigurer</code>的<code>@Configuration</code>类，但是<strong>不要</strong>加<code>@EnableWebMvc</code>。如果希望提供自定义的<code>RequestMappingHandlerMapping</code>，<code>RequestMappingHandlerAdapter</code>或者<code>ExceptionHandlerExceptionResolver</code>实例,可以声明一个<code>WebMvcRegistrationsAdapter</code>实例，并且提供这些组件。</p><p>如果想要完全控制Spring MVC，可以添加自己的<code>@Configuration</code>类，并以<code>@EnableWebMvc</code>注解。</p><h4 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h4><p>Spring MVC 使用<code>HttpMessageConverter</code>接口来转换HTTP请求和响应。包括了一些合理的开箱即用的默认功能，例如Object可以自动转换为JSON（使用Jackson库）或者XML（如果可用的话使用Jackson XML扩展，否则使用JAXB）。String 默认使<code>用UTF-8</code>编码。</p><p>如果需要添加或者自定义converter可以使用Spring Boot 的<code>HttpMessageConverters</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.web.HttpMessageConverters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">customConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpMessageConverter&lt;?&gt; additional = ...</span><br><span class="line">        HttpMessageConverter&lt;?&gt; another = ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(additional, another);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何传递给context的<code>HttpMessageConverter</code> bean 都会添加到converter列表中。也可以通过这种方式覆盖缺省的converter。</p><h4 id="自定义JSON序列化和反序列化"><a href="#自定义JSON序列化和反序列化" class="headerlink" title="自定义JSON序列化和反序列化"></a>自定义JSON序列化和反序列化</h4><p>如果使用Jackson来序列化和反序列化JSON数据，可能想要编写自己的<code>JsonSerializer</code>和<code>JsonDeserializer</code>类。自定义serializer通常通过一个模块注册到Jackson，但是Spring Boot提供了一替代的<code>@jsoncomponent</code>注解，它使直接注册Spring bean变得更加容易。</p><p>可以直接在<code>JsonSerializer</code>或者<code>JsonDeserializer</code>实现类上使用<code>@JsonComponent</code>。也可以在包含内部serializers/deserializers类的类上使用。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.*;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.jackson.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Serializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">SomeObject</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">SomeObject</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationContext</code>中所有的<code>@JsonComponent</code> bean都将会自动注册到Jackson，并且由于<code>@JsonComponent</code>由<code>@Component</code>元注解注解，常规的组件扫描规则也将适用于这些组件。</p><p>Spring Boot也提供了<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java"><code>JsonObjectSerializer</code></a>和<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java"><code>JsonObjectDeserializer</code></a>基类，它们在序列化对象时为标准的Jackson版本提供了有用的替代方法。</p><h4 id="MessageCodesResolver"><a href="#MessageCodesResolver" class="headerlink" title="MessageCodesResolver"></a>MessageCodesResolver</h4><p>Spring MVC有一个用于生成错误代码的策略，用于从绑定错误中呈现错误消息：<code>MessageCodesResolver</code>。如果设置了<code>spring.mvc.message-codes-resolver.format</code>属性<code>PREFIX_ERROR_CODE</code>或者<code>POSTFIX-ERROR_CODE</code>（可以查看<code>DefaultMessageCodesResolver.Format</code>枚举），Spring Boot会为你创建一个。</p><h4 id="静态内容"><a href="#静态内容" class="headerlink" title="静态内容"></a>静态内容</h4><p>Spring Boot默认会在classpath中的<code>/static</code>(或<code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>)目录提供静态服务，或者从<code>ServlectContext</code>的根目录。它使用Spring MVC中的<code>ResourceHttpRequestHandler</code>因此可以通过添加自己的<code>WebMvcConfigurer</code>并且重载<code>addResourceHandlers</code>方法来修改它的行为。</p><p>在独立的web应用程序中，也启用了来自容器的默认servlet，并充当备用服务器，如果Spring决定不处理它，则从<code>ServletContext</code>的根中提供内容。大多数情况下，这种情况不会发生（除非修改了默认的MVC配置）因为Spring会一直可以通过<code>DispatcherServlet</code>来处理请求。</p><p>resource默认映射到<code>/**</code>，但是可以通过<code>spring.mvc.static-path-pattern</code>来调整。例如重定向所有的resource到<code>/resources/**</code>可以向下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.static-path-pattern&#x3D;&#x2F;resources&#x2F;**</span><br></pre></td></tr></table></figure><p>也可以通过<code>spring.resources.static-locations</code>（通过一个目录列表替换掉默认值）来自定义静态resource位置。如果这么做默认的欢迎页面侦测将会切换到自定义的位置，因此如果启动时在定义的位置中有任意的<code>index.html</code>，它将会是应用的主页。</p><p>除了上面的标准静态resource位置之外，<a href="http://www.webjars.org/">Webjar内容</a>是一个特殊的例子。任何<code>/webjars/**</code>路径的资源都将从jar文件中得到服务，如果它们被打包成webjar格式。</p><blockquote><p>如果应用会被打包成jar，不要使用<code>src/main/webapp</code>目录。尽管这个目录是一个公用的标准，但是它仅仅是在打包成war的时候生效，并且在生成jar时它会被大多数构建工具默默地忽略掉。</p></blockquote><p>Spring Boot 也支持Spring MVC提供的高级resource处理功能，允许使用诸如静态资源缓存破坏或使用Webjar的版本无关url。</p><p>要使用Webjar的版本无关url，添加<code>webjars-locator</code>依赖就可以了。然后申明Webjar，以jQuery举例，<code>“/webjars/jquery/dist/jquery.min.js”</code>会变成<code>“/webjars/jquery/x.y.z/dist/jquery.min.js”</code>，这里的<code>x.y.z</code>就是Webjar版本。</p><blockquote><p>如果使用的是JBoss，需要声明<code>sebjars-locator-jboss-vfs</code>依赖代替<code>webjars-locator</code>，否则所有的Webjars会解析为<code>404</code>。</p></blockquote><p>要使用缓存破坏，下面的配置将会为所有静态resource配置一个缓存破坏策略，有效地添加了一个hash值到URL中，例如<code>&lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&gt;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.chain.strategy.content.enabled&#x3D;true</span><br><span class="line">spring.resources.chain.strategy.content.paths&#x3D;&#x2F;**</span><br></pre></td></tr></table></figure><blockquote><p>自动配置了在运行时对Thymeleaf和FreeMarker模板中的资源链接重新编写，这得益于<code>ResourceUrlEncodingFilter</code>。当使用JSP时应该手动声明这个filter。其他的模板引擎目前还不能自动支持，但是可以使用自定义模板宏/helper，以及使用<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/javadoc-api/org/springframework/web/servlet/resource/ResourceUrlProvider.html"><code>ResourceUrlProvider</code></a>。</p></blockquote><p>当动态加载resource时，如JavaScript模块加载器，重命名文件不是一个选项。这也是为什么其他的策略依旧支持并且可以相互组合。“fixed” 策略将会在URL中添加一个静态的版本号，无需修改文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.chain.strategy.content.enabled&#x3D;true</span><br><span class="line">spring.resources.chain.strategy.content.paths&#x3D;&#x2F;**</span><br><span class="line">spring.resources.chain.strategy.fixed.enabled&#x3D;true</span><br><span class="line">spring.resources.chain.strategy.fixed.paths&#x3D;&#x2F;js&#x2F;lib&#x2F;</span><br><span class="line">spring.resources.chain.strategy.fixed.version&#x3D;v12</span><br></pre></td></tr></table></figure><p>在上面的配置中，JavaScript加载位于<code>&quot;/js/lib/&quot;</code>的模块时将会使用”fixed” 版本策略<code>&quot;/v12/js/lib/mymodule.js&quot;</code>，然而其他的resource将仍然使用<code>&lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&gt;</code>。</p><p>可以查看<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ResourceProperties.java"><code>ResourceProperties</code></a>了解更多支持的选项</p><blockquote><p>这个功能在这个专用的<a href="https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources">博客</a>和Spring Framework的<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/web.html#mvc-config-static-resources">文档</a>上有完整的说明。</p></blockquote><h4 id="自定义Favicon"><a href="#自定义Favicon" class="headerlink" title="自定义Favicon"></a>自定义Favicon</h4><p>Spring Boot在配置的静态内容位置和classpath根目录（按此顺序）中查找<code>favicon.ico</code>。如果找到了，将自动作为应用的favicon。</p><h4 id="ConfigurableWebBindingInitializer"><a href="#ConfigurableWebBindingInitializer" class="headerlink" title="ConfigurableWebBindingInitializer"></a>ConfigurableWebBindingInitializer</h4><p>Spring MVC使用<code>WebBindingInitializer</code>来为特殊请求初始化一个<code>WebDataBinder</code>。如果创建了自己的<code>ConfigurableWebBindingInitializer</code> <code>@Bean</code>，Spring Boot将自动配置Spring MVC使用它。</p><h4 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h4><p>跟REST服务一样，也可以使用Spring MVC来提供动态HTML内容。Spring MVC 支持一系列模板技术，包括Thymeleaf，FreeMarker和JSP。许多其他的模板引擎也发布了他们自己的Spring MVC集成方案。</p><p>Spring Boot包括针对以下模板引擎的自动配置功能：</p><ul><li><a href="http://freemarker.org/docs/">FreeMarker</a></li><li><a href="http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine">Groovy</a></li><li><a href="http://www.thymeleaf.org/">Thymeleaf</a></li><li><a href="http://mustache.github.io/">Mustache</a></li></ul><blockquote><p>有可能的话应该尽量避免使用JSP ，在使用嵌入式servlet容器时有一些<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-jsp-limitations">已知的限制</a>。</p></blockquote><p>当你在使用其中一种模板引擎并使用默认配置时，将会从<code>src/main/resources/templates</code>目录中自动发现模板。</p><blockquote><p>IntelliJ IDEA根据运行应用程序的方式不同classpath排序不一样。在IDE中通过main方法启动应用和使用Maven和Gradle或者打包的jar来运行会导致不同的顺序。这会导致Spring Boot在classpath中查找模板失败。如果你碰到了这个问题，可以在IDE中重新对classpath排序，将模块的class和resource放在首位。或者可以配置模板前缀来查找classpath中的每个模板目录：<code>classpath*:/templates/</code>。</p></blockquote><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>Spring Boot提供了一个默认的<code>/error</code>映射，以一种合理的方式处理所有错误，并且作为一个全局的错误页面注册到servlet容器中。对于机器客户端，它将生成一个JSON响应，其中包括错误的详细信息、HTTP状态和异常消息。对于浏览器客户端有一个“whitelabel”错误视图，它以HTML格式（或者添加一个<code>View</code>解析到<code>error</code>来自定义）呈现相同的数据。要完全替换掉默认的行为，可以实现<code>ErrorController</code>然后注册一个这种类型的bean定义，或者只需添加类型ErrorAttributes的bean，就可以使用现有的机制，但可以替换内容。</p><blockquote><p><code>BasicErrorController</code>可以用作自定义<code>ErrorController</code>的基类。当你需要添加一个handler来处理新的content type（默认专门处理<code>text/html</code>并为其他所有内容提供一个后路）时会非常有用。要达到这个目的只需要继承<code>BasicErrorController</code>然后添加一个拥有<code>produces</code>属性的<code>@RequestMapping</code>的公共方法，然后创建一个这个类型的bean。</p></blockquote><p>也可以定义一个<code>@ControllerAdvice</code>为特定的controller或者异常类型返回自定义的JSON内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(basePackageClasses = FooController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooControllerAdvice</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(YourException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) &#123;</span><br><span class="line">        HttpStatus status = getStatus(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> CustomErrorType(status.value(), ex.getMessage()), status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> HttpStatus <span class="title">getStatus</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Integer statusCode = (Integer) request.getAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (statusCode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HttpStatus.valueOf(statusCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，如果一个与<code>FooController</code>在同一个包中的Controller抛出<code>YourException</code>，那么将使用一个CustomerErrorType  POJO的json，而不是ErrorAttributes。</p><h5 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h5><p>如果要为给定的状态码显示自定义的HTML错误页面，可以在<code>/error</code>文件夹中添加一个文件。错误页面可以是静态HTML（例如在何意静态resource目录下添加的文件）或使用模板。文件名应该是确定的状态码或者一系列。</p><p>例如，将<code>404</code>映射到一个静态文件，文件夹结构应该像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src&#x2F;</span><br><span class="line"> +- main&#x2F;</span><br><span class="line">     +- java&#x2F;</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources&#x2F;</span><br><span class="line">         +- public&#x2F;</span><br><span class="line">             +- error&#x2F;</span><br><span class="line">             |   +- 404.html</span><br><span class="line">             +- &lt;other public assets&gt;</span><br></pre></td></tr></table></figure><p>要映射所有<code>5xx</code>的错误，并且使用FreeMarker模板，目录应该是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src&#x2F;</span><br><span class="line"> +- main&#x2F;</span><br><span class="line">     +- java&#x2F;</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources&#x2F;</span><br><span class="line">         +- templates&#x2F;</span><br><span class="line">             +- error&#x2F;</span><br><span class="line">             |   +- 5xx.ftl</span><br><span class="line">             +- &lt;other templates&gt;</span><br></pre></td></tr></table></figure><p>更复杂的映射可以添加实现了<code>ErrorViewResolver</code>接口的bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorViewResolver</span> <span class="keyword">implements</span> <span class="title">ErrorViewResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use the request or status to optionally return a ModelAndView</span></span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用常规的Spring MVC特性比如<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/web.html#mvc-exceptionhandlers"><code>@ExceptonHandler</code></a>方法和<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/web.html#mvc-ann-controller-advice"><code>@ControllerAdvice</code></a>。<code>ErrorController</code>会处理任何未处理的异常。</p><h5 id="在Spring-MVC之外映射错误页面"><a href="#在Spring-MVC之外映射错误页面" class="headerlink" title="在Spring MVC之外映射错误页面"></a>在Spring MVC之外映射错误页面</h5><p>对那些没有使用Spring MVC的应用，可以使用<code>ErrorPageRegister</code>接口来直接注册<code>ErrorPages</code>。这个抽象概念直接与底层的嵌入式servlet容器一起工作即使没有Spring MVC <code>DispatcherServlet</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ErrorPageRegistrar <span class="title">errorPageRegistrar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyErrorPageRegistrar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorPageRegistrar</span> <span class="keyword">implements</span> <span class="title">ErrorPageRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerErrorPages</span><span class="params">(ErrorPageRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.BAD_REQUEST, <span class="string">&quot;/400&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果注册的<code>ErrorPage</code>的路径被一个<code>Filter</code>处理而结束了（比如和一些非Spring的web框架一样，比如Jersey和Wicket），然后这个<code>Filter</code>必须得明确地注册为<code>ERROR</code> dispatcher。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    registration.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">    ...</span><br><span class="line">    registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(默认<code>FilterRegistrationBean</code> 不包含<code>ERROR</code> dispatcher类型)。</p><h5 id="WebSphere-应用服务器中错误处理"><a href="#WebSphere-应用服务器中错误处理" class="headerlink" title="WebSphere 应用服务器中错误处理"></a>WebSphere 应用服务器中错误处理</h5><p>当部署到一个servlet容器时，Spring Boot使用它的错误页面过滤器来转发请求到适当的错误页面，并携带错误码。如果response还没有提交，这个请求只能转发到正确的错误页面。WebSphere 8.0或者以上版本默认会根据正确完成servlet的service方法来提交response。应该设置<code>com.ibm.ws.webcontainer.invokeFlushAfterService</code>为<code>false</code>来禁止这个行为。</p><h4 id="Spring-HATEOAS"><a href="#Spring-HATEOAS" class="headerlink" title="Spring HATEOAS"></a>Spring HATEOAS</h4><p>如果正在开发的RESTful API 使用多媒体，Spring Boot 为Spring HATEOAS提供了自动配置，能够与大多数应用一起工作。自动配置替换了使用<code>@EnableHypermediaSupport</code>的必要性并且注册了一些bean使构建多媒体应用变得简单，这些bean包括一个<code>LinkDiscoverers</code>(为了应用端支持)和一个为了正确整理response到需要的表现形式而配置的<code>ObjectMapper</code>。这个<code>ObjectMapper</code>将基于<code>spring.jackson.*</code>属性或者可能存在的<code>Jackson2ObjectMapperBuilder</code> bean 进行自定义。</p><p>可以通过使用<code>@EnableHypermediaSupport</code>来控制Spring HATEOAS的配置。要注意的是这将会禁用上面提到的<code>ObjectMapper</code>自定义。</p><h4 id="CORS支持"><a href="#CORS支持" class="headerlink" title="CORS支持"></a>CORS支持</h4><p><a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">跨域资源共享</a>是一被大多数浏览器实现的W3C标准，它允许你以一种灵活的方式来指定哪种类型的跨域请求是被授权的，代替使用一些不安全和不强大的方式比如IFRAME 和JSONP。</p><p>从4.2开始，Spring MVC<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/web.html#cors">跨域支持</a>开箱即用。在Spring Boot应用中与<code>@CrossOrigin</code>注解一起使用<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/web.html#controller-method-cors-configuration">controller方法CORS配置</a>不需要使用任何特定的配置。可以通过注册拥有一个自定义的<code>addCorsMappings(CorsRegistry)</code>的WebMvcConfigurer` bean 来定义<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/web.html#global-cors-configuration">全局的CORS配置</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">corsConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addMapping(<span class="string">&quot;/api/**&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-WebFlux框架"><a href="#Spring-WebFlux框架" class="headerlink" title="Spring WebFlux框架"></a>Spring WebFlux框架</h3><h4 id="Spring-WebFlux自动配置"><a href="#Spring-WebFlux自动配置" class="headerlink" title="Spring WebFlux自动配置"></a>Spring WebFlux自动配置</h4><h4 id="HttpMessageReaders-和-HttpMessageWriters-HTTP编码"><a href="#HttpMessageReaders-和-HttpMessageWriters-HTTP编码" class="headerlink" title="HttpMessageReaders 和 HttpMessageWriters HTTP编码"></a>HttpMessageReaders 和 HttpMessageWriters HTTP编码</h4><h4 id="静态内容-1"><a href="#静态内容-1" class="headerlink" title="静态内容"></a>静态内容</h4><h4 id="模板引擎-1"><a href="#模板引擎-1" class="headerlink" title="模板引擎"></a>模板引擎</h4><h3 id="JAX-RS-和Jersey"><a href="#JAX-RS-和Jersey" class="headerlink" title="JAX-RS 和Jersey"></a>JAX-RS 和Jersey</h3><p>如果你更喜欢REST端点的jax-rs编程模型，可以使用一个可用的实现来代替Spring MVC。Jersey 1.x和 Apache CXF在将他们的<code>Servlet</code>和<code>Filter</code>作为<code>@Bean</code>注册到应用上下文中的情况下就已经工作的很好了。Jersey 2.x有一些本地Spring支持，所以我们也在Spring Boot 中通过一个starter 提供了自动配置支持。</p><p>开始开发Jersey 2.x只需要添加<code>spring-boot-starter-jersey</code>依赖然后写一个<code>ResourceConfig</code>类型的<code>@Bean</code>并在这里注册所有的端点就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JerseyConfig</span> <span class="keyword">extends</span> <span class="title">ResourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JerseyConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        register(Endpoint.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Jersey对扫描可执行档案的支持是相当有限的。例如在运行一个可执行的war包时它不能扫描<code>WEB-INF/classes</code>目录的包中发现的endpoint。为了避免这个限制，不应该使用<code>packages</code>方法并且endpoint应该像上面一样通过<code>register</code>方法单独注册。</p><p>也可以注册任意数量的实现<code>ResourceConfigCustomizer</code>接口的bean来进行更高级的自定义。</p><p>所有注册的endpoint都应该有<code>@Component</code>和HTTP resource注解（如<code>@GET</code>）,例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Path(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Endpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>Endpoint</code>是一个Spring <code>@Component</code>，因此它的生命周期由Spring来管理，并且你可以<code>@Autowired</code> 依赖并且通过<code>@Value</code>注入外部的配置。Jersey servlet默认会注册并映射到<code>/*</code>。可以通过添加<code>@ApplicationPath</code>到<code>ResourceConfig</code>修改这个映射。</p><p>Jersey默认将会作为<code>@ServletRegistrationBean</code>类型的<code>@Bean</code>中的一个Servlet，这个<code>@ServletRegistrationBean</code>名称为<code>jerseyServletRegistration</code>。默认情况下这个servlet会延迟初始化，但是你可以通过<code>spring.jersey.servlet.load-on-startup</code>来自定义。可以创建一个自己的相同名称的bean来禁用或者覆盖这个bean。也可以使用一个Filter通过设置<code>spring.jersey.type=filter</code>来代替这个Servlet（在这种情况下，要替换或覆盖的@Bean是<code>jerseyFilterRegistration</code>）。这个servlet有个<code>@Order</code>注解，可以通过<code>spring.jersey.filter.order</code>来设置。注册Servlet和Filter可以给定初始化参数，使用<code>spring.jersey.init.*</code>来指定一个属性map。</p><p>这里有一个<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-jersey">Jersey例子</a>可以看到如何设置。还有一个<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-jersey1">Jersey 1.x 例子</a>。注意在Jersey 1.x例子中spring-boot maven插件配置了不打包某些Jersey的jar，这样他们可以被JAX-RS的实现扫描到（因为这个例子要求在Filter注册中对它们进行扫描）。如果你有任何JAX-RS resource打包成了内部jar时，可能也需要这么做。</p><h3 id="嵌入式servlet容器支持"><a href="#嵌入式servlet容器支持" class="headerlink" title="嵌入式servlet容器支持"></a>嵌入式servlet容器支持</h3><p>Spring Boot 支持嵌入式Tomcat，Jetty，Undertow服务器。大多数开发者只需要使用对应的”Starter”来获取完整配置的实例。嵌入式服务器默认会在<code>8080</code>端口监听HTTP请求。</p><blockquote><p>如果你选择在CentOS上使用Tomcat则要注意，默认情况下会使用一个临时目录来存储编绎的JSP和上传的文件等。当你的应用程序运行导致失败时，该目录有可能被<code>tmpwatch</code>删除。要避免这样你可能想要自定义<code>tmpwatch</code>配置，这样<code>tomcat.*</code>目录不会删除，或者配置<code>server.tomcat.basedir</code>这样的话嵌入式Tomcat会使用不同的目录。</p></blockquote><h4 id="Servlet，Filter和listerner"><a href="#Servlet，Filter和listerner" class="headerlink" title="Servlet，Filter和listerner"></a>Servlet，Filter和listerner</h4><p>当使用嵌入式servlet容器时既可以使用Spring Bean又可以扫描Servlet组件来注册Servlet，Filter和来自servlet规范的所有listener（例如<code>HttpSessionListener</code>）。</p><h4 id="Servlet上下文初始化"><a href="#Servlet上下文初始化" class="headerlink" title="Servlet上下文初始化"></a>Servlet上下文初始化</h4><p>任何一个Spring bean的的<code>Servlet</code>，<code>Filter</code>或者Serlvet<code>*Listener</code>的实例都将在嵌入式容器中注册。如果想从<code>application.properties</code>中引用一个值，这将非常方便。</p><p>默认情况下如果context只包含一个Servlet，它将会映射到<code>/</code>。在有多个Servlet Bean的情况下，bean的名称将会作为path的前缀。Filter会映射到<code>/*</code>。如果基于约定的映射不足够灵活,可以使用<code>ServletRegistrationBean</code>,<code>FilterRegistrationBean</code>和<code>ServletListenerRegistrationBean</code>类来完全控制。</p><h4 id="ServletWebServerApplicationContext"><a href="#ServletWebServerApplicationContext" class="headerlink" title="ServletWebServerApplicationContext"></a>ServletWebServerApplicationContext</h4><p>嵌入式servlet容器不会直接执行Servlet 3.0以上的<code>javax.servlet.ServletContainerInitializer</code>接口，或者是Spring的<code>org.springframework.web.WebApplicationInitializer</code>接口。这是一个刻意的设计，目的是为了减少在war中运行的第三方库会破坏Spring Boot应用程序的风险。</p><p>如果你需要在Spring Boot应用中执行servlet上下文初始化，需要注册一个实现了<code>org.springframework.boot.web.servlet.ServletContextInitializer</code>接口的bean。唯一的<code>onStartup</code>方法提供了访问<code>ServletContext</code>的能力，并且可以在必要的情况下轻松地用来作为已知<code>WebApplicationInitializer</code>的桥接器。</p><h5 id="扫描Servlet，Filter和lisenter"><a href="#扫描Servlet，Filter和lisenter" class="headerlink" title="扫描Servlet，Filter和lisenter"></a>扫描Servlet，Filter和lisenter</h5><p>当使用嵌入式容器时，可以使用<code>@ServletComponentScan</code>来启用对注解了<code>@WebServlet</code>，<code>@WebFilter</code>和<code>@WebListener</code>类进行自动注册。</p><blockquote><p><code>@ServletComponentScan</code>在独立容器中时没有效果，在这里将会使用容器的自有发现机制。</p></blockquote><h4 id="ServletWebServerApplicatonContext"><a href="#ServletWebServerApplicatonContext" class="headerlink" title="ServletWebServerApplicatonContext"></a>ServletWebServerApplicatonContext</h4><p>Spring Boot为嵌入式容器支持使用了一个新的<code>ApplicationContext</code>类型。<code>ServletWebServerApplicationContext</code>是一个专门的<code>WebApplicationContext</code>类型，通过搜索一个单独的<code>ServletWebServerFactory</code> bean来引导自己。通常是一个<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>或者是<code>UndertowServletWebServerFactory</code>将被自动配置。</p><blockquote><p>通常不需要感知这些实现类。大多数应用会自动配置并且将为你创建合适的<code>ApplicationContext</code>和<code>ServletWebServerFactory</code>。</p></blockquote><h4 id="自定义嵌入式servlet容器"><a href="#自定义嵌入式servlet容器" class="headerlink" title="自定义嵌入式servlet容器"></a>自定义嵌入式servlet容器</h4><p>可以通过使用Spring <code>Environment</code>属性来配置常见的servlet容器设置。通常你将在<code>application.properties</code>文件中定义这些属性。</p><p>常见的服务器设置包括：</p><ul><li>网络设置：侦听HTTP请求的端口（<code>server.port</code>），接口地址绑定到<code>server.address</code>等等。</li><li>Session设置：session是否执久化（<code>server.session.persistence</code>），session超时时间（<code>server.session.timeout</code>），session数据的位置（<code>server.session.store-dir</code>）和session-cookie配置（<code>server.session.cookie.*</code>）。</li><li>错误管理：错误页面的位置（<code>server.error.path</code>）等。</li><li><a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-configure-ssl">SSL</a></li><li><a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#how-to-enable-http-response-compression">HTTP压缩</a></li></ul><p>Spring Boot尽可能多地暴露通用设置，但这并不总是可行的。对于那些情况下，专用的命名空间提供特定服务器的自定义（查看<code>server.tomcat</code>和<code>server.undertow</code>）。例如可以使用嵌入式servlet容器的特定功能配置<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-configure-accesslogs">访问日志</a>。</p><blockquote><p>查看<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java"><code>ServerProperties</code></a>类获取详细清单。</p></blockquote><h5 id="编程式自定义"><a href="#编程式自定义" class="headerlink" title="编程式自定义"></a>编程式自定义</h5><p>如果需要通过编程来自定义嵌入式servlet容器，可以注册一个实现了<code>WebServerFactoryCustomizer</code> 接口的Spring bean。<code>WebServerFactoryCustomizer</code>提供了访问<code>ConfigurableServletWebServerFactory</code>的方法，<code>ConfigurableServletWebServerFactory</code>包含了大量定制setter方法。在Tomcat，Jetty和Undertow中存在专门的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.WebServerFactoryCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationBean</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableServletWebServerFactory server)</span> </span>&#123;</span><br><span class="line">        server.setPort(<span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="直接自定义ConfigurableServletWebServerFactory"><a href="#直接自定义ConfigurableServletWebServerFactory" class="headerlink" title="直接自定义ConfigurableServletWebServerFactory"></a>直接自定义ConfigurableServletWebServerFactory</h5><p>如果上面的自定义方式太局限，可以注册自己的<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>，<code>UndertowServletWebServerFactory</code> bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableServletWebServerFactory <span class="title">webServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TomcatServletWebServerFactory factory = <span class="keyword">new</span> TomcatServletWebServerFactory();</span><br><span class="line">    factory.setPort(<span class="number">9000</span>);</span><br><span class="line">    factory.setSessionTimeout(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    factory.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="string">&quot;/notfound.html&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set方法提供了许多配置选项。如果你需要做一些更独特的事情，还提供了几个受保护的方法“钩子”。更多详情请查看源代码文档。</p><h4 id="JSP限制"><a href="#JSP限制" class="headerlink" title="JSP限制"></a>JSP限制</h4><p>当使用嵌入式servlet容器（并且被打包成可执行包）运行Spring Boot应用时，对JSP的支持有一些限制。</p><ul><li>对于Tomcat，如果使用war包，它就可以工作，即可执行的war将工作，并且也可以部署到一个标准容器(不限于，但包括Tomcat）。一个可执行的jar不能工作，因为在Tomcat中有一个硬编码的文件模式。</li><li>对于Jetty，如果使用war包，它就可以工作，即可执行的war将工作，并且也可以部署到一个标准容器。</li><li>Undertow不支持JSP。</li><li>创建自定义的<code>error.jsp</code>页面不会覆盖默认的<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-error-handling">错误处理</a>视图，而是应该使用自定义错误页面。</li></ul><p>这里有一个<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-web-jsp">JSP例子</a>可以看到如何设置。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>如果在classpath中发现了Spring Security，那么web应用所有的HTTP端点会默认使用”basic”认证。可以添加<code>@EnableGlobalMethodSecurity</code>来添加方法级别的安全。更多信息可以查看<a href="http://docs.spring.io/spring-security/site/docs/5.0.0.BUILD-SNAPSHOT/reference/htmlsingle#jc-method">Spring Security Reference</a>。</p><p>默认的<code>AuthenticationManager</code>有一个单独的用户（“user” 用户名和随机密码，密码在应用程序启动时打印在INFO级别）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Using default security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35</span><br></pre></td></tr></table></figure><blockquote><p>如果你调整了日志配置，确保<code>org.springframework.boot.autoconfigure.security</code>类型设置为<code>INFO</code>级别，否则默认密码不会打印。</p></blockquote><p>可以通过提供<code>security.user.password</code>属性来修改密码。这个和其他有用的属性通过<code>SecurityProperties</code>（属性前缀为”security”）扩展。</p><h3 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h3><h4 id="授权服务器"><a href="#授权服务器" class="headerlink" title="授权服务器"></a>授权服务器</h4><h4 id="资源服务器"><a href="#资源服务器" class="headerlink" title="资源服务器"></a>资源服务器</h4><h3 id="User信息中的Token类型"><a href="#User信息中的Token类型" class="headerlink" title="User信息中的Token类型"></a>User信息中的Token类型</h3><h3 id="自定义User信息-RestTemplate"><a href="#自定义User信息-RestTemplate" class="headerlink" title="自定义User信息 RestTemplate"></a>自定义User信息 RestTemplate</h3><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><h4 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h4><h3 id="Actuator-安全"><a href="#Actuator-安全" class="headerlink" title="Actuator 安全"></a>Actuator 安全</h3><h2 id="SQL数据库"><a href="#SQL数据库" class="headerlink" title="SQL数据库"></a>SQL数据库</h2><p>Spring Framework对SQL数据库提供了大量支持。从使用<code>JdbcTemplate</code>直接的JDBC访问到完全的“对象关系映射”技术如Hibernate。Spring Data提供了额外的功能级别，直接从接口创建<code>Repository</code>实现，并使用约定从方法名称生成查询。</p><h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><p>Java的<code>javax.sql.DataSource</code>接口提供了与数据库连接工作的标准方法。传统上，数据源使用<code>URL</code>和一些凭证来建立数据库连接。</p><blockquote><p>还可以查看<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-configure-a-datasource">“如何操作”</a>的部分，以获得更高级的示例，尤其是要对数据源的配置进行完全控制。</p></blockquote><h4 id="嵌入式数据库支持"><a href="#嵌入式数据库支持" class="headerlink" title="嵌入式数据库支持"></a>嵌入式数据库支持</h4><p>使用内存中嵌入式数据库开发应用程序通常很方便。明显地内存数据库不提供持久化；你需要当应用程序启动时填充数据库，并准备在应用程序结束时抛出数据。</p><blockquote><p>这里有<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-database-initialization">如何初始化数据库</a>。</p></blockquote><p>Spring Boot可以自动配置嵌入式<a href="http://www.h2database.com/">H2</a>，<a href="http://hsqldb.org/">HSQL</a>和<a href="http://db.apache.org/derby/">Derby</a>数据库。不需要提供任何连接URL，只需要简单地包含想要使用的嵌入式数据库的构建依赖。</p><blockquote><p>如果在测试用例中使用这个功能，你可能注意到了整个测试用命重用了相同的数据库，而不管使用了多少个应用上下文。如果你想确保每个上下文使用独立的嵌入式数据库，你应该设置<code>spring.datasource.generate-unique-name</code>为<code>true</code>。</p></blockquote><p>例如典型的POM依赖是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>需要对spring jdbc的依赖，以便自动配置嵌入式数据库。在这个例子中它通过<code>spring-boot-starter-data-jpa</code>来传递这个依赖。</p></blockquote><blockquote><p>如果出于某种原因，你确实为嵌入式数据库配置了连接URL，那么应该注意确保数据库的自动关闭是禁用的。如果你正在使用H2，你应该使用<code>DB_CLOSE_ON_EXIT=FALSE</code>来禁用。如果使用HSQLDB，应该确保没有使用<code>shutdown=true</code>。禁用数据库的自动关闭功能可以让Spring Boot在数据库关闭时进行控制，从而确保在不再需要访问数据库时发生这种情况。</p></blockquote><h4 id="连接生产库"><a href="#连接生产库" class="headerlink" title="连接生产库"></a>连接生产库</h4><p>还可以使用<code>DataSource</code>池自动配置生产数据库连接。下面是选择具体实现的算法：</p><ul><li>我们更喜欢HikariCP因为它的性能和并发性，所以如果它可用，我们总是选择它。</li><li>否则如果Tomcat<code>DataSource</code>连接池可用，就会使用它。</li><li>HikariCP 和Tomcat<code>DataSource</code>连接池都不可用并且 Commons DBCP2可用则使用它。</li></ul><p>如果你使用<code>spring-boot-starter-jdbc</code>或者<code>spring-boot-starter-data-jpa</code> “starter” 则会自动依赖<code>HikariCP</code>。</p><blockquote><p>可以通过设置<code>spring.datasource.type</code>属性来完全绕开这个算法并且指定连接池。如果你在Tomcat容器中运行你的应用程序，那么这一点尤为重要，因为默认提供了<code>tomcat-jdbc</code>。</p></blockquote><blockquote><p>可以手动配置额外的连接池。如果你定义了自己的<code>DataSource</code> bean，则不会发生自动配置。</p></blockquote><p><code>spring.datasource.*</code>中的扩展配置属性可以控制数据源配置。例如，你可以在<code>application.properties</code>中声明以下块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;test</span><br><span class="line">spring.datasource.username&#x3D;dbuser</span><br><span class="line">spring.datasource.password&#x3D;dbpass</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><blockquote><p>你至少应该使用<code>spring.datasource.url</code>属性来指定url或者Sprig Boot 会尝试自动配置一个嵌入式数据库。</p></blockquote><blockquote><p>你通常不需要指定<code>driver-class-name</code>，因为对于大多数数据库Spring boot 可以从url中推断出来。</p></blockquote><blockquote><p>对于创建<code>DataSource</code>池，我们需要能够验证一个有效的<code>Driver</code>类是否可用，所以我们在做任何事情之前都要检查它。例如，如果你设了<code>spring.datasource.driver-class-name=com.mysql.jdbc</code>,那么这个类就必须是可加载的。</p></blockquote><p>更多受支持的选项，请参见<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java"><code>DataSourceProperties</code></a>。这些是标准的选项，不管实际是什么实现都可以工作。也可以通过它们各自的前缀（<code>spring.datasource.hikari.*</code>,<code>spring.datasource.tomcat.*</code>，和<code>spring.datasource.dbcp2.*</code>）微调特定实现设置。请参阅你正在使用的连接池实现的文档获取更多细节。</p><p>例如如果你正在使用<a href="http://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html#Common_Attributes">Tomcat连接池</a>，可以自定义许多额外的设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Number of ms to wait before throwing an exception if no connection is available.</span><br><span class="line">spring.datasource.tomcat.max-wait&#x3D;10000</span><br><span class="line"></span><br><span class="line"># Maximum number of active connections that can be allocated from this pool at the same time.</span><br><span class="line">spring.datasource.tomcat.max-active&#x3D;50</span><br><span class="line"></span><br><span class="line"># Validate the connection before borrowing it from the pool.</span><br><span class="line">spring.datasource.tomcat.test-on-borrow&#x3D;true</span><br></pre></td></tr></table></figure><h4 id="连接JNDI数据库"><a href="#连接JNDI数据库" class="headerlink" title="连接JNDI数据库"></a>连接JNDI数据库</h4><p>如果你正在将Spring Boot应用程序部署到应用程序服务器，那么你可能需要使用应用程序服务器的内置特性来配置和管理数据源，并使用JNDI访问它。</p><p><code>spring.datasource.jndi-name</code>属性可以用作<code>spring.datasource.url</code>,<code>spring.datasource.username</code>和<code>spring.datasource.password</code>属性的另一种选择从特定的JNDI位置访问<code>DataSource</code>。例如下面<code>applicaion.properties</code>中的块展示了如何访问JBoss定义的<code>DataSource</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.jndi-name&#x3D;java:jboss&#x2F;datasources&#x2F;customers</span><br></pre></td></tr></table></figure><h3 id="使用JdbcTemplate"><a href="#使用JdbcTemplate" class="headerlink" title="使用JdbcTemplate"></a>使用JdbcTemplate</h3><p>Spring 的<code>JdbcTemplate</code>和<code>NamedParameterJdbcTemplate</code>类是自动配置的并且可以直接<code>@Autowire</code>他们到你自己的bean中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你可以通过<code>spring.jdbc.template.*</code>来自定义template的一些属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jdbc.template.max-rows&#x3D;500</span><br></pre></td></tr></table></figure><blockquote><p>NamedParameterJdbcTemplate在背后重用相同的JdbcTemplate实例。如果定义了多个<code>JdbcTemplate</code>并且不存在主要的候选者，不会自动配置<code>NamedParameterJdbcTemplate</code>。</p></blockquote><h3 id="JPA和Spring-Data"><a href="#JPA和Spring-Data" class="headerlink" title="JPA和Spring Data"></a>JPA和Spring Data</h3><p>Java Persistence API 是一种允许你映射对象到关系型数据的技术。<code>spring-boot-starter-data-jpa</code> POM提供了一种快速开始的方式。它提供了下面关键的依赖：</p><ul><li>Hibernate - 最流行的JPA实现之一</li><li>Spring Data JPA - 使实现基于JPA的repositories变得容易</li><li>Spring ORM - Spring Framework的核心ORM支持</li></ul><blockquote><p>在这里不涉及到太多JPA和Spring Data细节。可以访问<a href="http://spring.io/guides/gs/accessing-data-jpa/">Accessing Data with JPA</a>指南和阅读<a href="http://spring.io/guides/gs/accessing-data-jpa/">Spring Data JPA</a>和<a href="http://hibernate.org/orm/documentation/">Hibernate </a>文档。</p></blockquote><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><p>传统上，JPA “Entity”的类是在<code>persistence.xml</code>文件中指定的。在Spring Boot 中这个文件不是必需的，而是使用“Entity Scanning”。默认情况下在主配置类（某个注解了<code>@EnableAutoConfiguration</code> 或<code>@SpringBootApplication</code>的类）下面的所有包都会被搜索到。</p><p>任何注解了<code>@Entity</code>,<code>@Embeddable</code>或<code>@MappedSuperclass</code>的类都是被考虑的对象。一个典型的实体类应该是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... additional members, often include @OneToMany mappings</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">City</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// no-args constructor required by JPA spec</span></span><br><span class="line">        <span class="comment">// this one is protected since it shouldn&#x27;t be used directly</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">City</span><span class="params">(String name, String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.country = country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... etc</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>可以使用<code>@EntityScan</code>注解来自定义扫描位置。更多查看<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-separate-entity-definitions-from-spring-configuration">Section 78.4, “Separate @Entity definitions from Spring configuration” </a></p></blockquote><h4 id="Spring-Data-JPA仓库"><a href="#Spring-Data-JPA仓库" class="headerlink" title="Spring Data JPA仓库"></a>Spring Data JPA仓库</h4><p>Spring Data JPA repository是你可以定义来访问数据的接口。JPA查询会从你的方法名自动创建查询。例如，<code>CityRepository</code>接口可能声明了<code>findAllByState(String state)</code>方法来根据给定状态查找所有的城市。</p><p>对于更复杂的查询你可以使用Spring Data的<code>Query</code>注解来注解你的方法。</p><p>Spring Data repository通常继承自<code>Repository</code>或者<code>CrudRepository</code>接口。如果使用自动配置，将会从包含主配置类（注解了<code>@EnableAutoConfiguration</code>或<code>@SpringBooApplication</code>的类）的包中往下查找repository。</p><p>这里有一个典型的Spring Data repository：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Page&lt;City&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">City <span class="title">findByNameAndCountryAllIgnoringCase</span><span class="params">(String name, String country)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们仅仅触及Spring Data JPA的表面。可以查看<a href="http://projects.spring.io/spring-data-jpa/">文档</a>获取完整的细节。</p></blockquote><h4 id="创建和删除JPA数据库"><a href="#创建和删除JPA数据库" class="headerlink" title="创建和删除JPA数据库"></a>创建和删除JPA数据库</h4><p>默认情况下，JPA数据库<strong>只</strong>在使用嵌入式数据库（H2,HSQL或Derby）时才会自动创建。你也可以使用<code>spring.jpa.*</code>属性明确地配置JPA<code>。例如可以在</code>application.properties`中添加下面的配置来创建和删除表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.hibernate.ddl-auto&#x3D;create-drop</span><br></pre></td></tr></table></figure><blockquote><p>Hibernate自有内部属性名称是<code>hibernate.hbm2ddl.auto</code>（如果你能记住它更好）。你可以和其他Hibernate原生属性一样设置它，使用<code>spring.jpa.properties.*</code>（这个前缀在添加到entity manager之前被剥离出来）。例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.properties.hibernate.globally_quoted_identifiers&#x3D;true</span><br></pre></td></tr></table></figure><p>传给Hibernate entity manager的是<code>hiberbate.globally_quoted_identifiers</code>。</p><p>默认情况下DDL执行（或验证）推迟到<code>ApplicationContext</code>启动之后。还有一个<code>spring.jpa.generate-ddl</code>标志，但是在Hibernate autoconfig启用的情况下不会使用因为<code>ddl-auto</code>设置更细粒度。</p><h4 id="在View中打开EntityManager"><a href="#在View中打开EntityManager" class="headerlink" title="在View中打开EntityManager"></a>在View中打开EntityManager</h4><p>如果正在运行一个web应用，Spring Boot默认会注册<code>OpenEntityManageerInViewInterceptor</code>来应用“Open EntityManager in View” 模式，例如来在web视图允许延迟加载。如果你不想要这种行为，你应用在<code>applicaiont.properties</code>中设置<code>spring.jpa.open-in-view</code>来<code>false</code>。</p><h3 id="使用H2的web控制台"><a href="#使用H2的web控制台" class="headerlink" title="使用H2的web控制台"></a>使用H2的web控制台</h3><h4 id="修改H2控制台的路径"><a href="#修改H2控制台的路径" class="headerlink" title="修改H2控制台的路径"></a>修改H2控制台的路径</h4><h4 id="加密H2的控制台"><a href="#加密H2的控制台" class="headerlink" title="加密H2的控制台"></a>加密H2的控制台</h4><h3 id="使用jOOQ"><a href="#使用jOOQ" class="headerlink" title="使用jOOQ"></a>使用jOOQ</h3><h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><h4 id="使用DSLContext"><a href="#使用DSLContext" class="headerlink" title="使用DSLContext"></a>使用DSLContext</h4><h4 id="jOOQ-SQL方言"><a href="#jOOQ-SQL方言" class="headerlink" title="jOOQ SQL方言"></a>jOOQ SQL方言</h4><h4 id="自定义jOOQ"><a href="#自定义jOOQ" class="headerlink" title="自定义jOOQ"></a>自定义jOOQ</h4><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><p>Spring Data提供额外的项目来帮助你访问一些NoSQL技术，包括<a href="http://projects.spring.io/spring-data-mongodb/">MongoDB</a>，<a href="http://projects.spring.io/spring-data-neo4j/">Neo4J</a>，<a href="https://github.com/spring-projects/spring-data-elasticsearch/">Elasticsearch</a>，<a href="http://projects.spring.io/spring-data-solr/">Solr</a>，<a href="http://projects.spring.io/spring-data-redis/">Redis</a>，<a href="http://projects.spring.io/spring-data-gemfire/">Gemfire</a>，<a href="http://projects.spring.io/spring-data-cassandra/">Cassandra</a>，<a href="http://projects.spring.io/spring-data-couchbase/">Couchbase</a>和<a href="http://projects.spring.io/spring-data-ldap/">LDAP</a>。Spring Boot 对Redis，MongoDB，Neo4j，Elastcisearch，Solr，Cassandra，Couchbase和LDAP提供了自动配置；你可以使用其他项目，但是你需要自己配置它们。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis 是一个缓存，消息代理和功能丰富的键值存储。Spring Boot为<a href="https://github.com/xetorthio/jedis/">Jedis</a> 和<a href="https://github.com/mp911de/lettuce/">Lettuce</a> 客户端库提供基本的自动配置并由Spring Data Redis在它们之上提供抽象。</p><p>默认有一个<code>spring-boot-starter-data-redis</code> “Starter” 以方便的方式收集依赖并且默认使用 <a href="https://github.com/xetorthio/jedis/">Jedis</a>。如果你正在构建一个响应式应用程序，那么<code>spring-stardata-data-redis-reactive</code> “Starter” 将会让你继续前进。</p><h4 id="连接到Redis"><a href="#连接到Redis" class="headerlink" title="连接到Redis"></a>连接到Redis</h4><p>你可以像任何其他Spring Bean一样注入自动配置的<code>RedisConnectionFactory</code>，<code>StringRedisTemplate</code>或者<code>RedisTemplate</code> 实例。默认情况下这些实例会尝试使用<code>localhost:6379</code>来连接到Redis 服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(StringRedisTemplate template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>你也可以注册任意数量的实现<code>JedisClientConfigurationBuilderCustomizer</code> 的bean 来实现更高级的定制。如果你正在使用Lettuce，可以使用<code>LettuceClientConfigurationBuilderCustomizer</code>。</p></blockquote><p>如果你在任何自己的自动配置类型上加了<code>@Bean</code>，它会替代默认的（除了在RedisTemplate的情况下，排除是基于bean名称“redisTemplate”而不是其类型）。如果commons-pool2在classpath中，则默认情况下你将获得一个连接池工厂。</p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><h4 id="连接到MongoDB数据库"><a href="#连接到MongoDB数据库" class="headerlink" title="连接到MongoDB数据库"></a>连接到MongoDB数据库</h4><h4 id="MongoTemplate"><a href="#MongoTemplate" class="headerlink" title="MongoTemplate"></a>MongoTemplate</h4><h4 id="Spring-Data-MongoDB仓库"><a href="#Spring-Data-MongoDB仓库" class="headerlink" title="Spring Data MongoDB仓库"></a>Spring Data MongoDB仓库</h4><h4 id="嵌入式Mongo"><a href="#嵌入式Mongo" class="headerlink" title="嵌入式Mongo"></a>嵌入式Mongo</h4><h3 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h3><h4 id="连接到Neo4j数据库"><a href="#连接到Neo4j数据库" class="headerlink" title="连接到Neo4j数据库"></a>连接到Neo4j数据库</h4><h4 id="使用嵌入式模式"><a href="#使用嵌入式模式" class="headerlink" title="使用嵌入式模式"></a>使用嵌入式模式</h4><h4 id="Neo4jSession"><a href="#Neo4jSession" class="headerlink" title="Neo4jSession"></a>Neo4jSession</h4><h4 id="Spring-Data-Neo4j仓库"><a href="#Spring-Data-Neo4j仓库" class="headerlink" title="Spring Data Neo4j仓库"></a>Spring Data Neo4j仓库</h4><h4 id="仓库示例"><a href="#仓库示例" class="headerlink" title="仓库示例"></a>仓库示例</h4><h3 id="Gemfire"><a href="#Gemfire" class="headerlink" title="Gemfire"></a>Gemfire</h3><h3 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h3><h4 id="连接到Solr"><a href="#连接到Solr" class="headerlink" title="连接到Solr"></a>连接到Solr</h4><h4 id="Spring-Data-Solr仓库"><a href="#Spring-Data-Solr仓库" class="headerlink" title="Spring Data Solr仓库"></a>Spring Data Solr仓库</h4><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><h4 id="使用Jest连接Elasticsearch"><a href="#使用Jest连接Elasticsearch" class="headerlink" title="使用Jest连接Elasticsearch"></a>使用Jest连接Elasticsearch</h4><h4 id="使用Spring-Data连接Elasticsearch"><a href="#使用Spring-Data连接Elasticsearch" class="headerlink" title="使用Spring Data连接Elasticsearch"></a>使用Spring Data连接Elasticsearch</h4><h4 id="Spring-Data-Elasticsearch-仓库"><a href="#Spring-Data-Elasticsearch-仓库" class="headerlink" title="Spring Data Elasticsearch 仓库"></a>Spring Data Elasticsearch 仓库</h4><h3 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h3><h4 id="连接到Cassandra"><a href="#连接到Cassandra" class="headerlink" title="连接到Cassandra"></a>连接到Cassandra</h4><h4 id="Spring-Data-Cassandra仓库"><a href="#Spring-Data-Cassandra仓库" class="headerlink" title="Spring Data Cassandra仓库"></a>Spring Data Cassandra仓库</h4><h3 id="Couchbase"><a href="#Couchbase" class="headerlink" title="Couchbase"></a>Couchbase</h3><h4 id="连接到Couchbase"><a href="#连接到Couchbase" class="headerlink" title="连接到Couchbase"></a>连接到Couchbase</h4><h4 id="Spring-Data-Couchbase仓库"><a href="#Spring-Data-Couchbase仓库" class="headerlink" title="Spring Data Couchbase仓库"></a>Spring Data Couchbase仓库</h4><h3 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h3><h4 id="连接到LDAP服务器"><a href="#连接到LDAP服务器" class="headerlink" title="连接到LDAP服务器"></a>连接到LDAP服务器</h4><h4 id="Spring-Data-LDAP仓库"><a href="#Spring-Data-LDAP仓库" class="headerlink" title="Spring Data LDAP仓库"></a>Spring Data LDAP仓库</h4><h4 id="嵌入式内存LDAP服务器"><a href="#嵌入式内存LDAP服务器" class="headerlink" title="嵌入式内存LDAP服务器"></a>嵌入式内存LDAP服务器</h4><h3 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h3><h4 id="连接到InfluxDB"><a href="#连接到InfluxDB" class="headerlink" title="连接到InfluxDB"></a>连接到InfluxDB</h4><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Spring Framework为透明地向应用程序添加缓存提供了支持。在其核心，抽象层将缓存应用于方法，从而减少基于缓存中可用信息的执行数量。缓存逻辑是透明地应用的，不会对调用程序产生任何干扰。只要通过@Enablecaching注解启用了缓存支持，Spring Boot就会自动配置缓存基础结构。</p><blockquote><p>查看Spring Framework文件<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/integration.html#cache">相关章节</a>获取更多信息。</p></blockquote><p>简而言之，将缓存添加到服务的操作中就像向其方法添加相关注释一样简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(&quot;piDecimals&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computePiDecimal</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此示例演示如何在可能代价高昂的操作中使用缓存。在调用<code>computePiDecimal</code>之前，抽象层会在<code>piDecimals</code>缓存中查找匹配参数<code>i</code>的实体。如果找到了，缓存中的内容会立即返回给调用方，并且不会调用这个方法。否则这个方法会被调用并且在返回值之前会更新缓存。</p><blockquote><p>也可以明确地使用标准的JSR-107（JCache）注解（比如<code>@CacheResult</code>）。我们强烈建议你不要把它们混在一起。</p></blockquote><p>如果没有添加具体的缓存库，Spring Boot将会自动配置一个简单的实现，它使用内存中的并发Map。当需要缓存时（如上面例子中的<code>piDecimals</code>），这个provider将为你即时创建它。简单的提供者并不推荐用于生产，但是对于入门并确保您了解这些特性是非常好的。当你已经决定要使用的缓存提供程序时，请一定要阅读它的文档，以确定如何配置你的应用程序使用的缓存。实际上，所有的提供者都要求你显式地配置应用程序中使用的每个缓存。有些提供了自定义spring.cache.cache-names属性定义的默认缓存的方法。</p><blockquote><p>也可以透明地<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/integration.html#cache-annotations-put">更新</a>或从缓存中<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/integration.html#cache-annotations-evict">删除</a>数据。</p></blockquote><blockquote><p>如果你使用的缓存基础设施不是基于接口的，那么确保启用了<code>@EnableCaching</code>的<code>proxyTargetClass</code>属性。</p></blockquote><h3 id="支持的缓存实现"><a href="#支持的缓存实现" class="headerlink" title="支持的缓存实现"></a>支持的缓存实现</h3><p>缓存抽象层没有提供实际的存储，依赖于<code>org.springframework.cache.Cache</code>和<code>org.springframework.cache.CacheManager</code>接口实现。</p><p>如果你没有定义<code>CacheManager</code>类型的或名为<code>cacheResolver</code>（查看<code>CachingConfigurer</code>）的<code>CacheResolver</code> bean，Spring Boot尝试加载下面的实现（按此顺序）：</p><ul><li><a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-generic">Generic</a></li><li><a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-jcache">JCache（JSR-107）</a>（EhCache 3，Hazelcast，Infinispan，etc）</li><li><a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-ehcache2">EhCache 2.x</a></li><li><a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-hazelcast">Hazelcast</a></li><li><a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-infinispan">Infinispan</a></li><li><a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-couchbase">Couchbase</a></li><li><a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-redis">Redis</a></li><li><a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-caffeine">Caffeine</a></li><li><a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-simple">Simple</a></li></ul><blockquote><p>也可以使用<code>spring.cache.type</code>属性强制使用缓存实现。如果您需要在某些环境中<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-caching-provider-none">完全禁用缓存</a>(例如测试)，那么可以使用该属性。</p></blockquote><blockquote><p>使用<code>spring-boot-starter-cache</code> “Starter”来快速添加基本的缓存依赖，这个starter引入了<code>spring-context-support</code>:如果是手动添加的依赖，为了使用JCache，EhCache 2.x或Guava支持，你必须得包含<code>spring-context-support</code>。</p></blockquote><p>如果Spring Boot自动配置了<code>CacheManager</code>，可以通过暴露一个实现了<code>CacheManagerCustomizer</code>接口的bean在<code>CacheManager</code>完全初始化之前进一步优化它的配置。下面的代码设置了一个标志，表示null值应该被传递到底层的map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt; <span class="title">cacheManagerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConcurrentMapCacheManager cacheManager)</span> </span>&#123;</span><br><span class="line">            cacheManager.setAllowNullValues(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的例子中，预计会自动配置一个<code>ConcurrentMapCacheManager</code>。如果不是这种情况(你提供了自己的配置，或者是自动配置了不同的缓存实现)，则不会调用customizer了。你可以提供很多个customizer并且可以使用常规的<code>@Order</code>或者<code>Ordered</code>来排序。</p></blockquote><h4 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h4><p>如果上下文中定义了不止一个<code>org.springframework.cache.Cache</code> bean，则使用通用缓存。<code>CacheManager</code>包装所有创建的这个类型的bean。</p><h4 id="JCache（JSR-107）"><a href="#JCache（JSR-107）" class="headerlink" title="JCache（JSR-107）"></a>JCache（JSR-107）</h4><p>JCache是通过类路径中存在<code>javax.cache.spi.CachingProvider</code>来加载的，<code>spring-boot-starter-cache</code> “starter” 提供了<code>JCacheCacheManager</code>。有很多兼容的库并且Spring Boot 提供了对Ehcache 3、Hazelcast和Infinispan的依赖管理。还可以添加任何其他兼容的库。</p><p>有可能会出现有多个提供者的情况，在这种情况下必须明确指定提供者。即使JSR-107标准没有强制定义配置文件的位置，但是Spring Boot尽最大可能来适应具体实现。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Only necessary if more than one provider is present</span></span><br><span class="line"><span class="meta">spring.cache.jcache.provider</span>=<span class="string">com.acme.MyCachingProvider</span></span><br><span class="line"><span class="meta">spring.cache.jcache.config</span>=<span class="string">classpath:acme.xml</span></span><br></pre></td></tr></table></figure><blockquote><p>由于缓存库有可能提供本地实现和JSR-107支持，Spring Boot将会优先选择JSR-107支持，因此如果你切换到不同的JSR-107实现，Spring Boot还是可以支持相同的功能。</p></blockquote><blockquote><p>Spring Boot 对<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-hazelcast">Hazelcast有一个通用的实现</a>。如果有一个单独的<code>HazelcastInstance</code>可用，它会自动地为<code>CacheManager</code>重用，除非指定<code>spring.cache.jcache.config</code>属性。</p></blockquote><p>还有一些方式来自定义底层的<code>javax.cache.cacheManager</code>:</p><ul><li>缓存可以在启动的时候通过<code>spring.cache.cache-names</code>属性来创建。如果定义了自已的<code>javax.cache.configuration.Configuration</code> bean ，将会用它来自定义它们。</li><li>CacheManager引用调用<code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code> bean 来进行完全定制。</li></ul><blockquote><p>如果定义了一个标准的<code>javax.cache.CacheManager</code> bean，它会自动被抽象层期望的<code>org.springframework.cache.CacheManager</code>实现包装。不进行进一步的定制。</p></blockquote><h4 id="EhCache-2-x"><a href="#EhCache-2-x" class="headerlink" title="EhCache 2.x"></a>EhCache 2.x</h4><p>如果在classpath的根目录上找到了<code>ehcache.xml</code>文件，那么将会使用EhCache 2.x。如果是EhCache 2.x，<code>spring-boot-starter-cache</code> “Starter”提供的<code>EhCacheCacheManager</code>和它提供的这个文件用来启动缓存管理器。也可以使用这种方式来提供可选的配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.ehcache.config&#x3D;classpath:config&#x2F;another-config.xml</span><br></pre></td></tr></table></figure><h4 id="Hazelcast"><a href="#Hazelcast" class="headerlink" title="Hazelcast"></a>Hazelcast</h4><h4 id="Infinispan"><a href="#Infinispan" class="headerlink" title="Infinispan"></a>Infinispan</h4><h4 id="Couchbase-1"><a href="#Couchbase-1" class="headerlink" title="Couchbase"></a>Couchbase</h4><h4 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h4><p>如果Redis可用并且配置了，<code>RedisCacheManager</code>将会自动配置。还可以使用<code>spring.cache.cache-names</code>属性在启动时创建额外的缓存。</p><blockquote><p>在缺省情况下，添加了一个key的前缀，以防止如果两个单独的缓存使用相同的密钥，Redis将会有重叠的key，并可能会返回无效值的情况。如果你创建了自己的<code>RedisCacheManager</code>，我们强烈建议保持开启这个设置。</p></blockquote><h4 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h4><h4 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h4><p>如果没有发现其他的提供者，将会配置一个使用<code>ConcurrentHashMap</code>作为缓存存储的简单实现。如果应用没有提供缓存库，这将是默认配置。缓存默认是实时创建的，但是你可以使用<code>cache-names</code>属性限制可用的缓存列表。例如，如果你只想要<code>foo</code>和<code>bar</code>缓存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names&#x3D;foo,bar</span><br></pre></td></tr></table></figure><p>如果你这样做，你的应用程序使用一个未列出的缓存那么当需要缓存时，它会在运行时失败，但在启动时不会。如果你使用未声明的缓存，这与“真实”缓存提供者的行为方式类似。</p><h4 id="None"><a href="#None" class="headerlink" title="None"></a>None</h4><p>当你的配置中出现了@EnableCache时，也可以预期适当的缓存配置。如果在某些环境中需要禁用缓存，那么强制缓存类型为<code>none</code>，以使用无操作实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.type&#x3D;none</span><br></pre></td></tr></table></figure><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>Spring Framework 提供了集成消息系统的扩展支持：从简单地使用JMS API <code>JmsTemplate</code> 到完整的接收异步消息的架构。Spring AMQP为“Advanced Message Queuing Protocol”提供了一个类似的特性集并且Spring Boot也为<code>RabbitTemplate</code>和RabbitMQ提供配置自动配置选项。在Spring WebSocket中还原生支持STOMP的消息传递，Spring Boot通过starter和少量的自动配置支持这一点。Spring Boot 也支持Apache Kafka。</p><h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p><code>javax.jms.ConnectionFactory</code>接口提供了创建与JMS代理进行交互的<code>javax.jms.Connection</code>的标准方法。尽管Spring需要一个<code>ConnectionFactory</code>来与JMS一起工作，但是你通常不需要直接使用它并且可以依赖更高层次的消息抽象层（查看<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/integration.html#jms">Spring Framework的文档</a>获取更多细节）。Spring Boot 也自动配置必要的组件来发送与接收消息。</p><h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4><p>当Spring Boot在classpath中发现ActiveMQ时，也会配置一个<code>ConnectionFactory</code>。如果提供了代理，将启动一个嵌入式代理并且自动配置它（只要没有通过配置指定代理URL）。</p><blockquote><p>如果你使用了<code>spring-boot-starter-activemq</code>，则提供连接或嵌入ActiveMQ实例的必要依赖项，以及与JMS集成的Spring基础设施。</p></blockquote><p>ActiveMQ配置由<code>spring.activemq.*</code>中的外部配置属性控制。例如，你可以在<code>application.properties</code>中声明下面的语句：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.activemq.broker-url</span>=<span class="string">tcp://192.168.1.210:9876</span></span><br><span class="line"><span class="meta">spring.activemq.user</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.activemq.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure><p>你还可以通过添加<code>org.apache.activemq:activemq-pool</code>的依赖来使用JMS资源池，并相应地配置<code>PooledConnectionFactory</code>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.activemq.pool.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.activemq.pool.max-connections</span>=<span class="string">50</span></span><br></pre></td></tr></table></figure><p>查看<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.java"><code>ActiveMQProperties</code></a>获取更多地的支持属性。</p><p>默认情况下，如果不存在destination ，ActiveMQ会创建一个，因此，destination 是根据它们提供的名称来解析的。</p><h4 id="Artemis"><a href="#Artemis" class="headerlink" title="Artemis"></a>Artemis</h4><p>如果Spring Boot 在classpath中发现了Artemis，则会自动配置<code>ConnectionFactory</code>。如果代理存在，则将自动启动并配置嵌入式代理(除非模式属性已显式设置)。支持的模式有:<code>embedded</code>（显式地指出需要使用嵌入式代理，并且在代理在类路径中不可用时导致错误）和<code>native</code>使用<code>netty</code>传输协议来连接代理。当配置后者时，Spring Boot 配置一个<code>ConnectionFactory</code>，使用默认设置连接到在本地机器上运行的代理。</p><blockquote><p>如果你使用了<code>spring-boot-starter-artemis</code>，将会提供连接已经存在的Artemis实例的必要依赖，以及与JMS集成的Spring基础组件。添加<code>org.apache.activemq:artemis-jms-server</code>到你的应用中允许你使用<code>embedded</code>模式。</p></blockquote><p>Artemis的配置是由在spring.artemis.*的外部配置属性控制的。例如，你可以在<code>application.properties</code>中声明以下代码：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.artemis.mode</span>=<span class="string">native</span></span><br><span class="line"><span class="meta">spring.artemis.host</span>=<span class="string">192.168.1.210</span></span><br><span class="line"><span class="meta">spring.artemis.port</span>=<span class="string">9876</span></span><br><span class="line"><span class="meta">spring.artemis.user</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.artemis.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure><p>在嵌入代理时，你可以选择是否启用持久性，以及应该提供的destination列表。可以将它们指定为以逗号分隔的列表，以使用默认选项创建它们；或者你可以定义<code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code>或<code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code>类型的bean(s)，分别用于高级队列和主题配置。</p><p>查看<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.java"><code>ArtemisProperties</code></a> 获取更多支持的属性。</p><p>任何JNDI查找都不涉及到，destination都是根据它们的名称来解析的，或者在”Artemis “的配置中使用“name”属性，或者通过配置提供的名称。</p><h4 id="使用JNDI-ConnectionFactory"><a href="#使用JNDI-ConnectionFactory" class="headerlink" title="使用JNDI ConnectionFactory"></a>使用JNDI ConnectionFactory</h4><p>如果你在应用程序服务器中运行你的应用程序，Spring Boot将尝试使用JNDI来定位一个JMS <code>ConnectionFactory</code>。默认会检查<code>java:/JmsXA</code>和<code>java:/XAConnectionFactory</code>。你可以使用<code>spring.jms.jndi-name</code>属性来指定其他的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jms.jndi-name&#x3D;java:&#x2F;MyConnectionFactory</span><br></pre></td></tr></table></figure><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>Spring的<code>JmsTemplate</code>是自动配置的并且你可以直接注入到你的bean中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JmsTemplate jmsTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jmsTemplate = jmsTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>JmsMessagingTemplate</code>也可以以类似的方式注入。如果定义了<code>DestinationResolver</code>或<code>MessageConverter</code> bean，它们将自动关联到自动配置的<code>JmsTemplate</code>。</p></blockquote><h4 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h4><p>当JMS 基础组件存在时，任何bean都可以用 @JmsListener 注解来创建监听器端点。如果没有定义<code>JmsListenerContainerFactory</code> bean，会自动配置一个默认的。如果定义了<code>DestinationResolver</code>或<code>MessageConverter</code> bean，那么它们将自动与缺省工厂相关联。</p><p>默认的工厂默认是事务性的。如果你在一个<code>JtaTransactionManager</code>存在的基础结构中运行，那么默认情况下，它将与监听器容器相关联。如果不是的话，<code>sessionTransacted</code>标志将会启用。在后一种情况下，你可以将本地数据存储事务与传入消息的处理关联起来，方法是在listener方法(或其委托方法)上添加<code>@Transactional</code>。这将确保在本地事务完成后传入消息被确认。这还包括在相同JMS会话中执行的响应消息发送。</p><p>下面的组件在<code>someQueue</code>上创建了一个监听端点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;someQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>查看<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/javadoc-api/org/springframework/jms/annotation/EnableJms.html"><code>@EnableJms</code>文档</a>查看更多细节。</p></blockquote><p>如果你需要创建更多的<code>JmsListenerContainerFactory</code>实例或者你想要覆盖默认的，Spring Boot提供了<code>DefaultJmsListenerContainerFactoryConfigurer</code>来实例化<code>DefaultJmsListenerContainerFactory</code>并且与自动配置的使用相同的设置。</p><p>例如，下面的内容展示了另一个使用特定<code>MessageConverter</code>的工厂:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactory <span class="title">myFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            DefaultJmsListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        DefaultJmsListenerContainerFactory factory =</span><br><span class="line">                <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">        configurer.configure(factory, connectionFactory());</span><br><span class="line">        factory.setMessageConverter(myMessageConverter());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以在任何<code>@JmsListener</code>注解的方法中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;someQueue&quot;, containerFactory=&quot;myFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>高级消息队列协议(AMQP)是面向消息中间件的一种平台无关的、线级协议(?)。Spring AMQP 项目Spring的核心概念应用到基于AMQP的消息解决方案的开发。Spring Boot提供了多种便利，可以通过RabbitMQ与AMQP进行合作，包括<code>spring-boot-starter-amqp</code> “Starter”。</p><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>RabbitMQ是一种基于AMQP协议的轻量级的、可靠的、可伸缩的、可移植的消息代理。Spring使用RabbitMQ来使用AMQP协议进行通信。<br>RabbitMQ配置由<code>spring.rabbitmq.*</code>中的外部配置属性控制。例如，可以在<code>application.properties</code>中声明以下代码：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure><p>请参阅<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java"><code>RabbitProperties</code></a>获得更多受支持的选项。</p><blockquote><p>查看<a href="http://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/">理解AMQP，RabbitMQ使用的协议</a>了解更多细节</p></blockquote><h4 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h4><p>Spring的 <code>AmqpTemplate</code> 和 <code>AmqpAdmin</code> 是自动配置的,你可以自动装配他们到自己的 bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpAdmin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AmqpAdmin amqpAdmin;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amqpAdmin = amqpAdmin;</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate = amqpTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>RabbitMessagingTemplate</code>可以以类似的方式注入。如果定义了<code>MessageConverter</code>  bean，那么它将自动与自动配置的<code>AmqpTemplate</code>相关联。</p></blockquote><p>任何<code>org.springframework.amqp.core.Queue</code>定义为bean的队列将在必要时自动用于在RabbitMQ实例上声明一个对应的队列。</p><p>你可以启用<code>AmqpTemplate</code>上的重试来重试操作，例如在丢失代理连接的事件中。默认情况下，重试是禁用的。</p><h4 id="接收消息-1"><a href="#接收消息-1" class="headerlink" title="接收消息"></a>接收消息</h4><p>当Rabbit组件存在时，任何bean都可以用<code>@RabbitListener</code>注解来创建一个监听器端点。如果没有定义<code>RabbitListenerContainerFactory</code>,默认自动配置<code>SimpleRabbitListenerContainerFactory</code>,并且你可以使用<code>spring.rabbitmq.listener.type</code>属性切换到一个直接的容器。如果定义了<code>MessageConverter</code>或<code>MessageRecoverer</code> bean，那么它们将自动与缺省工厂相关联。</p><p>下面的组件在<code>someQueue</code>队列上创建一个监听器端点:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;someQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>请查看<a href="http://docs.spring.io/spring-amqp/docs/current/api/org/springframework/amqp/rabbit/annotation/EnableRabbit.html"><code>@EnableRabbit</code>的Javadoc</a>以获得更多详细信息。</p></blockquote><p>如果你需要创建多个<code>RabbitListenerContainerFactory</code>实例或者你想覆盖默认的,Spring Boot提供了<code>SimpleRabbitListenerContainerFactoryConfigurer</code>和<code>DirectRabbitListenerContainerFactoryConfigurer</code>,你可以用它来初始化一个<code>SimpleRabbitListenerContainerFactory</code>和<code>DirectRabbitListenerContainerFactory</code>,并且与自动配置的使用相同的设置。</p><blockquote><p>不管选择哪种容器类型，这两个bean都是由自动配置公开的。</p></blockquote><p>例如，下面的内容展示了另一个使用特定<code>MessageConverter</code>的工厂:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">myFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            SimpleRabbitListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory =</span><br><span class="line">                <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        configurer.configure(factory, connectionFactory);</span><br><span class="line">        factory.setMessageConverter(myMessageConverter());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以在任何 @RabbitListener 注解的方法中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;someQueue&quot;, containerFactory=&quot;myFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以启用重试来处理监听器抛出异常的情况。默认情况下使用<code>RejectAndDontRequeueRecoverer</code>但是你可以定义一个自己的<code>MessageRecoverer</code>。当重试耗尽时，消息将被拒绝，并且被丢弃或者如果代理配置了交换，则消息将路由到死信交换。默认情况下，重试是禁用的。</p><blockquote><p><strong>如果没启用重试，侦听器抛出异常，默认情况下，将为无限重试分发。你可以通过两种方式来修改该行为;将<code>defaultRequeueRejected</code>属性设置为<code>false</code>，并尝试零重新交付;或者,抛出<code>AmqpRejectAndDontRequeueException</code>表示该消息应该被拒绝。这是在启用重试并且达到了最大的交付尝试时所使用的机制</strong></p></blockquote><h3 id="Apache-Kafka"><a href="#Apache-Kafka" class="headerlink" title="Apache Kafka"></a>Apache Kafka</h3><p>通过提供<code>spring-kafka</code>项目的自动配置来支持<a href="http://kafka.apache.org/"><code>Apache Kafka</code></a>。</p><p>Kafka 的配置由<code>spring.kafka.*</code>的外部配置属性控制。例如，你可以在<code>application.properties</code>中声明以下部分:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.bootstrap-servers</span>=<span class="string">localhost:9092</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.group-id</span>=<span class="string">myGroup</span></span><br></pre></td></tr></table></figure><p>更多受支持的选项，请参见<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.java"><code>KafkaProperties</code></a>。</p><h4 id="发送消息-2"><a href="#发送消息-2" class="headerlink" title="发送消息"></a>发送消息</h4><p>Spring的<code>KafkaTemplate</code>是自动配置的，你可以直接在你自己的bean中注入它们:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(KafkaTemplate kafkaTemplate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.kafkaTemplate = kafkaTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接收消息-2"><a href="#接收消息-2" class="headerlink" title="接收消息"></a>接收消息</h4><p>当Apache Kafka基础组件存在时，任何bean都可以用@卡夫卡式的注解来创建一个监听器端点。如果没有定义<code>KafkaListenerContainerFactory</code>,会自动配置一个默认的，并且key定义在<code>spring.kafka.listener.*</code>中。</p><p>以下组件在<code>someTopic</code>主题上创建一个监听器端点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;someTopic&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="额外的Kafka属性"><a href="#额外的Kafka属性" class="headerlink" title="额外的Kafka属性"></a>额外的Kafka属性</h4><p>自动配置支持的属性在<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#common-application-properties">附录A，通用应用程序属性</a>中可以查看。请注意，这些属性大部分(连字符或驼峰形式)都直接映射到Apache Kafka的点状属性，请参阅Apache Kafka文档以获得详细信息。</p><p>这些属性的前几项都适用于生产者和消费者，但如果希望使用不同的值，则可以在生产者或消费者级别指定。Apache Kafka指定了具有重要性的属性：HIGH，MEDIUM和LOW。Spring Boot自动配置支持所有HIGH重要性的属性，一些选择的MEDIUM和LOW，以及任何没有默认值的属性。</p><p>Kafka 所支持的属性中只有一个子集可以通过<code>KafkaProperties</code>类来获得。如果你希望配置没有直接支持的生产者或消费者的附加属性，请使用以下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.properties.foo.bar&#x3D;baz</span><br><span class="line">spring.kafka.consumer.properties.fiz.buz&#x3D;qux</span><br><span class="line"># 这里应该是.吧？</span><br><span class="line">spring,kafka.producer.properties.baz.qux&#x3D;fiz </span><br></pre></td></tr></table></figure><p>这设置了普通的<code>foo.bar</code> Kafka 属性为<code>baz</code>(适用于生产者和消费者)，消费者<code>fiz.buz</code>属性为<code>qux</code>和生产者<code>baz.qux</code>属性为<code>fiz</code>。</p><blockquote><p><strong>以这种方式设置的属性将覆盖Spring Boot 显式支持的任何配置项。</strong></p></blockquote><h2 id="使用“RestTemplate”-调用REST-服务"><a href="#使用“RestTemplate”-调用REST-服务" class="headerlink" title="使用“RestTemplate” 调用REST 服务"></a>使用“RestTemplate” 调用REST 服务</h2><p>如果需要在应用程序中调用远程REST服务，那么可以使用Spring Framework的<code>RestTemplate</code>类。由于<code>RestTemplate</code>实例通常需要在被使用之前进行定制，所以Spring Boot 不提供任何单独的自动配置的<code>RestTemplate</code> bean。但是，它可以自动配置一个<code>RestTemplateBuilder</code>，当需要时可以使用它创建<code>RestTemplate</code>实例。自动配置的<code>RestTemplateBuilder</code>将确保将合理的<code>HttpMessageConverters</code>应用于<code>RestTemplate</code>实例。</p><p>下面是一个典型的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(RestTemplateBuilder restTemplateBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplateBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Details <span class="title">someRestCall</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">&quot;/&#123;name&#125;/details&quot;</span>, Details.class, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>RestTemplateBuilder</code>包含许多有用的方法，这些方法可用于快速配置<code>RestTemplate</code>。例如，要添加基本的身份验证支持，你可以使用<code>builder.basicAuthorization(&quot;user&quot;, &quot;password&quot;).build()</code>。</p></blockquote><h3 id="定制RestTemplate"><a href="#定制RestTemplate" class="headerlink" title="定制RestTemplate"></a>定制RestTemplate</h3><p><code>RestTemplate</code>定制主要有三种方法，这取决于你希望定制的范围有多大。</p><p>要使任何定制的范围尽可能窄，只需插入自动配置的<code>RestTemplateBuilder</code>，然后根据需要调用它的方法就行了。每个方法调用都返回一个新的<code>RestTemplateBuilder</code>实例，因此定制只会影响该构建器的使用。为了在应用层面定制，可以使用额外的定制化定制一个<code>RestTemplateCustomizer</code> bean。所有这些bean都将自动注册到自动配置的<code>RestTemplateBuilder</code>中，并将应用于使用它构建的任何模板。</p><p>下面是一个定制化器的例子，它配置了除192.168.0.5之外的所有主机使用代理:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCustomizer</span> <span class="keyword">implements</span> <span class="title">RestTemplateCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        HttpHost proxy = <span class="keyword">new</span> HttpHost(<span class="string">&quot;proxy.example.com&quot;</span>);</span><br><span class="line">        HttpClient httpClient = HttpClientBuilder.create()</span><br><span class="line">                .setRoutePlanner(<span class="keyword">new</span> DefaultProxyRoutePlanner(proxy) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> HttpHost <span class="title">determineProxy</span><span class="params">(HttpHost target,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HttpRequest request, HttpContext context)</span></span></span><br><span class="line"><span class="function">                                    <span class="keyword">throws</span> HttpException </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (target.getHostName().equals(<span class="string">&quot;192.168.0.5&quot;</span>)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.determineProxy(target, request, context);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;).build();</span><br><span class="line">        restTemplate.setRequestFactory(</span><br><span class="line">                <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，最极端的(也是很少使用的)选择是创建你自己的<code>RestTemplateBuilder</code> bean。这将关闭<code>RestTemplateBuilder</code>的自动配置，并防止使用任何<code>RestTemplateCustomizer</code> bean。</p><h2 id="使用“WebClient”-调用REST-服务"><a href="#使用“WebClient”-调用REST-服务" class="headerlink" title="使用“WebClient” 调用REST 服务"></a>使用“WebClient” 调用REST 服务</h2><h3 id="定制WebClient"><a href="#定制WebClient" class="headerlink" title="定制WebClient"></a>定制WebClient</h3><h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><p>只要在类路径上发现JSR-303的实现(例如Hibernate validator)就会自动启用Bean校验1.1支持的方法校验特性。这允许在bean方法的参数和/或返回值上使用<code>javax.valication</code>约束注解。有这些注解的方法的目标类需要在类级别上用<code>@Validated</code>注解进行注解，因为内联约束注解需要搜索它们的方法。</p><p>例如，以下服务触发第一个参数的验证，确保它的大小在8到10之间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Archive <span class="title">findByCodeAndAuthor</span><span class="params">(<span class="meta">@Size(min = 8, max = 10)</span> String code,</span></span></span><br><span class="line"><span class="function"><span class="params">            Author author)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="邮件发送"><a href="#邮件发送" class="headerlink" title="邮件发送"></a>邮件发送</h2><p>Spring框架为使用<code>JavaMailSender</code>接口发送电子邮件提供了一种简单的抽象，Spring Boot 为它提供了自动配置以及启动模块。</p><blockquote><p>查看<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/integration.html#mail">参考文档</a>以了解如何使用<code>JavaMailSender</code>的详细说明</p></blockquote><p>如果spring.mail.host和相关的库(如spring-boot-starter-mail所定义的)可用，如果不存在，就会创建一个默认的JavaMailSender。sender可以通过<code>spring.mail</code>命名空间中的配置项进一步定制，查看<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java"><code>MailProperties</code></a>以获得更多细节。</p><p>特别是，某些默认的超时值是无限的，你可能想要更改它，以避免被无响应的邮件服务器阻塞线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.properties.mail.smtp.connectiontimeout&#x3D;5000</span><br><span class="line">spring.mail.properties.mail.smtp.timeout&#x3D;3000</span><br><span class="line">spring.mail.properties.mail.smtp.writetimeout&#x3D;5000</span><br></pre></td></tr></table></figure><h2 id="JTA-分布式事务"><a href="#JTA-分布式事务" class="headerlink" title="JTA 分布式事务"></a>JTA 分布式事务</h2><p>Spring Boot通过使用Atomikos或Bitronix嵌入式事务管理器来支持跨多个XA资源的分布式JTA事务。在部署到合适的Java EE应用服务器时，JTA事务也得到了支持。当检测到JTA环境时，将使用Spring的<code>JtaTransactionManager</code>来管理事务。将对自动配置的JMS、数据源和JPA bean进行升级，以支持XA事务。你可以使用诸如<code>@Transactional</code>之类的标准Spring 方式来参与分布式事务。如果你在一个JTA环境中，并且仍然希望使用本地事务，那么你可以设置<code>spring.jta.enabled</code>属性设置为<code>false</code>来禁用JTA自动配置。</p><h3 id="使用Atomikos-事务管理器"><a href="#使用Atomikos-事务管理器" class="headerlink" title="使用Atomikos 事务管理器"></a>使用Atomikos 事务管理器</h3><p>Atomikos是一个流行的开源事务管理器，可以嵌入到Spring Boot应用程序中。你可以使用<code>spring-boot-starter-jta-atomikos</code> Starter来获取适当的Atomikos库。Spring Boot将自动配置Atomikos，并确保将适当的<code>depends-on</code>设置应用到你的Spring bean上，以正确的启动和关闭顺序。</p><p>在缺省情况下，Atomikos事务日志将被写入到应用程序主目录(应用程序jar文件所在的目录)的<code>transaction-logs</code>目录中。你可以通过在<code>application.properties</code>文件中设置一个<code>spring.jta.log-dir</code>属性来定制这个目录。<code>spring.jta.atomikos.properties</code>开始的属性也可以用来定制于Atomikos <code>UserTransactionServiceImp</code>。请参阅<a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/jta/atomikos/AtomikosProperties.html"><code>AtomikosProperties</code> Javadoc</a>以获得完整的详细信息。</p><blockquote><p>为了确保多个事务管理器能够安全地协调相同的资源管理器，每个Atomikos实例必须配置一个惟一的ID，默认情况下，这个ID是Atomikos正在运行的机器的IP地址。为了确保产品的唯一性，你应该为应用程序的每个实例配置<code>spring.jta.transaction-manager-id</code>属性使用不同的值。</p></blockquote><h3 id="使用Bitronix-事务管理器"><a href="#使用Bitronix-事务管理器" class="headerlink" title="使用Bitronix 事务管理器"></a>使用Bitronix 事务管理器</h3><h3 id="使用Narayana-事务管理器"><a href="#使用Narayana-事务管理器" class="headerlink" title="使用Narayana 事务管理器"></a>使用Narayana 事务管理器</h3><h3 id="使用Java-EE管理的事务管理器"><a href="#使用Java-EE管理的事务管理器" class="headerlink" title="使用Java EE管理的事务管理器"></a>使用Java EE管理的事务管理器</h3><h3 id="混合XA和非XA-JMS连接"><a href="#混合XA和非XA-JMS连接" class="headerlink" title="混合XA和非XA JMS连接"></a>混合XA和非XA JMS连接</h3><h3 id="支持另一个嵌入式事务管理器"><a href="#支持另一个嵌入式事务管理器" class="headerlink" title="支持另一个嵌入式事务管理器"></a>支持另一个嵌入式事务管理器</h3><h2 id="Hazelcast-1"><a href="#Hazelcast-1" class="headerlink" title="Hazelcast"></a>Hazelcast</h2><h2 id="Quartz-Scheduler"><a href="#Quartz-Scheduler" class="headerlink" title="Quartz Scheduler"></a>Quartz Scheduler</h2><p>Spring引导为使用Quartz调度器提供了几项便利，包括<code>spring-boot-starter-quartz</code> ‘Starter’。如果可以使用Quartz，则将自动配置一个<code>Scheduler</code>(通过<code>SchedulerFactoryBean</code>抽象层)。</p><p>以下类型的bean将被自动获取并与<code>Scheduler</code>关联:</p><ul><li><code>JobDetail</code>:定义了一个特定的Job。<code>JobDetail</code>实例可以通过<code>JobBuilder </code>API轻松构建。</li><li><code>Calendar</code></li><li><code>Trigger</code>:定义特定job何时触发。</li></ul><p>默认情况下，将使用一个内存中的<code>JobStore</code>。但是，如果你的应用程序中有<code>DataSource </code> bean和配置了<code>spring.quartz.job-store-type</code>属性，则可以配置一个基于jdbc的存储:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.quartz.job-store-type&#x3D;jdbc</span><br></pre></td></tr></table></figure><p>当使用jdbc存储时,可以在启动时初始化相关表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.quartz.jdbc.initialize-schema &#x3D; true</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下会检测到数据库，并使用Quartz库提供的标准脚本进行初始化。还可以使用<code>spring.quartz.jdbc.schema</code>属性提供自定义脚本。</p></blockquote><p>Quartz调度器的配置可以使用Quartz 配置属性(参见<code>spring.quartz.properties.*</code>)和允许编程式定制<code>SchedulerFactoryBean</code>的<code>SchedulerFactoryBeanCustomizer</code> bean。</p><p>Job可以定义set方法来注入数据映射属性。常规bean也可以以类似的方式注入:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject &quot;MyService&quot; bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyService</span><span class="params">(MyService myService)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject the &quot;name&quot; job data property</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Integration"><a href="#Spring-Integration" class="headerlink" title="Spring Integration"></a>Spring Integration</h2><p>Spring Boot为使用Spring Integration提供了一些方便，包括<code>spring-boot-starter-integration</code>‘Starter’。Spring Integration为消息传递提供了抽象，还提供了HTTP、TCP等其他传输协议。如果你的类路径上有Spring Integration，它将通过<code>@EnableIntegration</code>注解进行初始化。</p><p>Spring Boot还将配置一些由附加的Spring Integration模块所触发的特性。如果“spring-integration-jmx”也在类路径上，消息处理统计信息将在JMX上发布。如果“spring-integration-jdbc”可用，则可以在启动时创建默认的数据库表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.integration.jdbc.initializer.enabled&#x3D;true</span><br></pre></td></tr></table></figure><p>查看<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationAutoConfiguration.java"><code>IntegrationAutoConfiguration</code></a> 和<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationProperties.java"><code>IntegrationProperties</code></a>类了解更多的细节。</p><h2 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h2><p>Spring Boot为许多存储提供了Spring Session 自动配置:</p><ul><li>JDBC</li><li>Redis</li><li>Hazelcast</li><li>HashMap</li></ul><p>如果可以使用Spring Session ，那么你必须选择你希望使用的<code>StoreType</code>来存储会话。例如，使用JDBC作为后端存储，您可以将应用程序配置为如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.session.store-type&#x3D;jdbc</span><br></pre></td></tr></table></figure><blockquote><p>你可以通过将<code>store-type</code>设置为<code>none</code>来禁用Spring Session。</p></blockquote><p>每种存储都有特定的附加设置。例如，可以为jdbc存储定制表的名称:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.session.jdbc.table-name&#x3D;SESSIONS</span><br></pre></td></tr></table></figure><h2 id="JMX监视和管理"><a href="#JMX监视和管理" class="headerlink" title="JMX监视和管理"></a>JMX监视和管理</h2><p>Java管理扩展(JMX)提供了一种监视和管理应用程序的标准机制。在默认情况下，Spring Boot将创建一个bean id为‘mbeanServer’的<code>MBeanServer</code>，并公开任何使用Spring JMX注解注解的bean(<code>@ManagedResource</code>、<code>@ManagedAttribute</code>、<code>@ManagedOperation</code>)。</p><p>有关更多详细信息，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java"><code>JmxAutoConfiguration</code></a>类。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Spring Boot提供了许多实用程序和注释，以便在测试应用程序时提供帮助。测试支持由两个模块提供;<code>spring-boot-test</code>包含核心项目，<code>spring-boot-test-autoconfigure</code>支持测试的自动配置。</p><p>大多数开发人员只会使用<code>spring-boot-starter-test</code> “Starter”，它既引入了Spring Boot测试模块，也引用了JUnit、AssertJ、Hamcrest和其他一些有用的库。</p><h3 id="测试范围的依赖"><a href="#测试范围的依赖" class="headerlink" title="测试范围的依赖"></a>测试范围的依赖</h3><p>如果你使用<code>spring-boot-starter-test</code>‘Starter(在<code>test``scope</code>)，你将会找到以下所提供的库：</p><ul><li><a href="http://junit.org/">JUnit</a> - Java应用程序单元测试的实际标准</li><li><a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/testing.html#integration-testing">Spring Test</a>和Spring Boot Test - Spring Boot应用程序的实用工具和集成测试支持</li><li><a href="http://joel-costigliola.github.io/assertj/">AssertJ</a> - 流式的断言库</li><li><a href="http://hamcrest.org/JavaHamcrest/">Hamcrest</a> - 一个对象匹配库(也称为约束或谓词)。</li><li><a href="http://mockito.org/">Mockito</a> - 一个Java mocking框架。</li><li><a href="https://github.com/skyscreamer/JSONassert">JSONassert</a> - 一个用于JSON的断言库。</li><li><a href="https://github.com/jayway/JsonPath">JsonPath</a> - JSON的XPath库</li></ul><h3 id="测试Spring应用"><a href="#测试Spring应用" class="headerlink" title="测试Spring应用"></a>测试Spring应用</h3><p>依赖注入的一个主要优点是，它应该使你的代码更容易进行单元测试。你可以使用<code>new</code>操作符简单地实例化对象，而不需要涉及Spring。还可以使用<em>模拟对象</em>而不是实际依赖项。</p><p>通常，你需要跨过“单元测试”，并开始“集成测试”(Spring ApplicationContext实际上涉及到了这个过程)。在不需要部署应用程序或需要连接到其他组件的情况下，能够执行集成测试是很有用的。</p><p>Spring Framework包含一个专用的测试模块，用于进行这样的集成测试。你可以直接声明依赖项<code>org.springframework:spring-test</code>或使用<code>spring-boot-starter-test</code> “Starter”来传递依赖。</p><p>如果你之前没有使用过<code>Spring-test</code>模块，你应该阅读<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/testing.html#testing">Spring Framework参考文档</a>的相关部分。</p><h3 id="测试Spring-Boot应用"><a href="#测试Spring-Boot应用" class="headerlink" title="测试Spring Boot应用"></a>测试Spring Boot应用</h3><p>Spring Boot 应用程序只是一个Spring ApplicationContext，所以没有什么特别的事情需要做来测试超出了你通常使用的Spring上下文的范围的部分。需要注意的一件事是，如果你使用<code>SpringApplication</code>来创建它，那么Spring Boot的外部属性、日志记录和其他特性在默认情况下是默认安装的。</p><p>Spring Boot提供了一个<code>@SpringBootTest</code>注解 ，当你需要Spring Boot特性时，它可以作为标准<code>spring-test``@ContextConfiguration</code>注释的替代品。该注解通过在<code>SpringApplication</code>中创建<code>ApplicationContext </code>来工作。</p><p>你可以使用<code>@SpringBootTest</code>的 <code>webEnvironment</code>属性来进一步细化你的测试将如何运行:</p><ul><li><code>MOCK</code> - 加载一个<code>WebApplicationContext</code>并提供一个模拟servlet环境。在使用该注解时，不会启动嵌入式servlet容器。如果在你的类路径中不存在servlet api，该模式将透明地返回创建常规的非web <code>ApplicationContext</code>。可以与<code>@AutoConfigureMockMvc</code> 一起使用基于<code>MockMvc</code>的应用程序测试。</li><li><code>RANDOM_PORT</code> - 加载一个<code>ServletWebServerApplicationContext</code>和提供了一个真正的servlet环境。嵌入式的servlet容器将被启动并在一个随机的端口上监听。</li><li><code>DEFINED_PORT</code> - 加载一个<code>ServletWebServerApplicationContext</code>和提供了一个真正的servlet环境。嵌入的servlet容器将被启动并监听一个已定义的端口(例如在你的<code>application.properties</code>或默认端口<code>8080</code>)。</li><li><code>NONE</code> - 使用<code>SpringApplication</code>加载一个<code>ApplicationContext</code>，但是不提供<em>任何</em>servlet环境(模拟或其他)。</li></ul><blockquote><p>如果你的测试是<code>@Transactional</code>，它将在默认情况下在每个测试方法结束时回滚事务。如果你将此设置与<code>RANDOM_PORT </code>或<code>DEFINED_PORT</code>结合使用，那么在服务器上启动的任何事务都不会回滚，因为测试运行在不同的线程中，而不是服务器处理。</p></blockquote><blockquote><p>除了<code>@SpringBootTest</code> 而外，还提供了一些其他的注解，用于测试应用程序的特定部分。详情见下文。</p></blockquote><blockquote><p>不要忘记将@RunWith(SpringRunner.class)添加到你的测试中，否则注解将被忽略。</p></blockquote><h4 id="检测测试配置"><a href="#检测测试配置" class="headerlink" title="检测测试配置"></a>检测测试配置</h4><p>如果你熟悉Spring Test Framework，则可以使用<code>@ContextConfiguration(classes=...)</code>来指定要加载哪个Spring <code>@Configuration</code>。或者，你可能经常在测试中使用嵌套的<code>@Configuration</code>类。</p><p>在测试Spring Boot应用程序时，通常不需要这样做。Spring Boot的<code>@*Test</code>注解将自动搜索你的主配置，只要您不显式地定义一个配置。</p><p>搜索算法在包含测试的包中起作用，直到找到一个<code>@SpringBootApplication</code>或<code>@SpringBootConfiguration </code>注解的类。只要你以一种合理的方式构造你的代码，你的主配置通常就会被发现。如果你想要定制主配置，你可以使用一个嵌套的<code>@TestConfiguration </code>类。不像一个嵌套的<code>@Configuration </code>类，它将代替应用程序的主要配置，一个嵌套的<code>@TestConfiguration </code>类将被用于应用程序的主要配置。</p><blockquote><p>Spring的测试框架将在测试之间缓存应用程序上下文。因此，只要你的测试共享相同的配置(不管它是如何被发现的)，加载上下文的潜在时间消耗过程只会发生一次。</p></blockquote><h4 id="排除测试配置"><a href="#排除测试配置" class="headerlink" title="排除测试配置"></a>排除测试配置</h4><p>如果你的应用程序使用组件扫描，例如，如果您使用<code>@SpringBootApplication </code>或<code>@ComponentScan</code>，那么你可能会发现仅为特定测试而创建的顶级配置类意外地在各处被发现。</p><p>正如我们已经看到的，<code>@TestConfiguration </code>可以用于测试的内部类以定制主配置。当被放置在顶级类上时，<code>@TestConfiguration </code>表示<code>src/test/java</code>中的类不应该通过扫描来获取。然后，可以显式地导入该类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Import(MyTestsConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你直接使用<code>@ComponentScan</code>(即不是通过<code>@SpringBootApplication</code>)，你将需要使用它注册<code>TypeExcludeFilter</code>。请参阅<a href="http://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/api/org/springframework/boot/context/TypeExcludeFilter.html">Javadoc</a>以获得详细信息。</p></blockquote><h4 id="使用随机端口"><a href="#使用随机端口" class="headerlink" title="使用随机端口"></a>使用随机端口</h4><p>如果你需要为测试启动一个完整的运行服务器，我们建议你使用随机端口。如果你使用的是<code>@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)</code>，你的测试运行时将随机选择一个可用的端口。</p><p>可以使用<code>@LocalServerPort</code>注解来将实际的<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#howto-discover-the-http-port-at-runtime">端口注入</a>到你的测试中。为方便起见，需要对启动服务器进行REST调用的测试可以另外使用<code>@Autowire</code>一个<code>TestRestTemplate</code>，它将解析与运行的服务器的相对链接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.web.client.TestRestTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomPortExampleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TestRestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String body = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">&quot;/&quot;</span>, String.class);</span><br><span class="line">assertThat(body).isEqualTo(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟和监视-bean"><a href="#模拟和监视-bean" class="headerlink" title="模拟和监视 bean"></a>模拟和监视 bean</h4><p>在运行测试时，有时需要模拟应用程序上下文中的某些组件。例如，在开发期间，你可能会对一些不可用的远程服务有一个facade。当你想要模拟在真实环境中可能很难触发的故障时，mock也会很有用。</p><p>Spring Boot包含一个<code>@MockBean </code>注解，它可用于在<code>ApplicationContext</code>中定义一个bean的Mockito 模拟。你可以使用注解来添加新的bean，或者替换一个现有的bean定义。注解可以直接用于测试类、测试中的字段或`@Configuration``类和字段。当在一个字段中使用时，也将对创建的模拟实例进行注入。模拟bean在每个测试方法之后自动重置。</p><blockquote><p>只要你的测试使用了Spring Boot的一个测试注解(也就是<code>@SpringBootTest</code>)，这个特性就会自动启用。为了使用不同的配置，需要显式地添加监听器:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@TestExecutionListeners(MockitoTestExecutionListener.class)</span><br></pre></td></tr></table></figure><p>这里有一个典型的例子，我们用一个模拟实现来替换一个现有的<code>RemoteService</code> bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> RemoteService remoteService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Reverser reverser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// RemoteService has been injected into the reverser bean</span></span><br><span class="line">        given(<span class="keyword">this</span>.remoteService.someCall()).willReturn(<span class="string">&quot;mock&quot;</span>);</span><br><span class="line">        String reverse = reverser.reverseSomeCall();</span><br><span class="line">        assertThat(reverse).isEqualTo(<span class="string">&quot;kcom&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，你还可以使用<code>@SpyBean </code>将任何现有的bean包装成一个Mockito <code>spy</code>。请参阅Javadoc以获得完整的详细信息。</p><h4 id="自动配置测试"><a href="#自动配置测试" class="headerlink" title="自动配置测试"></a>自动配置测试</h4><p>Spring Boot的自动配置系统适用于应用程序，但有时对测试来说有点太大了。只加载需要测试应用程序“切片”的配置部分通常是有帮助的。例如，你可能想要测试Spring MVC控制器是否正确地映射到url，并且你不希望在这些测试中涉及到数据库调用;或者你<em>可能想要</em>测试JPA实体，并且当这些测试运行时，你对web层不感兴趣。</p><p><code>spring-boot-test-autoconfigure</code>模块包含许多注解，可用于自动配置这些“切片”。它们中的每一个都以类似的方式工作，提供了一个<code>@…Test</code>注解，它加载了<code>ApplicationContext</code>和一个或多个可用于定制自动配置设置的<code>@AutoConfigure...</code>注解。</p><blockquote><p>每个切片都加装一组非常受限制的自动配置类。如果你需要排除其中的一个，那么大多数<code>@…Test</code>注解提供了一个<code>excludeAutoConfiguration </code>属性。或者,你可以使用<code>@ImportAutoConfiguration#exclude</code>。</p></blockquote><blockquote><p>还可以使用<code>@AutoConfigure..</code>注解和标准的<code>@SpringBootTest</code>注解。如果你对“切片”应用程序不感兴趣但是你需要一些自动配置的测试bean，你可以使用这种组合。</p></blockquote><h4 id="自动配置JSON测试"><a href="#自动配置JSON测试" class="headerlink" title="自动配置JSON测试"></a>自动配置JSON测试</h4><p>要测试对象JSON序列化和反序列化，你可以使用<code>@JsonTest</code>注释。<code>@JsonTest</code>将自动配置Jackson <code>ObjectMapper</code>、任何<code>@JsonComponent</code> bean和任何Jackson <code>Modules</code>。它也会对<code>Gson</code>进行配置，如果你碰巧用的不是杰克逊。如果你需要配置自动配置的元素，你可以使用<code>@AutoConfigureJsonTesters</code>注解。</p><p>Spring Boot包括基于AssertJ 的Helper，与JSONassert和JsonPath库一起工作，以检查JSON是否符合预期。<code>JacksonTester</code>、<code>GsonTester</code>和<code>BasicJsonTester</code>类可以分别用于Jackson、Gson和字符串。在使用<code>@JsonTest</code>时，测试类上的任何helper字段都可以<code>@Autowired</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.json.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.json.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@JsonTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJsonTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JacksonTester&lt;VehicleDetails&gt; json;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSerialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        VehicleDetails details = <span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Civic&quot;</span>);</span><br><span class="line">        <span class="comment">// Assert against a `.json` file in the same package as the test</span></span><br><span class="line">        assertThat(<span class="keyword">this</span>.json.write(details)).isEqualToJson(<span class="string">&quot;expected.json&quot;</span>);</span><br><span class="line">        <span class="comment">// Or use JSON path based assertions</span></span><br><span class="line">        assertThat(<span class="keyword">this</span>.json.write(details)).hasJsonPathStringValue(<span class="string">&quot;@.make&quot;</span>);</span><br><span class="line">        assertThat(<span class="keyword">this</span>.json.write(details)).extractingJsonPathStringValue(<span class="string">&quot;@.make&quot;</span>)</span><br><span class="line">                .isEqualTo(<span class="string">&quot;Honda&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeserialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;&#123;\&quot;make\&quot;:\&quot;Ford\&quot;,\&quot;model\&quot;:\&quot;Focus\&quot;&#125;&quot;</span>;</span><br><span class="line">        assertThat(<span class="keyword">this</span>.json.parse(content))</span><br><span class="line">                .isEqualTo(<span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Ford&quot;</span>, <span class="string">&quot;Focus&quot;</span>));</span><br><span class="line">        assertThat(<span class="keyword">this</span>.json.parseObject(content).getMake()).isEqualTo(<span class="string">&quot;Ford&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JSON helper类也可以直接在标准单元测试中使用。如果没有使用<code>@JsonTest</code>，只需在<code>@Before</code>方法中调用helper的<code>initFields</code>方法。</p></blockquote><p><code>@JsonTest</code>启用的自动配置列表可以在<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#test-auto-configuration">附录中</a>找到。</p><h4 id="自动配置Spring-MVC测试"><a href="#自动配置Spring-MVC测试" class="headerlink" title="自动配置Spring MVC测试"></a>自动配置Spring MVC测试</h4><p>为了测试Spring MVC控制器如你预期的工作，你可以使用<code>@WebMvcTest</code>注解。<code>@WebMvcTest</code>将自动配置Spring MVC基础组件和限制扫描<code>@ Controller</code>,<code>@ControllerAdvice</code>,<code>@JsonComponent</code>,<code>Filter</code>,<code>WebMvcConfigurer</code> <code>HandlerMethodArgumentResolver</code> bean。在使用该注解时，不会对常规的<code>@Component</code> bean进行扫描。</p><p>通常，<code>@WebMvcTest</code>将局限于单个控制器，并与<code>@MockBean</code>结合使用，为需要的协作者提供模拟实现。<code>@WebMvcTest</code>也自动配置<code>MockMvc</code>。Mock MVC提供了一种强大的方法来快速测试MVC控制器，而不需要启动一个完整的HTTP服务器。</p><blockquote><p>你还可以使用<code>@AutoConfigureMockMvc</code>注解在非<code>@WebMvcTest</code>(如<code>SpringBootTest</code>)中自动配置<code>MockMvc</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(UserVehicleController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> UserVehicleService userVehicleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">&quot;sboot&quot;</span>))</span><br><span class="line">                .willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Civic&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.mvc.perform(get(<span class="string">&quot;/sboot/vehicle&quot;</span>).accept(MediaType.TEXT_PLAIN))</span><br><span class="line">                .andExpect(status().isOk()).andExpect(content().string(<span class="string">&quot;Honda Civic&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你需要配置自动配置的元素(例如，servlet过滤器何时生效)，你可以在<code>@AutoConfigureMockMvc</code>注解中使用属性。</p></blockquote><p>如果使用HtmlUnit或Selenium，自动配置还将提供一个HtmlUnit <code>WebClient</code> bean和/或一个<code>WebDriver</code> bean。下面是一个使用HtmlUnit的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.gargoylesoftware.htmlunit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(UserVehicleController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHtmlUnitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> UserVehicleService userVehicleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">&quot;sboot&quot;</span>))</span><br><span class="line">                .willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Civic&quot;</span>));</span><br><span class="line">        HtmlPage page = <span class="keyword">this</span>.webClient.getPage(<span class="string">&quot;/sboot/vehicle.html&quot;</span>);</span><br><span class="line">        assertThat(page.getBody().getTextContent()).isEqualTo(<span class="string">&quot;Honda Civic&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在默认情况下，Spring Boot将把<code>WebDriver</code> bean放入一个特殊的“范围”中，以确保在每次测试之后driver都会结束，并注入一个新的实例。如果你不想要这种行为，您可以将<code>@Scope(&quot;singleton&quot;)</code>添加到你的<code>WebDriver``@bean</code>定义中。</p></blockquote><p><code>@WebMvcTest</code>启用的自动配置列表可以在<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#test-auto-configuration">附录中找到</a>。</p><h4 id="自动配置Spring-WebFlux测试"><a href="#自动配置Spring-WebFlux测试" class="headerlink" title="自动配置Spring WebFlux测试"></a>自动配置Spring WebFlux测试</h4><h4 id="自动配置JPA-Data测试"><a href="#自动配置JPA-Data测试" class="headerlink" title="自动配置JPA Data测试"></a>自动配置JPA Data测试</h4><p>如果你想要测试JPA应用程序，可以使用<code>@DataJpaTest</code>。默认情况下，它将配置一个内存中的嵌入式数据库，扫描<code>@Entity</code>类并配置Spring Data JPA存储库。常规的<code>@Component</code> bean不会被加载到<code>ApplicationContext</code>中。</p><p>JPA测试都是事务性的并且在每个测试结束的时候都将回滚，请参阅<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions">Spring参考文档</a>中的相关部分了解更多细节。如果这不是你想要的，您可以禁用一个测试或整个类的事务管理，就像下面这样:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleNonTransactionalTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JPA测试还可以注入一个<code>TestEntityManager</code> bean，它为专门为测试设计的标准JPA <code>EntityManager</code>提供了另一种选择。如果你想在<code>@DataJpaTests</code>外使用<code>TestEntityManager</code> 还可以使用<code>@AutoConfigureTestEntityManager</code>注解。如果需要的话，还可以使用<code>JdbcTemplate</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRepositoryTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestEntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.entityManager.persist(<span class="keyword">new</span> User(<span class="string">&quot;sboot&quot;</span>, <span class="string">&quot;1234&quot;</span>));</span><br><span class="line">        User user = <span class="keyword">this</span>.repository.findByUsername(<span class="string">&quot;sboot&quot;</span>);</span><br><span class="line">        assertThat(user.getUsername()).isEqualTo(<span class="string">&quot;sboot&quot;</span>);</span><br><span class="line">        assertThat(user.getVin()).isEqualTo(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存中嵌入式数据库通常适用于测试，因为它们是快速的，不需要任何开发人员安装。然而,如果你喜欢在一个真正的数据库上运行测试可以使用<code>@AutoConfigureTestDatabase</code>注解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@AutoConfigureTestDatabase(replace=Replace.NONE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRepositoryTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#test-auto-configuration">附录中</a>可以找到由<code>@DataJpaTest</code>启用的自动配置列表。</p><h4 id="自动配置JDBC测试"><a href="#自动配置JDBC测试" class="headerlink" title="自动配置JDBC测试"></a>自动配置JDBC测试</h4><p><code>@JdbcTest </code>类似于<code>@DataJpaTest</code>，但对于纯jdbc相关的测试来说是类似的。默认情况下，它还将配置一个内存中的嵌入式数据库和一个<code>JdbcTemplate</code>。常规的<code>@Component</code> bean不会被加载到<code>ApplicationContext</code>中。</p><p>JDBC测试在缺省情况下是事务性的，并且在每个测试结束时回滚，请参阅Spring参考文档中的<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions">相关部分</a>以获得更多详细信息。如果这不是你想要的，你可以禁用一个测试或整个类的事务管理，就像下面这样:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@JdbcTest</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleNonTransactionalTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你喜欢你的测试运行在一个真正的数据库,你可以你<code>DataJpaTest</code>一样使用<code>@AutoConfigureTestDatabase</code> 注解。</p><p>在<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#test-auto-configuration">附录</a>中可以找到由<code>@JdbcTest</code>启用的自动配置列表。</p><h4 id="自动配置jOOQ测试"><a href="#自动配置jOOQ测试" class="headerlink" title="自动配置jOOQ测试"></a>自动配置jOOQ测试</h4><h4 id="自动配置MongoDB-Data测试"><a href="#自动配置MongoDB-Data测试" class="headerlink" title="自动配置MongoDB Data测试"></a>自动配置MongoDB Data测试</h4><h4 id="自动配置Neo4j-Data测试"><a href="#自动配置Neo4j-Data测试" class="headerlink" title="自动配置Neo4j Data测试"></a>自动配置Neo4j Data测试</h4><h4 id="自动配置Redis-Data测试"><a href="#自动配置Redis-Data测试" class="headerlink" title="自动配置Redis Data测试"></a>自动配置Redis Data测试</h4><p>如果您想测试Redis应用程序，可以使用<code>@DataRedisTest</code>。默认情况下，它将扫描<code>@RedisHash</code>类，并配置Spring Data Redis存储库。常规的<code>@Component</code> bean不会被加载到<code>ApplicationContext</code>中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataRedisTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataRedisTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> YourRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@DataRedisTest</code>启用的自动配置列表可以在<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#test-auto-configuration">附录</a>中找到。</p><h4 id="自动配置LDAP-Data测试"><a href="#自动配置LDAP-Data测试" class="headerlink" title="自动配置LDAP Data测试"></a>自动配置LDAP Data测试</h4><h4 id="自动配置REST客户端"><a href="#自动配置REST客户端" class="headerlink" title="自动配置REST客户端"></a>自动配置REST客户端</h4><p>如果你想测试REST客户端，可以使用<code>@RestClientTest</code>注释。默认情况下，它将自动配置Jackson和GSON支持，配置<code>RestTemplateBuilder</code>，并添加对<code>MockRestServiceServer</code>的支持。你想要测试的特定bean应该使用<code>@RestClientTest</code>的<code>value</code>或<code>components</code>属性指定:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@RestClientTest(RemoteVehicleDetailsService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRestClientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RemoteVehicleDetailsService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockRestServiceServer server;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getVehicleDetailsWhenResultIsSuccessShouldReturnDetails</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.server.expect(requestTo(<span class="string">&quot;/greet/details&quot;</span>))</span><br><span class="line">                .andRespond(withSuccess(<span class="string">&quot;hello&quot;</span>, MediaType.TEXT_PLAIN));</span><br><span class="line">        String greeting = <span class="keyword">this</span>.service.callRestService();</span><br><span class="line">        assertThat(greeting).isEqualTo(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#test-auto-configuration">附录</a>中可以找到由<code>@RestClientTest</code>启用的自动配置列表。</p><h4 id="自动配置的Spring-REST-Doc测试"><a href="#自动配置的Spring-REST-Doc测试" class="headerlink" title="自动配置的Spring REST Doc测试"></a>自动配置的Spring REST Doc测试</h4><p>如果您想在测试中使用Spring REST Doc，可以使用<code>@AutoConfigureRestDocs</code>注释。它将自动配置<code>MockMvc</code>，以使用Spring REST Doc，并消除Spring REST Doc的JUnit规则的需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(UserController.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDocumentationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvc.perform(get(<span class="string">&quot;/users&quot;</span>).accept(MediaType.TEXT_PLAIN))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andDo(document(<span class="string">&quot;list-users&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@AutoConfigureRestDocs</code>可以用来覆盖默认的输出目录(如果你使用的是Maven则为<code>target/generated-snippets</code>或如果你使用的是Gradle则为<code>build/generated-snippets</code>)。它还可以用于配置在任何文档化的URI中出现的主机、scheme和端口。如果你需要控制更多的Spring REST Doc配置可以使用<code>RestDocsMockMvcConfigurationCustomizer</code> bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationConfiguration</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RestDocsMockMvcConfigurationCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(MockMvcRestDocumentationConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.snippets().withTemplateFormat(TemplateFormats.markdown());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想利用Spring REST Doc的参数化输出目录支持,你可以创建一个<code>RestDocumentationResultHandler</code> bean。自动配置将调用这个结果处理器的<code>alwaysDo</code>，从而导致每个<code>MockMvc</code>调用来自动生成默认的代码片段:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultHandlerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestDocumentationResultHandler <span class="title">restDocumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MockMvcRestDocumentation.document(<span class="string">&quot;&#123;method-name&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Spock来测试Spring-Boot应用程序"><a href="#使用Spock来测试Spring-Boot应用程序" class="headerlink" title="使用Spock来测试Spring Boot应用程序"></a>使用Spock来测试Spring Boot应用程序</h4><p>如果你想用Spock来测试一个Spring Boot应用程序，你应该增加Spock的<code>spock-spring</code>模块的依赖到你的应用程序构建中。<code>spock-spring</code>将Spring的测试框架集成到Spock中。建议你使用Spock 1.1或更高版本，以便从最近对Spock Spring框架和Spring Boot集成的一些改进中获益。请参考<a href="http://spockframework.org/spock/docs/1.1/modules.html">Spock的Spring模块的文档</a>，以了解更多细节。</p><h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><p>一些测试工具类被打包为<code>spring-oot</code>的一部分，这在测试应用程序时通常是有用的。</p><h4 id="ConfigFileApplicationContextInitializer"><a href="#ConfigFileApplicationContextInitializer" class="headerlink" title="ConfigFileApplicationContextInitializer"></a>ConfigFileApplicationContextInitializer</h4><p><code>ConfigFileApplicationContextInitializer</code>是一个 <code>ApplicationContextInitializer</code>,适用于测试加载Spring Boot <code>application.properties</code>文件。当你不需要<code>@SpringBootTest</code>提供的全部功能时，你可以使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(classes = Config.class,</span></span><br><span class="line"><span class="meta">    initializers = ConfigFileApplicationContextInitializer.class)</span></span><br></pre></td></tr></table></figure><blockquote><p>单独使用<code>ConfigFileApplicationContextInitializer</code>不会提供支持<code>@Value(&quot;$&#123;…&#125;&quot;)</code>注入。它的唯一工作就是确保应用<code>application.properties</code>文件被加载到Spring的环境中。对于<code>@Value</code>支持你需要另外配置一个<code>PropertySourcesPlaceholderConfigurer</code>或使用会自动配置的<code>@SpringBootTest</code>。</p></blockquote><h4 id="EnvironmentTestUtils"><a href="#EnvironmentTestUtils" class="headerlink" title="EnvironmentTestUtils"></a>EnvironmentTestUtils</h4><p><code>EnvironmentTestUtils</code>允许你快速为<code>ConfigurableEnvironment</code>或<code>ConfigurableApplicationContext</code>添加属性。只需用使用<code>key=value</code>字符串来调用它:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EnvironmentTestUtils.addEnvironment(env, <span class="string">&quot;org=Spring&quot;</span>, <span class="string">&quot;name=Boot&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="OutputCapture"><a href="#OutputCapture" class="headerlink" title="OutputCapture"></a>OutputCapture</h4><p><code>OutputCapture</code>是一个JUnit <code>Rule</code>，你可以使用它来捕获<code>System.out</code>和<code>System.err</code>输出。只需将捕获声明为一个<code>@Rule</code>，然后使用<code>toString()</code>断言:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.rule.OutputCapture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> OutputCapture capture = <span class="keyword">new</span> OutputCapture();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testName</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        assertThat(capture.toString(), containsString(<span class="string">&quot;World&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TestRestTemplate"><a href="#TestRestTemplate" class="headerlink" title="TestRestTemplate"></a>TestRestTemplate</h4><p><code>TestRestTemplate</code>是一个方便的Spring <code>RestTemplate</code>替代品，它在集成测试中很有用。你可以获得一个普通的模板，或者一个发送基本HTTP身份验证的模板(带有用户名和密码)。在任何一种情况下，模板都将以一种测试友好的方式运行，不会向服务器端错误抛出异常。建议使用Apache HTTP客户端(版本4.3.2或更高的)，这不是强制的，如果在你有类路径中有这个库，那么<code>TestRestTemplate</code>将通过适当地配置客户端来响应。如果你确实使用了Apache的HTTP客户端，将启用一些额外的测试友好特性：</p><ul><li>重定向将不会被执行(因此你可以断言响应位置)</li><li>cookie将被忽略(因此模板是无状态的)</li></ul><p>可以在你的集成测试中直接实例化<code>TestRestTemplate</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestRestTemplate template = <span class="keyword">new</span> TestRestTemplate();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpHeaders headers = template.getForEntity(<span class="string">&quot;http://myhost.com/example&quot;</span>, String.class).getHeaders();</span><br><span class="line">        assertThat(headers.getLocation().toString(), containsString(<span class="string">&quot;myotherhost&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，如果你正在使用<code>@SpringBootTest</code>注解的<code>WebEnvironment.RANDOM_PORT</code>或<code>WebEnvironment.DEFINED_PORT</code>，你只需注入一个完全配置的<code>TestRestTemplate</code>并开始使用它。如果需要，可以通过<code>RestTemplateBuilder</code>来应用额外的定制。任何不指定主机和端口的URL都将自动连接到嵌入式服务器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestRestTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpHeaders headers = template.getForEntity(<span class="string">&quot;/example&quot;</span>, String.class).getHeaders();</span><br><span class="line">        assertThat(headers.getLocation().toString(), containsString(<span class="string">&quot;myotherhost&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestConfiguration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RestTemplateBuilder <span class="title">restTemplateBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RestTemplateBuilder()</span><br><span class="line">                .additionalMessageConverters(...)</span><br><span class="line">                .customizers(...);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h2><p>Spring Boot 为嵌入式Tomcat(8和7)、Jetty 9和Undertow提供WebSockets 自动配置。如果你正在将一个war文件部署到一个独立的容器中，Spring Boot假设容器将负责它的WebSocket支持的配置。</p><p>Spring框架提供了丰富的WebSocket支持，可以通过<code>spring-boot-starter-websocket</code>模块轻松访问。</p><h2 id="Web-Services"><a href="#Web-Services" class="headerlink" title="Web Services"></a>Web Services</h2><p>Spring Boot提供了Web服务的自动配置，因此所有需要的都是定义你的端点。</p><p><a href="http://docs.spring.io/spring-ws/docs/2.4.0.RELEASE/reference/htmlsingle">Spring Web服务的特性</a>可以通过<code>spring-boot-starter-webservices</code>模块轻松地访问。</p><h2 id="创建自己的自动配置"><a href="#创建自己的自动配置" class="headerlink" title="创建自己的自动配置"></a>创建自己的自动配置</h2><p>如果你在一家开发共享库的公司工作，或者你在一个开源或商业库公司工作，你可能想要开发你自己的自动配置。自动配置类可以捆绑在外部jar中，还可以被Spring Boot获取。</p><p>自动配置可以与一个“starter”相关联，它提供了自动配置代码以及你将使用的典型库。我们将首先介绍你需要了解关于构建你自己的自动配置的内容，然后我们将继续介绍<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#boot-features-custom-starter">创建自定义starter所需的典型步骤</a>。</p><p>这里有一个<a href="https://github.com/snicoll-demos/spring-boot-master-auto-configuration">演示项目</a>可以展示如何一步一步地创建一个starter。</p><h3 id="理解自动配置bean"><a href="#理解自动配置bean" class="headerlink" title="理解自动配置bean"></a>理解自动配置bean</h3><p>在外壳之下，自动配置是用标准的<code>@Configuration</code>类实现的。当自动配置应该应用时，还会使用附加的<code>@Conditional</code>注解来约束。通常，自动配置类使用<code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingBean</code>注解。这确保了只有在找到相关类和没有声明自己的<code>@Configuration</code>时才会自动配置。</p><p>你可以浏览<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure"><code>spring-boot-autoconfigure</code></a>的源代码，以查看我们提供的<code>@Configuration</code>类(参见<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories"><code>META-INF/spring.factories</code></a>文件)。</p><h3 id="定位自动配置候选者"><a href="#定位自动配置候选者" class="headerlink" title="定位自动配置候选者"></a>定位自动配置候选者</h3><p>Spring Boot检查在你发布的jar中是否存在<code>META-INF/spring.factories</code>文件。应该在该文件以<code>EnableAutoConfiguration</code> key列出你的配置类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\</span><br><span class="line">com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</span><br></pre></td></tr></table></figure><p>如果你的配置需要按照特定的顺序使用，那么你可以使用<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureAfter.java"><code>@AutoConfigureAfter</code></a>或<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureBefore.java"><code>@AutoConfigureBefore</code></a>注解。例如，如果你提供了web专用的配置，那么你的类可能需要在<code>WebMvcAutoConfiguration</code>之后应用。</p><p>如果你想要排序某些自动配置并且它们不应该对彼此有任何直接的了解，那么你也可以使用<code>@AutoconfigureOrder</code>。该注解与常规的<code>@Order</code>注解具有相同的语义，但提供了自动配置类的专用顺序。</p><blockquote><p>自动配置<em>只能</em>以这种方式加载。确保它们是在特定的包空间中定义的，并且不要对它们使用组件扫描。</p></blockquote><h3 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h3><p>你几乎总是希望在自动配置类中包含一个或多个<code>@Conditional</code>注解。<code>@ConditionalOnMissingBean</code>是一个常见的例子，它允许开发人员在不满意你的默认设置的情况下“覆盖”自动配置。</p><p>Spring Boot包含许多<code>@Conditional</code>注解，可以通过注解<code>@Configuration</code>类或单独的<code>@Bean</code>方法在自己的代码中重用。</p><h4 id="类条件"><a href="#类条件" class="headerlink" title="类条件"></a>类条件</h4><p><code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingClass</code>注解允许基于特定类的存在与否来是否包含该配置。由于使用<a href="http://asm.ow2.org/">ASM</a>解析注解元数据，所以实际上可以使用<code>value</code>属性引用真正的类，即使这个类可能不会出现在正在运行的应用程序类路径中。如果你喜欢使用<code>String</code>值指定类名，那么也可以使用<code>name</code>属性。</p><blockquote><p>如果你使用<code>@ConditionalOnClass</code>或<code>@ConditionalOnMissingClass</code>作为元注解的一部分来组成你自己的组合注解，你必须使用<code>name</code>来指定类在这种情况下不处理。</p></blockquote><h4 id="Bean条件"><a href="#Bean条件" class="headerlink" title="Bean条件"></a>Bean条件</h4><p><code>@ConditionalOnBean</code> 和<code>@ConditionalOnMissingBean</code>注解允许根据特定bean的存在或不存在来是否包含bean。你可以使用<code>value</code>属性来按类型指定bean，也可以通过<code>name</code>指定bean。<code>search</code>属性允许你在搜索bean时限制应该考虑的<code>ApplicationContext</code>层次结构。</p><p>当被放置在<code>@Bean</code>方法上时，目标类型默认为该方法的返回类型，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，如果在<code>ApplicationContext</code>中没有包含类型<code>MyService</code>的bean，那么将创建<code>myService</code> bean。</p><blockquote><p>你需要非常谨慎地处理bean定义的顺序，因为这些条件是根据目前处理的内容进行计算的。出于这个原因，我们建议只在自动配置类上使用<code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>注解(因为在添加了任何用户定义的bean定义之后，这些注解就会被加载)。</p></blockquote><blockquote><p><code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>不会阻止<code>@Configuration</code>类的创建。在类级别上使用这些条件相当于用注解标记每个包含的<code>@Bean</code>方法。</p></blockquote><h4 id="属性条件"><a href="#属性条件" class="headerlink" title="属性条件"></a>属性条件</h4><p><code>@ConditionalOnProperty</code>注解允许基于Spring Environment属性来是否包含配置。使用<code>prefix</code>和<code>name</code>属性来指定应该检查的属性。默认情况下，任何存在且不等于<code>false</code>的属性将被匹配。你还可以使用<code>havingValue</code>和<code>matchIfMissing</code>属性创建更高级的检查。</p><h4 id="资源条件"><a href="#资源条件" class="headerlink" title="资源条件"></a>资源条件</h4><p><code>@ConditionalOnResource</code>注解只允许在特定的资源出现时才包含配置。资源可以指定使用通常的Spring 的约定,例如,<code>file:/home/user/test.dat</code>。</p><h4 id="Web应用条件"><a href="#Web应用条件" class="headerlink" title="Web应用条件"></a>Web应用条件</h4><p><code>@@ConditionalOnWebApplication</code>和<code>@ConditionalOnNotWebApplication</code>注解允许取决于应用是一个“web应用”来是否包含配置。一个web应用是使用Spring <code>WebApplicationContext</code>,定义了一个<code>session</code> scope或拥有<code>StandardServletEnvironment</code>的任何应用。</p><h4 id="SpEL表达式条件"><a href="#SpEL表达式条件" class="headerlink" title="SpEL表达式条件"></a>SpEL表达式条件</h4><p><code>@ConditionalOnExpression</code>注解允许基于<a href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/core.html#expressions">SpEL表达式</a>的结果包含配置。</p><h3 id="创建自己的starter"><a href="#创建自己的starter" class="headerlink" title="创建自己的starter"></a>创建自己的starter</h3><p>对于一个库，一个完整的Spring Boot starter可能包含以下组件:</p><ul><li>包含自动配置代码的<code>autoconfigure</code>模块</li><li>启动器模块提供对 autoconfigure 模块的依赖，以及库和其他通常有用的附加依赖项。简而言之，添加这个starter应该足以开始使用该库。</li></ul><blockquote><p>如果你不需要将这两个关注点分开，你可以将自动配置代码和依赖项管理合并在一个模块中。</p></blockquote><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>请确保为你的starter提供适当的命名空间。不要以<code>spring-boot</code> 开头，即使你使用的是不同的Maven  groupId。我们可能会在将来为你自动配置的东西提供官方支持。</p><p>这是一个经验法则。让我们假设你正在为“acme”创建一个starter，请将自动配置模块命名为<code>acme-spring-boot-autoconfigure</code>和starter命名为<code>acme-spring-boot-starter</code>。如果你只有一个组合了这两个模块的模块，那就使用<code>acme-spring-boot-starter</code>。</p><p>此外，如果你的启动器提供了配置  key，那么为它们使用适当的命名空间。特别是，不要将你的key包含在Spring Boot 使用的命名空间中(例如<code>server</code>, <code>management</code>, <code>spring</code>等)。这些都是“我们的”，我们可以在将来改进/修改它们，这样可能破坏你的东西。</p><p>确保<a href="http://www.doczh.site/docs/spring-boot/spring-boot-docs/current/en/reference/htmlsingle/index.html#configuration-metadata-annotation-processor">触发元数据生成</a>，以便你的key也可以使用IDE辅助功能。你可能需要检查生成的元数据(<code>META-INF/spring-configuration-metadata.json</code>)，以确保你的key被正确地记录。</p><h4 id="自动配置模块"><a href="#自动配置模块" class="headerlink" title="自动配置模块"></a>自动配置模块</h4><p>autoconfigure 模块包含了从这个库启动的所有必要的内容。它还可能包含配置key定义(<code>@ConfigurationProperties</code>)和任何可用于进一步定制组件如何初始化的回调接口。</p><blockquote><p>你应该将对库的依赖项标记为可选的，这样你就可以更容易地在你的项目中包含autoconfigure模块。如果你这样做，将不会提供这些库，而且Spring Boot将默认关闭。</p></blockquote><h4 id="starter模块"><a href="#starter模块" class="headerlink" title="starter模块"></a>starter模块</h4><p>starter是一个空jar。它的唯一目的是提供必要的依赖项来与库一起工作;把它看作需要什么上手的自以为是的观点（不懂）。</p><p>不要对starter添加的项目做出假设。 如果你自动配置的库通常需要其他starter，请提及它们。 如果可选依赖关系的数量高，则提供一组适当的<em>默认依赖</em>关系可能会很困难，因为你应避免为库的典型用法带来不必要的依赖关系。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> 特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo学习7-只订阅服务不注册</title>
      <link href="/post/beda/"/>
      <url>/post/beda/</url>
      
        <content type="html"><![CDATA[<p>在实际开发过程中，经常会共用一个注册中心，这时如果我们的服务还没有开发好，可能就会影响消费者不能正常运行。这个时候可以让这个开发者只订阅注册中心（因为有可能会需要调用其他的服务），但是不注册上去，消费者直接连接到这个开发中的提供者。<br>禁用注册配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://localhost:2181&quot;</span> <span class="attr">register</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://localhost:2181?register=false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>关系图：<br><img src="http://ooll8xqpq.bkt.clouddn.com/subscribe-only.jpg" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> 订阅 </tag>
            
            <tag> 注册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo学习6-直连提供者</title>
      <link href="/post/e377/"/>
      <url>/post/e377/</url>
      
        <content type="html"><![CDATA[<p>在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连。在点对点直连方式下，将以服务接口为单位，忽略注册中心的提供者列表，A接口配置点对点，不影响B接口从注册中心获取列表。</p><h3 id="三种实现方式"><a href="#三种实现方式" class="headerlink" title="三种实现方式"></a>三种实现方式</h3><h4 id="Reference-Config"><a href="#Reference-Config" class="headerlink" title="Reference Config"></a>Reference Config</h4><p>如果是线上需求需要点对点，可以在xml和dubbo.properties文件中通过url属性指定提供者，这将绕过注册中心，如有多个地址用分号隔开。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;life.qzz.dubbodemo.api.DemoService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">url</span>=<span class="string">&quot;dubbo://localhost:20880&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h4><p>在JVM启动参数中加入<code>-D</code>参数映射服务地址，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dlife.qzz.dubbodemo.api.DemoService=dubbo://localhost:20880</span><br></pre></td></tr></table></figure><p>key为服务名，value为服务提供者url，此配置优先级最高。<br><strong>为了避免复杂化线上环境，不要在线上使用这个功能，只应在测试环境使用（暂时还无法理解）</strong></p><h4 id="文件映射"><a href="#文件映射" class="headerlink" title="文件映射"></a>文件映射</h4><p>如果服务较多，也可以用文件映射，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Ddubbo.resolve.file=dubbo-resolve.properties</span><br></pre></td></tr></table></figure><p>dubbo-resolve.properties文件中配置服务映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">life.qzz.dubbodemo.api.DemoService&#x3D;dubbo:&#x2F;&#x2F;localhost:20880</span><br></pre></td></tr></table></figure><p>此配置优先级高于<a href="dubbo:reference/">dubbo:reference/</a>中的配置，2.0以上的版本会自动加载${user.home}/dubbo-resolve.properties文件，不需要配置。</p><p>优先级关系：</p><p><img src="http://ooll8xqpq.bkt.clouddn.com/dubbo-directly.jpg" alt="image"></p><p><strong>为了避免复杂化线上环境，不要在线上使用这个功能，只应在测试阶段使用。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> 直连提供者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo学习5-restfull接口</title>
      <link href="/post/dc62/"/>
      <url>/post/dc62/</url>
      
        <content type="html"><![CDATA[<h4 id="使用jax-rs和dubbo来搭建restfull接口"><a href="#使用jax-rs和dubbo来搭建restfull接口" class="headerlink" title="使用jax-rs和dubbo来搭建restfull接口"></a>使用jax-rs和dubbo来搭建restfull接口</h4><h5 id="需要用到的框架："><a href="#需要用到的框架：" class="headerlink" title="需要用到的框架："></a>需要用到的框架：</h5><ul><li>jax-rs</li><li>dubbo</li><li>resteasy-client</li><li>org.mortbay.jetty(因为dubbo支持的jetty版本比较老)</li></ul><h5 id="完整的pom文件："><a href="#完整的pom文件：" class="headerlink" title="完整的pom文件："></a>完整的pom文件：</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.resteasy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxrs-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.12.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.resteasy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resteasy-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.4.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">        &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">        &lt;artifactId&gt;jetty-server&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">        &lt;version&gt;9.4.0.M1&lt;/version&gt;</span></span><br><span class="line"><span class="comment">    &lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">    &lt;dependency&gt;</span></span><br><span class="line"><span class="comment">        &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">        &lt;artifactId&gt;jetty-webapp-logging&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">        &lt;version&gt;9.0.0&lt;/version&gt;</span></span><br><span class="line"><span class="comment">    &lt;/dependency&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">        &lt;groupId&gt;io.netty&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">        &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">        &lt;version&gt;4.1.13.Final&lt;/version&gt;</span></span><br><span class="line"><span class="comment">    &lt;/dependency&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>life.qzz<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo5.api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="provider"><a href="#provider" class="headerlink" title="provider:"></a>provider:</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Path(&quot;demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Path(&quot;hello&quot;)</span></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="meta">@Produces(MediaType.APPLICATION_JSON)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;服务调用开始&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;message\&quot;: \&quot;hello\&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="dubbo的配置："><a href="#dubbo的配置：" class="headerlink" title="dubbo的配置："></a>dubbo的配置：</h6><p>dubbo.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">dubbo.application.name</span>=<span class="string">helloapp</span></span><br><span class="line"><span class="meta">dubbo.registry.address</span> = <span class="string">zookeeper://localhost:2181</span></span><br><span class="line"><span class="meta">dubbo.protocol.name</span>=<span class="string">rest</span></span><br><span class="line"><span class="meta">dubbo.protocol.port</span> = <span class="string">20880</span></span><br></pre></td></tr></table></figure><p><strong>在dubbo.properties中指定协议为<code>rest</code>不起作用，需要在xml中指定。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 需要在这里指定协议,默认的server为jetty--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;rest&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;life.qzz.dubbodemo.api.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;life.qzz.dubbodemo.api.impl.DemoServiceImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>使用postman发起请求：<code>http://localhost:20880/demo/hello</code>，返回结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;message&quot;</span>: <span class="string">&quot;hello&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>这里简单地返回了一个字符串，如果要像spring mvc一样自动将返回对象序列化，得自己实现，会报下面的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jboss.resteasy.core.NoMessageBodyWriterFoundFailure: Could not find MessageBodyWriter <span class="keyword">for</span> response object of type: life.qzz.dubbodemo.api.User of media type: application/json</span><br></pre></td></tr></table></figure><p>如要使用jackson来序列化Json，加入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.resteasy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resteasy-jackson-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.4.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> restfull </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo学习1- 配置</title>
      <link href="/post/c1b3/"/>
      <url>/post/c1b3/</url>
      
        <content type="html"><![CDATA[<h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><p>dubbo通过spring的xml文件进行配置，可以方便地与spring进行集成。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>下面是一个简单的provider端配置示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--应用名称，用于区分服务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;hello-app&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义一个协议，以及使用的端口号--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义注册中心--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://localhost:2181&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义一个服务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;life.qzz.dubbodemo.api.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring的bean，服务会引用到它作为具体的实现--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;life.qzz.dubbodemo.api.impl.DemoServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>consumer端配置示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;hello-app&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://localhost:2181&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用的服务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;life.qzz.dubbodemo.api.DemoService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在对dubbo进行扩展时，可以通过<code>&lt;dubbo:parameter&gt;</code>标签来设置自定义参数，同时也支持spring的<code>p</code>标签。如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;jms&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">&quot;queue&quot;</span> <span class="attr">value</span>=<span class="string">&quot;http://localhost/queue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:protocol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;jms&quot;</span> <span class="attr">p:queue</span>=<span class="string">&quot;http://localhost/queue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="配置关系图"><a href="#配置关系图" class="headerlink" title="配置关系图"></a>配置关系图</h4><p><img src="http://ooll8xqpq.bkt.clouddn.com/dubbo_config_relation.png" alt="image"></p><ul><li><a href="dubbo:service/">dubbo:service/</a> 服务配置，用于暴露一个服务，定义服务的元数据，一个服务可以用多种协议暴露，也可以注册到多个注册中心。</li><li><a href="dubbo:reference/">dubbo:reference/</a> 引用配置，用于创建一个远程服务代理，一个引用可以指向多个注册中心。</li><li><a href="dubbo:protocol/">dubbo:protocol/</a> 协议配置，用于定义暴露服务的协议。协议由提供方定义，消费方被动接受。</li><li><a href="dubbo:application/">dubbo:application/</a> 应用配置，用于配置当前应用信息。</li><li><a href="dubbo:module/">dubbo:module/</a> 模块配置，用于配置当前模块信息，可选。</li><li><a href="dubbo:registry/">dubbo:registry/</a> 注册中心配置，用于配置连接注册中心相关配置。</li><li><a href="dubbo:monitor/">dubbo:monitor/</a> 监控中心配置，用于配置监控中心相关配置，可选。</li><li><a href="dubbo:provider/">dubbo:provider/</a> 提供方缺省配置，当ProtocolConfig和ServiceConfig某属性没有配置时，使用此缺省值，可选。</li><li><a href="dubbo:consumer/">dubbo:consumer/</a> 消费方缺省配置，当ReferenceConfig某属性没有配置时，使用此缺省值，可选。</li><li><a href="dubbo:method/">dubbo:method/</a> 方法配置，为ServiceConfig和ReferenceConfig指定方法级别的配置信息。</li><li><a href="dubbo:argument/">dubbo:argument/</a> 用于指定方法参数配置。</li></ul><h4 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h4><p><img src="http://ooll8xqpq.bkt.clouddn.com/dubbo-config-override.jpg" alt="image"></p><ul><li>上图中以timeout为值，显示了配置的查找顺序，其他retires，loadbalance，actives等类似。</li></ul><ol><li>方法级优先，接口级次之，全局配置再次之。</li><li>如果级别一样，则消费方优先，提供方再次之。</li></ol><ul><li>服务提供者的配置，通过URL由注册中心传递给服务消费者。</li><li>建议由服务提供者设置超时时间，因为一个方法要执行多久，提供方很清楚，如果一个服务消费者同时引用多个提供者，则无需关心超时时间。</li><li>理论上ReferenceConfig的非标识配置，在ConsumerConfig，ServiceConfig，ProviderConfig均可缺省配置（比如：只需要配置id和interface）。</li></ul><p><strong>上面的优先级查找顺序只针对提供者和消费者都是dubbo实现的，比如如果消费者是浏览器，提供者用的是rest协议，那么这种优先级关系应该不存在。</strong></p><p><a href="https://github.com/qzzsunly/dubbodemo/tree/master/demo1">demo地址</a></p><h3 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h3><ul><li>如果公共配置很简单，需要多个Spring容器共享配置，可以使用dubbo.properties作为缺省配置。</li><li>Dubbo会自动加载classpath根目录下的dubbo.properties，可以通过JVM启动参数`-Ddubbo.properties.file=xxx.properties<br>改变缺省配置位置。</li></ul><p><strong>如果classpath根目录下存在多个dubbo.properties文件，比如多个jar包中有dubbo.properties，Dubbo会任意加载，这容易导致混乱，所以最好只用一个dubbo.properties文件。</strong></p><h4 id="映射规则"><a href="#映射规则" class="headerlink" title="映射规则"></a>映射规则</h4><p>属性文件的key值与xml的配置存在一定的映射关系。</p><ol><li>将XML配置的标签名，加上属性名，再用点<code>.</code>进行分隔，多个属性拆成多行书写。比如：</li></ol><ul><li>dubbo.application.name=hello 等价于&lt;dubbo:application name=”hello”/&gt;</li><li>dubbo.registry.address=zookeeper://localhost:2181 等价于&lt;dubbo:registry address=”zookeeper://localhost:2181”/&gt;</li></ul><ol start="2"><li>如果XML有多行同名标签配置，可以用id进行区分，如果没有id号将对所有同名标签生效。比如：</li></ol><ul><li>dubbo.protocol.rmi.port=1099 等价于&lt;dubbo:protocol id=”rmi” name=”rmi” port=”1099”/&gt;(协议的id没配时，缺省使用协议名作为id)</li><li>dubbo.registry.china.address = zookeeper://localhost:2181 等价于 &lt;dubbo:registry id =”china” address=”zookeeper://localhost:2181”/&gt;</li></ul><h4 id="典型配置"><a href="#典型配置" class="headerlink" title="典型配置"></a>典型配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">dubbo.application.name</span>=<span class="string">hello</span></span><br><span class="line"><span class="meta">dubbo.application.owner</span>=<span class="string">qzz</span></span><br><span class="line"><span class="meta">dubbo.registry.address</span>=<span class="string">zookeeper://localhost:2181</span></span><br></pre></td></tr></table></figure><h4 id="覆盖策略"><a href="#覆盖策略" class="headerlink" title="覆盖策略"></a>覆盖策略</h4><p><img src="http://ooll8xqpq.bkt.clouddn.com/dubbo-properties-override.jpg" alt="image"></p><ul><li>JVM启动参数优先，这样可以在部署和启动的时候进行参数重写，比如在启动的时候改变协议的端口号。</li><li>XML次之，如果在XML中有配置，则dubbo.properties中的相应配置项会失效。</li><li>Properties最后，相当于缺省值，只有XML和启动参数都有没有对应的配置项时，dubbo.properties中的相应配置项才会生效，通常用于共享公共配置，比如应用名。</li></ul><h3 id="API配置"><a href="#API配置" class="headerlink" title="API配置"></a>API配置</h3><p>API配置的使用范围用来做OpenAPI，ESB，Test，Mock等系统集成，普通服务的提供方和消费方，宜采用其他配置方式。API的属性与配置项一一对应，如：ApplicationConfig.setName(“hello”)对应&lt;dubbo:application name=”hello”/&gt;。</p><h4 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> life.qzz.dubbodemo.api.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ProtocolConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ServiceConfig;</span><br><span class="line"><span class="keyword">import</span> life.qzz.dubbodemo.api.DemoService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*ApplicationContext context = new ClassPathXmlApplicationContext(&quot;provider.xml&quot;);</span></span><br><span class="line"><span class="comment">        System.in.read();*/</span></span><br><span class="line"></span><br><span class="line">        DemoService demoService = <span class="keyword">new</span> DemoServiceImpl();</span><br><span class="line">       <span class="comment">//应用配置</span></span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册中心配置</span></span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig(<span class="string">&quot;zookeeper://localhost:2181&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//协议配置</span></span><br><span class="line">        ProtocolConfig protocolConfig = <span class="keyword">new</span> ProtocolConfig(<span class="string">&quot;dubbo&quot;</span>,<span class="number">20880</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务配置</span></span><br><span class="line">        ServiceConfig&lt;DemoService&gt; serviceConfig = <span class="keyword">new</span> ServiceConfig&lt;&gt;();</span><br><span class="line">        serviceConfig.setInterface(DemoService.class);</span><br><span class="line">        serviceConfig.setRef(demoService);</span><br><span class="line">        serviceConfig.setProtocol(protocolConfig);</span><br><span class="line">        serviceConfig.setRegistry(registryConfig);</span><br><span class="line">        serviceConfig.setApplication(applicationConfig);</span><br><span class="line">        serviceConfig.export();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> life.qzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ReferenceConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> life.qzz.dubbodemo.api.DemoService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hello world!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">/* System.out.println( &quot;Hello World!&quot; );</span></span><br><span class="line"><span class="comment">        new ClassPathXmlApplicationContext(&quot;consumer.xml&quot;).getBean(DemoController.class).sayHello(&quot;qzzz&quot;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//应用配置</span></span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册中心配置</span></span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig(<span class="string">&quot;zookeeper://localhost:2181&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//引用配置</span></span><br><span class="line">        ReferenceConfig&lt;DemoService&gt; r = <span class="keyword">new</span> ReferenceConfig&lt;&gt;();</span><br><span class="line">        r.setInterface(DemoService.class);</span><br><span class="line">        r.setRegistry(registryConfig);</span><br><span class="line">        r.setApplication(applicationConfig);</span><br><span class="line">        DemoService service = r.get();<span class="comment">//注意：此代理对象内部封装了所有通讯细节，对象较重，请缓存复用</span></span><br><span class="line">        System.out.println( service.sayHello(<span class="string">&quot;qzz&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="特殊场景"><a href="#特殊场景" class="headerlink" title="特殊场景"></a>特殊场景</h4><h5 id="方法级配置"><a href="#方法级配置" class="headerlink" title="方法级配置"></a>方法级配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法级配置</span></span><br><span class="line">List&lt;MethodConfig&gt; methods = <span class="keyword">new</span> ArrayList&lt;MethodConfig&gt;();</span><br><span class="line">MethodConfig method = <span class="keyword">new</span> MethodConfig();</span><br><span class="line">method.setName(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">method.setTimeout(<span class="number">10000</span>);</span><br><span class="line">method.setRetries(<span class="number">0</span>);</span><br><span class="line">methods.add(method);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用远程服务</span></span><br><span class="line">ReferenceConfig&lt;DemoService&gt; reference = <span class="keyword">new</span> ReferenceConfig&lt;DemoService&gt;(); <span class="comment">// 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏</span></span><br><span class="line"></span><br><span class="line">reference.setMethods(methods); <span class="comment">// 设置方法级配置</span></span><br></pre></td></tr></table></figure><h5 id="点对点直连"><a href="#点对点直连" class="headerlink" title="点对点直连"></a>点对点直连</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReferenceConfig&lt;DemoService&gt; reference = <span class="keyword">new</span> ReferenceConfig&lt;DemoService&gt;(); <span class="comment">// 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏</span></span><br><span class="line"><span class="comment">// 如果点对点直连，可以用reference.setUrl()指定目标地址，设置url后将绕过注册中心，</span></span><br><span class="line"><span class="comment">// 其中，协议对应provider.setProtocol()的值，端口对应provider.setPort()的值，</span></span><br><span class="line"><span class="comment">// 路径对应service.setPath()的值，如果未设置path，缺省path为接口名</span></span><br><span class="line">reference.setUrl(<span class="string">&quot;dubbo://localhost:20880/com.xxx.XxxService&quot;</span>); </span><br></pre></td></tr></table></figure><p>官方文档上说<code>ServiceConfig</code>，<code>ReferenceConfig</code>为重对象，内部封装了与注册中心的连接，以及与服务提供者的连接，需要缓存，否则会造成内存和连接泄露。这里有点儿疑问：</p><ol><li>需要暴露多个服务的时候需要new 多个ServiceConfig实例，每个实例中者封装了与注册中心的连接。这个应该没毛病，每个服务可以使用不一样的注册中心。个人觉得<code>ApplicationConfig</code>,<code>RegistryConfig</code>,<code>ProtocolConfig</code>这些实例应该单独实例化之后，再设置到<code>ServiceConfig</code>，<code>ReferenceConfig</code>中去比较好吧，因为<code>ApplicationConfig</code>这些只需要初始化一次之后，可以在多个<code>ServiceConfig</code>和<code>ReferenceConfig</code>中引用，不需要在每个<code>ServiceConfig</code>，<code>ReferenceConfig</code>配置的过程中初始化。</li><li>在什么样的情况下需要获取这些实例？一般服务暴露出去之后这个实例也就用不上了吧？在做系统集成的时候如果需要管理这些Service的话，应该是需要拿到这些配置对象的。</li></ol><p><a href="https://github.com/qzzsunly/dubbodemo/blob/master/demo0">demo地址</a></p><h3 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h3><p>dubbo 2.2.1以上版本开始支持注解配置。</p><h4 id="服务提供方注解"><a href="#服务提供方注解" class="headerlink" title="服务提供方注解"></a>服务提供方注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> life.qzz.dubbodemo.api.DemoService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露服务</span></span><br><span class="line"><span class="meta">@Service(version = &quot;1.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello :&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;hello-app&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://localhost:2181&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 扫描注解包路径，多个包用逗号分隔，不填pacakge表示扫描当前ApplicationContext中所有的类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">&quot;life.qzz.dubbodemo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="服务消费方注解"><a href="#服务消费方注解" class="headerlink" title="服务消费方注解"></a>服务消费方注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Reference(version = &quot;1.0&quot;)</span><span class="comment">//引用服务</span></span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(demoService.sayHello(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;hello-app&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://localhost:2181&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 扫描注解包路径，多个包用逗号分隔，不填pacakge表示扫描当前ApplicationContext中所有的类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">&quot;life.qzz.dubbodemo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>也可以使用spring的component-scan：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:annotation</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;life.qzz.dubbodemo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;com.alibaba.dubbo.config.annotation.Service&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/qzzsunly/dubbodemo/tree/master/demo2">demo地址</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo学习4-集群容灾与负载均衡配置</title>
      <link href="/post/154c/"/>
      <url>/post/154c/</url>
      
        <content type="html"><![CDATA[<h4 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h4><p>调用关系图：</p><p><img src="http://ooll8xqpq.bkt.clouddn.com/cluster.jpg" alt="调用关系图"></p><ul><li>这里的Invoker是Provider的一个可调用Service的抽象，Invoder封装了Provider的地址和Service接口信息。</li><li>Direcotry代表多个Invoder，可以看成是List<Invoder>，但与List不同的是，它的值可能是动态变化的，比如注册中心推送变更。</Invoder></li><li>Cluster将Directory中的多个Invoder伪装成一个Invoder，对上层透明，伪装过程包含了容错逻辑，调用失败后，根据容错逻辑进行接下来的处理。</li><li>Router负责从多个Invoder中按路由规则选出子集，比如读写分离，应用隔离等。</li><li>LoadBalance负责从多个Invoder中选出具体的一个去进行调用，选的过程包含了负载均衡算法，调用失败后可能需要重选。</li></ul><h5 id="dubbo提供的容错模式"><a href="#dubbo提供的容错模式" class="headerlink" title="dubbo提供的容错模式"></a>dubbo提供的容错模式</h5><h6 id="Failover-Cluster-失败自动切换"><a href="#Failover-Cluster-失败自动切换" class="headerlink" title="Failover Cluster 失败自动切换"></a>Failover Cluster 失败自动切换</h6><ul><li>当出现失败时，重试其他服务器（默认）</li><li>通常用于读操作，但重试会带来更长延迟</li><li>可通过<code>retries</code>来设置重试次数（不含第一次）</li></ul><h6 id="Failfast-Cluster-快速失败"><a href="#Failfast-Cluster-快速失败" class="headerlink" title="Failfast Cluster 快速失败"></a>Failfast Cluster 快速失败</h6><ul><li>只发起一次调用，失败立即报错</li><li>通常用于非幂等性的操作，比如新增记录</li></ul><h6 id="Failsafe-Cluster-失败安全"><a href="#Failsafe-Cluster-失败安全" class="headerlink" title="Failsafe Cluster 失败安全"></a>Failsafe Cluster 失败安全</h6><ul><li>出现异常时直接忽略</li><li>通常用于写入审记日志等操作</li></ul><h6 id="Failback-Cluster-失败自动恢复"><a href="#Failback-Cluster-失败自动恢复" class="headerlink" title="Failback Cluster 失败自动恢复"></a>Failback Cluster 失败自动恢复</h6><ul><li>后台记录失败请求，定时重发</li><li>通常用于消息通知操作</li></ul><h6 id="Forking-Cluster-并行调用"><a href="#Forking-Cluster-并行调用" class="headerlink" title="Forking Cluster 并行调用"></a>Forking Cluster 并行调用</h6><ul><li>并行调用多个服务器，只要一个成功即返回</li><li>通常用于实时性要求较高的读操作，但需要浪费更多服务资源</li><li>可以通过<code>forks</code> 来设置最大并行数</li></ul><h6 id="Broadcast-Cluster-广播调用"><a href="#Broadcast-Cluster-广播调用" class="headerlink" title="Broadcast Cluster 广播调用"></a>Broadcast Cluster 广播调用</h6><ul><li>广播调用所有提供者，逐个调用，任意一台报错则报错</li><li>通常用于通知所有提供者更新缓存或日志等本地资源信息</li></ul><p>重试次数配置如：（failover模式生效）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">retries</span> = <span class="string">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">retries</span> =<span class="string">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span> =<span class="string">&quot;sayHello&quot;</span> <span class="attr">retries</span> = <span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><p>集群模式配置如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span> =<span class="string">&quot;failsafe&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">&quot;failsafe&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h5><p>提供了两个provider，代码基本一致，端口号不一样。为了能模拟失败的场景，设置了超时时间，并且在service的代码中加入了线程休眠。当进入service的方法中时，手动结束掉进程，观察consumer端的反应。</p><p>provider1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;服务调用前&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        logger.debug(<span class="string">&quot;服务调用开始&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello :&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dubbo.application.name=helloapp</span><br><span class="line">dubbo.registry.address = zookeeper:<span class="comment">//localhost:2181</span></span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">dubbo.protocol.port = <span class="number">20880</span></span><br></pre></td></tr></table></figure><p>provider2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;调用Provider2的服务&quot;</span>);</span><br><span class="line">        logger.debug(<span class="string">&quot;休息20秒&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello :&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dubbo.application.name=helloapp</span><br><span class="line">dubbo.registry.address = zookeeper:<span class="comment">//localhost:2181</span></span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">dubbo.protocol.port = <span class="number">20881</span></span><br></pre></td></tr></table></figure><p>consumer：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">&quot;life.qzz.dubbodemo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;life.qzz.dubbodemo.api.DemoService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">init</span>=<span class="string">&quot;true&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;50000&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;服务返回结果：&#123;&#125;&quot;</span> , demoService.sayHello(name));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h6><ol><li>failover<br>开始调用provider1，线程进行休眠，这时结束provider1的进程。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[DubboServerHandler-10.96.2.111:20880-thread-5] DemoServiceImpl.sayHello(20) | 服务调用前</span><br></pre></td></tr></table></figure></li></ol><p>consumer出现了连接异常错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.net.ConnectException: Connection refused: no further information: /<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20880</span></span><br><span class="line">at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)</span><br><span class="line">at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:<span class="number">717</span>)</span><br><span class="line">at org.jboss.netty.channel.socket.nio.NioClientBoss.connect(NioClientBoss.java:<span class="number">150</span>)</span><br><span class="line">at org.jboss.netty.channel.socket.nio.NioClientBoss.processSelectedKeys(NioClientBoss.java:<span class="number">105</span>)</span><br><span class="line">at org.jboss.netty.channel.socket.nio.NioClientBoss.process(NioClientBoss.java:<span class="number">79</span>)</span><br><span class="line">at org.jboss.netty.channel.socket.nio.AbstractNioSelector.run(AbstractNioSelector.java:<span class="number">312</span>)</span><br><span class="line">at org.jboss.netty.channel.socket.nio.NioClientBoss.run(NioClientBoss.java:<span class="number">42</span>)</span><br><span class="line">... <span class="number">3</span> more</span><br></pre></td></tr></table></figure><p>但是consumer的方法还没结束，日志中打印了如下信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:<span class="number">79</span>) WARN [main] FailoverClusterInvoker.doInvoke(<span class="number">79</span>) |  [DUBBO] Although retry the method sayHello in the service life.qzz.dubbodemo.api.DemoService was successful by the provider <span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20881</span>, but there have been failed providers [<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20880</span>] (<span class="number">1</span>/<span class="number">1</span>) from the registry localhost:<span class="number">2181</span> on the consumer <span class="number">10.96</span>.<span class="number">2.111</span> using the dubbo version <span class="number">2.8</span>.<span class="number">4.</span> </span><br></pre></td></tr></table></figure><p>provider1调用失败了，重新调用了provider2的方法。provider2打印出了日志，并且consumer也打印出了返回的信息。</p><p>consumer日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">life.qzz.dubbodemo.controller.DemoController.hello(DemoController.java:<span class="number">27</span>) DEBUG [main] DemoController.hello(<span class="number">27</span>) | 服务返回结果：hello :qzz</span><br></pre></td></tr></table></figure><p>provider2日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">life.qzz.dubbodemo.api.impl.DemoServiceImpl.sayHello(DemoServiceImpl.java:<span class="number">20</span>) DEBUG [DubboServerHandler-<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20881</span>-thread-<span class="number">2</span>] DemoServiceImpl.sayHello(<span class="number">20</span>) | 调用Provider2的服务</span><br><span class="line">life.qzz.dubbodemo.api.impl.DemoServiceImpl.sayHello(DemoServiceImpl.java:<span class="number">21</span>) DEBUG [DubboServerHandler-<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20881</span>-thread-<span class="number">2</span>] DemoServiceImpl.sayHello(<span class="number">21</span>) | 休息<span class="number">20</span>秒</span><br></pre></td></tr></table></figure><h6 id="failsafe"><a href="#failsafe" class="headerlink" title="failsafe"></a>failsafe</h6><p>provider的配置不用改，consumer的配置改为如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">&quot;life.qzz.dubbodemo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;life.qzz.dubbodemo.api.DemoService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">init</span>=<span class="string">&quot;true&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;50000&quot;</span> <span class="attr">cluster</span>=<span class="string">&quot;failsafe&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>超时之后出现错误，consumer打印出了null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.dubbo.rpc.cluster.support.FailsafeClusterInvoker.doInvoke(FailsafeClusterInvoker.java:<span class="number">50</span>) ERROR [main] FailsafeClusterInvoker.doInvoke(<span class="number">50</span>) |  [DUBBO] Failsafe ignore exception: Invoke remote method timeout.</span><br><span class="line">life.qzz.dubbodemo.controller.DemoController.hello(DemoController.java:<span class="number">27</span>) DEBUG [main] DemoController.hello(<span class="number">27</span>) | 服务返回结果：<span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>并没有去调用另一个provider，我们的方法也没有抛出异常，也就是说错误没有在暴露给我们的方法。</p><h6 id="failfast"><a href="#failfast" class="headerlink" title="failfast"></a>failfast</h6><p>出现了异常信息，consumer没有打印出日志，也就是说我们的方法出现了异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> com.alibaba.dubbo.rpc.RpcException: Failfast invoke providers dubbo:<span class="comment">//10.96.2.111:20881/life.qzz.dubbodemo.api.DemoService?anyhost=true&amp;application=helloapp&amp;check=false&amp;cluster=failfast&amp;default.check=false&amp;dubbo=2.8.4&amp;generic=false&amp;init=true&amp;interface=life.qzz.dubbodemo.api.DemoService&amp;methods=sayHello&amp;pid=11248&amp;side=consumer&amp;timeout=50000&amp;timestamp=1501137556130 RandomLoadBalance select from all providers [com.alibaba.dubbo.registry.integration.RegistryDirectory$InvokerDelegete@6950ed69, com.alibaba.dubbo.registry.integration.RegistryDirectory$InvokerDelegete@6dd7b5a3] for service life.qzz.dubbodemo.api.DemoService method sayHello on consumer 10.96.2.111 use dubbo version 2.8.4, but no luck to perform the invocation. Last error is: Invoke remote method timeout. method: sayHello, provider: dubbo://10.96.2.111:20881/life.qzz.dubbodemo.api.DemoService?anyhost=true&amp;application=helloapp&amp;check=false&amp;cluster=failfast&amp;default.check=false&amp;dubbo=2.8.4&amp;generic=false&amp;init=true&amp;interface=life.qzz.dubbodemo.api.DemoService&amp;methods=sayHello&amp;pid=11248&amp;side=consumer&amp;timeout=50000&amp;timestamp=1501137556130, cause: Waiting server-side response timeout by scan timer. start time: 2017-07-27 14:39:17.073, end time: 2017-07-27 14:40:07.088, client elapsed: 25 ms, server elapsed: 49988 ms, timeout: 50000 ms, request: Request [id=0, version=2.0.0, twoway=true, event=false, broken=false, data=RpcInvocation [methodName=sayHello, parameterTypes=[class java.lang.String], arguments=[qzz], attachments=&#123;path=life.qzz.dubbodemo.api.DemoService, interface=life.qzz.dubbodemo.api.DemoService, version=0.0.0, timeout=50000&#125;]], channel: 10.96.2.111:0 -&gt; /10.96.2.111:20881</span></span><br><span class="line">at com.alibaba.dubbo.rpc.cluster.support.FailfastClusterInvoker.doInvoke(FailfastClusterInvoker.java:<span class="number">52</span>)</span><br><span class="line">at com.alibaba.dubbo.rpc.cluster.support.AbstractClusterInvoker.invoke(AbstractClusterInvoker.java:<span class="number">227</span>)</span><br><span class="line">at com.alibaba.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker.invoke(MockClusterInvoker.java:<span class="number">72</span>)</span><br><span class="line">at com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:<span class="number">52</span>)</span><br><span class="line">at com.alibaba.dubbo.common.bytecode.proxy0.sayHello(proxy0.java)</span><br><span class="line">at life.qzz.dubbodemo.controller.DemoController.hello(DemoController.java:<span class="number">27</span>)</span><br><span class="line">at life.qzz.dubbodemo.Consumer.main(Consumer.java:<span class="number">20</span>)</span><br></pre></td></tr></table></figure><h6 id="failback"><a href="#failback" class="headerlink" title="failback"></a>failback</h6><p>虽然日志中打印出了等待重试，但是我没有在日志中发现具体的重试行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.dubbo.rpc.cluster.support.FailbackClusterInvoker.doInvoke(FailbackClusterInvoker.java:<span class="number">104</span>) ERROR [main] FailbackClusterInvoker.doInvoke(<span class="number">104</span>) |  [DUBBO] Failback to invoke method sayHello, wait <span class="keyword">for</span> retry in background. Ignored exception: Invoke remote method timeout.</span><br></pre></td></tr></table></figure><p>在超时时间内将关掉的provider重新打开，直到consumer超时时，provider打印出了调用的信息，但是consumer打印出了null。<br>provider日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">01</span> life.qzz.dubbodemo.api.impl.DemoServiceImpl.sayHello(DemoServiceImpl.java:<span class="number">20</span>) DEBUG [DubboServerHandler-<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20881</span>-thread-<span class="number">5</span>] DemoServiceImpl.sayHello(<span class="number">20</span>) | 调用Provider2的服务</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">01</span> life.qzz.dubbodemo.api.impl.DemoServiceImpl.sayHello(DemoServiceImpl.java:<span class="number">21</span>) DEBUG [DubboServerHandler-<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20881</span>-thread-<span class="number">5</span>] DemoServiceImpl.sayHello(<span class="number">21</span>) | 休息<span class="number">20</span>秒</span><br></pre></td></tr></table></figure><p>consumer日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">56</span> life.qzz.dubbodemo.controller.DemoController.hello(DemoController.java:<span class="number">27</span>) DEBUG [main] DemoController.hello(<span class="number">27</span>) | 服务返回结果：<span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>不晓得重试的机制是什么，超时的时候才重新发起请求么？</p><h6 id="forking"><a href="#forking" class="headerlink" title="forking"></a>forking</h6><p>consumer：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;life.qzz.dubbodemo.api.DemoService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">init</span>=<span class="string">&quot;true&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;60000&quot;</span> <span class="attr">cluster</span>=<span class="string">&quot;forking&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>但是<code>forks</code>这个属性貌似不能加啊！！！</p><p>provider1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">09</span> life.qzz.dubbodemo.api.impl.DemoServiceImpl.sayHello(DemoServiceImpl.java:<span class="number">20</span>) DEBUG [DubboServerHandler-<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20880</span>-thread-<span class="number">2</span>] DemoServiceImpl.sayHello(<span class="number">20</span>) | 服务调用前</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">19</span> life.qzz.dubbodemo.api.impl.DemoServiceImpl.sayHello(DemoServiceImpl.java:<span class="number">26</span>) DEBUG [DubboServerHandler-<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20880</span>-thread-<span class="number">2</span>] DemoServiceImpl.sayHello(<span class="number">26</span>) | 休息结束</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">19</span> life.qzz.dubbodemo.api.impl.DemoServiceImpl.sayHello(DemoServiceImpl.java:<span class="number">27</span>) DEBUG [DubboServerHandler-<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20880</span>-thread-<span class="number">2</span>] DemoServiceImpl.sayHello(<span class="number">27</span>) | 服务调用开始</span><br></pre></td></tr></table></figure><p>provider2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">09</span> life.qzz.dubbodemo.api.impl.DemoServiceImpl.sayHello(DemoServiceImpl.java:<span class="number">20</span>) DEBUG [DubboServerHandler-<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20881</span>-thread-<span class="number">2</span>] DemoServiceImpl.sayHello(<span class="number">20</span>) | 调用Provider2的服务</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">09</span> life.qzz.dubbodemo.api.impl.DemoServiceImpl.sayHello(DemoServiceImpl.java:<span class="number">21</span>) DEBUG [DubboServerHandler-<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20881</span>-thread-<span class="number">2</span>] DemoServiceImpl.sayHello(<span class="number">21</span>) | 休息<span class="number">20</span>秒</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">29</span> life.qzz.dubbodemo.api.impl.DemoServiceImpl.sayHello(DemoServiceImpl.java:<span class="number">27</span>) DEBUG [DubboServerHandler-<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20881</span>-thread-<span class="number">2</span>] DemoServiceImpl.sayHello(<span class="number">27</span>) | 休息结束</span><br></pre></td></tr></table></figure><p>consumer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">19</span> life.qzz.dubbodemo.controller.DemoController.hello(DemoController.java:<span class="number">27</span>) DEBUG [main] DemoController.hello(<span class="number">27</span>) | 服务返回结果：hello :qzz</span><br></pre></td></tr></table></figure><p>从时间先后顺序可以看到provider1返回之后consumer就得到了返回结果。</p><h6 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast"></a>broadcast</h6><p>provider1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">25</span> life.qzz.dubbodemo.api.impl.DemoServiceImpl.sayHello(DemoServiceImpl.java:<span class="number">20</span>) DEBUG [DubboServerHandler-<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20880</span>-thread-<span class="number">6</span>] DemoServiceImpl.sayHello(<span class="number">20</span>) | 服务调用前</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">35</span> life.qzz.dubbodemo.api.impl.DemoServiceImpl.sayHello(DemoServiceImpl.java:<span class="number">26</span>) DEBUG [DubboServerHandler-<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20880</span>-thread-<span class="number">6</span>] DemoServiceImpl.sayHello(<span class="number">26</span>) | 休息结束</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">35</span> life.qzz.dubbodemo.api.impl.DemoServiceImpl.sayHello(DemoServiceImpl.java:<span class="number">27</span>) DEBUG [DubboServerHandler-<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20880</span>-thread-<span class="number">6</span>] DemoServiceImpl.sayHello(<span class="number">27</span>) | 服务调用开始</span><br></pre></td></tr></table></figure><p>provider2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">35</span> life.qzz.dubbodemo.api.impl.DemoServiceImpl.sayHello(DemoServiceImpl.java:<span class="number">20</span>) DEBUG [DubboServerHandler-<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20881</span>-thread-<span class="number">6</span>] DemoServiceImpl.sayHello(<span class="number">20</span>) | 调用Provider2的服务</span><br><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">35</span> life.qzz.dubbodemo.api.impl.DemoServiceImpl.sayHello(DemoServiceImpl.java:<span class="number">21</span>) DEBUG [DubboServerHandler-<span class="number">10.96</span>.<span class="number">2.111</span>:<span class="number">20881</span>-thread-<span class="number">6</span>] DemoServiceImpl.sayHello(<span class="number">21</span>) | 休息<span class="number">20</span>秒</span><br></pre></td></tr></table></figure><p>consumer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> com.alibaba.dubbo.rpc.RpcException: Invoke remote method timeout. method: sayHello, provider: dubbo:<span class="comment">//10.96.2.111:20881/life.qzz.dubbodemo.api.DemoService?anyhost=true&amp;application=helloapp&amp;check=false&amp;cluster=broadcast&amp;default.check=false&amp;dubbo=2.8.4&amp;generic=false&amp;init=true&amp;interface=life.qzz.dubbodemo.api.DemoService&amp;methods=sayHello&amp;pid=3028&amp;side=consumer&amp;timeout=60000&amp;timestamp=1501141224739, cause: Waiting server-side response timeout. start time: 2017-07-27 15:40:35.559, end time: 2017-07-27 15:41:35.564, client elapsed: 0 ms, server elapsed: 60004 ms, timeout: 60000 ms, request: Request [id=1, version=2.0.0, twoway=true, event=false, broken=false, data=RpcInvocation [methodName=sayHello, parameterTypes=[class java.lang.String], arguments=[qzz], attachments=&#123;path=life.qzz.dubbodemo.api.DemoService, interface=life.qzz.dubbodemo.api.DemoService, version=0.0.0, timeout=60000&#125;]], channel: 10.96.2.111:0 -&gt; /10.96.2.111:20881</span></span><br><span class="line">at com.alibaba.dubbo.rpc.protocol.dubbo.DubboInvoker.doInvoke(DubboInvoker.java:<span class="number">99</span>)</span><br><span class="line">at com.alibaba.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:<span class="number">144</span>)</span><br><span class="line">at com.alibaba.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:<span class="number">75</span>)</span><br><span class="line">at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$<span class="number">1.</span>invoke(ProtocolFilterWrapper.java:<span class="number">91</span>)</span><br><span class="line">at com.alibaba.dubbo.rpc.protocol.dubbo.filter.FutureFilter.invoke(FutureFilter.java:<span class="number">53</span>)</span><br><span class="line">at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$<span class="number">1.</span>invoke(ProtocolFilterWrapper.java:<span class="number">91</span>)</span><br><span class="line">at com.alibaba.dubbo.rpc.filter.ConsumerContextFilter.invoke(ConsumerContextFilter.java:<span class="number">48</span>)</span><br><span class="line">at com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$<span class="number">1.</span>invoke(ProtocolFilterWrapper.java:<span class="number">91</span>)</span><br><span class="line">at com.alibaba.dubbo.rpc.listener.ListenerInvokerWrapper.invoke(ListenerInvokerWrapper.java:<span class="number">74</span>)</span><br><span class="line">at com.alibaba.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:<span class="number">53</span>)</span><br><span class="line">at com.alibaba.dubbo.rpc.cluster.support.BroadcastClusterInvoker.doInvoke(BroadcastClusterInvoker.java:<span class="number">51</span>)</span><br><span class="line">at com.alibaba.dubbo.rpc.cluster.support.AbstractClusterInvoker.invoke(AbstractClusterInvoker.java:<span class="number">227</span>)</span><br><span class="line">at com.alibaba.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker.invoke(MockClusterInvoker.java:<span class="number">72</span>)</span><br><span class="line">at com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:<span class="number">52</span>)</span><br><span class="line">at com.alibaba.dubbo.common.bytecode.proxy0.sayHello(proxy0.java)</span><br><span class="line">at life.qzz.dubbodemo.controller.DemoController.hello(DemoController.java:<span class="number">27</span>)</span><br><span class="line">at life.qzz.dubbodemo.Consumer.main(Consumer.java:<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>provider1 在40:35秒结束，provider2开始执行，然后结束掉provider2的进程，consumer最终报错。</p>]]></content>
      
      
      
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> 集群 </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo学习3-启动时检查</title>
      <link href="/post/dbef/"/>
      <url>/post/dbef/</url>
      
        <content type="html"><![CDATA[<h4 id="启动时检查"><a href="#启动时检查" class="headerlink" title="启动时检查"></a>启动时检查</h4><p>dubbo默认启动时会检测所依赖的服务是否可用，不可用时将抛出异常，阻止spring 初始化完成，默认check=true。<br>如果你的Spring容器是懒加载的，或者通过API编程延迟引用服务，请关闭check，否则服务临时不可用时，会抛出异常，拿到null引用，如果check=false，总是会返回引用，当服务恢复时，能自动连上。<br>可以通过将<code>check</code>设置为<code>false</code>来关闭检查，比如测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。</p><ul><li><p>关闭某个服务启动时的检查（没有提供者时会报错）：<br>会出现以下异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Failed to check the status of the service life.qzz.dubbodemo.api.DemoService. </span><br><span class="line">No provider available <span class="keyword">for</span> the service life.qzz.dubbodemo.api.DemoService from the url </span><br><span class="line">zookeeper:<span class="comment">//localhost:2181/com.alibaba.dubbo.registry.RegistryService?application=helloapp</span></span><br><span class="line"><span class="comment">// &amp;dubbo=2.8.4&amp;interface=life.qzz.dubbodemo.api.DemoService&amp;methods=sayHello&amp;pid=9820&amp;side=consumer&amp;timestamp=1501054461459 </span></span><br><span class="line"> to the consumer <span class="number">10.96</span>.<span class="number">2.111</span> use dubbo version <span class="number">2.8</span>.<span class="number">4</span></span><br></pre></td></tr></table></figure><p>将此引用配置为<code>check=false</code>可以关闭检查</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;life.qzz.dubbodemo.api.DemoService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>关闭所有服务启动时的检查（没有提供者时会报错）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>关闭注册中心启动时检查（注册订阅失败时报错）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>连不上zk时会出异常，默认尝试3次后失败：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.I0Itec.zkclient.exception.ZkTimeoutException: Unable to connect to zookeeper server within timeout: <span class="number">5000</span></span><br><span class="line">    at org.I0Itec.zkclient.ZkClient.connect(ZkClient.java:<span class="number">876</span>)</span><br><span class="line">    at org.I0Itec.zkclient.ZkClient.&lt;init&gt;(ZkClient.java:<span class="number">98</span>)</span><br><span class="line">    at org.I0Itec.zkclient.ZkClient.&lt;init&gt;(ZkClient.java:<span class="number">92</span>)</span><br><span class="line">    at org.I0Itec.zkclient.ZkClient.&lt;init&gt;(ZkClient.java:<span class="number">80</span>)</span><br></pre></td></tr></table></figure></li></ul><p>可以在dubbo.properties配置文件中做一些默认设置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">dubbo.reference.life.qzz.dubbodemo.api.DemoService.check</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">dubbo.reference.check</span>=<span class="string">false 官方文档上说“强制改变所有reference的check值，就算配置中有声明，也会被覆盖”，经测试xml和注解中配置会覆盖此项配置</span></span><br><span class="line"><span class="meta">dubbo.consumer.check</span>=<span class="string">false 是设置check的缺省值，如果配置中有显式的声明，如：&lt;dubbo:reference check=&quot;true&quot;/&gt;，不会受影响。比dubbo.reference.check优先级低</span></span><br><span class="line"><span class="meta">dubbo.registry.check</span>=<span class="string">false  前面两个都是指订阅成功，但提供者列表是否为空是否报错，如果注册订阅失败时，也允许启动，需使用此选项，将在后台定时重试。此处定时重试暂款测试出来，不知如何测试</span></span><br></pre></td></tr></table></figure><p>引用缺省是延迟初始化的，只有引用被注入到其它Bean，或被getBean()获取，才会初始化。<br>如果需要饥饿加载，即没有人引用也立即生成动态代理，可以配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;life.qzz.dubbodemo.api.DemoService&quot;</span> <span class="attr">init</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>总结：<br>配置文件中的<code>dubbo.reference.check</code>，<code>dubbo.consumer.check</code>，<code>dubbo.registry.check</code>做一些默认的配置，在xml和注解中针对具体情况做特殊性的配置。</p><p><a href="http://git.oschina.net/qzz/qinzaizhen/tree/master/dubbodemo/demo3">demo地址</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> 启动检查 </tag>
            
            <tag> check </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The valid characters are defined in RFC 7230 and RFC 3986</title>
      <link href="/post/4e8e/"/>
      <url>/post/4e8e/</url>
      
        <content type="html"><![CDATA[<p>今天在使用tomcat的过程中遇到了这个问题。表现为400错误以及空白页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Error parsing HTTP request header</span><br><span class="line">Note: further occurrences of HTTP header parsing errors will be logged at DEBUG level.</span><br><span class="line">Java.lang.IllegalArgumentException: Invalid character found in the request target. The valid characters are defined in RFC <span class="number">7230</span> and RFC <span class="number">3986</span></span><br><span class="line">at org.apache.coyote.http11.InternalInputBuffer.parseRequestLine(InternalInputBuffer.java:<span class="number">189</span>)</span><br><span class="line">at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:<span class="number">1000</span>)</span><br><span class="line">at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:<span class="number">637</span>)</span><br><span class="line">at org.apache.tomcat.util.NET.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:<span class="number">318</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1145</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">615</span>)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:<span class="number">61</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><p>原因是新版本的tomcat规范了get请求url中参数，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。<a href="https://tools.ietf.org/html/rfc3986">原文第2章</a>关于字符那部分有说明。<br>保留字符：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reserved    = gen-delims / sub-delims</span><br><span class="line">gen-delims  = &quot;:&quot; / &quot;/&quot; / &quot;?&quot; / &quot;#&quot; / &quot;[&quot; / &quot;]&quot; / &quot;@&quot;</span><br><span class="line">sub-delims  = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;&#x27;&quot; / &quot;(&quot; / &quot;)&quot;</span><br><span class="line">          / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot;</span><br></pre></td></tr></table></figure><p>非保留字符（字母、数字，-_.~）：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unreserved  = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;</span><br></pre></td></tr></table></figure><p>还有一些字符放在url中可能会引起解析的歧义（<a href="http://blog.csdn.net/laokaizzz/article/details/60752593">此部分来源于</a>）：</p><ul><li>空格Url在传输的过程，或者用户在排版的过程，或者文本处理程序在处理Url的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉</li><li>引号以及&lt;&gt;引号和尖括号通常用于在普通文本中起到分隔Url的作用</li><li>#通常用于表示书签或者锚点</li><li>%百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码</li><li>{}|^[]`~某一些网关或者传输代理会篡改这些字符</li></ul><p>当出现这些字符时就需要进行<code>urlencode</code>。在javascript中有两种encode的方法:<br> -|encodeURI|encodeURIComponent<br> –|–|–<br> 相同点| 不会对字母、数字、标点符号 - _ . ! ~ * ‘ ( )进行编码<br> 不同点|不会对URI中具有特殊含义的字符进行编码 <code>：;/?:@&amp;=+$,#</code>，因为此方法将参数当成完整的URL，这些字符在URI中具有合法的意义，无需编码|除上面的不会编码之外，其他的字符都会编码  <code>：;/?:@&amp;=+$,#</code></p><p>因此如果在URI组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码，如：<code>http://localhost/redirect?url=http://localhost/index</code>, 这里的<code>url</code>参数的值就应该进行编码，需要用<code>encodeURIComponent</code>方法对<code>http://localhost/index</code>进行编码。</p><p>具体的使用例子(<a href="http://www.w3school.com.cn/jsref/jsref_encodeURIComponent.asp">来源于w3c encodeURIComponent</a>，<a href="http://www.w3school.com.cn/jsref/jsref_encodeuri.asp">encodeuri</a>)：</p><p><strong>encodeURI</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="built_in">encodeURI</span>(<span class="string">&quot;http://www.w3school.com.cn&quot;</span>)+ <span class="string">&quot;&lt;br /&gt;&quot;</span>)</span><br><span class="line"><span class="built_in">document</span>.write(<span class="built_in">encodeURI</span>(<span class="string">&quot;http://www.w3school.com.cn/My first/&quot;</span>))</span><br><span class="line"><span class="built_in">document</span>.write(<span class="built_in">encodeURI</span>(<span class="string">&quot;,/?:@&amp;=+$#&quot;</span>))</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://www.w3school.com.cn</span><br><span class="line">http://www.w3school.com.cn/My%20first/</span><br><span class="line">,/?:@&amp;=+$#</span><br></pre></td></tr></table></figure><p><strong>encodeURIComponent</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="built_in">encodeURIComponent</span>(<span class="string">&quot;http://www.w3school.com.cn&quot;</span>))</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;br /&gt;&quot;</span>)</span><br><span class="line"><span class="built_in">document</span>.write(<span class="built_in">encodeURIComponent</span>(<span class="string">&quot;http://www.w3school.com.cn/p 1/&quot;</span>))</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;br /&gt;&quot;</span>)</span><br><span class="line"><span class="built_in">document</span>.write(<span class="built_in">encodeURIComponent</span>(<span class="string">&quot;,/?:@&amp;=+$#&quot;</span>))</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http%3A%2F%2Fwww.w3school.com.cn</span><br><span class="line">http%3A%2F%2Fwww.w3school.com.cn%2Fp%201%2F</span><br><span class="line">%2C%2F%3F%3A%40%26%3D%2B%24%23</span><br></pre></td></tr></table></figure><p>具体的判断在tomcat的<code>org.apache.tomcat.util.http.parser.HttpParser</code>中的<code>IS_NOT_REQUEST_TARGET</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HTTP header value parser implementation. Parsing HTTP headers as per RFC2616</span></span><br><span class="line"><span class="comment"> * is not always as simple as it first appears. For headers that only use tokens</span></span><br><span class="line"><span class="comment"> * the simple approach will normally be sufficient. However, for the other</span></span><br><span class="line"><span class="comment"> * headers, while simple code meets 99.9% of cases, there are often some edge</span></span><br><span class="line"><span class="comment"> * cases that make things far more complicated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The purpose of this parser is to let the parser worry about the edge cases.</span></span><br><span class="line"><span class="comment"> * It provides tolerant (where safe to do so) parsing of HTTP header values</span></span><br><span class="line"><span class="comment"> * assuming that wrapped header lines have already been unwrapped. (The Tomcat</span></span><br><span class="line"><span class="comment"> * header processing code does the unwrapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StringManager sm = StringManager.getManager(HttpParser.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(HttpParser.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_SIZE = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] IS_CONTROL = <span class="keyword">new</span> <span class="keyword">boolean</span>[ARRAY_SIZE];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] IS_SEPARATOR = <span class="keyword">new</span> <span class="keyword">boolean</span>[ARRAY_SIZE];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] IS_TOKEN = <span class="keyword">new</span> <span class="keyword">boolean</span>[ARRAY_SIZE];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] IS_HEX = <span class="keyword">new</span> <span class="keyword">boolean</span>[ARRAY_SIZE];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] IS_NOT_REQUEST_TARGET = <span class="keyword">new</span> <span class="keyword">boolean</span>[ARRAY_SIZE];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] IS_HTTP_PROTOCOL = <span class="keyword">new</span> <span class="keyword">boolean</span>[ARRAY_SIZE];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] REQUEST_TARGET_ALLOW = <span class="keyword">new</span> <span class="keyword">boolean</span>[ARRAY_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        String prop = System.getProperty(<span class="string">&quot;tomcat.util.http.parser.HttpParser.requestTargetAllow&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (prop != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prop.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = prop.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;&#125;&#x27;</span> || c == <span class="string">&#x27;|&#x27;</span>) &#123;</span><br><span class="line">                    REQUEST_TARGET_ALLOW[c] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.warn(sm.getString(<span class="string">&quot;httpparser.invalidRequestTargetCharacter&quot;</span>,</span><br><span class="line">                            Character.valueOf(c)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++) &#123;</span><br><span class="line">            <span class="comment">// Control&gt; 0-31, 127</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">32</span> || i == <span class="number">127</span>) &#123;</span><br><span class="line">                IS_CONTROL[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Separator</span></span><br><span class="line">            <span class="keyword">if</span> (    i == <span class="string">&#x27;(&#x27;</span> || i == <span class="string">&#x27;)&#x27;</span> || i == <span class="string">&#x27;&lt;&#x27;</span> || i == <span class="string">&#x27;&gt;&#x27;</span>  || i == <span class="string">&#x27;@&#x27;</span>  ||</span><br><span class="line">                    i == <span class="string">&#x27;,&#x27;</span> || i == <span class="string">&#x27;;&#x27;</span> || i == <span class="string">&#x27;:&#x27;</span> || i == <span class="string">&#x27;\\&#x27;</span> || i == <span class="string">&#x27;\&quot;&#x27;</span> ||</span><br><span class="line">                    i == <span class="string">&#x27;/&#x27;</span> || i == <span class="string">&#x27;[&#x27;</span> || i == <span class="string">&#x27;]&#x27;</span> || i == <span class="string">&#x27;?&#x27;</span>  || i == <span class="string">&#x27;=&#x27;</span>  ||</span><br><span class="line">                    i == <span class="string">&#x27;&#123;&#x27;</span> || i == <span class="string">&#x27;&#125;&#x27;</span> || i == <span class="string">&#x27; &#x27;</span> || i == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line">                IS_SEPARATOR[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Token: Anything 0-127 that is not a control and not a separator</span></span><br><span class="line">            <span class="keyword">if</span> (!IS_CONTROL[i] &amp;&amp; !IS_SEPARATOR[i] &amp;&amp; i &lt; <span class="number">128</span>) &#123;</span><br><span class="line">                IS_TOKEN[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex: 0-9, a-f, A-F</span></span><br><span class="line">            <span class="keyword">if</span> ((i &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; i &lt;=<span class="string">&#x27;9&#x27;</span>) || (i &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; i &lt;= <span class="string">&#x27;f&#x27;</span>) || (i &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; i &lt;= <span class="string">&#x27;F&#x27;</span>)) &#123;</span><br><span class="line">                IS_HEX[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Not valid for request target.</span></span><br><span class="line">            <span class="comment">// Combination of multiple rules from RFC7230 and RFC 3986. Must be</span></span><br><span class="line">            <span class="comment">// ASCII, no controls plus a few additional characters excluded</span></span><br><span class="line">            <span class="keyword">if</span> (IS_CONTROL[i] || i &gt; <span class="number">127</span> ||</span><br><span class="line">                    i == <span class="string">&#x27; &#x27;</span> || i == <span class="string">&#x27;\&quot;&#x27;</span> || i == <span class="string">&#x27;#&#x27;</span> || i == <span class="string">&#x27;&lt;&#x27;</span> || i == <span class="string">&#x27;&gt;&#x27;</span> || i == <span class="string">&#x27;\\&#x27;</span> ||</span><br><span class="line">                    i == <span class="string">&#x27;^&#x27;</span> || i == <span class="string">&#x27;`&#x27;</span>  || i == <span class="string">&#x27;&#123;&#x27;</span> || i == <span class="string">&#x27;|&#x27;</span> || i == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!REQUEST_TARGET_ALLOW[i]) &#123;</span><br><span class="line">                    IS_NOT_REQUEST_TARGET[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Not valid for HTTP protocol</span></span><br><span class="line">            <span class="comment">// &quot;HTTP/&quot; DIGIT &quot;.&quot; DIGIT</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="string">&#x27;H&#x27;</span> || i == <span class="string">&#x27;T&#x27;</span> || i == <span class="string">&#x27;P&#x27;</span> || i == <span class="string">&#x27;/&#x27;</span> || i == <span class="string">&#x27;.&#x27;</span> || (i &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; i &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">                IS_HTTP_PROTOCOL[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换成tomcat<code>7.0.69</code>可以成功运行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> encodeURIComponent </tag>
            
            <tag> encodeURI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows 编绎spring-framework源代码遇到的问题</title>
      <link href="/post/53da/"/>
      <url>/post/53da/</url>
      
        <content type="html"><![CDATA[<ol><li>schemaZip 找不到问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:spring-webmvc-portlet:sourcesJar UP-TO-DATE</span><br><span class="line">:spring-webmvc-tiles2:javadoc SKIPPED</span><br><span class="line">:spring-webmvc-tiles2:javadocJar SKIPPED</span><br><span class="line">:spring-webmvc-tiles2:sourcesJar SKIPPED</span><br><span class="line">:spring-websocket:javadoc UP-TO-DATE</span><br><span class="line">:spring-websocket:javadocJar UP-TO-DATE</span><br><span class="line">:spring-websocket:sourcesJar UP-TO-DATE</span><br><span class="line">:schemaZip</span><br><span class="line"></span><br><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Failed to capture snapshot of input files <span class="keyword">for</span> task <span class="string">&#x27;schemaZip&#x27;</span> during up-to-date c</span><br><span class="line">heck.  See stacktrace <span class="keyword">for</span> details.</span><br><span class="line">&gt; java.io.FileNotFoundException: d:\...spring-framework-schema.zip</span><br></pre></td></tr></table></figure>主要是因为在windows上路径分隔符不一样导致的。<a href="https://stackoverflow.com/questions/34916981/build-spring-framework-source-code-encounter-an-error">stackoverflow给出了解决办法</a><br>将<code>spring-framework/gradle/docs.gradle</code>中的<code>schemaZip</code>任务修改为下面形式就可以了。</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> schemaZip(type: Zip) &#123;</span><br><span class="line">        <span class="keyword">group</span> = <span class="string">&quot;Distribution&quot;</span></span><br><span class="line">        baseName = <span class="string">&quot;spring-framework&quot;</span></span><br><span class="line">        classifier = <span class="string">&quot;schema&quot;</span></span><br><span class="line">        <span class="keyword">description</span> = <span class="string">&quot;Builds -$&#123;classifier&#125; archive containing all &quot;</span> +</span><br><span class="line">            <span class="string">&quot;XSDs for deployment at http://springframework.org/schema.&quot;</span></span><br><span class="line">        duplicatesStrategy <span class="string">&#x27;exclude&#x27;</span></span><br><span class="line">        moduleProjects.<span class="keyword">each</span> &#123; subproject -&gt;</span><br><span class="line">            <span class="keyword">def</span> Properties schemas = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">            subproject.<span class="keyword">sourceSets</span>.main.resources.<span class="keyword">find</span> &#123;</span><br><span class="line">                it.path.endsWith(<span class="string">&quot;META-INF\\spring.schemas&quot;</span>)</span><br><span class="line">            &#125;?.withInputStream &#123; schemas.load(it) &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">def</span> key : schemas.keySet()) &#123;</span><br><span class="line">                <span class="keyword">def</span> shortName = key.replaceAll(<span class="regexp">/http.*schema.(.*).spring-.*/</span>, <span class="string">&#x27;$1&#x27;</span>)</span><br><span class="line">                assert shortName != key</span><br><span class="line">                <span class="keyword">File</span> xsdFile = subproject.<span class="keyword">sourceSets</span>.main.resources.<span class="keyword">find</span> &#123;</span><br><span class="line">                    it.path.endsWith(schemas.get(key).replaceAll(<span class="string">&#x27;\\/&#x27;</span>,<span class="string">&#x27;\\\\&#x27;</span>))</span><br><span class="line">                &#125;</span><br><span class="line">                assert xsdFile != <span class="keyword">null</span></span><br><span class="line">                <span class="keyword">into</span> (shortName) &#123;</span><br><span class="line">                    <span class="keyword">from</span> xsdFile.path</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>因为测试用例执行不过的问题<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &#x27;:spring-aop:compileTestJava&#x27;.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compilation failed; see the compiler error output <span class="keyword">for</span> details.</span></span><br></pre></td></tr></table></figure>网上有说加上 <code>-x test</code> 可以跳过测试，但是如果test代码有编绎错误的话好像还是会失败。</li><li>加上 <code>--continue</code>参数失败之后继续</li><li><code>-x compileTestJava</code> 直接跳过这个报错的任务。</li></ol><p>最后想吐槽一下的是为啥测试用例编绎不过。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> schemaZip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intellij 激活网站</title>
      <link href="/post/9bbe/"/>
      <url>/post/9bbe/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://intellij.mandroid.cn/">http://intellij.mandroid.cn/</a></li><li><a href="http://idea.imsxm.com/">http://idea.imsxm.com/</a></li><li><a href="http://idea.iteblog.com/key.php">http://idea.iteblog.com/key.php</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sublime Text3 + Markdown + 实时预览</title>
      <link href="/post/1b4b/"/>
      <url>/post/1b4b/</url>
      
        <content type="html"><![CDATA[<p>安装准备：</p><p>找到菜单栏：<code>Preferences</code> → <code>Package Control</code> → <code>Package Control:Install Package</code>；<br>没有找到<code>Package Control</code>，那么点击<code>Package Control</code> 安装吧，安装完重启Sublime。<br>安装过程：</p><p>需要两款插件：<code>Markdown Editing</code> + <code>MarkdownLivePreview</code>；<br>在<code>Package Control</code> → <code>Install Package</code>中输入两款插件的名字，找到相应插件，点击即可自动完成安装，安装完重启Sublime；<br>简单设置：<code>Preferences</code> → <code>Package Settings</code> → <code>MarkdownLivePreview</code> → Setting，打开后将左边default的设置代码复制到右边User栏，找到<code>markdown_live_preview_on_open</code>: false,把false改为<code>true</code>，保存。<br>使用方法：<br>使用Sublime新建一个文件，右下角选择编辑方式为“Markdown”，将其保存为.md文件，选择保存位置并单击确定，此时自动弹出Markdown文本编辑框（左）和预览框（右），然后就开始愉快地编辑吧。</p><p><strong>注意</strong></p><p>若保存.md文件时无法保存到当前文件夹，可安装AdvancedNewFile插件，方法与前面两款插件相同，并且进行设置，同样将default的设置代码复制到User，找到”default_root”: “project_folder”,，把project_folder改为current，保存。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>angularjs 改变样式</title>
      <link href="/post/71fe/"/>
      <url>/post/71fe/</url>
      
        <content type="html"><![CDATA[<h4 id="angularjs-改变样式主要有三种方式"><a href="#angularjs-改变样式主要有三种方式" class="headerlink" title="angularjs 改变样式主要有三种方式"></a>angularjs 改变样式主要有三种方式</h4><ol><li>直接使用变量绑定</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.play</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">color</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.play2</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">font-size</span><span class="selector-pseudo">:25px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-app</span>=<span class="string">&quot;myApp&quot;</span> <span class="attr">ng-controller</span>=<span class="string">&quot;myCtrl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;&#123;&#123;class&#125;&#125;&quot;</span>&gt;</span>我的play样式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> app = angular.module(<span class="string">&#x27;myApp&#x27;</span>, []);</span></span><br><span class="line"><span class="javascript">app.controller(<span class="string">&#x27;myCtrl&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">$scope.class = <span class="string">&#x27;play&#x27;</span>;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果图</p><p><img src="http://ooll8xqpq.bkt.clouddn.com/images/%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A.png" alt="image"></p><p><strong>这种方式耦合性较高，将视图的变化放在了controller中</strong></p><ol start="2"><li> 字符串数组形式</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.play</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">color</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.play2</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">font-size</span><span class="selector-pseudo">:25px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-app</span>=<span class="string">&quot;myApp&quot;</span> <span class="attr">ng-controller</span>=<span class="string">&quot;myCtrl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ng-class</span>=<span class="string">&quot;&#123;true:&#x27;play&#x27;,false:&#x27;play2&#x27;&#125;[isplay]&quot;</span>&gt;</span>我是字符串数组形式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> app = angular.module(<span class="string">&#x27;myApp&#x27;</span>, []);</span></span><br><span class="line"><span class="javascript">app.controller(<span class="string">&#x27;myCtrl&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">$scope.isplay=<span class="literal">true</span>;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果图</p><p><img src="http://ooll8xqpq.bkt.clouddn.com/images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F.png" alt="image"></p><p>可以理解为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test=&#123;<span class="attr">true</span>: <span class="string">&#x27;active&#x27;</span>, <span class="attr">false</span>: <span class="string">&#x27;inactive&#x27;</span>&#125;;</span><br><span class="line">test[isActive];</span><br></pre></td></tr></table></figure><p>也可以不用true和false来表示。<br>比如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ng-class</span>=<span class="string">&quot;&#123;play:&#x27;play&#x27;,notplay:&#x27;play2&#x27;&#125;[isplay]&quot;</span>&gt;</span>我是字符串数组形式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">$scope.isplay=&#x27;play&#x27;;</span><br></pre></td></tr></table></figure><p>个人理解原理应该是一样的，也是判断是不是true吧。手动滑稽。<br>还有一种更简捷的写法是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ng-class</span>=<span class="string">&quot;&#123;&#x27;play2&#x27;:&#x27;play&#x27;&#125;&quot;</span>&gt;</span>我是字符串数组形式2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前面的为true时的样式，后面为false时的样式<br>3. 第二种方式中两个样式是互斥的，如果需要组合不同的样式，就需要第三种了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.play</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">color</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.play2</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">font-size</span><span class="selector-pseudo">:25px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-app</span>=<span class="string">&quot;myApp&quot;</span> <span class="attr">ng-controller</span>=<span class="string">&quot;myCtrl&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ng-class</span>=<span class="string">&quot;&#123;&#x27;play&#x27;:isplay,&#x27;play2&#x27;:isplay2&#125;&quot;</span>&gt;</span>我是key-value形式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> app = angular.module(<span class="string">&#x27;myApp&#x27;</span>, []);</span></span><br><span class="line"><span class="javascript">app.controller(<span class="string">&#x27;myCtrl&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">$scope.isplay=<span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">$scope.isplay2 = <span class="literal">true</span>;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果图</p><p><img src="http://ooll8xqpq.bkt.clouddn.com/images/key-value%E5%BD%A2%E5%BC%8F.png" alt="image"></p><p>前面的是样式的class，后面为表达式，为true时激活些样式。当isplay和isplay2都为true，元素将获得两种样式。<br>按照常规理解应该是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;isplay:&#x27;play&#x27;,isplay2:&#x27;play2&#x27;&#125;</span><br></pre></td></tr></table></figure><p>这样的写法才更容易让人理解吧？<br><strong>总结：</strong> </p><ol><li>如果是二选一的情况下用第二种，尤其是简写形式。</li><li>复杂的样式用第三种。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> angularjs </tag>
            
            <tag> 样式 </tag>
            
            <tag> class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吃前吃后</title>
      <link href="/post/bee5/"/>
      <url>/post/bee5/</url>
      
        <content type="html"><![CDATA[<p>吃货吃鸡腿的速度太快了。</p><p>吃之前的图<img src="http://ooll8xqpq.bkt.clouddn.com/%E5%90%83%E5%89%8D.jpg" alt="image"><br>前后不到几分钟的事情。<br>吃之后的图<img src="http://ooll8xqpq.bkt.clouddn.com/%E5%90%83%E5%90%8E.jpg" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 吃货，媳妇儿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.23面试总结</title>
      <link href="/post/cc21/"/>
      <url>/post/cc21/</url>
      
        <content type="html"><![CDATA[<p>找工作了一个星期，面试了一些中大型公司，普遍的对并发，网络IO，JMS，分布式都有要求，而且需要了解其原理。</p><p>面试不上的原因：</p><ol><li>项目经验跟公司预期的互联网项目有差距，没有用到dubbo，jms等技术。针对这点需要将分布式，消息系统整合进项目经验中来。并且对dubbo的原理，MQ的原理，redis需要了解。</li><li>多线程知识体系不完善，JVM了解的不够深入，MYSQL的优化经验不足。针对这点接下来需要强化多线程体系的完善与学习，JVM知识的学习与运用，加强MYSQL sql优化经验。</li><li><strong>说话声音太小</strong>， 这个问题很严重了。</li><li>使用到的技术仅限于使用层面，没有更深入了解其中原理。需要加强学习。</li></ol><p>接下来的几个月时间需要针对以上存在的问题进行突破，争取早日进入大公司。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.20梦</title>
      <link href="/post/647e/"/>
      <url>/post/647e/</url>
      
        <content type="html"><![CDATA[<p>内战，跟国民党打仗，被国民党追杀,就被人追着逃跑，我们一共2个人，跑到学校的一座烂尾楼里，从一个地方分开了，然后我就躲在那个靠近拐角的一间烂房子里，那些人从对面追过来然后从右边拐弯下去，结果房子太烂了都是没有窗户，墙也是破的，她们还是看见我了，第一个我就躲在门口，他进来时我一把扎在他胸口上，用铅笔，干掉了一个.过了一会第二个来了，结果又发现我了，这个带的有枪，我在他进来那一秒，用铅笔扎中了他脖子，又干掉一个.我赶紧继续逃，刚好这时学生们下课了，我不知道从哪换了一套校服，大红色的，然后我在人群中又找到了我的同伴，她也换了衣服的，我们在人群里混着逃跑.然后我们逃啊逃，但是对方人太多了，跑出学生区域就被发现了，我们就开始拼命的跑，后面好多人拼命追，好像只要跑出这一块地方，前面就是界线，就是共产党的人接应我们，但是这个距离好长，拼命跑到最后，还要翻出那个篱笆的高栅栏，紧张的要命，我们还是出来了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 梦，媳妇儿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.16面试总结</title>
      <link href="/post/ca2e/"/>
      <url>/post/ca2e/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vm无法将网络更改为桥接状态：没有未桥接的主机网络适配器</title>
      <link href="/post/50f9/"/>
      <url>/post/50f9/</url>
      
        <content type="html"><![CDATA[<p>使用<code>桥接模式</code>，虚拟机与物理机是在一个网段，可以互相ping 通。<code>NAT</code>模式下主机无法ping通虚拟机。<br>在更改为桥接模式时出现以下错误</p><blockquote><p><strong>设备vmnet0上的网桥没有运行</strong></p></blockquote><p>解决办法如下：</p><blockquote><p>vm 的编辑菜单下“虚拟网络编辑器”</p></blockquote><p><img src="http://ooll8xqpq.bkt.clouddn.com/net.png" alt="image"></p><p>我出现的情况是VMnet0不存在，这个时候点击<code>还原默认设置</code>，让vm重新生成虚拟网卡。</p><p>另：<br>点击网卡更改为<code>桥接模式</code>时出现<code>无法将网络更改为桥接状态：没有未桥接的主机网络适配器</code>，也可以点击<code>还原默认设置</code>。</p><p>如果恢复默认后还是不行，试一下下面的方案（未测试）:</p><ol><li>打开物理网卡的属性窗口检查是否安装并选中了“VMWare Bridge protocol”。</li><li>若没有，点击：安装—服务—从磁盘安装(C:Program FilesVMWare Workstationnetbridge.inf)，选中对话框的“VMware Bridge Protocol”完成安装。若该服务未出现，可能是VMWare软件安装不正确，需要重装。</li><li>打开Virtual Network Editor，查看桥接绑定物理卡是否成功。若否，须启动vmnet bridging 驱动，打开命令行窗口，输入：net start vmnetbridge；或者重启计算机自启动该驱动。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> vm </tag>
            
            <tag> 桥接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vm添加新的硬盘</title>
      <link href="/post/5e2/"/>
      <url>/post/5e2/</url>
      
        <content type="html"><![CDATA[<p>启动虚拟机，进入打开终端，输入：fdisk –l 然后就可以看到已经发现了新的硬盘，大小为：2147MB。<br>然后输入：fdisk/dev/sdb 给新硬盘分区输入n ，进行分区，让我们选择1-4，那我们可以选择1<br>然后就一直回车。<br>当出现：Command (m for help):后再输入W ，存盘退出fdisk模式，完成后，我们对新硬盘进行格式化，输入Mkfs –t ext3 /dev/sdb出现Proceed anyway？（y，n）时，这时输入“Y”回车。<br>格式化完成后，我们要做的就是对新硬盘设定挂载点,可以新建目录，例如：mkdir /newdisk然后把新硬盘挂载到这个位置：mount /dev/sdb /newdisk 挂载好了，查看一下：df<br>12<br>还没有结束，我们要让系统重启后会自动挂载新硬盘，编辑：vi /etc/fstab 按Insert键插入一行：/dev/sdb /newdisk ext3 defaults 0 0 ，输入完毕后Esc :wq保存退出，新硬盘也就添加完毕了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vm </tag>
            
            <tag> 硬盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.9梦</title>
      <link href="/post/e1f9/"/>
      <url>/post/e1f9/</url>
      
        <content type="html"><![CDATA[<p>人物有媳妇儿，陶世博，然后还有一个女的还有一个男的(迈克，又不是我！)，然后我们被别人追杀，我还有麦克，我们要去把陶世博还有一个女的厂抢来，然后，我们在同时要被别人追杀，还要去救他们，然后就是在那个高楼之间你知道吗，一个一个的高楼，我们直接徒手从一个楼跳到另一个楼，用手抓住，然后再跳另一个楼，在楼梯之间徒手攀爬。<br>然后迈克真的很聪明，看似是在躲避他们的追杀，实际上兜了一圈，是在某一个拐角处是兜了一圈是为了救他们，然后呢，刚好刚好就救到他们之后就弄了一辆破车，那个破车好像是我们酒店的那个996，应该是丰田卡罗拉，然后这个时候车里面好像又有我妈，然后我然后这个车很神奇，它的驾驶位置在正中间，然后左边右边各有一个副驾驶的位置，也就是说这个车是六人坐的不是五人坐的是六人座的，因为它前面就中间是主驾驶左边右边有两个副驾驶，好神奇的车，但是那个车很破，然后我就抱着陶世博还是下雨嘛他衣服全部都湿了，这个时候的陶世博是三岁的陶世博不是七岁，是三岁多还很小，他衣服打湿了他说他想睡觉，然后我就用那个秋衣给他擦干，然后给他打到肚子上面让他睡觉，然后我们就开着那个车就开始跑嘛，因为还有人在追我们，然后到了有一个路口那个路特别烂坑坑洼洼的，还有好多出租车停地乱七八糟的不好走，然后前面就有围追我们的人，结果这个时候就出现了一个帮我们的女的是一个女明星，具体是谁我忘记了还是很斯文的那一种，但是不知道为什么梦里面她特别酷他带了一队人是骑那种重型摩托车的重型机车。<br>她就是一脚一踢就把一辆机车骑出去撞到一个人，他就这么连着推了五六辆那个机车刺激，把对方全部都击倒了，然后我们就顺利的可以逃走了，然后我们就开开开到一个地方那个地方是一栋楼那种楼他是那种房子就是平均层高只有两米，就是那种收纳盒，你见过吗，一个一个的收拉盒一层一层的，然后那个房间是没有门的你进那个房子你知道怎么进吗，只能徒手，他有一个窗户也就你徒手从这一边爬到那一边，然后从窗户爬进这个方面去。<br>这时候就是有我，我妈还有陶世博还有一个男的，然后我们在那个小房子里空间很小，然后还有很多我们的东西什么衣服呀，还有水果有香蕉和亲提还有别的很多东西化妆品，然后，然后我们就睡了一觉，第二天起来了我 们从那个房子里出去的时候就发现了神秘的变化就是我什么都看不见，天空就是那种怎么说呢，有一些有一些那种裂纹，但是忽明忽暗的光，整个就是感觉漆黑一片，置身宇宙中的知道吗，当时我就说我就说感觉不对劲儿，发现有一个地方是一个圆形的原始的那一块在天上有一个圆形的，然后他是有很多那种竖的阴影，还有很多小鱼游来游去，就像那就好像是一块儿玉，玉的背后有一个光源，你明白那种感觉吗忽隐忽现的，一会儿明一会儿暗，然后就是变化，其他的地方就是感觉很奇妙，感觉像是置身于宇宙中，然后我当时就说说说。<br>我当时就说宇宙爆炸了，然后我们所有人都在那儿，感觉很恐怖，感觉所有人都要灭亡了，后来我发现天还是感觉那个头顶上不对劲，因为我看到有那种复古的那种雕饰有复古的东西，我用手摸了一下上面掺着一颗宝石，然后我又发现他是有规则的就是每隔多远，有一颗每隔多远有一颗最后才发现我们并不是在宇宙中是在一个，建筑物里面是一个西方的那种古老的建筑，但是外面的天气的变化真的是不知道什么原因是存在的。<br>然后过了一会儿，我就意识到我们应该逃命了，我就跟我妈说我们要赶紧去下一个地方要逃命了，然后我们就从就准备回家就得从一个地方还有一个坎就是从这边像楼梯通道一样从这个窗子爬出去然后再徒手在墙上徒手爬到那一边去到再从窗户回到自己的房子里，但是还有陶世博我妈就说太麻烦了，因为还要还要怕把陶给我然后我再背着她爬过去嘛，然后最后就说算了，让他们俩个上面等我，我一个人回去收拾东西，然后我就一个人爬回去，最后爬回去发现我们上面和下面的人都在我们那间屋子里吃饭，然后我就开始收东西，这个时候不知道为什么就出现了张银华，然后我就开始时我就发现我们的东西太多了一包一包一包一包的吃的喝的化妆品衣服钱什么都有。<br>然后不知道为什么还聊到了我们高中的同学，这是那个玩的好的现在去了传销的，张秦然后就是聊了很多，然后他就帮我收东西，然后我就感觉我东西太多了，提不走就感觉拎不走啊，我都想搞个那种密码箱把它拖走了，后来不知道为什么就醒了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 媳妇儿，梦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.8梦</title>
      <link href="/post/1df8/"/>
      <url>/post/1df8/</url>
      
        <content type="html"><![CDATA[<p>梦到大四快要毕业了，回了一趟学校，结果校门口遇到一个男孩，大二的（大二还叫男孩？为啥不是我？）<br>一路有说有笑送媳妇儿回去（让陌生人送？），经过西苑简直感慨万千那些吃的（吃了这么久还没有吃腻？），最后买了类似于关东煮一样的，请他吃了一份，送到最后不知道为啥变成了一个女的（呃），结果居然回到家了，然后妈躺在床上媳妇儿还以为是爷爷（难道没开灯？），然后妈说话就特别的带刺，接着就想送这个女的走了，结果这是个捞金的，说让媳妇儿帮他弄到什么什么门票和自助餐的票，那么贵弄不到也懒得弄，就想忽悠她送她先出去，一出去就有一个好长的楼梯，搬着好重的行李（哪来的？），结果没走2步行李就被坏人给顺手拿了（坏人好力气！），然后马上发现追过去，他们有几个人，就开始表演魔术和杂耍之类，弄不回来行李，然后那个人还模仿的是这个女的喜欢的角色，她就不相信是这个人拿了她的行李，还跟他互动很开心，媳妇儿失望了也懒得管了，然后可能就醒了（没睡醒）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 媳妇儿，梦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.7梦2</title>
      <link href="/post/56c9/"/>
      <url>/post/56c9/</url>
      
        <content type="html"><![CDATA[<p>媳妇儿梦到自己化成了小丑（？为啥是小丑，不是爱美么），潜入了一间屋子，进进出出，最后在那间屋子捅死了一个人（多么可爱的人啊，在梦里居然这么血腥暴力啊，得教育），闭上了眼睛没看下去（还是胆小嘛，到底是个小姑娘家），结果发现是在看电视（逗），然后过了一会梦魇了（多次了），感觉门口邓总还有其他人在那拼命的跺脚特别响，怎么都醒不过来（被人扯住了吧，哈哈）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 媳妇儿，梦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错误记录0607</title>
      <link href="/post/4b65/"/>
      <url>/post/4b65/</url>
      
        <content type="html"><![CDATA[<p>今天碰到一个隐藏的问题，csv文件是utf-8bom的格式，导致第一列数据会多一个字符<code>\uFEFF</code>,匹配的时候不相等。</p><p>csv文件以utf-8 bom 编码时，文件开头会多一个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">王2宝,Mike,王三宝</span><br><span class="line">100,108,155</span><br><span class="line">105,108,160</span><br><span class="line">110,108,165</span><br><span class="line">115,105,170</span><br><span class="line">120,101,175</span><br><span class="line">125,100,180</span><br></pre></td></tr></table></figure><p>有个业务操作是需要根据第一行的人名去map中获取value，map的key是<code>王2宝</code>，csv中读取到的乍一看去也<code>2宝</code>，但就是获取不到值，其他的<code>Mike</code>、<code>王三宝</code>都已经正确保存，而且能查到。数据库中查询<code>like &#39;王%宝&#39;</code> 居然只查询到<code>王三宝</code>，当时就惊呆了，怎么会只插入一部分，检查代码也没有查出来问题。然后用<code>like &#39;%宝&#39;</code>居然查出来了，这是怎么回事。最后想到会不会是多了什么字符导致匹配不上。打印了一下<code>王2宝</code>的长度，果然有问题，多了一个。调试的时候看了一下<code>王2宝</code>的值，好家伙，前面有个<code>\uFEFF</code>。<br>手动去掉多的这个字符就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = name.contains(Character.toString(<span class="string">&#x27;\uFEFF&#x27;</span>)) ? <span class="keyword">new</span> StringBuffer(name).deleteCharAt(name.indexOf(<span class="string">&#x27;\uFEFF&#x27;</span>)).toString()</span><br></pre></td></tr></table></figure><p><strong>有时候看起来一样的字符实际上不一样，出现这样的问题时，可以看一下每个字符的数值是不是一致</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 错误记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.6梦</title>
      <link href="/post/f5fa/"/>
      <url>/post/f5fa/</url>
      
        <content type="html"><![CDATA[<p>昨晚做梦在上大学，但是宿舍是初中的宿舍，上体育课选运动鞋，起来晚了穿了别人的运动裤懒得换就买下来，张书晨说卖给我10块钱<br>又是裤又鞋的，还穿别人旧的。逗</p>]]></content>
      
      
      
        <tags>
            
            <tag> 媳妇儿，梦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.7梦</title>
      <link href="/post/9fb/"/>
      <url>/post/9fb/</url>
      
        <content type="html"><![CDATA[<p>看欢乐颂看太久了吧，居然做都是曲肖筱和赵医生这对。话说咋就没有我呢？咋得突然跑到马路上去小找小爹了，还是以前的旧房子。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 媳妇儿，梦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改mysql的默认编码</title>
      <link href="/post/25a6/"/>
      <url>/post/25a6/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character_set_server &#x3D; utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set &#x3D; utf8</span><br></pre></td></tr></table></figure><p>mysql: 使用mysql命令时所需要的配置<br>mysqld: 数据库服务器需要的配置</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.26梦</title>
      <link href="/post/ec4d/"/>
      <url>/post/ec4d/</url>
      
        <content type="html"><![CDATA[<p>媳妇儿梦见带着世博去野生动物园玩，不晓得在哪儿弄到了一辆车，结果是个手动档，还半天没发现，逗死了。<br>下一步就是买个自动代步车。加油。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 梦 </tag>
            
            <tag> 媳妇儿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错误记录</title>
      <link href="/post/4c63/"/>
      <url>/post/4c63/</url>
      
        <content type="html"><![CDATA[<p>今天写了一要命的错误代码，居然半天没有发现，而且对比了之前写的代码还没有发现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Properties properties ;<span class="comment">//这里忘记初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(IDCardUtil.class);</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        properties.load(IDCardUtil.class.getClassLoader().getResourceAsStream(<span class="string">&quot;native.properties&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;未找到省份文件&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==<strong>这种低级错误真是不应该</strong>==</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工作记录 </tag>
            
            <tag> 错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencsv读取csv文件</title>
      <link href="/post/b5b5/"/>
      <url>/post/b5b5/</url>
      
        <content type="html"><![CDATA[<p>最近的工作中需要读取到csv文件，其实csv文件就是一种纯文本文件，数据之间通过<code>,</code>隔开，可以使用io包中的Reader来读取，读取一行之后就按<code>,</code>分隔就能得到数据。<br>opencsv也使用到了Reader来读取csv文件，内部做了封装可以读取所有行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String[]&gt; datas = csvReader.readAll();</span><br></pre></td></tr></table></figure><p>list的元素是每行的元素，是一个字符串数组。</p><p>maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.opencsv<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>opencsv<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> csv </tag>
            
            <tag> opencsv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>致阿姨的一段话</title>
      <link href="/post/d419/"/>
      <url>/post/d419/</url>
      
        <content type="html"><![CDATA[<p>阿姨您好，在这个伟大的日子里，祝您节日快乐，身体健健康康。您将小帆养育成人，付出了超凡的爱，我非常理解您作为母亲的感受和心情，希望小帆能过的幸福快乐，我也一直在朝这个方向努力奋斗。礼物太轻，无法表达对您的感恩和敬重，祝您节日快乐！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 母亲节 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-9日梦</title>
      <link href="/post/2958/"/>
      <url>/post/2958/</url>
      
        <content type="html"><![CDATA[<ul><li>媳妇儿：梦见一个人背着包，穿越荒野</li><li>我：这事怎么能没有我参与，差评！</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 梦 </tag>
            
            <tag> 媳妇儿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>quartz表达式</title>
      <link href="/post/14/"/>
      <url>/post/14/</url>
      
        <content type="html"><![CDATA[<p>字段之间用空格来格开</p><table><thead><tr><th>字段名</th><th>允许的值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td>秒</td><td>0-59</td><td>, - * /</td></tr><tr><td>分</td><td>0-59</td><td>, - * /</td></tr><tr><td>小时</td><td>0-23</td><td>, - * /</td></tr><tr><td>日</td><td>1-31</td><td>, - * ? / L W C</td></tr><tr><td>月</td><td>1-12 or JAN-DEC</td><td>, - * /</td></tr><tr><td>周几</td><td>1-7 or SUN-SAT</td><td>, - * ? / L C #</td></tr><tr><td>年 (可选字段)</td><td>empty, 1970-2099</td><td>, - * /</td></tr></tbody></table><p><code>*</code> 字符可以用于所有字段，在<code>分</code>字段中设为<code>*</code>表示<code>每一分钟</code>的含义。   </p><p><code>?</code> 字符可以用在<code>日</code>和<code>周几</code>字段. 它用来指定 <code>不明确的值</code>. 这在你需要指定这两个字段中的某一个值而不是另外一个的时候会被用到。在后面的例子中可以看到其含义，比如某月的第3天和周3，不能同时指定(可能冲突)，指定其中一个，另外一个就需要用<code>?</code>代替。  </p><p><code>-</code> 字符被用来指定一个值的范围，比如在<code>小时</code>字段中设为”10-12”表示”10点到12点”。  </p><p><code>,</code> 字符指定数个值。比如在<code>周几</code>字段中设为”MON,WED,FRI”表示”the days Monday, Wednesday, and Friday”。   </p><p><code>/</code> 字符用来指定一个值的的增加幅度。 比如在<code>秒</code>字段中设置为”0/15”表示”第0, 15, 30, 和 45秒”。而 “5/15”则表示”第5, 20, 35, 和 50”. 在<code>/</code>前加<code>*</code>字符相当于指定从0秒开始. 每个字段都有一系列可以开始或结束的数值。对于<code>秒</code>和<code>分</code>字段来说，其数值范围为0到59，对于<code>小时</code>字段来说其为0到23, 对于<code>日</code>字段来说为0到31, 而对于<code>月</code>字段来说为1到12。<code>/</code>字段仅仅只是帮助你在允许的数值范围内从开始”第n”的值。 因此对于<code>月</code>字段来说”7/6”只是表示7月开始而不是“每六个月”, 请注意其中微妙的差别。 </p><p><code>L</code> 字符可用在<code>日</code>和<code>周几</code>这两个字段。它是”last”的缩写, 但是在这两个字段中有不同的含义。例如,<code>日</code>字段中的<code>L</code>表示”一个月中的最后一天” —— 对于一月就是31号对于二月来说就是28号（非闰年）。而在<code>周几</code>字段中, 它简单的表示”7” or “SAT”，但是如果在<code>周几</code>字段中使用时跟在某个数字之后, 它表示”该月最后一个星期×” —— 比如”6L”表示”该月最后一个周五”。当使用<code>L</code>选项时,指定确定的列表或者范围非常重要，否则你会被结果搞糊涂的。</p><p><code>W</code> 可用于<code>日</code>字段。用来指定历给定日期最近的工作日(周一到周五) 。比如你将<code>日</code>字段设为”15W”，意为: “离该月15号最近的工作日”。因此如果15号为周六，触发器会在14号即周五调用。如果15号为周日, 触发器会在16号也就是周一触发。如果15号为周二,那么当天就会触发。然而如果你将<code>日</code>字段设为”1W”, 而一号又是周六, 触发器会于下周一也就是当月的3号触发,因为它不会越过当月的值的范围边界。<code>W</code>字符只能用于<code>日</code>字段的值为单独的一天而不是一系列值的时候。</p><p><code>L</code>和<code>W</code>可以组合用于<code>日</code>字段表示为<code>LW</code>，意为”该月最后一个工作日”。</p><p><code>#</code> 字符可用于<code>周几</code>字段。该字符表示“该月第几个周×”，比如”6#3”表示该月第三个周五( 6表示周五而”#3”该月第三个)。再比如: “2#1” = 表示该月第一个周一而 “4#5” = 该月第五个周三。注意如果你指定”#5”该月没有第五个“周×”，该月是不会触发的。</p><p><code>C</code> 字符可用于<code>日</code>和<code>周几</code>字段，它是”calendar”的缩写。它表示为基于相关的日历所计算出的值（如果有的话）。如果没有关联的日历, 那它等同于包含全部日历。<code>日</code>字段值为”5C”表示”日历中的第一天或者5号以后”，<code>周几</code>字段值为”1C”则表示”日历中的第一天或者周日以后”。</p><p>对于<code>月份</code>字段和<code>周几</code>字段来说合法的字符都不是大小写敏感的。</p><p>下面是一些完整的例子:</p><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>“0 0 12 * * ?”</td><td>每天中午十二点触发</td></tr><tr><td>“0 15 10 ? * *”</td><td>每天早上10：15触发</td></tr><tr><td>“0 15 10 * * ?”</td><td>每天早上10：15触发</td></tr><tr><td>“0 15 10 * * ? *”</td><td>每天早上10：15触发</td></tr><tr><td>“0 15 10 * * ? 2005”</td><td>2005年的每天早上10：15触发</td></tr><tr><td>“0 * 14 * * ?”</td><td>每天从下午2点开始到2点59分每分钟一次触发</td></tr><tr><td>“0 0/5 14 * * ?”</td><td>每天从下午2点开始到2：55分结束每5分钟一次触发</td></tr><tr><td>“0 0/5 14,18 * * ?”</td><td>每天的下午2点至2：55和6点至6点55分两个时间段内每5分钟一次触发</td></tr><tr><td>“0 0-5 14 * * ?”</td><td>每天14:00至14:05每分钟一次触发</td></tr><tr><td>“0 10,44 14 ? 3 WED”</td><td>三月的每周三的14：10和14：44触发</td></tr><tr><td>“0 15 10 ? * MON-FRI”</td><td>每个周一、周二、周三、周四、周五的10：15触发</td></tr><tr><td>“0 15 10 15 * ?”</td><td>每月15号的10：15触发</td></tr><tr><td>“0 15 10 L * ?”</td><td>每月的最后一天的10：15触发</td></tr><tr><td>“0 15 10 ? * 6L”</td><td>每月最后一个周五的10：15触发</td></tr><tr><td>“0 15 10 ? * 6L”</td><td>每月最后一个周五的10：15触发</td></tr><tr><td>“0 15 10 ? * 6L 2002-2005”</td><td>2002年至2005年的每月最后一个周五的10：15触发</td></tr><tr><td>“0 15 10 ? * 6#3”</td><td>每月的第三个周五的10：15触发</td></tr><tr><td>“30 * * * * ?”</td><td>每半分钟触发任务</td></tr><tr><td>“30 10 * * * ?”</td><td>每小时的10分30秒触发任务</td></tr><tr><td>“30 10 1 * * ?”</td><td>每天1点10分30秒触发任务</td></tr><tr><td>“30 10 1 20 * ?”</td><td>每月20号1点10分30秒触发任务</td></tr><tr><td>“30 10 1 20 10 ? *”</td><td>每年10月20号1点10分30秒触发任务</td></tr><tr><td>“30 10 1 20 10 ? 2011”</td><td>2011年10月20号1点10分30秒触发任务</td></tr><tr><td>“30 10 1 ? 10 * 2011”</td><td>2011年10月每天1点10分30秒触发任务</td></tr><tr><td>“30 10 1 ? 10 SUN 2011”</td><td>2011年10月每周日1点10分30秒触发任务</td></tr><tr><td>“15,30,45 * * * * ?”</td><td>每15秒，30秒，45秒时触发任务</td></tr><tr><td>“15-45 * * * * ?”</td><td>15到45秒内，每秒都触发任务</td></tr><tr><td>“15/5 * * * * ?”</td><td>每分钟的每15秒开始触发，每隔5秒触发一次</td></tr><tr><td>“15-30/5 * * * * ?”</td><td>每分钟的15秒到30秒之间开始触发，每隔5秒触发一次</td></tr><tr><td>“0 0/3 * * * ?”</td><td>每小时的第0分0秒开始，每三分钟触发一次</td></tr><tr><td>“0 15 10 ? * MON-FRI”</td><td>星期一到星期五的10点15分0秒触发任务</td></tr><tr><td>“0 15 10 L * ?”</td><td>每个月最后一天的10点15分0秒触发任务</td></tr><tr><td>“0 15 10 LW * ?”</td><td>每个月最后一个工作日的10点15分0秒触发任务</td></tr><tr><td>“0 15 10 ? * 5L”</td><td>每个月最后一个星期四的10点15分0秒触发任务</td></tr><tr><td>“0 15 10 ? * 5#3”</td><td>每个月第三周的星期四的10点15分0秒触发任务</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> quartz </tag>
            
            <tag> cron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven跳过单元测试</title>
      <link href="/post/9dc2/"/>
      <url>/post/9dc2/</url>
      
        <content type="html"><![CDATA[<p>有两种方式可以跳过单元测试</p><ul><li>通过添加jvm参数的方式</li><li>在项目的pom文件中配置插件</li></ul><h6 id="通过jvm参数"><a href="#通过jvm参数" class="headerlink" title="通过jvm参数"></a>通过jvm参数</h6><ol><li>-DskipTests：不执行测试用例，但是会编绎test下的class，copy资源文件。</li><li>-Dmaven.test.skip=true：不编绎，不执行，不copy。</li></ol><h6 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h6><ol><li>不执行test的配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span><span class="comment">&lt;!--两种配置经试验效果一样--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;skip&gt;true&lt;/skip&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>不编绎test的配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在编绎插件里面配置<code>skip</code>就可以了，<code>surefire</code> 插件不配置一样可以达到目的。<br>但是会copy资源文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是我们加上这个配置之后，不copy资源文件了。</p><hr><p><strong>综上对比，我们可以猜测，加上jvm 变量之后会影响响所有相关的插件，插件会从变量中取出相应的值。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>quartz 工具类</title>
      <link href="/post/482/"/>
      <url>/post/482/</url>
      
        <content type="html"><![CDATA[<p>利用quartz实现动态创建任务，主要涉及的类有<code>Job</code>,<code>JobDetail</code>,<code>CronScheduleBuilder</code>,<code>CronTrigger</code>,<code>Scheduler</code>.</p><ul><li>Job:接口，对应到具体要做的事情。通常是业务代码实现。</li><li>JobDetail:接口，封装了<code>Job</code>相关的信息，比如key,description,jobDataMap等。<code>JobDataMap</code>用来传递数据到job中。</li><li>CronScheduleBuilder:表达式任务的builder。</li><li>CronTrigger:支持表达式的trigger。</li></ul><h5 id="ScheduleJob"><a href="#ScheduleJob" class="headerlink" title="ScheduleJob"></a>ScheduleJob</h5><p>为了动态添加，我们自己也封装了一下job相关的信息，包括名称，分组，表达式以及要执行的java方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 任务id </span></span><br><span class="line"><span class="keyword">private</span> String jobId;</span><br><span class="line"><span class="comment">// 任务名称 </span></span><br><span class="line"><span class="keyword">private</span> String jobName;</span><br><span class="line"><span class="comment">//任务分组 </span></span><br><span class="line"><span class="keyword">private</span> String jobGroup;</span><br><span class="line"><span class="comment">// 任务状态 0禁用 1启用 2删除</span></span><br><span class="line"><span class="keyword">private</span> String jobStatus;</span><br><span class="line"><span class="comment">// 任务运行时间表达式 </span></span><br><span class="line"><span class="keyword">private</span> String cronExpression;</span><br><span class="line"><span class="comment">// 任务描述 </span></span><br><span class="line"><span class="keyword">private</span> String description;</span><br></pre></td></tr></table></figure><p>数据来源可以是配置在数据库中，通过查询来构造<code>ScheduleJob</code>信息；测试的时候可以直接new一个<code>ScheduleJob</code>对象。</p><h5 id="QuartzStatefulJobFactory"><a href="#QuartzStatefulJobFactory" class="headerlink" title="QuartzStatefulJobFactory"></a>QuartzStatefulJobFactory</h5><p>实现一个Job,去调用我们自己的业务类。这种方式可以使用我们的job无需实现任务quartz的接口，从而实现解耦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisallowConcurrentExecution</span><span class="comment">//避免并发执行同一个job</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzStatefulJobFactory</span> <span class="keyword">implements</span> <span class="title">Job</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JOB_NAME_SEPARATOR = <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(QuartzStatefulJobFactory.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;任务开始运行&quot;</span>);</span><br><span class="line">        ScheduleJob scheduleJob = (ScheduleJob)context.getMergedJobDataMap().get(<span class="string">&quot;scheduleJob&quot;</span>);<span class="comment">//在这里将我们封装的job取出来。</span></span><br><span class="line">        logger.debug(<span class="string">&quot;任务名称 = [&quot;</span> + scheduleJob.getJobName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        String classPath = scheduleJob.getClassPath();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(classPath))&#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;任务类为空，忽略&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String className = classPath;</span><br><span class="line">        String methodName = <span class="string">&quot;execute&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.endsWith(classPath,<span class="string">&quot;()&quot;</span>))&#123;<span class="comment">//括号结尾的方法调用。比如 xxx.Object.test()</span></span><br><span class="line">            <span class="keyword">int</span> lastNameIndex = StringUtils.lastIndexOf(classPath,JOB_NAME_SEPARATOR);</span><br><span class="line">            className = StringUtils.substring(classPath,<span class="number">0</span>,lastNameIndex);</span><br><span class="line">            methodName = StringUtils.substring(classPath,lastNameIndex + <span class="number">1</span>, StringUtils.indexOf(classPath, <span class="string">&quot;()&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class jobClass =  ClassUtils.forName(className,ClassUtils.getDefaultClassLoader());</span><br><span class="line">           <span class="comment">/* ProxyFactoryBean proxy = new ProxyFactoryBean();</span></span><br><span class="line"><span class="comment">            proxy.setTargetClass(jobClass);</span></span><br><span class="line"><span class="comment">            Object target = proxy.getObject();*/</span></span><br><span class="line">           Object target = jobClass.newInstance();</span><br><span class="line">            Method method = ReflectionUtils.findMethod(jobClass,methodName);</span><br><span class="line">            ReflectionUtils.invokeMethod(method,target);<span class="comment">//调用业务方法</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;未找到所描述的类&quot;</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobExecutionException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="QuartzManager"><a href="#QuartzManager" class="headerlink" title="QuartzManager"></a>QuartzManager</h5><p>提供一个静态方法来添加job</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个定时任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sched  调度器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> job 任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addJob</span><span class="params">(Scheduler sched, ScheduleJob job, JobListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JobDetail jobDetail = JobBuilder.newJob( QuartzStatefulJobFactory.class)</span><br><span class="line">                    .withIdentity(job.getJobName(),job.getJobGroup()).withDescription(job.getDescription()).build();<span class="comment">// 任务名，任务组，任务执行类</span></span><br><span class="line">            jobDetail.getJobDataMap().put(<span class="string">&quot;scheduleJob&quot;</span>, job);</span><br><span class="line">            <span class="comment">//表达式调度构建器</span></span><br><span class="line">            CronScheduleBuilder scheduleBuilder = CronScheduleBuilder.cronSchedule(job.getCronExpression());</span><br><span class="line">            CronTrigger trigger = TriggerBuilder.newTrigger().withIdentity(job.getJobName(), job.getJobGroup()).withSchedule(scheduleBuilder).build();</span><br><span class="line"></span><br><span class="line">            sched.getListenerManager().addJobListener(listener);<span class="comment">//添加任务监听器</span></span><br><span class="line">            sched.scheduleJob(jobDetail,trigger);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobScheduleException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Quartz</code> 也提供了一些诸如一天的某点、重复这样简单的表达式，如<code>CronScheduleBuilder</code> 的dailyAtHourAndMinute方法，<code>DailyTimeIntervalScheduleBuilder</code>,<code>SimpleScheduleBuilder</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> quartz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea 创建 Spring boot应用</title>
      <link href="/post/361c/"/>
      <url>/post/361c/</url>
      
        <content type="html"><![CDATA[<p>Idea 号称开发JAVA 最智能的工具，下面就利用它来创建一个<code>Spring Boot</code> 应用。</p><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><ol><li><p>选择 <code>Create New Project</code><br><img src="http://ooll8xqpq.bkt.clouddn.com/springboot_step1.png" alt="step1"></p></li><li><p>利用Spring Initializr来初始化<code>Spring</code> 相关的框架<br>网络状况好的情况下利用这个工具可以可视化地选择使用的框架，勾选即可。选择所安装的Jdk ，没有的话就<code>New</code>一个。<br><img src="http://ooll8xqpq.bkt.clouddn.com/springboot_step2.png" alt="step2"></p></li><li><p>配置一些项目的基本信息<br><img src="http://ooll8xqpq.bkt.clouddn.com/springboot_step3.png" alt="step3"><br>这里创建<code>maven</code> 项目（<code>type</code> 选择第一个，会生成完整的<code>maven</code>项目），输入<code>groudId</code>，<code>artifactId</code>，然后选择下一步。</p></li><li><p>选择需要用到的框架  </p></li></ol><ul><li>左侧是功能的分类</li><li>中间是具体的功能</li><li>右侧是选中后的功能，点<code>x</code>可以取消</li><li>下部是相关的文档，可以打开在线文档</li><li>左上侧可以进行搜索<br>完成之后点击下一步<br><img src="http://ooll8xqpq.bkt.clouddn.com/springboot_step5.png" alt="step4"></li></ul><ol start="5"><li>补充项目保存的目录，以及项目名称<br><img src="http://ooll8xqpq.bkt.clouddn.com/springboot_step6.png" alt="step5"></li><li>确认之后创建项目。<br>一番等待之后就会创建好整个项目，idea会生成maven相关的目录结构，会创建好一个<code>run/debug</code>，这取决于网速。创建好之后就可以点击运行了。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Idea </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dependencies与dependencyManagement的区别</title>
      <link href="/post/a9cd/"/>
      <url>/post/a9cd/</url>
      
        <content type="html"><![CDATA[<h4 id="dependencyManagement-的使用场景"><a href="#dependencyManagement-的使用场景" class="headerlink" title="dependencyManagement 的使用场景"></a>dependencyManagement 的使用场景</h4><p>在多模块项目中，子项目可能会需要引入同样的依赖，更改版本时需要维护多套设置，这时将依赖申明到父模块的<code>dependencyManagement</code>元素中，维护共同的版本，子模块在使用时就可以省略掉版本号。</p><h4 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h4><p>这个元素就是用来申明依赖的。会传递给子模块。</p><h4 id="dependencies与dependencyManagement的区别"><a href="#dependencies与dependencyManagement的区别" class="headerlink" title="dependencies与dependencyManagement的区别"></a>dependencies与dependencyManagement的区别</h4><p>后者只申明项目中会用到的依赖，不会引入依赖。前者是实际引入依赖的元素，会传递给子项目。<br>子项目在引入时使用不同的版本就可以覆盖<code>dependencyManagement</code>的配置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备份hexo代码</title>
      <link href="/post/2746/"/>
      <url>/post/2746/</url>
      
        <content type="html"><![CDATA[<p>hexo git 只会将生成的页面提交到git中，为了保存hexo所做的修改以及文章的源文件，我们需要将hexo 和文章的源文件也保存到我们的git中。</p><ol><li>创建一个hexo 分支用来保存我们的hexo和源文件，并且设置成默认分支，因为我们主要管理此分支，设为默认比较方便。<br><img src="http://ooll8xqpq.bkt.clouddn.com/github_branch_settiongs.png" alt="image"><br>创建之后选中，并点击<code>update</code>按钮。</li><li>将仓库克隆下来，执行<code>npm install hexo</code>、<code>hexo init</code>、<code>npm install</code> 和 <code>npm install hexo-deployer-git</code>。 <strong>注意：<code>hexo init</code>会删除目录中.git文件，因此先复制到别处，执行完<code>hexo init</code> 后再拷备回来。</strong></li><li>修改博客根目录中的<code>_config.yml</code>。<br><img src="http://ooll8xqpq.bkt.clouddn.com/deploy.png" alt="image"><br>指定分支为master，这个分支用来保存发布后的页面。因为github 仓库是个人账号类型的，得放在master分支上。</li><li>执行完成之后就可以进行常规的git操作了，如<code>git add .</code>、<code>git commit</code> 、<code>git push</code>。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用httpclient 4.3发送post请求</title>
      <link href="/post/a7d9/"/>
      <url>/post/a7d9/</url>
      
        <content type="html"><![CDATA[<h3 id="单一类型的参数"><a href="#单一类型的参数" class="headerlink" title="单一类型的参数"></a>单一类型的参数</h3><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HttpPost httpPost = <span class="keyword">new</span> HttpPost(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">httpPost.setHeader(<span class="string">&quot;Accept-Language&quot;</span>, <span class="string">&quot;zh-cn,zh;q=0.5&quot;</span>);</span><br><span class="line">httpPost.setHeader(<span class="string">&quot;Accept-Charset&quot;</span>, <span class="string">&quot;GBK,utf-8;q=0.7,*;q=0.7&quot;</span>);</span><br><span class="line">httpPost.setHeader(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;keep-alive&quot;</span>);</span><br><span class="line">httpPost.addHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line">httpPost.setHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">httpPost.setEntity(<span class="keyword">new</span> StringEntity(jsonParam, APPLICATION_JSON));</span><br><span class="line">System.out.println(EntityUtils.toString(HttpClients.createDefault().execute(httpPost).getEntity()));<span class="comment">//打印响应结果</span></span><br></pre></td></tr></table></figure><p>大致步骤：</p><ol><li>构造HttpPost实例，参数是请求地址</li><li>添加一些基本的head，比如字符集之类的</li><li>添加参数</li></ol><p>HttpClient 框架将请求参数封装在<code>HttpEntity</code> 接口中, 常用的有<code>StringEntity</code>、<code>UrlEncodedFormEntity</code>、<code>FileEntity</code>、<code>InputStreamEntity</code>等。</p><h5 id="StringEntity"><a href="#StringEntity" class="headerlink" title="StringEntity"></a>StringEntity</h5><p>可以用来构造字符串类型的参数。内部使用了一个数组来保存数据。<br>比如构造一个表单<code>application/x-www-form-urlencoded</code>：”a=1&amp;b=2”。当然<code>UrlEncodedFormEntity</code>进一步做了封装，用来构造表单。再如发送json格式的参数，需要将json转成String。</p><h5 id="UrlEncodedFormEntity"><a href="#UrlEncodedFormEntity" class="headerlink" title="UrlEncodedFormEntity"></a>UrlEncodedFormEntity</h5><p>继承自<code>StringEntity</code>。对<code>StringEntity</code> 做了进一步的封装，构造函数中使用集合来作为参数，避免了参数的拼接，并且设置了<code>Content-Type=application/x-www-form-urlencoded</code>.</p><h5 id="FileEntity"><a href="#FileEntity" class="headerlink" title="FileEntity"></a>FileEntity</h5><p>将文件作为参数发送到服务端。<br>构造函数中使用一个file来接收本地文件。</p><h5 id="InputStreamEntity"><a href="#InputStreamEntity" class="headerlink" title="InputStreamEntity"></a>InputStreamEntity</h5><p>将流作为参数发送到服务端。可以是文件流，以及byte array 等其他形式的流，只要服务端能解析即可。</p><h3 id="多种类型的参数"><a href="#多种类型的参数" class="headerlink" title="多种类型的参数"></a>多种类型的参数</h3><p>如果你的参数中既有文件，又有普通的字符参数，上述方式就无法满足了。<br>这个时候需要使用<code>MultipartFormEntity</code>,但是无法直接使用，需要用到<code>MultipartEntityBuilder</code>来构建。  </p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MultipartEntityBuilder multiEntity = MultipartEntityBuilder.create();</span><br><span class="line">URLConnection imgConn = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.baidu.com/test.jpg&quot;</span>).openConnection();</span><br><span class="line">multiEntity.addPart(<span class="string">&quot;image&quot;</span>, <span class="keyword">new</span> InputStreamBody(imgConn.getInputStream(),<span class="string">&quot;image&quot;</span>));</span><br><span class="line">multiEntity.addPart(<span class="string">&quot;face_image_type&quot;</span>,<span class="keyword">new</span> StringBody(<span class="string">&quot;raw_image&quot;</span>, ContentType.TEXT_PLAIN));<span class="comment">//默认字符集不是utf-8，需要注意</span></span><br><span class="line">multiEntity.addPart(<span class="string">&quot;idcard_name&quot;</span>,<span class="keyword">new</span> StringBody(idCardName, ContentType.parse(<span class="string">&quot;text/plain;charset=UTF-8&quot;</span>)));</span><br><span class="line">httpPost.setEntity(multiEntity.build());<span class="comment">//调用build方法</span></span><br><span class="line">HttpResponse httpResponse = HttpClients.createDefault().execute(httpPost);</span><br></pre></td></tr></table></figure><p>我这里添加了一个流参数用来上传文件，一个字符串参数。有时候我们上传的文件是来自网络的，那就需要使用流了。如果是使用本地文件，则可以使用<code>FileBody</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> httpclient4 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
