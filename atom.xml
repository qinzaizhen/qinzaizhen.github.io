<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水娃火娃石榴娃</title>
  
  <subtitle>程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qzztf.com/"/>
  <updated>2024-06-16T07:25:26.154Z</updated>
  <id>http://qzztf.com/</id>
  
  <author>
    <name>水娃</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Cloud Gateway整合Spring Doc</title>
    <link href="http://qzztf.com/post/5441/"/>
    <id>http://qzztf.com/post/5441/</id>
    <published>2023-04-02T12:49:15.000Z</published>
    <updated>2024-06-16T07:25:26.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-Gateway整合Spring-Doc"><a href="#Spring-Cloud-Gateway整合Spring-Doc" class="headerlink" title="Spring Cloud Gateway整合Spring Doc"></a>Spring Cloud Gateway整合Spring Doc</h1><p>最近在新项目使用到了Spring Doc，支持open api 3.</p><h2 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h2><p>使用Spring Doc 1.6.14版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-webflux-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-webmvc-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-javadoc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-springdoc-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时想在网关项目中整合所有的服务api文档。各个服务使用nacos注册，网关读取到注册的服务路由，并初始化swagger的访问路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;swaggerRouteRefreshListener&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationListener&lt;RefreshRoutesEvent&gt; <span class="title">routeRefreshListener</span><span class="params">(RouteDefinitionLocator locator)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApplicationListener&lt;RefreshRoutesEvent&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(RefreshRoutesEvent event)</span> </span>&#123;</span><br><span class="line">            routeDefinitionLocator.getRouteDefinitions().collectList().subscribe(definitions -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                definitions.forEach(routeDefinition -&gt; &#123;</span><br><span class="line">                    <span class="comment">//注册的服务id都是特定前缀的 ReactiveCompositeDiscoveryClient_</span></span><br><span class="line">                    String group = routeDefinition.getId().replace(DISCOVERY_CLIENT_ID_PRE, <span class="string">&quot;&quot;</span>).toLowerCase();</span><br><span class="line">                    AbstractSwaggerUiConfigProperties.SwaggerUrl swaggerUrl = <span class="keyword">new</span> AbstractSwaggerUiConfigProperties.SwaggerUrl(</span><br><span class="line">                        group,</span><br><span class="line">                        routeDefinition.getUri().toString().replace(<span class="string">&quot;lb://&quot;</span>, <span class="string">&quot;&quot;</span>).toLowerCase() + <span class="string">&quot;/v3/api-docs&quot;</span>,</span><br><span class="line">                        <span class="comment">//displayName 是添加进nacos的自定义元数据，设置成中文，方便识别</span></span><br><span class="line">                        routeDefinition.getMetadata().getOrDefault(<span class="string">&quot;displayName&quot;</span>, <span class="string">&quot;&quot;</span>).toString()</span><br><span class="line">                    );</span><br><span class="line">                    Set&lt;AbstractSwaggerUiConfigProperties.SwaggerUrl&gt; urls = swaggerUiConfigProperties.getUrls();</span><br><span class="line">                    <span class="keyword">if</span> (urls == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        urls = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">                        swaggerUiConfigProperties.setUrls(urls);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//可以判断一下是不是已经加过了。</span></span><br><span class="line">                    urls.add(swaggerUrl);</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="处理knife4j"><a href="#处理knife4j" class="headerlink" title="处理knife4j"></a>处理knife4j</h2><p>如果使用knife4j作为页面展示，需要处理一下basePath。在openapi3里面貌似没有这个元素了。仅针对knife4j处理。</p><p>创建一个gateway filter，在返回值中加上basePath。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerGlobalFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        String path = request.getPath().toString();</span><br><span class="line">        String host = request.getLocalAddress().getHostString();</span><br><span class="line">        <span class="keyword">int</span> port = request.getLocalAddress().getPort();</span><br><span class="line">        <span class="keyword">if</span> (!path.endsWith(<span class="string">&quot;/v3/api-docs&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] pathArray = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        String basePath = pathArray[<span class="number">1</span>];</span><br><span class="line">        ServerHttpResponse originalResponse = exchange.getResponse();</span><br><span class="line"></span><br><span class="line">        ServerHttpResponseDecorator decoratedResponse = <span class="keyword">new</span> ServerHttpResponseDecorator(originalResponse) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">writeWith</span><span class="params">(Publisher&lt;? extends DataBuffer&gt; body)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">super</span>.getStatusCode().equals(HttpStatus.OK) &amp;&amp; body <span class="keyword">instanceof</span> Flux) &#123;</span><br><span class="line">                    Flux&lt;? extends DataBuffer&gt; fluxBody = Flux.from(body);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.writeWith(fluxBody.buffer().map(dataBuffers -&gt; &#123;</span><br><span class="line">                        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                        dataBuffers.forEach(dataBuffer -&gt; &#123;</span><br><span class="line">                            <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[dataBuffer.readableByteCount()];</span><br><span class="line">                            dataBuffer.read(content);</span><br><span class="line">                            DataBufferUtils.release(dataBuffer);</span><br><span class="line">                            list.add(<span class="keyword">new</span> String(content, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">                        &#125;);</span><br><span class="line">                        String s = <span class="keyword">this</span>.listToString(list);</span><br><span class="line">                        JSONObject jsonObject = JSONUtil.parseObj(s);</span><br><span class="line"></span><br><span class="line">                        jsonObject.put(<span class="string">&quot;host&quot;</span>, host + <span class="string">&quot;:&quot;</span> + port);</span><br><span class="line">                        jsonObject.put(<span class="string">&quot;basePath&quot;</span>, basePath);</span><br><span class="line">                        s = jsonObject.toString();</span><br><span class="line">                        <span class="comment">//设置更新后的header请求头长度</span></span><br><span class="line">                        <span class="keyword">int</span> length = s.getBytes().length;</span><br><span class="line">                        HttpHeaders headers = originalResponse.getHeaders();</span><br><span class="line">                        headers.setContentLength(length);</span><br><span class="line">                        <span class="keyword">return</span> bufferFactory().wrap(s.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">                    &#125;));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.writeWith(body);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//获取父类原始ServerHttpResponse的header请求头信息，这是代理Delegate类型</span></span><br><span class="line">                HttpHeaders httpHeaders = <span class="keyword">super</span>.getHeaders();</span><br><span class="line">                httpHeaders.set(HttpHeaders.CONTENT_TYPE, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> httpHeaders;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> String <span class="title">listToString</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">                StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">                    stringBuilder.append(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// replace response with decorator</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange.mutate().response(decoratedResponse).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附：Nacos添加自定义meta数据"><a href="#附：Nacos添加自定义meta数据" class="headerlink" title="附：Nacos添加自定义meta数据"></a>附：Nacos添加自定义meta数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; NacosDiscoveryProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosConfigDocAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired(required = false)</span></span><br><span class="line">   <span class="keyword">private</span> NacosDiscoveryProperties properties;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Value(&quot;$&#123;spring.application.displayName:$&#123;spring.application.name&#125;&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String displayName;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@PostConstruct</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      properties.getMetadata().put(<span class="string">&quot;displayName&quot;</span>, displayName);</span><br><span class="line">      properties.init();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Cloud-Gateway整合Spring-Doc&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Gateway整合Spring-Doc&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud Gateway整合Spring
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>处理字典值反显问题.md</title>
    <link href="http://qzztf.com/post/f507/"/>
    <id>http://qzztf.com/post/f507/</id>
    <published>2023-04-02T12:46:42.000Z</published>
    <updated>2024-06-16T07:25:26.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="处理字典值反显问题"><a href="#处理字典值反显问题" class="headerlink" title="处理字典值反显问题"></a>处理字典值反显问题</h1><p>项目中往往只保存了字典的key值，前端页面显示时需要展示字面值。</p><p>解决方案通常有以下几种：</p><ol><li>前端展示时，根据字典key，调用专门的接口去查询字面值。为了性能考虑，可以将查询结果缓存到浏览器。适用于不常变化的字典值。</li><li>后端返回结果前将字典值处理好后一起返回。这里面也有几种处理方式：<ol><li>查询时sql关联查询字典表。适用于字典模块与业务模块没有分离的情况。</li><li>返回结果根据字典值调用字典接口查询出字面值。适用于字典与业务分离的情况。字典接口可以根据情况做缓存。</li></ol></li></ol><p>这里简单说一下最后一种处理方式。</p><p>具体思路是利用mybatis的插件去处理每条记录中特定的字段。</p><h2 id="定义标记注解FieldBind"><a href="#定义标记注解FieldBind" class="headerlink" title="定义标记注解FieldBind"></a>定义标记注解FieldBind</h2><p>该注解用来某个字段上，用来标记该字段是字典值，需要反显。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FieldBind &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字典类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写字典值目标字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">target</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">handlerName</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>type：字典通常是分类的。一个分类下只有几个字典值。</li><li>target：处理后字面值保存到哪个字段。在返回的vo中多定义一个字段用来装字面值。</li><li>handlerName：处理器bean的名称。</li></ul><h2 id="定义字典处理器FieldBindHandler"><a href="#定义字典处理器FieldBindHandler" class="headerlink" title="定义字典处理器FieldBindHandler"></a>定义字典处理器FieldBindHandler</h2><p>FieldBindHandler接口是字典处理的抽象接口，用来查询字典值及其描述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FieldBindHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 字典类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 字典值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字典显示值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span>  &lt;T&gt; <span class="function">T <span class="title">handle</span><span class="params">(String type, Object value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列出所有可能的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> List&lt;Value&gt; <span class="title">listAll</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Value</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String value;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 描述</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String desp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工具类FieldBindHandlerHelper"><a href="#工具类FieldBindHandlerHelper" class="headerlink" title="工具类FieldBindHandlerHelper"></a>工具类FieldBindHandlerHelper</h2><p>该工具会遍历要处理对象的所有字段，识别出标记注解的字段，调用处理器FieldBindHandler获取到字面值，然后将字面值设置到目标字段中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldBindHandlerHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FieldBindHandler dictService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//hutool的SpringUtil的工具类</span></span><br><span class="line">        dictService = SpringUtil.getBean(FieldBindHandler.class);</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.MINUTES, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>), <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理返回结果值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.lang.Object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021/9/6 11:20</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">setFieldValue</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result.getClass().isPrimitive()) &#123;</span><br><span class="line">            <span class="comment">//基本类型直接返回</span></span><br><span class="line">            <span class="keyword">return</span> (T) result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">            <span class="comment">//map类型直接返回</span></span><br><span class="line">            <span class="keyword">return</span> (T) result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object obj : (Collection) result) &#123;</span><br><span class="line">                setFieldValue(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (T) result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此处可根据需要加上一些判断优化处理，如result为基本数据类型对象、Map时不再执行后续代码，或只处理限定类等</span></span><br><span class="line"></span><br><span class="line">        Field[] fs = ReflectUtil.getFields(result.getClass());</span><br><span class="line">        List&lt;Future&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;(fs.length);</span><br><span class="line">        <span class="keyword">for</span> (Field f : fs) &#123;</span><br><span class="line">            FieldBind dictBind = f.getAnnotation(FieldBind.class);</span><br><span class="line">            <span class="keyword">if</span> (dictBind == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取@FieldBind标记字段具体值</span></span><br><span class="line">            Object value = ReflectUtil.getFieldValue(result, f);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            futures.add(executor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 设置目标字段的转换值</span></span><br><span class="line">                    FieldBindHandler handler = dictService;</span><br><span class="line">                    <span class="keyword">if</span> (StrUtil.isNotBlank(dictBind.handlerName())) &#123;</span><br><span class="line">                        handler = SpringUtil.getBean(dictBind.handlerName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    ReflectUtil.setFieldValue(result, dictBind.target(), handler.handle(dictBind.type(), value));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        futures.stream().peek(future -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                future.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;字典转换失败&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> (T) result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mybatis插件FieldInterceptor"><a href="#mybatis插件FieldInterceptor" class="headerlink" title="mybatis插件FieldInterceptor"></a>mybatis插件FieldInterceptor</h2><p>此插件用来拦截mybatis处理resultset。在插件中会调用上面的工具类处理返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;@Signature(type = ResultSetHandler.class, method = &quot;handleResultSets&quot;, args = &#123;Statement.class&#125;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FieldBindHandlerHelper.setFieldValue(invocation.proceed());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target <span class="keyword">instanceof</span> ResultSetHandler) &#123;</span><br><span class="line">            <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现FieldBindHandler"><a href="#实现FieldBindHandler" class="headerlink" title="实现FieldBindHandler"></a>实现FieldBindHandler</h2><p>在项目中只需要实现字典获取的方式即可。如果公司的项目中实典的获取方式是统一的，只需要实现一次即可。</p><p><strong>如果实现了多个，则需要在其中一个指定<code>@primary</code>，并在<code>FieldBind</code>注解标记的字段中指定要使用的<code>FieldBindHandler</code></strong></p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FieldBind(type = &quot;subLabelType&quot;, target = &quot;labelTypeName&quot;, handlerName = &quot;sysDicFieldBindHandler&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String labelType;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 标签类型名称</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> String labelTypeName;</span><br></pre></td></tr></table></figure><p>至此我们就处理了字典的反显问题。</p><h2 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h2><p>优化的点：</p><ol><li>现在处理字典的时候，如果返回的是列表，是一条条数据进行处理的。同一个字典类型或同一个字典值将会查询多次，可以考虑一次处理多条记录。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;处理字典值反显问题&quot;&gt;&lt;a href=&quot;#处理字典值反显问题&quot; class=&quot;headerlink&quot; title=&quot;处理字典值反显问题&quot;&gt;&lt;/a&gt;处理字典值反显问题&lt;/h1&gt;&lt;p&gt;项目中往往只保存了字典的key值，前端页面显示时需要展示字面值。&lt;/p&gt;
&lt;p&gt;解决
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring AOP 调用同一个对象的方法</title>
    <link href="http://qzztf.com/post/9fa5/"/>
    <id>http://qzztf.com/post/9fa5/</id>
    <published>2020-12-05T14:55:47.000Z</published>
    <updated>2024-06-16T07:25:26.147Z</updated>
    
    <content type="html"><![CDATA[<p>经过前面的学习，我们了解了Spring AOP的执行过程。<br>这里想提醒注意一个小问题，我们在对象的方法中调用该对象的另外一个方法会出现什么现象呢？</p><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><ol><li><p>定义对象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessService</span> <span class="keyword">implements</span> <span class="title">IBusinessService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;i want to say again&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.sayAgain();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayAgain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;again&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;again&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在<code>sayHello</code> 方法中调用了该对象的<code>sayAgain</code>方法。</p><ol start="2"><li><p>配置aop</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.sexycode.spring.study.chapter5.BusinessService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.sexycode.spring.study.chapter5.LogAspect&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.sexycode.spring.study.chapter5.BusinessBeforeAdvice&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;log&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* cn.sexycode.spring.study.chapter5.BusinessService.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>在<code>BusinessService</code>的每个方法调用前打印<code>log</code>。</p><ol start="3"><li><p>执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;sameobject.xml&quot;</span>);</span><br><span class="line">    applicationContext.getBean(IBusinessService.class).sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log</span><br><span class="line">hello</span><br><span class="line">i want to say again</span><br><span class="line">again</span><br></pre></td></tr></table></figure><p>并没有想我们想象的那样在每个方法中打印<code>log</code>。</p><p>原因在前面的文章中提到过，将执行到目标对象的方法<code>sayHello</code>时，这个时直接调用<code>sayAgain</code>方法时，跟代理对象没有关系了，所以是不会生效的。我们要弄清楚方法调用之所以能被拦截，就是因为我们调用的是代理对象的方法，而不是目标对象的方法。这跟子类重写父类的方法容易混淆，当我们重写之后，调用的是子类的方法。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>想要解决这个问题也很简单，思路就是在方法内部调用代理对象的方法就可以了。</p><ol><li>暴露代理对象</li><li>将方法放到其他对象</li></ol><h2 id="暴露代理对象"><a href="#暴露代理对象" class="headerlink" title="暴露代理对象"></a>暴露代理对象</h2><p>Spring 给我们提供了一个工具类<code>org.springframework.aop.framework.AopContext#currentProxy</code>可以获取当前调用的代理对象。<strong>但是需要我们暴露出代理对象，如：<code>&lt;aop:aspectj-autoproxy expose-proxy=&quot;true&quot;&gt;</code></strong></p><h2 id="将两个方法拆分到不同的对象中"><a href="#将两个方法拆分到不同的对象中" class="headerlink" title="将两个方法拆分到不同的对象中"></a>将两个方法拆分到不同的对象中</h2><p>这个很好理解，拆分出去后调用的是两个代理对象的方法，也就可以被拦截。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过前面的学习，我们了解了Spring AOP的执行过程。&lt;br&gt;这里想提醒注意一个小问题，我们在对象的方法中调用该对象的另外一个方法会出现什么现象呢？&lt;/p&gt;
&lt;h1 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://qzztf.com/tags/Spring/"/>
    
      <category term="AOP" scheme="http://qzztf.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP基本用法3</title>
    <link href="http://qzztf.com/post/39fc/"/>
    <id>http://qzztf.com/post/39fc/</id>
    <published>2020-09-23T02:26:55.000Z</published>
    <updated>2024-06-16T07:25:26.144Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲到了使用XML 配置<code>ProxyFactoryBean</code>，结合注解配置<code>@Bean</code>也可以实现代码配置。还讲到了代码配置<code>ProxyFactory</code>。前者与Spring IOC 容器结合的更紧密，不需要自己调用<code>getProxy()</code>方法，从IOC 容器中获取的Bean 已经是最终的代理对象。</p><p>这两种方式需要我们自己设置目标对象，通知以及代理接口，使用起来还是比较繁琐的。每当我们需要一个代理对象时，就需要配置<code>ProxyFactoryBean</code>或<code>ProxyFactory</code>。</p><p>有没有更好的方式，只需要做简单的配置就可以为多个对象生成代理对象呢？</p><p>我们已经有了创建代理的方式，就是前面介绍的工厂类，剩下的工作只需要解决如何配置和如何解析配置的问题就可以了。</p><p>下面介绍最核心的类。</p><h2 id="AbstractAutoProxyCreator"><a href="#AbstractAutoProxyCreator" class="headerlink" title="AbstractAutoProxyCreator"></a>AbstractAutoProxyCreator</h2><p>看看Spring 官方介绍：</p><blockquote><p>该抽象类实现了BeanPostProcessor接口，用AOP代理来包装每个合适的bean，并在调用bean本身之前委托给指定的拦截器。这个类区分了“公共”拦截器和“特定”拦截器，前者用于它创建的所有代理，后者用于每个bean实例。可以不需要任何通用的拦截器。如果有，则可以使用<code>interceptorNames</code>属性设置它们。与org.springframework.aop.framework.ProxyFactoryBean 一样，使用拦截器名称而不是bean引用来正确处理原型顾问和拦截器：例如，支持有状态的混合。<code>interceptorNames</code>属性支持任何通知类型。</p><p>如果有大量的bean需要用类似的代理(即委托给相同的拦截器)来包装，那么这种自动代理特别有用。可以在bean工厂中注册一个这样的后处理程序，而不是为x个目标bean进行x个重复的代理定义，来达到相同的效果。</p><p>子类可以应用任何策略来决定一个bean是否被代理，例如通过类型、名称、bean定义细节等。它们还可以返回额外的拦截器，这些拦截器应该只应用于特定的bean实例。<code>BeanNameAutoProxyCreator</code>是一个简单的实现类，它通过指定名称识别要代理的bean。</p><p>可以使用任意数量的<code>TargetSourceCreator</code>实现来创建自定义目标源:例如，来共享原型对象。只要<code>TargetSourceCreator</code>指定了自定义<code>TargetSource</code>，即使没有通知，也会发生自动代理。如果没有设置TargetSourceCreator，或者没有匹配上，那么默认情况下将使用 <code>SingletonTargetSource</code>来包装目标bean实例.</p></blockquote><p>从上面的描述中，可以看出此类实现了<code>BeanPostProcessor</code>接口，拦截bean的创建过程。并提供了自定义获取目标对象的方式，以及识别通知，创建代理对象的核心逻辑。子类提供了多种更具体的创建代理的策略。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/post/39fc/AbstractAutoProxyCreator.png" alt="AbstractAutoProxyCreator"></p><p>从上图中可以看到此类实现了<code>SmartInstantiationAwareBeanPostProcessor</code>接口，该接口在前面<em>Bean的初始化中</em>讲到过，如果<code>postProcessBeforeInstantiation</code>方法返回了非<code>null</code>对象，则将会打断原bean的初始化过程，从而使用该方法返回的对象。如果上面的方法返回<code>null</code>，那么将走常规初始化对象方式，初始化对象之后将调用<code>postProcessAfterInitialization</code>方法，在此方法中可以根据需要返回代理对象。</p><p>我们猜想一下如何创建？</p><ol><li>判断是否需要创建</li><li>判断之前是否创建过</li><li>找到目标对象所有匹配的通知</li><li> 有了通知，剩下的就是通过之前的创建代理的方式来创建。</li></ol><h3 id="postProcessBeforeInstantiation-方法"><a href="#postProcessBeforeInstantiation-方法" class="headerlink" title="postProcessBeforeInstantiation 方法"></a>postProcessBeforeInstantiation 方法</h3><p>此方法将会在进行常规化实例bean时执行，如果不需要阻断初始化流程，则需要返回<code>null</code>。在这个方法实现中提供了一个自定义目标对象获取方式的机会，即<code>TargetSourceCreator</code>，如果注册了该接口的实现类并且返回非<code>null</code>目标对象，那么将在<code>postProcessBeforeInstantiation</code>方法中创建代理对象。如果没有注册或者注册的<code>TargetSourceCreator</code>实现都返回<code>null</code>，那么不会在<code>postProcessBeforeInstantiation</code>方法中创建代理对象，走常规初始化流程。初始化bean之后还有机会再次修改bean实例。</p><p>默认直接从Spring 工厂中拿对应的bean实例，并不会在此处实现自定义<code>TargetSourceCreator</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">    Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">    <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="postProcessAfterInitialization-方法"><a href="#postProcessAfterInitialization-方法" class="headerlink" title="postProcessAfterInitialization 方法"></a>postProcessAfterInitialization 方法</h3><p>在前面的方法中如果返回了<code>null</code>，那么将会继续初始化bean。初始化之后将调用<code>BeanPostProcessor.postProcessAfterInitialization</code>方法。<code>AbstractAutoProxyCreator</code>将在此方法中创建代理对象。这里有个小地方要注意，因为在实例化的过程中，如果是要提前暴露出来的bean，将会提前加入到<code>singletonFactories</code> map中，在获取这个bean的时候将会调用<code>getEarlyBeanReference</code>方法，也就是说可能需要在这个方法中创建代理对象，所以如果已经在<code>getEarlyBeanReference</code>方法中创建了，那么在<code>postProcessAfterInitialization</code>方法中就不需要再创建一次了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br></pre></td></tr></table></figure><h3 id="getEarlyBeanReference-方法"><a href="#getEarlyBeanReference-方法" class="headerlink" title="getEarlyBeanReference 方法"></a>getEarlyBeanReference 方法</h3><p>在提前暴露bean时会调用此方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyProxyReferences.add(cacheKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否需要创建"><a href="#判断是否需要创建" class="headerlink" title="判断是否需要创建"></a>判断是否需要创建</h3><p>看过了上面3个入口的代码，主要用<code>isInfrastructureClass(beanClass) </code>和 <code>shouldSkip(beanClass, beanName)</code>两个方法来判断。</p><p><code>isInfrastructureClass</code>用来判断该类是不是基础类，包括<code>Advice</code>、<code>Pointcut</code>、<code>Advisor</code>和<code>AopInfrastructureBean</code> 这些aop基础接口实现类，这些类的对象不应该被代理。</p><p><code>shouldSkip(beanClass, beanName)</code> 用来实现自定义的跳过逻辑，子类可以重写该方法。默认判断实例类是不是以<code>.ORIGINAL</code>结尾，是则跳过，反之则不跳过。</p><h3 id="判断之前是否创建过"><a href="#判断之前是否创建过" class="headerlink" title="判断之前是否创建过"></a>判断之前是否创建过</h3><p>通过<code>earlyProxyReferences</code> Set 将 提前暴露出来的bean缓存起来，<code>advisedBeans</code> Map用来存放经过历增强过程的Bean，已经增强过的对应的<code>value</code>为<code>True</code>，不需要增强的则为<code>False</code>。<code>targetSourcedBeans</code> Set用来将自定义<code>TargetSource</code>的bean缓存起来。</p><ol><li><p>在调用<code>postProcessBeforeInstantiation</code>方法时，如果没有传bean name，或者<code>targetSourcedBeans</code>不包含bean name，那么如果<code>advisedBeans</code>包含此缓存key(缓存key是以bean的Class和name来组成的，如果没有name则只使用class)，则代表之前已经处理过这种class或者bean name，直接返回<code>null</code>。</p><p>如果在此方法中创建了代理，则会将bean name 加入到<code>targetSourcedBeans</code>。</p></li><li><p>在调用<code>getEarlyBeanReference</code>方法时，如果<code>earlyProxyReferences</code> Set中没有包含此缓存key，则将此缓存key加入到<code>earlyProxyReferences</code>。如果bean name不为空并且<code>targetSourcedBeans</code>包含bean name，则意味着在第一中情况中已经创建了代理，直接返回该bean。</p><p>如果<code>advisedBeans</code>中缓存key对应的值为<code>False</code>，则意味着这个bean不需要创建代理，直接返回此bean。</p></li><li><p>在调用<code>postProcessAfterInitialization</code>方法时，如果<code>earlyProxyReferences</code> Set中包含此缓存key，则意味着在第二种情况中已经创建了代理，直接返回此bean即可。</p><p>如果bean name不为空并且<code>targetSourcedBeans</code>包含bean name，则意味着在第一种情况中已经创建了代理，直接返回该bean。</p><p>如果<code>advisedBeans</code>中缓存key对应的值为<code>False</code>，则意味着这个bean不需要创建代理，直接返回此bean。</p></li></ol><p>由于有三个入口可以用来创建代理对象，因此要保证只创建一次，所以用了上面的方式。</p><p>下面看一下完整的流程图：</p><p><img src="/post/39fc/AbstractAutoProxyCreator%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="AbstractAutoProxyCreator创建代理对象流程图"></p><h3 id="getAdvicesAndAdvisorsForBean-方法"><a href="#getAdvicesAndAdvisorsForBean-方法" class="headerlink" title="getAdvicesAndAdvisorsForBean 方法"></a>getAdvicesAndAdvisorsForBean 方法</h3><p>此方法用来查找当前bean匹配的通知，是一个抽象方法，需要子类去实现具体的查找逻辑。</p><p>查到到之后将通知的拦截器转换为Spring 的<code>Advisor</code>，这个转换过程中，可以预先配置通用的拦截器，可以在每个bean中生效，</p><p>具体的转换方法是<code>org.springframework.aop.framework.adapter.AdvisorAdapterRegistry#wrap()</code>。</p><h2 id="子类-BeanNameAutoProxyCreator"><a href="#子类-BeanNameAutoProxyCreator" class="headerlink" title="子类 BeanNameAutoProxyCreator"></a>子类 BeanNameAutoProxyCreator</h2><p>通过配置bean 名称过滤需要代理的bean并为其创建代理。</p><p>该类只能通过<code>interceptorNames</code>属性指定应用于所有匹配bean的拦截器名称，设置<code>beanNames</code>来配置要代理的bean，可能指定通配符<code>*</code>，如果需要为<code>FactoryBean</code>对象创建代理，需要加上<code>&amp;</code>标记。</p><p>如果bean能匹配上，则<code>getAdvicesAndAdvisorsForBean</code>将返回<code>PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS</code>，这是一个空数组，也就是说这个方法将不会返回额外的拦截器，但是会创建代理对象。</p><h2 id="子类-AbstractAdvisorAutoProxyCreator"><a href="#子类-AbstractAdvisorAutoProxyCreator" class="headerlink" title="子类 AbstractAdvisorAutoProxyCreator"></a>子类 AbstractAdvisorAutoProxyCreator</h2><blockquote><p>通用的自动代理创建器，基于每个bean检测到的advisor为特定bean构建AOP代理。<br>子类必须实现抽象<code>findCandidateAdvisors()</code>方法，以返回应用于任何对象的顾问列表。子类还可以重写继承的shouldSkip方法，以从自动代理中排除某些对象。<br>需要排序的通知应该实现<code>org.springframework.core.Ordered</code>接口。该类按<code>Ordered</code>的<code>order</code>值对通知进行排序，未实现<code>Ordered</code>接口的通知将被认为是无序的，它们将以未定义的顺序出现在advisor链的末尾。</p></blockquote><p>这个类实现了<code>getAdvicesAndAdvisorsForBean</code>方法，并提供了新的模板方法供子类去实现。主要是<code>findCandidateAdvisors</code>方法用来查找所有候选的<code>Advisor</code>，<code>findAdvisorsThatCanApply</code>方法用来筛选能匹配的<code>Advisor</code>，<code>extendAdvisors</code>方法用来注册额外的<code>Advisor</code>，<code>sortAdvisors</code>方法用来对<code>Advisor</code>进行排序。</p><h3 id="findCandidateAdvisors方法"><a href="#findCandidateAdvisors方法" class="headerlink" title="findCandidateAdvisors方法"></a>findCandidateAdvisors方法</h3><p>该方法用来查找<code>Advisor</code>实现类，默认使用工具类<code>BeanFactoryAdvisorRetrievalHelper</code>，最重要的一行代码是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">      <span class="keyword">this</span>.beanFactory, Advisor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>在beanFactory中查找所有<code>Advisor</code>实现类的Bean名称，然后再循环调用beanFactory的getBean()方法初始化advisor。</p><p>并定义了<code>volatile</code>修饰的<code>cachedAdvisorBeanNames</code>变量将找到的Advisor bean缓存起来，以便下次直接使用。</p><h3 id="findAdvisorsThatCanApply方法"><a href="#findAdvisorsThatCanApply方法" class="headerlink" title="findAdvisorsThatCanApply方法"></a>findAdvisorsThatCanApply方法</h3><p>此方法用于匹配当前目标对象和上一步中找到的Advisor。</p><p>先使用线程变量将当前bean暴露出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProxyCreationContext.setCurrentProxiedBeanName(beanName)</span><br></pre></td></tr></table></figure><p>再使用<code>AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass)</code>方法返回匹配的Advisor。</p><p>一些通用的方法都抽出放到了<code>AopUtils</code>这个工具类中。</p><p>在Spring AOP 中可以分为两种Advisor：<code>IntroductionAdvisor</code>和<code>PointcutAdvisor</code>。一种用来增强类（为对象引入新的接口），另一种用来增强具体的方法。</p><p>匹配流程：<img src="/post/39fc/advisor%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B.png" alt="advisor匹配过程"></p><p>从上面的流程图中可以看出，主要的步骤是遍历Advisor，再调用<code>IntroductionAdvisor</code>的ClassFilter的matches方法或者PointcutAdvisor的MethodMatcher的match方法，前者针对class级别的增强，后者为方法级别的增强。</p><h3 id="extendAdvisors方法"><a href="#extendAdvisors方法" class="headerlink" title="extendAdvisors方法"></a>extendAdvisors方法</h3><p>在上一步中已经找到了匹配的advisor，此方法用于子类去扩展，添加其他的advisor。</p><h3 id="sortAdvisors方法"><a href="#sortAdvisors方法" class="headerlink" title="sortAdvisors方法"></a>sortAdvisors方法</h3><p>根据<code>@Order</code>注解或者<code>Ordered</code>接口将advisor排序。</p><h2 id="子类-AspectJAwareAdvisorAutoProxyCreator"><a href="#子类-AspectJAwareAdvisorAutoProxyCreator" class="headerlink" title="子类 AspectJAwareAdvisorAutoProxyCreator"></a>子类 AspectJAwareAdvisorAutoProxyCreator</h2><p><code>AbstractAdvisorAutoProxyCreator</code>的子类，暴露出<code>AspectJ</code>的调用上下文，并解析当多个通知来自同一切面时<code>AspectJ</code>的通知优先级规则。</p><h3 id="sortAdvisors-方法"><a href="#sortAdvisors-方法" class="headerlink" title="sortAdvisors 方法"></a>sortAdvisors 方法</h3><p>按<code>AspectJ</code>优先级对通知进行排序。如果两个通知来自同一个<code>Aspect</code>，它们的顺序也会相同。来自同一<code>Aspect</code>的通知将根据以下规则进一步排序:<br>如果这一对中的任何一个是 <code>after advice</code>，那么最后声明的通知优先级最高(最后运行)。否则，先声明的通知优先级最高(先运行)。<br><strong>重要提示: <code>advisor</code>按优先级排序，从优先级最高到最低。在连接点之前，优先级最高的<code>advisor</code>先运行。在连接点之后，优先级最高的顾问最后运行。</strong></p><h3 id="extendAdvisors-方法"><a href="#extendAdvisors-方法" class="headerlink" title="extendAdvisors 方法"></a>extendAdvisors 方法</h3><p>添加<code>ExposeInvocationInterceptor</code> 到通知链开头。它将当前<code>MethodInvocation</code>对象公开为线程变量。我们偶尔需要这样的功能，例如，当切入点(例如<code>AspectJ</code>表达式切入点)需要知道完整的调用上下文时。除非真的有这个必要，一般不需要使用这个拦截器。</p><h2 id="子类-AnnotationAwareAspectJAutoProxyCreator"><a href="#子类-AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="子类 AnnotationAwareAspectJAutoProxyCreator"></a>子类 AnnotationAwareAspectJAutoProxyCreator</h2><p>继承自<code>AspectJAwareAdvisorAutoProxyCreator</code>，用来处理当前应用程序上下文中所有<code>AspectJ</code>注解声明的<code>Aspect</code>，以及Spring <code>Advisor</code>。</p><p>如果使用了<code>&lt;aop:include&gt;</code>元素，只有名称与正则匹配的@AspectJ bean 才会用于AOP。</p><h3 id="findCandidateAdvisors-方法"><a href="#findCandidateAdvisors-方法" class="headerlink" title="findCandidateAdvisors 方法"></a>findCandidateAdvisors 方法</h3><p>此方法先调用父类的方法处理常规的Advisor，以此支持上面提到过的AOP声明方式。</p><p>再由<code>BeanFactoryAspectJAdvisorsBuilder</code>获取通过AspecJ注解声明的Advisor。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面讲到了使用XML 配置&lt;code&gt;ProxyFactoryBean&lt;/code&gt;，结合注解配置&lt;code&gt;@Bean&lt;/code&gt;也可以实现代码配置。还讲到了代码配置&lt;code&gt;ProxyFactory&lt;/code&gt;。前者与Spring IOC 容器结合的更紧密，不需要
      
    
    </summary>
    
    
      <category term="Spring, AOP" scheme="http://qzztf.com/tags/Spring-AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP基本用法2</title>
    <link href="http://qzztf.com/post/f93d/"/>
    <id>http://qzztf.com/post/f93d/</id>
    <published>2020-09-23T02:25:58.000Z</published>
    <updated>2024-06-16T07:25:26.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-AOP-用法二"><a href="#Spring-AOP-用法二" class="headerlink" title="Spring AOP 用法二"></a>Spring AOP 用法二</h1><p>在上一篇中讲到通过xml配置<code>ProxyFactoryBean</code>来创建代理对象，在这一篇中看看通过编程的方式配置<code>ProxyFactory</code>。该类继承自<code>ProxyCreatorSupport</code>（之前提到过该类提供了一些创建代理对象的基础方法），提供了配置目标对象，代理接口和通知的功能。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">xmlBeanDefinitionReader.loadBeanDefinitions(<span class="string">&quot;AopXmlSimpleConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">// 获取需求代理的目标对象</span></span><br><span class="line">IBusinessService bean = beanFactory.getBean(<span class="string">&quot;businessService&quot;</span>, IBusinessService.class);</span><br><span class="line"><span class="comment">// 获取需要增强的通知</span></span><br><span class="line">Advice userBeforeAdvice = beanFactory.getBean(<span class="string">&quot;userBeforeAdvice&quot;</span>, Advice.class);</span><br><span class="line"><span class="comment">// 将目标对象传入构造函数，创建代理工厂</span></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(bean);</span><br><span class="line"><span class="comment">//添加我们的通知</span></span><br><span class="line">proxyFactory.addAdvice(userBeforeAdvice);</span><br><span class="line"><span class="comment">// 最终获取到代理对象</span></span><br><span class="line">IBusinessService proxy = (IBusinessService) proxyFactory.getProxy();</span><br><span class="line"><span class="comment">//调用代理对象的方法</span></span><br><span class="line">proxy.sayAgain();</span><br></pre></td></tr></table></figure><p>通过以上代码，我们创建出了最终的代理对象。大致步骤如下：</p><ol><li>通过构造函数，传入目标对象，创建代理工厂对象</li><li>添加通知</li><li>获取代理对象</li><li>调用代理对象的方法</li></ol><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before method advice</span><br><span class="line">again</span><br></pre></td></tr></table></figure><p>打印结果也说明了我们的代理对象正常工作，先执行了前置通知，再调用了目标对象的方法。</p><p>最重要的获取代理对象的方法都是在父类中完成的，与<code>ProxyFactoryBean</code>类似，该类只是提供了另外一种配置的方式。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数是这个类使用比较频繁的方法。可以通过目标对象，代理接口，以及通知来使用构造函数。</p><h3 id="ProxyFactory-Object-target"><a href="#ProxyFactory-Object-target" class="headerlink" title="ProxyFactory(Object target)"></a><code>ProxyFactory(Object target)</code></h3><p>通过此方法将根据目标对象创建<code>ProxyFactory</code>对象，并且会代理目标对象所有的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">  setTarget(target);</span><br><span class="line">  setInterfaces(ClassUtils.getAllInterfaces(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ProxyFactory-Class-lt-gt-proxyInterfaces"><a href="#ProxyFactory-Class-lt-gt-proxyInterfaces" class="headerlink" title="ProxyFactory(Class&lt;?&gt;... proxyInterfaces)"></a><code>ProxyFactory(Class&lt;?&gt;... proxyInterfaces)</code></h3><p>传入代理接口数组构造<code>ProxyFactory</code>对象，这种情况下只设置了代理接口，则必须手动设置通知，否则在创建代理的过程中无法通过校验。</p><p>目前创建的Jdk动态代理和cglib代理都判断了通知和目标对象不能同时为空。</p><p>Jdk代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">  Assert.notNull(config, <span class="string">&quot;AdvisedSupport must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (config.getAdvisors().length == <span class="number">0</span> &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;No advisors and no TargetSource specified&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.advised = config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cglib代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CglibAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">  Assert.notNull(config, <span class="string">&quot;AdvisedSupport must not be null&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (config.getAdvisors().length == <span class="number">0</span> &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;No advisors and no TargetSource specified&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.advised = config;</span><br><span class="line">  <span class="keyword">this</span>.advisedDispatcher = <span class="keyword">new</span> AdvisedDispatcher(<span class="keyword">this</span>.advised);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设置了拦截器，由于在最终调用目标对象方法时，没有判断目标对象是否为空，所以会报空指针异常。</p><h3 id="ProxyFactory-Class-lt-gt-proxyInterface-Interceptor-interceptor"><a href="#ProxyFactory-Class-lt-gt-proxyInterface-Interceptor-interceptor" class="headerlink" title="ProxyFactory(Class&lt;?&gt; proxyInterface, Interceptor interceptor)"></a><code>ProxyFactory(Class&lt;?&gt; proxyInterface, Interceptor interceptor)</code></h3><p>此方法同时设置代理接口和拦截器。由于没有目标对象，也会出现上面的空指针异常情况。针对只有一个拦截器的情况下，此方法创建代理对象比较方法。</p><h3 id="ProxyFactory-Class-lt-gt-proxyInterface-TargetSource-targetSource"><a href="#ProxyFactory-Class-lt-gt-proxyInterface-TargetSource-targetSource" class="headerlink" title="ProxyFactory(Class&lt;?&gt; proxyInterface, TargetSource targetSource)"></a><code>ProxyFactory(Class&lt;?&gt; proxyInterface, TargetSource targetSource)</code></h3><p>此方法根据代理接口和<code>TargetSource</code>创建<code>ProxyFactory</code>对象。</p><h2 id="getProxy方法"><a href="#getProxy方法" class="headerlink" title="getProxy方法"></a><code>getProxy</code>方法</h2><p>通过此方法将会获取最终的代理对象。</p><p>通过构造函数创建<code>ProxyFactory</code>对象后，还需要根据实际情况设置目标对象、代理接口以及通知，然后再调用<code>getProxy</code>方法获取代理对象。</p><h3 id="Object-getProxy-无参方法"><a href="#Object-getProxy-无参方法" class="headerlink" title="Object getProxy()无参方法"></a><code>Object getProxy()</code>无参方法</h3><p>根据<code>ProxyFactory</code>的设置创建代理对象。可以重复调用此方法，如果添加或删除接口，添加或者删除拦截器，效果会有所不同。由于多次调用使用的是同一个<code>ProxyFactory</code>对象，只是配置不同，在调用代理对象的方法时，会影响到代理对象的执行过程。</p><p>此方法使用默认类加载器来创建代理，一般是线程上下文类加载器。</p><h3 id="Object-getProxy-ClassLoader-classLoader"><a href="#Object-getProxy-ClassLoader-classLoader" class="headerlink" title="Object getProxy(ClassLoader classLoader)"></a><code>Object getProxy(ClassLoader classLoader)</code></h3><p>跟上面的方法类似，只是使用指定的类加载器。</p><h3 id="static-lt-T-gt-T-getProxy-Class-lt-T-gt-proxyInterface-Interceptor-interceptor"><a href="#static-lt-T-gt-T-getProxy-Class-lt-T-gt-proxyInterface-Interceptor-interceptor" class="headerlink" title="static &lt;T&gt; T getProxy(Class&lt;T&gt; proxyInterface, Interceptor interceptor)"></a><code>static &lt;T&gt; T getProxy(Class&lt;T&gt; proxyInterface, Interceptor interceptor)</code></h3><p>此方法是静态方法，根据指定的代理接口和拦截器创建代理。内部使用<code>ProxyFactory(Class&lt;?&gt; proxyInterface, Interceptor interceptor)</code>方法创建<code>ProxyFactory</code>对象之后再调用无参<code>getProxy()</code>方法。</p><h3 id="static-lt-T-gt-T-getProxy-Class-lt-T-gt-proxyInterface-TargetSource-targetSource"><a href="#static-lt-T-gt-T-getProxy-Class-lt-T-gt-proxyInterface-TargetSource-targetSource" class="headerlink" title="static &lt;T&gt; T getProxy(Class&lt;T&gt; proxyInterface, TargetSource targetSource)"></a><code>static &lt;T&gt; T getProxy(Class&lt;T&gt; proxyInterface, TargetSource targetSource)</code></h3><p>此静态方法为指定的<code>TargetSource</code>创建代理，该代理会实现指定的接口。方法内部使用<code>new ProxyFactory(proxyInterface, targetSource)</code>方法创建<code>ProxyFactory</code>对象之后再调用无参<code>getProxy()</code>方法。</p><h3 id="static-Object-getProxy-TargetSource-targetSource"><a href="#static-Object-getProxy-TargetSource-targetSource" class="headerlink" title="static Object getProxy(TargetSource targetSource)"></a><code>static Object getProxy(TargetSource targetSource)</code></h3><p>该静态方法为指定的<code>TargetSource</code>创建一个代理，扩展<code>TargetSource</code>的目标类。由于没有指定接口，所以方法内部会设置<code>proxyTargetClass</code>为<code>true</code>，通过cglib来创建目标对象的子类。</p><p>以下代码用来判断是否用jdk代理还是cglib来生成代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">  Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">  <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">                                 <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-AOP-用法二&quot;&gt;&lt;a href=&quot;#Spring-AOP-用法二&quot; class=&quot;headerlink&quot; title=&quot;Spring AOP 用法二&quot;&gt;&lt;/a&gt;Spring AOP 用法二&lt;/h1&gt;&lt;p&gt;在上一篇中讲到通过xml配置&lt;code&gt;Pr
      
    
    </summary>
    
    
      <category term="Spring, AOP" scheme="http://qzztf.com/tags/Spring-AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP基本用法</title>
    <link href="http://qzztf.com/post/fc6f/"/>
    <id>http://qzztf.com/post/fc6f/</id>
    <published>2020-09-23T02:24:56.000Z</published>
    <updated>2024-06-16T07:25:26.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-AOP-用法"><a href="#Spring-AOP-用法" class="headerlink" title="Spring AOP 用法"></a>Spring AOP 用法</h1><p>前面讲到了AOP相关的思想和基本概念，实现方式可分为静态编绎型和代理两种方式。前者的代表作是<code>AspectJ</code>，在编绎阶段将通知织入到class中，需要用到特殊的工具来编绎。<code>AspectJ</code>定义了一种表达式语言来定义连接点，Spring 默认是基于JDK动态代理来实现AOP，并且只支持方法作为切入点。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>Spring 自己实现了一套AOP，还部分支持<code>AspectJ</code>。两种方式都可以使用编程式和xml配置方式。</p><p>使用Spring AOP大概有以下几种方式：</p><ol><li>在xml中配置<code>ProxyFactoryBean</code>，显式地设置advisors, advice, target等，或以编程方式使用<code>ProxyFactory</code>。Spring支持通过 jdk 动态代理和 cglib 来生成代理对象。前者只支持接口，后者可以支持类。还可以以编程形式配置<code>AspectJProxyFactory</code>, 该类基于apsectj语法来配置切面。</li><li>配置<code>AutoProxyCreator</code>，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象</li><li>通过<code>&lt;aop:config&gt;</code>来配置，使用<code>AspectJ</code>的语法来定义切入点</li><li>通过<code>&lt;aop:aspectj-autoproxy&gt;</code>来配置，使用<code>AspectJ</code>的注解来标识通知及切入点</li></ol><h3 id="xml-配置-ProxyFactoryBean"><a href="#xml-配置-ProxyFactoryBean" class="headerlink" title="xml 配置 ProxyFactoryBean"></a>xml 配置 ProxyFactoryBean</h3><ol><li><p>创建通知</p><p>这里以前置通知类型为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBeforeAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method advice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建业务代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBusinessService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessService</span> <span class="keyword">implements</span> <span class="title">IBusinessService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置代理类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--业务实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.sexycode.spring.study.chapter5.BusinessService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--通知实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.sexycode.spring.study.chapter5.BusinessBeforeAdvice&quot;</span> <span class="attr">id</span>=<span class="string">&quot;userBeforeAdvice&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span> <span class="attr">id</span>=<span class="string">&quot;businessProxy&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--代理的接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interfaces&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cn.sexycode.spring.study.chapter5.IBusinessService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--目标对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;businessService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--要应用的通知实现--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptorNames&quot;</span> <span class="attr">value</span>=<span class="string">&quot;userBeforeAdvice&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>配置需要代理的接口，配置了此属性，将会使用Jdk 动态代理生成代理对象</li><li>需要代理的目标对象，即我们的业务对象</li><li>使用的通知bean名称<code>interceptorNames</code>，是个数组。如果不配置<code>targetName</code>/<code>target</code>/<code>targetSource</code>属性，数组的最后一个可以是目标对象的名字。这个属性还支持通配符<code>*</code>，如：<code>userBeforeAdvice*</code>，代表所有以<code>userBeforeAdvice</code>开头的bean都会成为通知。但是如果目标对象的名字出现在这个属性时，通配符不能是最后一个。</li></ol><p>经过上面的配置，已经将通知织入到代理对象中了，下面直接获取生成的代理对象，再调用方法即可以看到织入的结果。</p></li><li><p>获取代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">xmlBeanDefinitionReader.loadBeanDefinitions(<span class="string">&quot;AopXmlSimpleConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获取代理对象</span></span><br><span class="line">((IBusinessService) beanFactory.getBean(<span class="string">&quot;businessProxy&quot;</span>)).sayHello();</span><br></pre></td></tr></table></figure><p>这里要注意的是要直接获取代理对象，然后转成我们的接口类型，再调用方法即可。</p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;打印的是通知的内容</span><br><span class="line">Before method advice</span><br><span class="line">&#x2F;&#x2F;业务代码</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></li></ol><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>这种方式其实跟《AOP的基本概念》一文开头描述的思想类似，为每个业务实现类创建代理对象，只不过这里的织入时机已经可以配置了。</p><p>那么Spring 是如何生成代理对象的？又是如何织入通知的？</p><p>可以想象一下，在获取bean的时候，初始化所有的通知，并创建代理类，在调用代理对象的方法时调用通知的代码和原对象的方法。</p><p>看一下该类的类图：</p><p><img src="/post/fc6f/ProxyFactoryBean.png" alt="ProxyFactoryBean"></p><p><code>ProxyFactoryBean</code>类实现了<code>FactoryBean</code>接口。也就是说最终会通过<code>getObject</code>方法返回生成的对象。<code>ProxyConfig</code>类提供了一些代理对象的配置项，可以确保所有的代理创建器都具有一致的属性。<code>AdvisedSupport</code>类管理通知和切面，不提供实际的创建代理的方法，由它的子类去实现。<code>ProxyCreatorSupport</code>是代理工厂的基类，提供创建代理对象的公共操作，内部使用可配置的<code>AopProxyFactory</code>代理工厂来创建代理，默认的<code>AopProxyFactory</code>工厂实现根据情况创建<code>JdkDynamicAopProxy</code>或者<code>JdkDynamicAopProxy</code>代理。</p><h3 id="getObject-方法"><a href="#getObject-方法" class="headerlink" title="getObject 方法"></a>getObject 方法</h3><p>前面讲到了，当Spring初始化此bean时，最终会调用<code>getObject</code>方法返回实际的bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">initializeAdvisorChain();</span><br><span class="line"><span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line"><span class="keyword">return</span> getSingletonInstance();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Using non-singleton proxies with singleton targets is often undesirable. &quot;</span> +</span><br><span class="line"><span class="string">&quot;Enable prototype proxies by setting the &#x27;targetName&#x27; property.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newPrototypeInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化通知链"><a href="#初始化通知链" class="headerlink" title="初始化通知链"></a>初始化通知链</h4><p>第一步就是初始化切面链，配置此代理时，可以应用多个切面，所以最终会形成一个调用链。如果此bean是单例的，则会创建单例对象。</p><p>初始化方法<code>initializeAdvisorChain()</code>是一个线程同步的方法，方法声明上加了<code>synchronized</code>关键字。</p><p>初始化切面链时，如果之前已经初始化过，将不会再次初始化。初始化时会遍历所有配置的通知，如果是通配符<code>*</code>，则会根据类型<code>Advisor</code>和<code>Interceptor</code>查找所有的bean，并排序，再判断bean的名称是否匹配前缀，是则认为是一个通知，会将其加入到通知链中。如果不是通配符，再判断该bean或者此代理工厂bean是否单例，是的话则会在<code>BeanFactory</code>中查找该bean，加入到链中。不是单例则需要将该通知先记录下来，等到最后创建代理对象时，再创建该通知对象。这里为什么需要这样判断是不是单例？这样可以避免在初始化通知链时创建原型对象，这个时候还不需要初化原型通知对象，在最终使用到此对象时再初始化即可。</p><p>在添加通知时，由于<code>intercepterNames</code>中即可以是<code>Advice</code>也可以是<code>Advisor</code>，或者是其他自定义的通知类型（实现<code>Advice</code>接口），所以需要将通知转换成<code>Advisor</code>(Spring封装了通知以及通知的适用范围)。如果本身就是<code>Advisor</code>，则不需要转换。如果是<code>Advice</code>，并且是支持通知类型，则转换成<code>DefaultPointcutAdvisor</code>。转换时通过适配器<code>AdvisorAdapter</code>来判断是否支持该通知。<code>ProxyFactoryBean</code>默认使用<code>GlobalAdvisorAdapterRegistry.getInstance()</code>方式获取到默认的适配器注册器，可以替换该注册器，添加自定义的适配器。也可以注册<code>AdvisorAdapterRegistrationManager</code>，然后注册实现<code>AdvisorAdapter</code>的bean，该后处理器会自动注册自定义的适配器。Spring 默认注册了<code>MethodBeforeAdviceAdapter</code>、<code>AfterReturningAdviceAdapter</code>、<code>ThrowsAdviceAdapter</code>三个适配器。通过适配器最终可以将基于<code>AspectJ</code>的通知转换成Spring 的<code>Advisor</code>，达到设计上的统一。</p><h4 id="单例代理对象"><a href="#单例代理对象" class="headerlink" title="单例代理对象"></a>单例代理对象</h4><p>到这一步，初始化通知链完毕，根据<code>isSingleton()</code>方法决定是返回单例对象还是原型对象。需要返回单例代理对象时，则需要在这一步中创建。</p><p>如果之前已经创建过了，则直接返回缓存的单例对象。</p><p>如果没有创建过，则需要创建代理对象。</p><ol><li><p>刷新目标对象，从<code>BeanFactory</code>中获取到实际的目标对象。并封装成<code>TargetSource</code>。</p></li><li><p>在自动检测接口模式（未指定代理接口里默认为<code>true</code>，如果没有指定接口时，将此值设置为<code>false</code>来使用cglib创建代理对象）、代理接口未指定、不是代理目标对象的情况下，将获取到目标对象所有的接口，并代理所有接口。</p></li><li><p>准备工作做完了，接下来就是创建代理对象了。创建之前先激活<code>AdvisedSupportListener</code>监听器。这里由默认的<code>AopProxyFactory</code>工厂指定了两种创建代理对象的方式，根据情况使用jdk动态代理方式还是cglib方式。满足以下情况时：将使用cglib代理。1). 优化代理（比如说在代理对象创建之后，再更改通知不生效，默认为<code>false</code>），2). 直接代理目标对象，3). 用户没有指定代理接口。在上面提到的3点中，如果代理目标类是接口，或者是jdk代理，则还是会使用jdk代理方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">                                         <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>确定代理方式之后，就是使用对应的方式去创建代理对象了。jdk方式使用<code>JdkDynamicAopProxy</code>对象来最终生成代理对象，cglib使用<code>ObjenesisCglibAopProxy</code>对象。</p></li></ol><h4 id="JDK代理对象"><a href="#JDK代理对象" class="headerlink" title="JDK代理对象"></a>JDK代理对象</h4><p>使用jdk代理生成代理对象时，会先确定完整的接口。在原有接口基础上会新加入<code>SpringProxy</code>，<code>Advised</code>，<code>DecoratingProxy</code>接口。创建代理时会将自己作为<code>InvocationHandler</code>传进去，<code>JdkDynamicAopProxy</code>实现了<code>InvocationHandler</code>接口，最终调用代理对象的方法时会执行该接口的方法。</p><h5 id="invoke方法"><a href="#invoke方法" class="headerlink" title="invoke方法"></a>invoke方法</h5><p><code>JdkDynamicAopProxy</code>实现了<code>InvocationHandler</code>接口，也就是说当代理对象的方法被调用时，<code>JdkDynamicAopProxy</code>的<code>invoke</code>方法将会被调用，从而通过<code>invoke</code>的实现逻辑完成对目标方法调用的拦截。</p><p>主要的逻辑是<code>equals</code>，<code>hashCode</code>方法的判断，<code>Advised</code>和<code>DecoratingProxy</code>接口的判断。这些方法需要特殊处理，如果目标类实现了<code>equals</code>，<code>hashCode</code>方法，那么需要去比较原始对象，否则，直接调用代理对象的<code>equals</code>和<code>hashCode</code>方法就可以了。。</p><p>接下来需要根据当前调用的方法获取到对应的拦截器链，如果拦截器链为空，则表示当前方法不需要拦截，直接调用目标对象的方法就可以了。如果不为空，则表示需要拦截，生成<code>ReflectiveMethodInvocation</code>对象，该对象封装了拦截器的调用过程。</p><h6 id="获取拦截器链"><a href="#获取拦截器链" class="headerlink" title="获取拦截器链"></a>获取拦截器链</h6><p>获取调用方法的拦截器链，目标对象所有的通知，之前已经初始化过了，但是每个方法所需要的不一样，所以这一步还需要根据方法进行过滤。具体逻辑在<code>AdvisedSupport.getInterceptorsAndDynamicInterceptionAdvice()</code>方法中，会将结果缓存下来下次直接使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    MethodCacheKey cacheKey = <span class="keyword">new</span> MethodCacheKey(method);</span><br><span class="line">    List&lt;Object&gt; cached = <span class="keyword">this</span>.methodCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cached = <span class="keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">            <span class="keyword">this</span>, method, targetClass);</span><br><span class="line">        <span class="keyword">this</span>.methodCache.put(cacheKey, cached);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AdvisedSupport</code>通过<code>AdvisorChainFactory</code>(默认使用<code>DefaultAdvisorChainFactory</code>)创建一个拦截链，针对每个已经注册的<code>Advisor</code>，如果是<code>PointcutAdvisor</code>，获取到对应的<code>Pointcut</code>，再得到其<code>ClassFilter</code>，检查是否匹配目标类型，类型检查通过之后再得到<code>MethodMatcher</code>进行方法匹配。<em>在获取拦截链阶段，不过滤方法参数</em>。如果<code>MethodMatcher</code>是运行时的(也就是要比较参数的)，则包装成<code>InterceptorAndDynamicMethodMatcher</code>，其内部包含当前<code>MethodMatcher</code>，在<code>ReflectiveMethodInvocation</code>内方法调用时根据方法调用时的参数再判断该拦截器是否可以拦截此方法。</p><p>如果是引入<code>IntroductionAdvisor</code>，则只需要过滤class即可。</p><p>符合要求的通知会通过<code>AdvisorAdapter</code>转换成方法拦截器<code>MethodInterceptor</code>。</p><p>不同的通知类型有相应的拦截器。比如<code>MethodBeforeAdvice</code>有<code>MethodBeforeAdviceInterceptor</code>与其对应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">BeforeAdvice</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MethodBeforeAdvice advice;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new MethodBeforeAdviceInterceptor for the given advice.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> advice the MethodBeforeAdvice to wrap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MethodBeforeAdviceInterceptor</span><span class="params">(MethodBeforeAdvice advice)</span> </span>&#123;</span><br><span class="line">Assert.notNull(advice, <span class="string">&quot;Advice must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>.advice = advice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line"><span class="keyword">return</span> mi.proceed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用该拦截器的invoke方法时，会先调用其持有的advice的before方法，也就是我们的通知方法，然后再继续<code>MethodInvocation</code>的方法调用，该设计是常见的链式调用方式。</p><p>同理<code>AfterReturningAdvice</code>对应的是<code>AfterReturningAdviceInterceptor</code>，<code>ThrowsAdvice</code>对应<code>ThrowsAdviceInterceptor</code>。</p><h6 id="ReflectiveMethodInvocation-执行拦截器链"><a href="#ReflectiveMethodInvocation-执行拦截器链" class="headerlink" title="ReflectiveMethodInvocation 执行拦截器链"></a>ReflectiveMethodInvocation 执行拦截器链</h6><p>在上一步获取拦截器链之后，构造出<code>ReflectiveMethodInvocation </code>对象，封装了代理，目标对象，方法，以及拦截器链，然后调用该对象的<code>proceed</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//We start with an index of -1 and increment early.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object interceptorOrInterceptionAdvice =</span><br><span class="line">        <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">        <span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">        <span class="comment">// been evaluated and found to match.</span></span><br><span class="line">        InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">            (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dynamic matching failed.</span></span><br><span class="line">            <span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">            <span class="keyword">return</span> proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">        <span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReflectiveMethodInvocation</code>维护一个当前执行拦截器的下标值<code>currentInterceptorIndex</code>，从<code>-1</code>开始，如果<strong>等于</strong>拦截器链的<strong>长度-1</strong>，则表示拦截器已经执行完了，调用目标对象的方法。</p><p>如果不相等，则会调用拦截器的方法。</p><ol><li>获取到第一个拦截器，并将<code>currentInterceptorIndex</code>+1。</li><li>如果拦截器是<code>InterceptorAndDynamicMethodMatcher</code>类型，则需要进行参数匹配，匹配上则调用该拦截器的方法。否则调用<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法，这里是递归调用。最终结束条件就是下标值是拦截器链的<strong>长度-1</strong>。</li><li>如果是普通的<code>MethodInterceptor</code>的，则调用<code>invoke</code>方法，并将自身传进去。</li></ol><p>整个调用过程，其实在<code>Filter</code>的使用过程中，我们就已经接触了。在每个过滤器的执行过程中，将链维护对象传递到每个过滤器中，执行完成之后再调用链对象的方法，链对象的方法会继续调用下一个过滤器。如果想终止链的调用，可以不调用链的方法。</p><h4 id="CGLIB生成的代理对象"><a href="#CGLIB生成的代理对象" class="headerlink" title="CGLIB生成的代理对象"></a>CGLIB生成的代理对象</h4><p>使用<code>ObjenesisCglibAopProxy</code>对象来生成cglib代理对象时。<code>ObjenesisCglibAopProxy</code>继承了<code>CglibAopProxy</code>重写了<code>createProxyClassAndInstance()</code>方法，支持不需要通过构造器来实例化对象的功能。</p><p>cglib生成的代理对象实现aop功能，主要需要设置callback。</p><p>可以看一下<code>getProxy</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating CGLIB proxy: &quot;</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">        Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">&quot;Target class must be available for creating a CGLIB proxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">            proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">            Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">                <span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">        validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">        Enhancer enhancer = createEnhancer();</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            enhancer.setClassLoader(classLoader);</span><br><span class="line">            <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">                ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">                enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">        enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">        enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">        enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">        Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">        Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">            types[x] = callbacks[x].getClass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">        enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">            <span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">        enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">        <span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Could not generate CGLIB subclass of &quot;</span> + <span class="keyword">this</span>.advised.getTargetClass() +</span><br><span class="line">                                     <span class="string">&quot;: Common causes of this problem include using a final class or a non-visible class&quot;</span>,</span><br><span class="line">                                     ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Unexpected AOP exception&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点就在<code>getCallbacks</code>方法里，将<code>AdvisedSupport</code>对象封装成<code>DynamicAdvisedInterceptor</code>。另外加了一些性能优化相关的逻辑。<code>equals</code>和<code>hashCode</code>相关的拦截器，这两个方法是需要特殊处理的。以及是否暴露当前代理对象到当前线程中，可以设置<code>exposeProxy</code>属性为<code>true</code>，然后通过<code>AopContext.currentProxy()</code>方法取得当前代理对象。</p><p>这里Spring根据用途将callback拆成了多个:<code>aopInterceptor</code>、<code>EqualsInterceptor</code>、<code>HashCodeInterceptor</code>等，然后为<code>enhancer</code>设置<code>CallbackFilter</code>决定哪些方法使用对应的callback，每个callback对应一个固定值，<code>CallbackFilter</code>返回具体的方法所对应的值。</p><p>重点看看<code>DynamicAdvisedInterceptor</code>，也就是需要应用通知的拦截器。</p><p>该类的逻辑跟jdk代理的类似，将拦截器链封装成一个<code>CglibMethodInvocation</code>对象，这个类继承自<code>ReflectiveMethodInvocation</code>类，该类的逻辑与父类没有什么大的差别。</p><h4 id="原型代理对象"><a href="#原型代理对象" class="headerlink" title="原型代理对象"></a>原型代理对象</h4><p>当<code>ProxyFactoryBean</code>不是单例时，则需要在每次获取时创建代理对象，创建的过程与单例模式区别不大，主要是每次都需要复制一份配置，通过复制出的配置再去创建代理对象，也就是说每个代理对象拥有的配置都是独立的。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>创建代理的过程总结如下图：</p><p><img src="/post/fc6f/ProxyFactoryBean%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%A8%8B.png" alt="ProxyFactoryBean创建代理对象流程"></p><p>执行过程如下：</p><p><img src="/post/fc6f/%E4%BB%A3%E7%90%86%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="调用过程"></p><h2 id="代理属性配置"><a href="#代理属性配置" class="headerlink" title="代理属性配置"></a>代理属性配置</h2><p>在前面提到了<code>ProxyFactoryBean</code>顶层继承了<code>ProxyConfig</code>类，该类提供了一些基础属性配置。下面看一下具体有哪些属性以及其作用。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>proxyTargetClass</td><td>是否直接代理目标类，而不只是代理特定的接口。默认设置是<code>false</code>。将其设置为<code>true</code>，以强制对目标类进行代理。如果目标类是接口，则将为给定接口创建JDK代理。如果目标类是任何其他类，那么将为给定的类创建一个CGLIB代理。</td></tr><tr><td>optimize</td><td>代理是否应该执行积极的优化。“积极的优化”的确切含义在不同的代理之间会有所不同，默认设置是<code>false</code>。例如，优化通常意味着在创建代理之后将不能更改通知。由于这个原因，优化在默认情况下是禁用的。</td></tr><tr><td>opaque</td><td>是否应阻止将此配置创建的代理转换为<code>Advised</code>来查询代理状态。默认值是<code>false</code>，这意味着任何AOP代理都可以被强制转换为<code>Advised</code>的，因为会给代理对象加上<code>Advised</code>接口。</td></tr><tr><td>exposeProxy</td><td>设置AOP框架是否应该将代理公开为ThreadLocal，以便通过AopContext类获取代理。如果<code>Advised</code>的对象需要调用自己另一个被拦截的方法时可以使用这种方式。(如果使用<code>this</code>，将不会拦截调用)。默认为“false”，以避免不必要的拦截。尽量不使用此种方式，因为依赖于Spring Aop。</td></tr><tr><td>frozen</td><td>设置这个配置是否应该被冻结。当一个配置被冻结时，无法更改通知。这对于性能优化非常有用，当我们不希望调用者能够在强制转换为<code>Advised</code>后操作配置时也非常有用。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-AOP-用法&quot;&gt;&lt;a href=&quot;#Spring-AOP-用法&quot; class=&quot;headerlink&quot; title=&quot;Spring AOP 用法&quot;&gt;&lt;/a&gt;Spring AOP 用法&lt;/h1&gt;&lt;p&gt;前面讲到了AOP相关的思想和基本概念，实现方式可分为
      
    
    </summary>
    
    
      <category term="Spring, AOP" scheme="http://qzztf.com/tags/Spring-AOP/"/>
    
  </entry>
  
  <entry>
    <title>AOP的基本概念</title>
    <link href="http://qzztf.com/post/35c5/"/>
    <id>http://qzztf.com/post/35c5/</id>
    <published>2020-09-23T02:22:00.000Z</published>
    <updated>2024-06-16T07:25:26.138Z</updated>
    
    <content type="html"><![CDATA[<p>任何技术的出现都是为了解决某类问题。</p><h1 id="AOP是什么？"><a href="#AOP是什么？" class="headerlink" title="AOP是什么？"></a>AOP是什么？</h1><p>AOP出现以前，代码逻辑都是从上到下编写。当我们需要在原有主逻辑不变的情况下，修改一些无关逻辑时，比如我们需要在每个方法中打印出入参，这时我们需要修改每个方法，然后加上打印日志的代码。这无疑是非常消耗精力的事情，而且这样的代码也不好维护，更不符合设计原则。</p><p>有没有更好的方式可以达成这样的目的？</p><p>我们可不可以在不修改原有逻辑的情况下将需要新增的代码插入到原有的代码中？</p><p>有的。我们可以创建原有对象的代理，将新增的代码写在代码对象的方法里，这样我们就可以不用修改原有对象的方法了。但是，方法这么多，难道我们要新增N 个代理对象吗？当然不是。我们有字节码工具，可以通过代码来为每个对象生成代理对象。</p><p>这样的局限性也很大。如果要在原有方法调用前插入日志需要新增代理对象，在调用后插入日志又要新增代理对象。随着需要插入的位置变多，我们就要创建更多的代理对象。</p><p>我们也可以通过在方法调用之间增加过滤器的方式，就像<code>Servlet</code>模式中的<code>Filter</code>一样。但是要给每个方法添加过滤器，显然不现实。</p><p>有没有一种更灵活的方式可以让我们控制插入的时机？</p><p>有。</p><p>AOP（Aspect Oriented Programming）,面向切面编程。通过预编绎和运行期动态代理可以在不修改源代码的给程序添加功能。</p><p>在面向对象的世界里，我们将业务功能自顶而下地抽象为一个个的类，但是有一些功能频繁地出现在某些类中，从设计角度讲，这些功能不应该出现在这些类中，这时我们通过AOP技术将这些无关的功能抽象成切面，然后再指定这些功能往业务功能中织入的规则，最终整合到我们的系统中。</p><h2 id="AOP-相关的概念"><a href="#AOP-相关的概念" class="headerlink" title="AOP 相关的概念"></a>AOP 相关的概念</h2><p>AOP本身只是一种思想，并不涉及到具体实现。为了解决上述问题，AOP引入了相关的基本概念。</p><h3 id="Join-Point"><a href="#Join-Point" class="headerlink" title="Join Point"></a>Join Point</h3><p>连接点，表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等。也就是我们要插入代码的地方。</p><h3 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h3><p>连接点的集合。用来描述连接点。如通过通配符、正则表达式等语法来定义连接点。实际执行时代码是插入到某个具体的连接点。</p><h3 id="Target-Object"><a href="#Target-Object" class="headerlink" title="Target Object"></a>Target Object</h3><p>将被织入通知的对象。也被称作被通知对象。</p><h3 id="AOP-proxy"><a href="#AOP-proxy" class="headerlink" title="AOP proxy"></a>AOP proxy</h3><p>AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</p><h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><p>定义具体要插入的内容，以及在连接点插入的时机，通过<code>before</code>、<code>after</code>等语义关键词表示。</p><h4 id="插入时机"><a href="#插入时机" class="headerlink" title="插入时机"></a>插入时机</h4><p>也可以理解为通知的类型。Spring中可以分为以下几种：</p><ol><li><p><code>Before</code></p><p>前置通知，在连接点前调用。</p></li><li><p><code>After</code></p><p>后置通知，在连接点后调用。</p></li><li><p><code>AfterReturning</code></p><p>返回通知，在连接点方法执行并正常返回后调用</p></li><li><p><code>AfterThrowing</code></p><p>异常通知，当连接点方法异常时调用</p></li><li><p><code>Around</code></p><p>环绕通知</p></li></ol><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>引入。添加方法或字段到被通知的类。 Spring允许引入新的接口或者字段到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。</p><h3 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h3><p>切面。连接点，切点，通知的载体。由这三者组合起来，才能称为一个完整的切面。</p><p>面向切面编程，也即是将我们想要新增的不影响主逻辑的代码抽出，并将其插入到原有目标代码的过程。</p><h1 id="AOP应用场景"><a href="#AOP应用场景" class="headerlink" title="AOP应用场景"></a>AOP应用场景</h1><p>在Spring中应用最广泛地当属事务管理。将事务控制抽象出切面，交由Spring IOC容器帮我们织入到目标对象中，并管理这些目标对象。想象一下如果没有AOP，那我们需要频繁地开启、提交、回滚事务。</p><p>还有日志记录，权限验证，链路追踪等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;任何技术的出现都是为了解决某类问题。&lt;/p&gt;
&lt;h1 id=&quot;AOP是什么？&quot;&gt;&lt;a href=&quot;#AOP是什么？&quot; class=&quot;headerlink&quot; title=&quot;AOP是什么？&quot;&gt;&lt;/a&gt;AOP是什么？&lt;/h1&gt;&lt;p&gt;AOP出现以前，代码逻辑都是从上到下编写。当我们
      
    
    </summary>
    
    
      <category term="Spring, AOP" scheme="http://qzztf.com/tags/Spring-AOP/"/>
    
  </entry>
  
  <entry>
    <title>自定义Scope</title>
    <link href="http://qzztf.com/post/fe03/"/>
    <id>http://qzztf.com/post/fe03/</id>
    <published>2019-11-27T09:41:46.000Z</published>
    <updated>2024-06-16T07:25:26.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h1><p>所谓生命周期，即是Bean何时创建，何时生存，何时销毁。也即Bean 存在的范围。更直白点儿就是Bean的作用范围，有点儿<em>变量</em>的意味。</p><p>Spring 内置了<code>singleton</code>、<code>prototype</code>两种<code>Scope</code>，Bean 默认为<code>singleton</code>，在Spring IOC 容器中，只会创建一个，并将其缓存起来。</p><p><code>prototype</code>作用域部署的bean，每一次请求（将其注入到另一个bean中，或者以程序的方式调用容器的<code>getBean()</code>方法）都会产生一个新的bean实例，相当与一个new的操作。对于<code>prototype</code>作用域的bean，有一点非常重要，那就是Spring不能对一个<code>prototype </code>bean的整个生命周期负责，容器在初始化、配置、装饰或者是装配完一个<code>prototype</code>实例后，将它交给客户端，随后就对该<code>prototype</code>实例不闻不问了。不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法，而对<code>prototype</code>而言，任何配置好的析构回调方法都将不会被调用(<code>destory-method</code>不会被调用)，因为在注册为<code>DisposableBean</code>时将<code>prototype</code>排除在外。 清除<code>prototype</code>作用域的对象并释放任何<code>prototype</code> bean所持有的昂贵资源，都是客户端代码的职责。让Spring 容器释放被<code>singleton</code>作用域 bean 占用资源的一种可行方式是，通过使用 bean的后置处理器，该处理器持有要被清除的bean的引用。</p><p>针对Web环境，Spring又增加了<code>session</code>、<code>request</code>、<code>global session</code>三种专用于Web应用程序上下文的<code>Scope</code>。</p><h2 id="Scope接口"><a href="#Scope接口" class="headerlink" title="Scope接口"></a><code>Scope</code>接口</h2><p>有时候我们还需要特殊的作用域，这时我们就可以实现该接口来达到我们的目的。上面提到的web环境中的三种也是基于此接口来实现的。</p><p>此接口是<code>ConfigurableBeanFactory</code>使用的策略接口，表示用于保存bean实例的作用范围。可以用来扩展<code>BeanFactory</code>的标准作用域<code>singleton</code>和<code>prototype</code>实现自定义作用域。</p><p>虽然该 SPI 接口主要用于扩展web环境中的Bean 作用范围，它也是完全通用的：提供了从任何底层存储机制(如HTTP会话或自定义会话机制)获取和设置对象的能力。传递到该类的<code>get</code>和<code>remove</code>方法中的名称将标识当前作用域中的目标对象。</p><p><code>Scope</code>实现类应该是线程安全的。如果需要的话，一个<code>Scope</code>实例可以供多个bean工厂同时使用(除非显式地希望知道所包含的bean工厂)，并且任意数量的线程可以从任意数量的工厂并发地访问该作用域。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><p>Object get(String name, ObjectFactory&lt;?&gt; objectFactory)：从此<code>Scope</code>返回具有给定名称的对象，如果没有找到，则通过<code>ObjectFactory#getObject()</code>创建。</p><p>这是<code>Scope</code>的核心操作，也是惟一绝对必需的操作。</p></li><li><p>Object remove(String name)：从<code>Scope</code>中删除该名称的对象。如果没有找到对象，则返回<code>null</code>；否则返回已删除的对象。</p><p>注意：实现类还应该删除指定对象已注册的销毁回调(如果有的话)。<strong>实际执行回调并销毁移除的对象是调用者的责任</strong>。</p><p>注意：这是一个可选操作。如果实现类不支持显式删除对象，则可能引发<code>UnsupportedOperationException</code>。</p></li><li><p>void registerDestructionCallback(String name, Runnable callback)：注册一个回调函数，在范围内指定对象被销毁时执行(或者在整个范围被销毁时，如果该范围没有销毁单个对象，而只是全部终止)。</p><p>注意:这是一个可选操作。此方法将仅对具有实际销毁配置的作用域bean调用(dispose - bean、destroy-method、DestructionAwareBeanPostProcessor)。实现类应该尽量在适当的时候执行给定的回调。如果底层运行时环境根本不支持这样的回调，则必须忽略回调并记录相应的警告。</p><p>请注意，“销毁”指的是作为<code>Scope</code>自身生命周期的一部分的对象的自动销毁，而不是指应用程序显式删除的单个作用域对象。如果一个作用域对象通过<code>remove(String)</code>方法被删除，那么任何已注册的销毁回调也应该被删除，假设被删除的对象将被重用或手动销毁。</p></li><li><p>Object resolveContextualObject(String key)：解析给定键的上下文对象(如果有的话)。如果此Scope支持多个上下文对象，则将每个对象与一个键值相关联，并返回与提供的<em>键</em>参数相对应的对象。否则，约定将返回<em>null</em>。例如: <code>request</code>对应的<code>HttpServletRequest</code>对象。</p><p>此方法提供了通过key来获取对象的功能。在Spring中有一个应用的地方，在自定义Scope的bean中通过<code>@Value</code>注解注入属性时，会通过此方法解析出对应的属性。</p></li><li><p>String getConversationId()：返回当前底层范围的会话ID(如果有的话)。</p><p>会话ID的确切含义取决于底层存储机制。对于<code>session</code>范围的对象，会话ID通常等于(或源自)session ID。</p><p>注意:这不是必须的。如果底层存储机制没有明显的ID时，则可以在此方法的实现中返回<code>null</code>。</p></li></ol><h2 id="自定义Scope"><a href="#自定义Scope" class="headerlink" title="自定义Scope"></a>自定义Scope</h2><p>在<code>AbstractBeanFactory</code>的<code>doGetBean</code>方法中，会判断是否是自定义<code>Scope</code>，并调用<code>get</code>方法。在我们的自定义Scope的get方法中，需要根据我们的场景来返回bean。比如我们要实现线程级别共享的bean，则需要判断当前线程是否存在，不存在就调用<code>ObjectFactory</code>的<code>getObject</code>方法创建bean，否则就返回存在的对象。<code>ObjectFactory</code>负责去创建bean，这个创建的过程跟其他的<code>Scope</code>一致，<code>Scope</code>要做的就是控制何时创建就OK了。</p><p>同时，我们还必须<strong>确保实现是线程安全的，</strong>因为Scope可以同时由多个bean工厂使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">        beforePrototypeCreation(beanName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            afterPrototypeCreation(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                    <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                                    <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                                    ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就以线程级别共享的Bean来创建自定义<code>ThreadScope</code>。</p><h3 id="自定义Scope类：ThreadScope"><a href="#自定义Scope类：ThreadScope" class="headerlink" title="自定义Scope类：ThreadScope"></a>自定义Scope类：<code>ThreadScope</code></h3><h4 id="实现Scope接口"><a href="#实现Scope接口" class="headerlink" title="实现Scope接口"></a>实现Scope接口</h4><p>实现自定义Scope，我们需要实现<code>Scope</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScope</span> <span class="keyword">implements</span> <span class="title">Scope</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="管理Scope中的对象和回调"><a href="#管理Scope中的对象和回调" class="headerlink" title="管理Scope中的对象和回调"></a>管理Scope中的对象和回调</h4><p>实现自定义<code>Scope</code>类时要考虑的第一件事是如何存储和管理作用域对象和销毁回调。</p><p>在此例中，使用<code>ThreadLocal</code>来保存对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用于保存线程变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; objectThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Map&lt;String, Runnable&gt;&gt; callbackThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure><h4 id="实现get方法"><a href="#实现get方法" class="headerlink" title="实现get方法"></a>实现<code>get</code>方法</h4><p>当Spring 容器遇到我们定义的<code>Scope</code>时，会从<code>Scope</code>中获取bean。因此我们需要实现<code>get</code>方法，当要获取的对象不在当前<code>Scope</code>中时，我们需要创建该对象并返回。</p><p>在这个例子中，则是判断当前线程中是否有该对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = Optional.ofNullable(objectThreadLocal.get()).orElse(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">Object o = Optional.ofNullable(map.get(name)).orElse(objectFactory.getObject());</span><br><span class="line">map.put(name,o);</span><br><span class="line">objectThreadLocal.set(map);</span><br><span class="line"><span class="keyword">return</span> o;</span><br></pre></td></tr></table></figure><p>在<code>Scope</code>接口定义的五个方法中，<strong>仅<code>get</code>方法才需要具有</strong>所描述行为<strong>的完整实现</strong>。其他四个方法是可选的，如果它们不需要或不支持功能，则可能引发<em>UnsupportedOperationException</em>。</p><h4 id="注册销毁回调"><a href="#注册销毁回调" class="headerlink" title="注册销毁回调"></a>注册销毁回调</h4><p>我们还需要<code>registerDestructionCallback</code>方法。此方法提供了一个回调，当命名对象被销毁或者<code>Scope</code>本身被销毁时执行此回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable callback)</span> </span>&#123;</span><br><span class="line">    callbackThreadLocal.get().put(name, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从Scope中删除对象"><a href="#从Scope中删除对象" class="headerlink" title="从Scope中删除对象"></a>从Scope中删除对象</h4><p>接下来实现<code>remove</code>方法，该方法从Scope中删除命名对象，并删除其注册的销毁回调，并返回删除的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = objectThreadLocal.get();</span><br><span class="line">Object o = map.remove(name);</span><br><span class="line">callbackThreadLocal.get().remove(name);</span><br><span class="line"><span class="keyword">return</span> o;</span><br></pre></td></tr></table></figure><p>请注意，Spring 并不会帮我们调用remove和执行回调方法，<strong>实际执行回调并销毁移除的对象是调用者的责任</strong>，因为Spring也不知道何时该remove掉对象。</p><h4 id="获取会话ID"><a href="#获取会话ID" class="headerlink" title="获取会话ID"></a>获取会话ID</h4><p>现在实现<code>getConversationId</code>方法。如果Scope支持会话ID的概念，则可以在此处将其返回。否则，约定将返回<em>null</em>：</p><p>此例中不需要会话ID，直接返回<code>null</code>。</p><h4 id="解析上下文对象"><a href="#解析上下文对象" class="headerlink" title="解析上下文对象"></a>解析上下文对象</h4><p>最后实现<code>resolveContextualObject</code>方法。如果范围支持多个上下文对象，则将每个对象与一个键值相关联，并返回与提供的<em>键</em>相对应的对象。否则，约定将返回<em>null</em>。此例中不需要。</p><h4 id="注册自定义Scope"><a href="#注册自定义Scope" class="headerlink" title="注册自定义Scope"></a>注册自定义<code>Scope</code></h4><p>为了使Spring容器知道这个新作用域，可以<strong>通过<code>ConfigurableBeanFactory</code>实例上的<code>registerScope</code>方法对其进行注册</strong>。让我们看一下该方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerScope</span><span class="params">(String scopeName, Scope scope)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数<code>scopeName</code>用于指定唯一标识，第二个参数<code>scope</code>指定具体的实例。</p><p>要拿到<code>ConfigurableBeanFactory</code>我们可以实现<code>BeanFactoryPostProcessor</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        beanFactory.registerScope(ThreadScope.SCOPE_NAME,<span class="keyword">new</span> ThreadScope());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将此<em>ThreadScopeBeanFactoryPostProcessor</em> 注册到Spring容器中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.addBeanFactoryPostProcessor(<span class="keyword">new</span> ThreadScopeBeanFactoryPostProcessor());</span><br></pre></td></tr></table></figure><p>Spring 为我们提供了一个更方便的类：<code>org.springframework.beans.factory.config.CustomScopeConfigurer</code>。</p><p>该类也实现了<code>BeanFactoryPostProcessor</code>接口，增加了两个方法：<code>setScopes(Map&lt;String, Object&gt; scopes)</code>和<code>addScope(String scopeName, Scope scope)</code>，可以更方便注册<code>Scope</code>。</p><p>同样也通过<code>context.addBeanFactoryPostProcessor()</code>方法将<code>CustomScopeConfigurer</code>注册到容器中。</p><p><em>这里手动注册的原因是可以更清楚的知道是如何使用这个<code>BeanFactoryPostProcessor</code>，在平时使用的过程中，只需要在xml中配置，或者使用注解<code>@Bean</code>配置即可</em>。</p><h4 id="使用自定义Scope"><a href="#使用自定义Scope" class="headerlink" title="使用自定义Scope"></a>使用自定义<code>Scope</code></h4><p>现在已经注册了自定义<code>Scope</code>，可以将其应用于我们的任何bean，通过使用`@Scope注解并指定我们的自定义Scope名称。</p><h5 id="定义Bean"><a href="#定义Bean" class="headerlink" title="定义Bean"></a>定义Bean</h5><p>让我们创建一个简单的<em>ScopeBean</em>类，稍后我们将声明这种类型的<code>ThreadScope</code>的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopeBean</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，我们没有在此类上使用类级别的<code>@Component</code>和<code>@Scope</code>批注。</p><h5 id="注册Bean"><a href="#注册Bean" class="headerlink" title="注册Bean"></a>注册Bean</h5><p>注册Bean有很多种方式：xml，<code>@Bean</code>注解。这里展示另一种方式：实现<code>BeanDefinitionRegistryPostProcessor</code>接口。该接口继承自<code>BeanFactoryPostProcessor</code>，在该接口的基础上添加了<code>postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)</code>方法，用来注册Bean。当你不想写配置文件或者配置类的时候，用编程的方式来注册Bean，也不愧是一种有效的方式。</p><p>从这里我们也看到<code>BeanFactoryPostProcessor</code>接口是我们想要扩展Spring时的突破口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopeBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(ScopeBean.class);</span><br><span class="line">        builder.setScope(ThreadScope.SCOPE_NAME);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;scopeBean&quot;</span>, builder.getBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中手动设置Scope为<code>ThreadScope</code>。</p><h4 id="测试自定义Scope"><a href="#测试自定义Scope" class="headerlink" title="测试自定义Scope"></a>测试自定义<code>Scope</code></h4><p>让我们编写一个测试类，通过加载<em>ApplicationContext</em>，并检索我们的<code>ThreadScope</code>的bean ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext();</span><br><span class="line">CustomScopeConfigurer customScopeConfigurer = <span class="keyword">new</span> CustomScopeConfigurer();</span><br><span class="line">customScopeConfigurer.addScope(ThreadScope.SCOPE_NAME, <span class="keyword">new</span> ThreadScope());</span><br><span class="line"><span class="comment">//只通过一种方式来注册scope</span></span><br><span class="line"><span class="comment">//context.addBeanFactoryPostProcessor(customScopeConfigurer);</span></span><br><span class="line">context.addBeanFactoryPostProcessor(<span class="keyword">new</span> ThreadScopeBeanFactoryPostProcessor());</span><br><span class="line"><span class="comment">//注册Bean</span></span><br><span class="line">context.addBeanFactoryPostProcessor(<span class="keyword">new</span> ScopeBeanDefinitionRegistryPostProcessor());</span><br><span class="line">context.refresh();</span><br><span class="line">System.out.println(<span class="string">&quot;同一线程：&quot;</span> + Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span> + context.getBean(ScopeBean.class));</span><br><span class="line">System.out.println(<span class="string">&quot;同一线程：&quot;</span> + Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span> + context.getBean(ScopeBean.class));</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不同线程：&quot;</span> + Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span> + context.getBean(ScopeBean.class));</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不同线程：&quot;</span> + Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span> + context.getBean(ScopeBean.class));</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>分别打印在同一个线程和不同线程中获取的Bean：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">同一线程：main:cn.sexycode.spring.study.chapter4.ScopeBean@e70f13a</span><br><span class="line">同一线程：main:cn.sexycode.spring.study.chapter4.ScopeBean@e70f13a</span><br><span class="line">不同线程：Thread-1:cn.sexycode.spring.study.chapter4.ScopeBean@c4c29bf</span><br><span class="line">不同线程：Thread-0:cn.sexycode.spring.study.chapter4.ScopeBean@3b41834c</span><br></pre></td></tr></table></figure><p>从结果中可以看出，在同一线程中获取的Bean 是同一个，不同线程中获取的Bean不同。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本文中，我们了解了<code>Scope</code>是什么，以及如何在Spring中定义，注册和使用自定义<code>Scope</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bean-的生命周期&quot;&gt;&lt;a href=&quot;#Bean-的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Bean 的生命周期&quot;&gt;&lt;/a&gt;Bean 的生命周期&lt;/h1&gt;&lt;p&gt;所谓生命周期，即是Bean何时创建，何时生存，何时销毁。也即Bean 存在的
      
    
    </summary>
    
    
      <category term="Scope" scheme="http://qzztf.com/tags/Scope/"/>
    
  </entry>
  
  <entry>
    <title>ObjectFactory与BeanFactory的区别</title>
    <link href="http://qzztf.com/post/4819/"/>
    <id>http://qzztf.com/post/4819/</id>
    <published>2019-09-26T08:24:59.000Z</published>
    <updated>2024-06-16T07:25:26.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ObjectFactory-与BeanFactory-的区别"><a href="#ObjectFactory-与BeanFactory-的区别" class="headerlink" title="ObjectFactory 与BeanFactory 的区别"></a>ObjectFactory 与BeanFactory 的区别</h1><p>Spring 体系中有一些跟 Bean获取相关的接口，比如：<code>ObjectFactory</code>、<code>BeanFactory </code>、<code>FactoryBean</code>、<code>ObjectProvider</code>等。有时候会让人不知道该使用哪一个。下面具体看一下区别。</p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>该接口是整个Spring容器的顶层接口，定义了从容器中获取Bean的方法。当我们的应用需要从容器中获取Bean的时候用此接口。在这里我们可以将整个容器看成是一个黑盒，不需要关心它是如何获取的，我们只关心结果。</p><h2 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h2><p>此接口定义了一个简单工厂，是一个函数式接口，可以在调用时返回一个对象实例(可能是共享的或独立的)。</p><p>这个接口类似于<code>FactoryBean</code>，但是后者的实现类通常被定义为<code>BeanFactory</code>中的SPI实例，而该类的实现通常被作为API(通过注入)提供给其他bean。因此，getObject()方法具有不同的异常处理行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回工厂管理的bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the resulting instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of creation errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><p>这个接口定义了创建单个对象的工厂。如果一个bean 实现了这个接口，那么它将被用作要公开的对象的工厂，而不是直接用作将自己公开的bean 实例。</p><p>注意： <strong>实现此接口的bean不能作为普通bean使用。<code>FactoryBean</code>是以bean形式定义的，但是引用该Bean 时是它创建的对象。</strong></p><p><code>FactoryBean</code>支持单例和原型对象，可以根据需要创建对象，也可以在启动时创建对象。<code>SmartFactoryBean</code>接口可以公开更细粒度的元数据。</p><p>这个接口在Spring 框架本身中大量使用，例如在AOP模块 <code>org.springframework.aop.framework.ProxyFactoryBean</code>或<code>org.springframework.jndi.JndiObjectFactoryBean</code>中。</p><p><code>FactoryBean</code>是一个编程规范。实现类不应该依赖于注解驱动的注入或其他反射工具。在启动过程中可能会提前调用<code>getObjectType() </code>和<code>getObject()</code>方法，甚至比后处理器都要早。如果需要访问其他bean，请实现<code>BeanFactoryAware</code>接口并通过编程获取，也就是说在<code>FactoryBean</code>中注解可能还没解析，通过注解注入其他Bean 可能不成功。</p><p>最后，<code>FactoryBean</code>对象会参与bean创建同步过程。通常不需要做内部同步，只需要在<code>FactoryBean</code>本身中进行延迟初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回此工厂对象生产的Bean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回此工厂对象生产的Bean类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 生产的Bean 是否单例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ObjectProvider"><a href="#ObjectProvider" class="headerlink" title="ObjectProvider"></a>ObjectProvider</h2><p>该接口是<code>ObjectFactory</code>的变体形式，专门为注入点设计，允许编程可选性和宽松的非惟一处理。</p><p>从Spring 5.1开始，这个接口扩展了<code>Iterable</code>并提供了流支持。因此，它可以在for循环中使用，提供forEach迭代并允许流访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectProvider</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt;, <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回该工厂管理的对象的实例(可能是共享的或独立的)。可以显式指定构造参数，类似于BeanFactory.getBean(String,Object)方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回该工厂管理的对象的实例(可能是共享的或独立的)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">T <span class="title">getIfAvailable</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回该工厂管理的对象的实例(可能是共享的或独立的)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultSupplier 回调函数，用于在工厂中不存在对象的情况下提供默认对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> T <span class="title">getIfAvailable</span><span class="params">(Supplier&lt;T&gt; defaultSupplier)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">T dependency = getIfAvailable();</span><br><span class="line"><span class="keyword">return</span> (dependency != <span class="keyword">null</span> ? dependency : defaultSupplier.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果存在该实例对象的话，则消费此对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dependencyConsumer 在对象存在的情况下，用来消费此实例的消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of creation errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getIfAvailable()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">ifAvailable</span><span class="params">(Consumer&lt;T&gt; dependencyConsumer)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">T dependency = getIfAvailable();</span><br><span class="line"><span class="keyword">if</span> (dependency != <span class="keyword">null</span>) &#123;</span><br><span class="line">dependencyConsumer.accept(dependency);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回实例，如果没有或者不唯一的话（如有多个的情况下都没有标记为primary）则返回 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of creation errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getObject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">T <span class="title">getIfUnique</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回实例，如果没有或者不唯一的话（如有多个的情况下都没有标记为primary）则返回提供的默认对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of creation errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getIfUnique()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> T <span class="title">getIfUnique</span><span class="params">(Supplier&lt;T&gt; defaultSupplier)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">T dependency = getIfUnique();</span><br><span class="line"><span class="keyword">return</span> (dependency != <span class="keyword">null</span> ? dependency : defaultSupplier.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果唯一的话，则消费此对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dependencyConsumer 如果对象唯一，则使用此消费者消费对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of creation errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getIfAvailable()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">ifUnique</span><span class="params">(Consumer&lt;T&gt; dependencyConsumer)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">T dependency = getIfUnique();</span><br><span class="line"><span class="keyword">if</span> (dependency != <span class="keyword">null</span>) &#123;</span><br><span class="line">dependencyConsumer.accept(dependency);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回所有匹配对象实例的迭代器，不保证特定的顺序(但通常按注册的顺序)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #stream()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> stream().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回所有匹配对象实例上的顺序流，不保证特定的顺序(但通常按注册的顺序)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #iterator()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #orderedStream()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;T&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Multi element access not supported&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回所有匹配对象实例上的顺序流，根据工厂的公共顺序比较器预先排序。</span></span><br><span class="line"><span class="comment">在标准Spring应用程序上下文中，这将根据 org.springframework.core.Ordered 的约定，如果是基于注解的配置，也要考虑 org.springframework.core.annotation.Order 注解，类似于列表/数组类型的多元素注入点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #stream()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.OrderComparator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;T&gt; <span class="title">orderedStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Ordered element access not supported&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="几者的区别"><a href="#几者的区别" class="headerlink" title="几者的区别"></a>几者的区别</h2><p><code>BeanFactory </code>与这几个不在一个层面上，名字比较像，所以容易混淆。<code>BeanFactory </code>是整个大的工厂，有各种各样的生产线，<code>FactoryBean</code>就好比是生产线。</p><p><code>FactoryBean</code> 与<code>ObjectFactory</code>相比，<code>FactoryBean</code> 主要强调自定义创建Bean的过程，通过编程的方式去创建我们的Bean，比配置文件的方式更加的灵活。而且<code>FactoryBean</code> 本身也是一个受Spring 容器管理的Bean，只不过我们更注重它创建出来的Bean。<code>FactoryBean</code> 还是Spring提供出来的SPI接口，用于扩展框架。而<code>ObjectFactory</code>是一个普通的工厂，与Spring 容器Bean的创建关系不大。在Spring 创建Bean的过程中，借助自定义<code>Scope</code> 可以控制创建对象的时机，参见<code>org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean</code>方法对自定义<code>Scope</code>的处理，自定义<code>Scope</code>可以参见<code>org.springframework.web.context.request.AbstractRequestAttributesScope.get</code>方法。</p><p><code>ObjectProvider</code> 扩展自<code>ObjectFactory</code>接口，提供了更多关于Bean的信息的方法，比如是否存在，是否唯一，提供和消费Bean，以及遍历Bean。通过这个接口，我们可以根据这些信息做更灵活的控制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ObjectFactory-与BeanFactory-的区别&quot;&gt;&lt;a href=&quot;#ObjectFactory-与BeanFactory-的区别&quot; class=&quot;headerlink&quot; title=&quot;ObjectFactory 与BeanFactory 的区别&quot;&gt;
      
    
    </summary>
    
    
      <category term="BeanFactory" scheme="http://qzztf.com/tags/BeanFactory/"/>
    
      <category term="ObjectFactory" scheme="http://qzztf.com/tags/ObjectFactory/"/>
    
      <category term="FactoryBean" scheme="http://qzztf.com/tags/FactoryBean/"/>
    
      <category term="ObjectProvider" scheme="http://qzztf.com/tags/ObjectProvider/"/>
    
  </entry>
  
  <entry>
    <title>BeanWrapper</title>
    <link href="http://qzztf.com/post/504e/"/>
    <id>http://qzztf.com/post/504e/</id>
    <published>2019-09-05T07:51:12.000Z</published>
    <updated>2024-06-16T07:25:26.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BeanWrapper"><a href="#BeanWrapper" class="headerlink" title="BeanWrapper"></a>BeanWrapper</h1><h2 id="BeanWrapper是什么"><a href="#BeanWrapper是什么" class="headerlink" title="BeanWrapper是什么"></a>BeanWrapper是什么</h2><p>Spring底层操作Java Bean的核心接口。</p><p>通常不直接使用该接口，而是通过<code>BeanFactory</code>或<code>DataBinder</code>。</p><p>提供分析和操作标准Java Bean的操作: 获取和设置属性值(单个或批量)、获取属性描述以及查询属性的可读性/可写性的能力。</p><p>此接口还支持嵌套属性，允许将子属性上的属性设置为无限深度。</p><p><code>BeanWrapper</code>的<code>extractOldValueForEditor</code>默认值是<code>false</code>，可以避免调用 <code>getter</code>方法。将此选项设置为<code>true</code>，可以向自定义编辑器暴露当前属性值。</p><p>可以看出<code>BeanWrapper</code>是操作Java Bean 的强大利器。</p><h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><p><img src="/post/504e/BeanWrapper%E7%B1%BB%E7%BB%93%E6%9E%84.png" alt="BeanWrapper类结构"></p><p>BeanWrapper 继承自<code>TypeConverter</code>，<code>PropertyEditorRegistry</code>，<code>PropertyAccessor</code>, <code>ConfigurablePropertyAccessor</code>接口。从名称可以看出具备了类型转换，属性编辑器注册，属性访问及配置的功能。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>接下来看看如何使用BeanWrapper来操作我们的Java Bean。</p><p>Spring给我们提供了一个实现类<code>BeanWrapperImpl</code>，我们就用这个类来展示。</p><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><p>Bean对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassRoom classRoom;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassRoom <span class="title">getClassRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classRoom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassRoom</span><span class="params">(ClassRoom classRoom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classRoom = classRoom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了<em>3</em>个属性，看一下使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">BeanWrapper wrapper = <span class="keyword">new</span> BeanWrapperImpl(student);</span><br><span class="line">System.out.println(<span class="string">&quot;展示bean 的属性&quot;</span>);</span><br><span class="line">Arrays.stream(wrapper.getPropertyDescriptors()).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">展示bean 的属性</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=age]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=class]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=classRoom]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=name]</span><br></pre></td></tr></table></figure><p>可以看出将有<code>get</code>方法的属性已经打印出来了。同时可以看到多打印了一个<code>class</code>属性，但是我们的类里面没有定义这个属性，<code>Object</code>类中有<code>getClass</code>的方法。我们大胆猜测Spring会遵循Java Bean的设计原则，通过<code>get</code>方法来获取属性。 </p><p>现在将<code>age</code>改成<code>age1</code>，<code>getAge</code>方法不变，看一下结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">展示bean 的属性</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=age]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=class]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=classRoom]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=name]</span><br></pre></td></tr></table></figure><p>打印出来的属性名一样。现在交换一下，将<code>getAge</code>改成<code>getAge1</code>，属性<code>age1</code>改成<code>age</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">展示bean 的属性</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=age1]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=class]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=classRoom]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=name]</span><br></pre></td></tr></table></figure><p>可以看到获取到的属性已经变成了<code>age1</code>。这充分验证了我们的猜想。</p><p>我们可以看一下Spring的代码，里面使用了<code>java.beans</code>包下<code>Introspector</code>类来获取Bean的信息。</p><h4 id="嵌套属性"><a href="#嵌套属性" class="headerlink" title="嵌套属性"></a>嵌套属性</h4><p>上面的结果中，我们并没有获取到ClassRoom的属性。BeanWrapper并不支持这种操作，我们可以扩展一下，比如判断属性，如果是自定义的类型，那么就再调用一次BeanWrapper的方法。这有个前提是这个属性不为<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setClassRoom(<span class="keyword">new</span> ClassRoom());</span><br><span class="line">BeanWrapper wrapper = <span class="keyword">new</span> BeanWrapperImpl(student);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;展示bean 的属性&quot;</span>);</span><br><span class="line">Arrays.stream(wrapper.getPropertyDescriptors()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;展示bean 的嵌套属性&quot;</span>);</span><br><span class="line">wrapper = <span class="keyword">new</span> PowerfulBeanWrapper(student);</span><br><span class="line">Arrays.stream(wrapper.getPropertyDescriptors()).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>先上结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">展示bean 的属性</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=age]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=class]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=classRoom]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=name]</span><br><span class="line">展示bean 的嵌套属性</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=age]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=class]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=classRoom]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=name]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=class]</span><br><span class="line">org.springframework.beans.GenericTypeAwarePropertyDescriptor[name=name]</span><br></pre></td></tr></table></figure><p>ClassRoom类只有一个name 属性，这里看到也打印出来了。证明思路是对的，只是这个结构还需要组织一下，现在是扁平的。</p><p>下面看一下<code>PowerfulBeanWrapper</code>的实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerfulBeanWrapper</span> <span class="keyword">extends</span> <span class="title">BeanWrapperImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PowerfulBeanWrapper</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyDescriptor[] getPropertyDescriptors() &#123;</span><br><span class="line">        PropertyDescriptor[] propertyDescriptors = <span class="keyword">super</span>.getPropertyDescriptors();</span><br><span class="line">        List&lt;PropertyDescriptor&gt; propertyDescriptorList = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(propertyDescriptors));</span><br><span class="line">        Arrays.stream(propertyDescriptors).forEach(propertyDescriptor -&gt; &#123;</span><br><span class="line">            Object value = getPropertyValue(propertyDescriptor.getName());</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !(value <span class="keyword">instanceof</span> Class) &amp;&amp; !value.getClass().isPrimitive()) &#123;</span><br><span class="line">                propertyDescriptorList.addAll(Arrays.asList(<span class="keyword">new</span> BeanWrapperImpl(value).getPropertyDescriptors()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> propertyDescriptorList.toArray(<span class="keyword">new</span> PropertyDescriptor[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接继承自<code>BeanWrapperImpl</code>类，覆盖了<code>getPropertyDescriptors</code>方法。遍历属性值，如果不为空并且不是Class，则再获取一次这个属性的属性。这里只获取了2层属性，可以在获取嵌套属性时换成我们的<code>PowerfulBeanWrapper</code>类既可支持无限层。</p><h3 id="获取属性值"><a href="#获取属性值" class="headerlink" title="获取属性值"></a>获取属性值</h3><p>可以使用BeanWrapper的<code>getPropertyValue</code>方法来获取属性值。上面的代码中已经展示过了。</p><p>支持获取嵌套属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">ClassRoom classRoom = <span class="keyword">new</span> ClassRoom();</span><br><span class="line">classRoom.setName(<span class="string">&quot;room1&quot;</span>);</span><br><span class="line">student.setClassRoom(classRoom);</span><br><span class="line">BeanWrapper wrapper = <span class="keyword">new</span> BeanWrapperImpl(student);</span><br><span class="line">System.out.println(wrapper.getPropertyValue(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">System.out.println(wrapper.getPropertyValue(<span class="string">&quot;classRoom.name&quot;</span>));</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line">room1</span><br></pre></td></tr></table></figure><p>可以看出来还是很方便的。</p><p><strong>注： 当嵌套对象为空时，默认获取嵌套对象的属性会抛出异常。</strong>  这时可以加一个设置：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wrapper.setAutoGrowNestedPaths(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;嵌套对象为空时：&quot;</span> + wrapper.getPropertyValue(<span class="string">&quot;classRoom.name&quot;</span>));</span><br></pre></td></tr></table></figure><p>该属性的意义是自动扩展嵌套属性，按照默认值来初始化属性。此处就会将<code>classRoom</code>初始化，并且里面的属性为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">嵌套对象为空时：<span class="keyword">null</span></span><br></pre></td></tr></table></figure><h3 id="设置属性值"><a href="#设置属性值" class="headerlink" title="设置属性值"></a>设置属性值</h3><p>可以通过<code>setPropertyValue</code>方法来设置属性值。同上，当嵌套对象为空时，不能设置嵌套对象的属性，设置<code>wrapper.setAutoGrowNestedPaths(true)</code>即可。</p><p>注意以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">wrapper.setPropertyValue(<span class="string">&quot;age&quot;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在这里设置属性值的时候是整数型，但是<code>age</code>声明的时候是String。BeanWrapper是如何正确的赋值的呢？</p><p><code>BeanWrapperImpl</code>内部会委托给<code>TypeConverterDelegate</code>类，先查找自定义<code>PropertyEditor</code>, 如果没有找到的话，则查找<code>ConversionService</code>，没有的话查找默认的<code>PropertyEditor</code>,再没有的话使用内部定义好的转换策略（按类型去判断，然后去转换）。</p><h2 id="PropertyEditor"><a href="#PropertyEditor" class="headerlink" title="PropertyEditor"></a>PropertyEditor</h2><p><code>PropertyEditor</code>属于Java Bean规范里面的类，可以给GUI程序设置对象属性值提供方便，所以接口里有一些和GUI相关的方法，显然目前已经过时了。同时，官方文档上解释，它是线程不安全的。必须得有一个默认构造函数。可以想象一下，在界面上填入一个值，这个值一般来说都是<code>String</code>类型的，填入之后这个值能自动设置到对应的对象中（ 这里纯粹是我意淫的，对<code>awt</code>并不是很熟，不知道是不是这样）。了解安卓编程的朋友可能知道，我们要取界面上填的值，通常要拿到界面元素，然后再拿到值，然后再设置到对象中去。当界面上有很多个输入控件时，这样繁琐的操作，简直要人命。所以安卓后来出了数据绑定。这里有一篇<a href="https://www.iteye.com/blog/stamen-1525668">文章</a>讲得很好。</p><p>BeanWrapperImpl内置了一些 <code>PropertyEditor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createDefaultEditors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.defaultEditors = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple editors, without parameterization capabilities.</span></span><br><span class="line"><span class="comment">// The JDK does not contain a default editor for any of these target types.</span></span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Charset.class, <span class="keyword">new</span> CharsetEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Class.class, <span class="keyword">new</span> ClassEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Class[].class, <span class="keyword">new</span> ClassArrayEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Currency.class, <span class="keyword">new</span> CurrencyEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(File.class, <span class="keyword">new</span> FileEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(InputStream.class, <span class="keyword">new</span> InputStreamEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(InputSource.class, <span class="keyword">new</span> InputSourceEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Locale.class, <span class="keyword">new</span> LocaleEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Path.class, <span class="keyword">new</span> PathEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Pattern.class, <span class="keyword">new</span> PatternEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Properties.class, <span class="keyword">new</span> PropertiesEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Reader.class, <span class="keyword">new</span> ReaderEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Resource[].class, <span class="keyword">new</span> ResourceArrayPropertyEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(TimeZone.class, <span class="keyword">new</span> TimeZoneEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(URI.class, <span class="keyword">new</span> URIEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(URL.class, <span class="keyword">new</span> URLEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(UUID.class, <span class="keyword">new</span> UUIDEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(ZoneId.class, <span class="keyword">new</span> ZoneIdEditor());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default instances of collection editors.</span></span><br><span class="line"><span class="comment">// Can be overridden by registering custom instances of those as custom editors.</span></span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Collection.class, <span class="keyword">new</span> CustomCollectionEditor(Collection.class));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Set.class, <span class="keyword">new</span> CustomCollectionEditor(Set.class));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(SortedSet.class, <span class="keyword">new</span> CustomCollectionEditor(SortedSet.class));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(List.class, <span class="keyword">new</span> CustomCollectionEditor(List.class));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(SortedMap.class, <span class="keyword">new</span> CustomMapEditor(SortedMap.class));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default editors for primitive arrays.</span></span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">byte</span>[].class, <span class="keyword">new</span> ByteArrayPropertyEditor());</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">char</span>[].class, <span class="keyword">new</span> CharArrayPropertyEditor());</span><br><span class="line"></span><br><span class="line"><span class="comment">// The JDK does not contain a default editor for char!</span></span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">char</span>.class, <span class="keyword">new</span> CharacterEditor(<span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Character.class, <span class="keyword">new</span> CharacterEditor(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring&#x27;s CustomBooleanEditor accepts more flag values than the JDK&#x27;s default editor.</span></span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">boolean</span>.class, <span class="keyword">new</span> CustomBooleanEditor(<span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Boolean.class, <span class="keyword">new</span> CustomBooleanEditor(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// The JDK does not contain default editors for number wrapper types!</span></span><br><span class="line"><span class="comment">// Override JDK primitive number editors with our own CustomNumberEditor.</span></span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">byte</span>.class, <span class="keyword">new</span> CustomNumberEditor(Byte.class, <span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Byte.class, <span class="keyword">new</span> CustomNumberEditor(Byte.class, <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">short</span>.class, <span class="keyword">new</span> CustomNumberEditor(Short.class, <span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Short.class, <span class="keyword">new</span> CustomNumberEditor(Short.class, <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">int</span>.class, <span class="keyword">new</span> CustomNumberEditor(Integer.class, <span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Integer.class, <span class="keyword">new</span> CustomNumberEditor(Integer.class, <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">long</span>.class, <span class="keyword">new</span> CustomNumberEditor(Long.class, <span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Long.class, <span class="keyword">new</span> CustomNumberEditor(Long.class, <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">float</span>.class, <span class="keyword">new</span> CustomNumberEditor(Float.class, <span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Float.class, <span class="keyword">new</span> CustomNumberEditor(Float.class, <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">double</span>.class, <span class="keyword">new</span> CustomNumberEditor(Double.class, <span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(Double.class, <span class="keyword">new</span> CustomNumberEditor(Double.class, <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(BigDecimal.class, <span class="keyword">new</span> CustomNumberEditor(BigDecimal.class, <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(BigInteger.class, <span class="keyword">new</span> CustomNumberEditor(BigInteger.class, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only register config value editors if explicitly requested.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.configValueEditorsActive) &#123;</span><br><span class="line">StringArrayPropertyEditor sae = <span class="keyword">new</span> StringArrayPropertyEditor();</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(String[].class, sae);</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">short</span>[].class, sae);</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">int</span>[].class, sae);</span><br><span class="line"><span class="keyword">this</span>.defaultEditors.put(<span class="keyword">long</span>[].class, sae);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有注册<code>String</code>, 所以走的是内置方案，直接调用<code>toString</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (String.class == requiredType &amp;&amp; ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) &#123;</span><br><span class="line">  <span class="comment">// We can stringify any primitive value...</span></span><br><span class="line">  <span class="keyword">return</span> (T) convertedValue.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义PropertyEditor"><a href="#自定义PropertyEditor" class="headerlink" title="自定义PropertyEditor"></a>自定义<code>PropertyEditor</code></h3><p>当Spring提供的<code>PropertyEditor</code>无法满足我们的需求时，我们可以自定义<code>PropertyEditor</code>。</p><p>一般不直接实现接口，而是继承<code>PropertyEditorSupport</code>类。Spring中大多数场景都是将传入的字符串转换成对应的属性值，需要重写<code>setAsText</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转换String -&gt; ClassRoom;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassRoomPropertyEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">//将逗号分隔的值转换成对象的属性值：room3,3</span></span><br><span class="line">        String[] strings = Optional.ofNullable(text).orElseGet(String::<span class="keyword">new</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        ClassRoom classRoom = <span class="keyword">new</span> ClassRoom();</span><br><span class="line">        classRoom.setName(strings[<span class="number">0</span>]);</span><br><span class="line">        classRoom.setSize(Integer.parseInt(strings[<span class="number">1</span>]));</span><br><span class="line">        setValue(classRoom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，将字符串进行分隔，第一个值作为<code>ClassRoom</code>的<code>name</code>值，第二个值作为<code>size</code>。如何使用这个<code>PropertyEditor</code>?</p><p>先注册这个类，再设置<code>Student</code>的<code>classRoom</code>属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wrapper = <span class="keyword">new</span> BeanWrapperImpl(student);</span><br><span class="line"><span class="comment">//注解自定义PropertyEditor</span></span><br><span class="line">wrapper.registerCustomEditor(ClassRoom.class, <span class="keyword">new</span> ClassRoomPropertyEditor());</span><br><span class="line">wrapper.setPropertyValue(<span class="string">&quot;classRoom&quot;</span>, <span class="string">&quot;room3,3&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样就给<code>Student</code>类的<code>classRoom</code>属性进行了初始化。</p><h2 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a><code>ConversionService</code></h2><p><code>ConversionService</code>是Spring提供的一套通用的类型转换机制的入口，相比<code>PropertyEditor</code>来说：</p><ol><li>支持的类型转换范围更广。</li><li>支持从父类型转换为子类型，即多态。</li><li>省去了Java GUI相关的概念。</li><li>线程安全。</li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p><code>boolean canConvert(@Nullable Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</code>：如果可以将<code>sourceType</code>对象转换为<code>targetType</code>，则返回<code>true</code>。</p><p>如果此方法返回<code>true</code>，则意味着<code>convert(Object, Class)</code>方法能够将<code>sourceType</code>实例转换为<code>targetType</code>。</p><p>关于集合、数组和Map类型需要特别注意：<strong>对于集合、数组和Map类型之间的转换，此方法将返回true，即使在底层元素不可转换的情况下，转换过程仍然可能生成一个<code>ConversionException</code>。在处理集合和映射时，调用者需要处理这种特殊情况。</strong></p></li><li><p><code>boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType)</code>：如果可以将<code>sourceType</code>对象转换为<code>targetType</code>，则返回<code>true</code>。<code>TypeDescriptor </code>提供关于将要发生转换的源和目标位置的附加上下文信息，通常是对象字段或属性的位置。</p><p>如果此方法返回<code>true</code>，则意味着<code>convert(Object、TypeDescriptor、TypeDescriptor)</code>能够将<code>sourceType</code>实例转换为<code>targetType</code>。</p><p>关于集合、数组和Map类型需要特别注意：<strong>对于集合、数组和Map类型之间的转换，此方法将返回true，即使在底层元素不可转换的情况下，转换过程仍然可能生成一个<code>ConversionException</code>。在处理集合和映射时，调用者需要处理这种特殊情况。</strong></p></li><li><p><code>&lt;T&gt; T convert(@Nullable Object source, Class&lt;T&gt; targetType)</code>：将给定的对象转换为指定的<code>targetType</code>类型对象。</p></li><li><p><code>Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType)</code>：将给定的对象转换为指定的<code>targetType</code>类型对象。<code>TypeDescriptor </code>提供关于将要发生转换的源和目标位置的附加上下文信息，通常是对象字段或属性位置。</p></li></ul><h2 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a><code>Converter</code></h2><p><code>Converter</code>是具体的某类转换器接口，负责将某个类型的对象转成另外一个类型的对象。并且是一个函数式接口。</p><p>就提供了一个转换方法：</p><ul><li><code>T convert(S source)</code>：转换对象类型。</li></ul><h2 id="ConverterFactory"><a href="#ConverterFactory" class="headerlink" title="ConverterFactory"></a><code>ConverterFactory</code></h2><p>生产一种<code>Converter</code>，这种<code>Converter</code>可以将对象从<code>S</code>转换为<code>R</code>的子类型。也就是说支持多态功能。<br>实现类还可以实现<code>ConditionalConverter</code>接口。</p><ul><li><code>&lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType)</code>：根据目标类型<code>T</code>获取<code>Converter</code>，该<code>Converter</code>将源类型<code>S</code>转换成<code>R</code>的子类型<code>T</code>。</li></ul><h2 id="ConditionalConverter"><a href="#ConditionalConverter" class="headerlink" title="ConditionalConverter"></a><code>ConditionalConverter</code></h2><p>该接口可以根据源和目标<code>TypeDescriptor</code>的属性选择性地执行<code>Converter</code>、<code>GenericConverter</code>或<code>ConverterFactory</code>。</p><p>通常用于根据字段或类特征(如注解或方法)的存在选择性地匹配自定义转换逻辑。例如，当从<code>String</code>字段转换为<code>Date</code>字段时，如果目标字段还有<code>@DateTimeFormat</code>注解，则实现类<code>matches</code>方法可能返回<code>true</code>，也就是说如果目标字段上没有<code>@DateTimeFormat</code>注解，那么可能不会应用该转换，该接口可以控制需不需要转换。</p><p>另外一个例子，当从字符串字段转换为<code>Account</code>字段时，如果目标<code>Account</code>类定义了公共静态<code>findAccount(String)</code>方法，则实现类<code>matches</code>方法可能返回<code>true</code>。</p><ul><li><code>boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType)</code>：是否需要转换。</li></ul><h2 id="GenericConverter"><a href="#GenericConverter" class="headerlink" title="GenericConverter"></a><code>GenericConverter</code></h2><p>这是最灵活的转换器SPI接口，也是最复杂的。它的灵活性在于<code>GenericConverter</code>可以支持多个源/目标类型对之间的转换(参见<code>getConvertibleTypes()</code>方法)。此外，<code>GenericConverter</code>实现类在类型转换过程中可以访问源/目标字段上下文，允许解析源和目标字段元数据，如注解和泛型信息，这些信息可用于复杂转换逻辑。</p><p>当比较简单的<code>Converter</code>或<code>ConverterFactory</code>接口够用时，通常不应使用此接口。<br>实现类还可以实现<code>ConditionalConverter</code>接口。</p><ul><li>Set<ConvertiblePair> getConvertibleTypes()：返回此<code>Converter</code>可以在源类型和目标类型之间转换的类型。<br>Set中每条都是一个可转换的源到目标类型对。<code>ConvertiblePair</code>保存源类型与目标类型的映射关系。<br>对于<code>ConditionalConverter</code>，此方法可能返回<code>null</code>，意味着该<code>GenericConverter</code>适用于所有源与目标类型对。未实现<code>ConditionalConverter</code>接口的实现类，此方法不能返回<code>null</code>。</ConvertiblePair></li></ul><h2 id="ConverterRegistry"><a href="#ConverterRegistry" class="headerlink" title="ConverterRegistry"></a><code>ConverterRegistry</code></h2><p>用来注册<code>Converter</code>。</p><h2 id="ConversionService组件结构"><a href="#ConversionService组件结构" class="headerlink" title="ConversionService组件结构"></a><code>ConversionService</code>组件结构</h2><p><img src="/post/504e/ConversionService%E7%BB%93%E6%9E%84.png" alt="ConversionService结构"></p><p><code>ConversionService</code>提供转换功能的统一入口，<code>ConverterRegistry</code>提供<code>Converter</code>注册功能，将<code>Converter</code>集中起来，转换时从中查出对应的<code>Converter</code>。<code>Converter</code>负责具体的转换过程。<code>ConfigurableConversionService</code>继承自<code>ConversionService</code>和<code>ConverterRegistry</code>，集成转换和注册功能。</p><p>下面看一下具体的实现类。</p><h2 id="GenericConversionService类"><a href="#GenericConversionService类" class="headerlink" title="GenericConversionService类"></a><code>GenericConversionService</code>类</h2><p>基础转换服务实现，适用于大部分情况。直接实现<code>ConfigurableConversionService</code>接口，实现了注册与转换功能。在注册<code>Converter</code>、<code>ConverterFactory</code>时，会将其转换成<code>GenericConverter</code>。</p><h2 id="DefaultConversionService类"><a href="#DefaultConversionService类" class="headerlink" title="DefaultConversionService类"></a><code>DefaultConversionService</code>类</h2><p>继承自<code>GenericConversionService</code>，配置了适合大多数环境的<code>Converter</code>。<br>该类使用时可以直接实例化，暴露出静态方法<code>addDefaultConverters(ConverterRegistry)</code>，用于对某个<code>ConverterRegistry</code>实例进行特殊处理，也就是说当某个<code>ConverterRegistry</code>需要增加一个默认的<code>Converter</code>时，可以调用这个方法。</p><p>这里我们可以直接使用<code>DefaultConversionService</code>类，Spring已经配置了一些<code>Converter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">student = <span class="keyword">new</span> Student();</span><br><span class="line">wrapper = <span class="keyword">new</span> BeanWrapperImpl(student);</span><br><span class="line">wrapper.setAutoGrowNestedPaths(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//注册ConversionService</span></span><br><span class="line">wrapper.setConversionService(<span class="keyword">new</span> DefaultConversionService());</span><br><span class="line">wrapper.setPropertyValue(<span class="string">&quot;classRoom.size&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ConversionService, 设置嵌套对象的属性 size：&quot;</span> + wrapper.getPropertyValue(<span class="string">&quot;classRoom.size&quot;</span>));</span><br><span class="line"><span class="comment">//这里将字符串转换成数字</span></span><br></pre></td></tr></table></figure><h2 id="Spring-提供的Converter"><a href="#Spring-提供的Converter" class="headerlink" title="Spring 提供的Converter"></a>Spring 提供的<code>Converter</code></h2><p>在Spring 的<code>org.springframework.core.convert.support</code>包中内置了一些转换器，提供数组、集合、字符串、数字、枚举、对象、Map、Boolean等之间的转换功能。</p><table><thead><tr><th></th><th>Array</th><th>Collection</th><th>Stream</th><th>ByteBuffer</th><th>String(Character)</th><th>Number(Integer)</th><th>Object</th><th>Enum</th><th>Map</th><th>Boolean</th><th>Charset</th><th>Currency</th><th>Locale</th><th>Properties</th><th>TimeZone</th><th>UUID</th><th>Calendar</th></tr></thead><tbody><tr><td>Array</td><td><code>ArrayToArrayConverter</code></td><td><code>ArrayToCollectionConverter</code></td><td><code>StreamConverter</code></td><td><code>ByteBufferConverter</code></td><td><code>ArrayToStringConverter</code></td><td></td><td><code>ArrayToObjectConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Collection</td><td><code>CollectionToArrayConverter</code></td><td><code>CollectionToCollectionConverter</code></td><td><code>StreamConverter</code></td><td></td><td><code>CollectionToStringConverter</code></td><td></td><td><code>CollectionToObjectConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Stream</td><td><code>StreamConverter</code></td><td><code>StreamConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>String(Character)</td><td><code>StringToArrayConverter</code></td><td><code>StringToCollectionConverter</code></td><td></td><td></td><td><code>StringToCharacterConverter</code></td><td><code>StringToNumberConverterFactory</code></td><td></td><td><code>StringToEnumConverterFactory</code></td><td></td><td><code>StringToBooleanConverter</code></td><td><code>StringToCharsetConverter</code></td><td><code>StringToCurrencyConverter</code></td><td><code>StringToLocaleConverter</code></td><td><code>StringToPropertiesConverter</code></td><td><code>StringToTimeZoneConverter</code></td><td><code>StringToUUIDConverter</code></td><td></td></tr><tr><td>ByteBuffer</td><td><code>ByteBufferConverter</code></td><td></td><td></td><td></td><td></td><td></td><td><code>ByteBufferConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Number(Integer)</td><td></td><td></td><td></td><td></td><td><code>NumberToCharacterConverter</code></td><td><code>NumberToNumberConverterFactory</code></td><td></td><td><code>IntegerToEnumConverterFactory</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Object</td><td><code>ObjectToArrayConverter</code></td><td><code>ObjectToCollectionConverter</code></td><td></td><td><code>ByteBufferConverter</code></td><td><code>ObjectToStringConverter</code></td><td></td><td><code>ObjectToObjectConverter</code>,<code>IdToEntityConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Enum</td><td></td><td></td><td></td><td></td><td><code>EnumToStringConverter</code></td><td><code>EnumToIntegerConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Map</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><code>MapToMapConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Boolean</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Properties</td><td></td><td></td><td></td><td></td><td><code>PropertiesToStringConverter</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ZoneId</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><code>ZoneIdToTimeZoneConverter</code></td><td></td><td></td></tr><tr><td>ZonedDateTime</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><code>ZonedDateTimeToCalendarConverter</code></td></tr></tbody></table><h3 id="StringToBooleanConverter"><a href="#StringToBooleanConverter" class="headerlink" title="StringToBooleanConverter"></a><code>StringToBooleanConverter</code></h3><p>将<code>String</code>转换成<code>Boolean</code>。<code>true</code>、<code>on、yes、1</code> 转换成<code>Boolean.TRUE</code>。<code>false、off</code> 、no<code> 、</code>0 <code>转换成</code>Boolean.FALSE`。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wrapper.setPropertyValue(<span class="string">&quot;good&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ConversionService, 设置bool值。 good：&quot;</span> + wrapper.getPropertyValue(<span class="string">&quot;good&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//ConversionService, 设置bool值。 good：true</span></span><br></pre></td></tr></table></figure><h2 id="自定义Converter"><a href="#自定义Converter" class="headerlink" title="自定义Converter"></a>自定义<code>Converter</code></h2><p>当Spring提供的转换器无法满足我们需要时，我们可以自定义转换逻辑。</p><p>上面提到的<code>Converter</code>、<code>GenericConverter</code>和<code>ConverterFactory</code>三个接口都可以用来实现转换逻辑。该如何选择？</p><ul><li><p><code>Converter</code>：单值。从<code>S</code>-&gt;<code>T</code>。一对一转换。</p></li><li><p><code>ConverterFactory</code>：从<code>S</code> -&gt; <code>T extends R</code>。一对多转换。 </p></li><li><p><code>GenericConverter</code> ：功能最复杂。实现多个类型对的转换。多对多转换。</p></li></ul><p>在自定义<code>PropertyEditor</code>示例中，我们实现了从<code>String</code>转换到<code>ClassRoom</code>的功能。在这里通过<code>Converter</code>来实现此功能。</p><ol><li><p><code>StringToClassRoomConverter实现</code>String<code>转换到</code>ClassRoom`的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToClassRoomConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">ClassRoom</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassRoom <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        String[] strings = Optional.ofNullable(source).orElseGet(String::<span class="keyword">new</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        ClassRoom classRoom = <span class="keyword">new</span> ClassRoom();</span><br><span class="line">        classRoom.setName(strings[<span class="number">0</span>]);</span><br><span class="line">        classRoom.setSize(Integer.parseInt(strings[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> classRoom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将此<code>StringToClassRoomConverter</code>注册到我们使用的<code>ConversionService</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DefaultConversionService conversionService = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line">conversionService.addConverter(<span class="keyword">new</span> StringToClassRoomConverter());</span><br><span class="line">wrapper.setConversionService(conversionService);</span><br></pre></td></tr></table></figure></li><li><p><code>BeanWrapper</code>使用此<code>ConversionService</code>设置Bean属性。这里不一定用<code>BeanWrapper</code> 来操作，可以直接调用<code>ConversionService</code>来转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wrapper.setPropertyValue(<span class="string">&quot;classRoom&quot;</span>, <span class="string">&quot;room4,4&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;自定义Converter, 设置嵌套对象的属性 name：&quot;</span> + wrapper.getPropertyValue(<span class="string">&quot;classRoom.name&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;自定义Converter, 设置嵌套对象的属性 size：&quot;</span> + wrapper.getPropertyValue(<span class="string">&quot;classRoom.size&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------</span></span><br><span class="line"><span class="comment">//自定义Converter, 设置嵌套对象的属性 name：room4</span></span><br><span class="line"><span class="comment">//自定义Converter, 设置嵌套对象的属性 size：4</span></span><br></pre></td></tr></table></figure><p>从输出结果来看，已经成功转换成功。</p></li></ol><p>当我们想从一个类型转换成某些类型时，可以实现<code>ConverterFactory</code>接口，因为我们也不知道总共有哪些类型，不可能每个类型都写一个<code>ConverterFactory</code>。比如说从<code>String</code>转换成枚举类型，前端传枚举类型的字面值，转换成具体的枚举类型。Spring 内置了<code>StringToEnumConverterFactory</code>来实现此功能。直接调用Enum的静态方法<code>Enum.valueOf(this.enumType, source.trim())</code>来实现转换。同理还有<code>IntegerToEnumConverterFactory</code>通过枚举的序号来转换。</p><p>当我们遇到容器型的转换需求时，因为容器内部保存的类型可能是多种多样的，比如说List里面既有String，也有int，我们要统一转成Long型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DefaultConversionService conversionService = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line">List source = <span class="keyword">new</span> ArrayList();</span><br><span class="line">source.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">source.add(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//这里要注意初始化成内部类，才能正确获取泛型，不然不会转换。因为这个例子中，如果不写成内部类，源类型和目标类型其实是一致的，CollectionToCollectionConverter（这个转换器支持集合之间的转换） 内部不会去做转换。</span></span><br><span class="line">List&lt;Long&gt; longList = <span class="keyword">new</span> ArrayList&lt;&gt;()&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (Object s : source) &#123;</span><br><span class="line">    System.out.println(s.getClass() + <span class="string">&quot; , &quot;</span> + s);</span><br><span class="line">&#125;</span><br><span class="line">List convert = conversionService.convert(source, longList.getClass());</span><br><span class="line"><span class="keyword">for</span> (Object s : convert) &#123;</span><br><span class="line">    System.out.println(s.getClass() + <span class="string">&quot; , &quot;</span> + s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------</span></span><br><span class="line"><span class="comment">//不是内部类，不转换</span></span><br><span class="line"><span class="comment">//class java.lang.String , 1</span></span><br><span class="line"><span class="comment">//class java.lang.Integer , 2</span></span><br><span class="line"><span class="comment">//class java.lang.String , 1</span></span><br><span class="line"><span class="comment">//class java.lang.Integer , 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------</span></span><br><span class="line"><span class="comment">//正确转换</span></span><br><span class="line"><span class="comment">//class java.lang.String , 1</span></span><br><span class="line"><span class="comment">//class java.lang.Integer , 2</span></span><br><span class="line"><span class="comment">//class java.lang.Long , 1</span></span><br><span class="line"><span class="comment">//class java.lang.Long , 2</span></span><br></pre></td></tr></table></figure><p>如果有多个<code>Converter</code>可以处理同一个转换需求，那么则看注意的先后顺序了，会取第一个符合条件的转换器。这里可以优化一下。</p><h2 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a><code>Formatter</code></h2><p>在前后端交互时，通常会遇到日期格式这样的问题，<code>Converter</code>虽然说也能解决这个问题，在转换时获取到正确的格式然后进行转换。但是这样无法灵活控制我们的格式，我们得把所有格式都写在我们的<code>Converter</code>里，换一种格式，又得改一次这个类。这时候<code>Formatter</code>接口出现了。</p><p><code>Formatter</code>接口位于<code>context</code>包中。</p><p>先看一下<code>Formatter</code>类，从<code>Parser</code>和<code>Printer</code>接口继承而来，实现了<code>String</code> &lt;-&gt; <code>Object</code>转换的功能。</p><p><img src="/post/504e/Formatter%E7%BB%93%E6%9E%84.png" alt="Formatter结构"></p><h2 id="FormatterRegistry"><a href="#FormatterRegistry" class="headerlink" title="FormatterRegistry"></a><code>FormatterRegistry</code></h2><p>继承自<code>ConverterRegistry</code>接口，用来注册<code>Formatter</code>。</p><ul><li><p><code>void addFormatter(Formatter&lt;?&gt; formatter)</code>：向特定类型的字段添加<code>Formatter</code>。字段类型由<code>Formatter</code>的泛型提供。</p></li><li><p><code>void addFormatterForFieldType(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter)</code>：向给定类型的字段添加<code>Formatter</code>。</p><p>在打印时，如果声明了<code>Formatter</code>的类型<code>T</code>，并且不能将<code>fieldType</code>赋值给<code>T</code>，则在打印字段值的任务委托给<code>Formatter</code>之前，将尝试强制转换为<code>T</code>。在解析时，如果<code>Formatter</code>返回的已解析对象不能分配给运行时字段类型，则在返回已解析字段值之前，将尝试强制转换为<code>fieldType</code>。例如，<code>DateFormatter</code>声明的泛型为<code>Date</code>，如果这里的<code>fieldType</code>为<code>DateTime</code>（假设存在），如果<code>DateTime</code>可以用<code>Date</code>变量接收，则意味着可以分配给<code>Date</code>，也就不需要转换。否则则需要转换为<code>Date</code>类型。具体能否分配，可以查看该方法：<code>org.springframework.core.convert.TypeDescriptor#isAssignableTo</code>。</p></li><li><p><code>void addFormatterForFieldType(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser)</code>：添加<code>Printer</code>/<code>Parser</code>对来格式化特定类型的字段，formatter 将委托给指定的<code>Printer</code>进行打印，并委托指定的<code>Parser</code>进行解析。</p><p>在打印时，如果声明了<code>Printer</code>的类型<code>T</code>，并且<code>fieldType</code>不能赋值给<code>T</code>，则在委托<code>Printer</code>打印字段值之前，将尝试转换化类型<code>T</code>。在解析时，如果<code>Parser</code>返回的对象不能分配给<code>fieldType</code>，则在返回解析后的字段值之前，将尝试转换为<code>fieldType</code>。这个方法与上一个方法的区别就是将<code>Formatter</code>拆开。</p></li><li><p><code>void addFormatterForFieldAnnotation(AnnotationFormatterFactory&lt;? extends Annotation&gt; annotationFormatterFactory)</code>：为格式化注解标注的字段添加<code>Formatter</code>。此方法与上述方法的区别是不再以类型作为转换的依据了，而是根据注解来转换。比如某个字段上使用了<code>DateTimeFormat</code>注解，那会调用对应的<code>Formatter</code>。</p></li></ul><h2 id="FormattingConversionService"><a href="#FormattingConversionService" class="headerlink" title="FormattingConversionService"></a><code>FormattingConversionService</code></h2><p><code>FormattingConversionService</code>类是Spring提供的支持<code>Formatter</code>接口的实现类，继承自<code>GenericConversionService</code>类，实现了<code>FormatterRegistry</code>和<code>EmbeddedValueResolverAware</code>接口，在<code>GenericConversionService</code>类的基础上增加了注册<code>Formatter</code>的功能。<code>EmbeddedValueResolverAware</code>接口用来解决字符串占位符、国际化等问题。注册<code>Formatter</code>时，会将<code>Formatter</code>转换成<code>GenericConverter</code>，调用此<code>GenericConverter</code>的<code>convert</code>方法时，将会调用<code>Formatter</code>的<code>print</code>或<code>parse</code>方法，由此可以看出我们需要格式化时，还是调用<code>FormattingConversionService</code>的<code>convert</code>方法即可。</p><h2 id="DefaultFormattingConversionService"><a href="#DefaultFormattingConversionService" class="headerlink" title="DefaultFormattingConversionService"></a><code>DefaultFormattingConversionService</code></h2><p>Spring 内部提供了一些<code>Formatter</code>，会通过<code>DefaultFormattingConversionService</code>注册，我们无不特殊要求，可以直接使用此类，再在此基础上注册我们自定义的<code>Formatter</code>。</p><h3 id="Spring提供的Formatter"><a href="#Spring提供的Formatter" class="headerlink" title="Spring提供的Formatter"></a>Spring提供的<code>Formatter</code></h3><table><thead><tr><th><code>Formatter</code>或<code>FormatterRegistrar</code></th><th><code>DefaultFormattingConversionService</code>是否注册</th><th>说明</th></tr></thead><tbody><tr><td><code>NumberFormatAnnotationFormatterFactory</code></td><td>Y</td><td>用于支持<code>@NumberFormat</code>注解</td></tr><tr><td><code>CurrencyUnitFormatter</code></td><td>JSR-354相关的jar包出现在classpath时注册</td><td><code>javax.money.CurrencyUnit</code></td></tr><tr><td><code>MonetaryAmountFormatter</code></td><td>JSR-354相关的jar包出现在classpath时注册</td><td><code>javax.money.MonetaryAmount</code></td></tr><tr><td><code>Jsr354NumberFormatAnnotationFormatterFactory</code></td><td>JSR-354相关的jar包出现在classpath时注册</td><td><code>@NumberFormat</code>注解</td></tr><tr><td><code>DateTimeFormatterRegistrar</code></td><td></td><td>用来注册<code>JSR-310</code>新版日期和时间相关</td></tr><tr><td><code>JodaTimeFormatterRegistrar</code></td><td></td><td>如果使用了<code>Joda</code>包，则会注册相关的``</td></tr><tr><td><code>DateFormatterRegistrar</code></td><td></td><td>注册<code>@DateTimeFormat</code>注解的<code>AnnotationFormatterFactory</code>用于<code>Date</code>，<code>Calendar</code>，<code>Long</code>之间格式化以及<code>Date</code>，<code>Calendar</code>，<code>Long</code>之间的转换的<code>Converter</code>。默认不会注册用于直接转换的<code>DateFormatter</code>，不需要<code>@DateTimeFormat</code>注解，我们可以手动注册。</td></tr></tbody></table><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><ol><li>以日期为例，如果不用注解的话，我们需要手动注册一下<code>Formatter</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService();</span><br><span class="line">conversionService.addFormatter(<span class="keyword">new</span> DateFormatter());</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(conversionService.convert(date, String.class));</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------</span></span><br><span class="line"><span class="comment">// 2019年9月3日</span></span><br></pre></td></tr></table></figure><p><code>DateFormatter</code>还支持指定格式。可以通过构造函数传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conversionService.addFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"><span class="comment">// 2019-09-03</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>还是以日期为例，使用Spring提供的<code>@DateTimeFormat</code>注解。</p><p>先创建一个类，里面有个日期字段使用<code>@DateTimeFormat</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Question</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br></pre></td></tr></table></figure><p>指定格式为<code>yyyy-MM-dd</code>，这里我们借助<code>BeanWrapper</code>来触发格式化的动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService();</span><br><span class="line"></span><br><span class="line">Question question = <span class="keyword">new</span> Question();</span><br><span class="line">BeanWrapper beanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(question);</span><br><span class="line">beanWrapper.setConversionService(conversionService);</span><br><span class="line">beanWrapper.setPropertyValue(<span class="string">&quot;createTime&quot;</span>, <span class="string">&quot;2019-09-03&quot;</span>);</span><br><span class="line">System.out.println(question.getCreateTime());</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------</span></span><br><span class="line"><span class="comment">// Tue Sep 03 00:00:00 CST 2019</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间格式化 字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;注解格式化日期：&quot;</span> + conversionService.convert(question.getCreateTime(), <span class="keyword">new</span> TypeDescriptor(question.getClass().getDeclaredField(<span class="string">&quot;createTime&quot;</span>)), TypeDescriptor.valueOf(String.class)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------</span></span><br><span class="line"><span class="comment">//注解格式化日期：2019-09-03</span></span><br></pre></td></tr></table></figure><p>通过打印的信息，可以看到已经成功将字符串<code>parse</code>为<code>Date</code>，并将日期<code>format</code>为字符串。由于注解在字段上，我们只提供了<code>Date</code>的值，所以还需要通过<code>TypeDescriptor</code>将字段的附加信息传递进去，这样才能正确识别到字段上的注解。</p></li></ol><h2 id="自定义Formatter"><a href="#自定义Formatter" class="headerlink" title="自定义Formatter"></a>自定义<code>Formatter</code></h2><p>除了Spring 给我们提供的这些<code>Formatter</code>之外，我们还可以自定义来实现特殊功能。</p><p>比如前台传过来一段字符串，我们根据正则表达式截取部分字符。</p><h3 id="定义StringFormat注解"><a href="#定义StringFormat注解" class="headerlink" title="定义StringFormat注解"></a>定义<code>StringFormat</code>注解</h3><p>此注解用来标注该字段需要用我们的自定义逻辑。可以指定具体的正则表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> StringFormat &#123;</span><br><span class="line">    <span class="function">String <span class="title">pattern</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义StringFormatAnnotationFormatterFactory"><a href="#定义StringFormatAnnotationFormatterFactory" class="headerlink" title="定义StringFormatAnnotationFormatterFactory"></a>定义<code>StringFormatAnnotationFormatterFactory</code></h3><p>此类实现<code>AnnotationFormatterFactory</code>接口，规定<code>StringFormat</code>注解支持的字段类型。我们使用正则分隔字符串，那么可能得到多个目标串，所以<code>getFieldTypes</code>返回<code>List</code>来接收目标类型。<code>getParser</code>方法返回我们的自定义<code>StringFormatFormatter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The types of fields that may be annotated with the &amp;lt;A&amp;gt; annotation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getFieldTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> Set.of(List.class, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the Printer to print the value of a field of &#123;<span class="doctag">@code</span> fieldType&#125; annotated with</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> annotation&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the type T the printer accepts is not assignable to &#123;<span class="doctag">@code</span> fieldType&#125;, a</span></span><br><span class="line"><span class="comment">     * coercion from &#123;<span class="doctag">@code</span> fieldType&#125; to T will be attempted before the Printer is invoked.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotation the annotation instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldType  the type of field that was annotated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the printer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Printer&lt;?&gt; getPrinter(StringFormat annotation, Class&lt;?&gt; fieldType) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringFormatFormatter(annotation.pattern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the Parser to parse a submitted value for a field of &#123;<span class="doctag">@code</span> fieldType&#125;</span></span><br><span class="line"><span class="comment">     * annotated with &#123;<span class="doctag">@code</span> annotation&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the object the parser returns is not assignable to &#123;<span class="doctag">@code</span> fieldType&#125;,</span></span><br><span class="line"><span class="comment">     * a coercion to &#123;<span class="doctag">@code</span> fieldType&#125; will be attempted before the field is set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotation the annotation instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldType  the type of field that was annotated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the parser</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Parser&lt;?&gt; getParser(StringFormat annotation, Class&lt;?&gt; fieldType) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringFormatFormatter(annotation.pattern());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="自定义-StringFormatFormatter"><a href="#自定义-StringFormatFormatter" class="headerlink" title="自定义 StringFormatFormatter"></a>自定义 <code>StringFormatFormatter</code></h3><p>该类实现<code>Formatter</code>。用来负责具体的解析逻辑。该类需要使用到注解中定义的正则表达式，这样我们就可以灵活控制每个字段的转换规则了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StringFormatFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span>&lt;<span class="title">Collection</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Pattern pattern;</span><br><span class="line">         StringFormatFormatter(String pattern) &#123;</span><br><span class="line">            <span class="keyword">this</span>.pattern = Pattern.compile(pattern);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Parse a text String to produce a T.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> text   the text string</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> locale the current user locale</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> an instance of T</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> ParseException           when a parse exception occurs in a java.text parsing library</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalArgumentException when a parse exception occurs</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection <span class="title">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Matcher matcher = pattern.matcher(text);</span><br><span class="line">            <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">                list.add(matcher.group());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>将我们的<code>Formatter</code>注册到<code>FormattingConversionService</code>，遇到对应的转换，则会调用我们的<code>Formatter</code>。下面的例子中<code>StringFormatEntity</code>类使用到了自定义的<code>StringFormat</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@StringFormat(pattern = &quot;\\d+&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; formats;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFormatterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">//注册 StringFormatAnnotationFormatterFactory </span></span><br><span class="line">        DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService();</span><br><span class="line">        conversionService.addFormatterForFieldAnnotation(<span class="keyword">new</span> StringFormatAnnotationFormatterFactory());</span><br><span class="line">        StringFormatEntity formatEntity = <span class="keyword">new</span> StringFormatEntity();</span><br><span class="line">        System.out.println(<span class="string">&quot;自定义注解格式化：&quot;</span> + conversionService.convert(<span class="string">&quot;fff43ffd344&quot;</span>, TypeDescriptor.valueOf(String.class) , <span class="keyword">new</span> TypeDescriptor(formatEntity.getClass().getDeclaredField(<span class="string">&quot;formats&quot;</span>))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义注解格式化：[43, 344]</span></span><br></pre></td></tr></table></figure><p>从打印出来的结果可以看出来已经正确将字符串转换成了<code>List</code>。不过<code>List</code>中都是字符串，我们还可以将字符串转换成数字类型。需要我们来主动转换吗？其实是不需要的，Spring 已经帮我们考虑到了此种情景，可以自动将<code>List</code>中的元素也转换成对应的类型。还记得<code>CollectionToCollectionConverter</code>这个转换器吗？不过有个细节要注意：**我们的<code>Formatter</code>返回的结果不能是<code>ArrayList</code>， 这样会丢失泛型，不能正确转换，所以我们可以返回<code>ArrayList</code>的子类<code>List&lt;String&gt; list = new ArrayList&lt;&gt;()&#123;&#125;;</code>， 这样会保留泛型，会调用后续的<code>Converter</code>**。</p><h2 id="Converter-的注册与获取"><a href="#Converter-的注册与获取" class="headerlink" title="Converter 的注册与获取"></a><code>Converter </code>的注册与获取</h2><p>主要通过<code>ConverterRegistry</code>和<code>FormatterRegistry</code>来注册以及移除<code>Converter</code>。</p><h3 id="ConverterRegistry-1"><a href="#ConverterRegistry-1" class="headerlink" title="ConverterRegistry"></a><code>ConverterRegistry</code></h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ol><li><p><code>void addConverter(Converter&lt;?, ?&gt; converter)</code>：注册简单的<code>Converter</code>，转换类型从<code>Converter</code>的泛型中获取。</p></li><li><p><code>&lt;S, T&gt; void addConverter(Class&lt;S&gt; sourceType, Class&lt;T&gt; targetType, Converter&lt;? super S, ? extends T&gt; converter)</code>： 注册普通转换器，并且明确指定可转换类型。</p><p>可以针对多个不同转换类型的情况重用<code>Converter</code>，而不必为每个对创建<code>Converter</code>类。指定的源类型是<code>Converter</code>定义的类型的子类型，目标类型是<code>Converter</code>定义的类型的父类型。为什么要如此定义？拿Spring提供的<code>ObjectToStringConverter</code>为例，该<code>Converter</code>定义的转换类型为<code>Object</code> -&gt; <code>String</code>，调用<code>Object.toString()</code>方法，只要是<code>Object</code>的子类，都可以调用此方法转换成<code>String</code>，因为<code>toString()</code>是共有的方法。同理，目标类型指定的类型需要是我定义的父类型，这样转换出来的一定是需要的类型。</p></li><li><p><code>void addConverter(GenericConverter converter)</code>：注册<code>GenericConverter </code>。</p></li><li><p><code>void addConverterFactory(ConverterFactory&lt;?, ?&gt; factory)</code>：注册<code>ConverterFactory</code>。</p></li><li><p><code>void removeConvertible(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</code>：移除<code>sourceType</code>到<code>targetType</code>的转换功能。</p></li></ol><h3 id="GenericConversionService"><a href="#GenericConversionService" class="headerlink" title="GenericConversionService"></a><code>GenericConversionService</code></h3><p><code>GenericConversionService</code>类实现了<code>ConverterRegistry</code>接口。现在看一下具体的注册过程。</p><ol><li><p><code>void addConverter(Converter&lt;?, ?&gt; converter)</code>：</p><p>因为没有指定转换类型，所以只能从<code>Converter</code>的泛型中获取转换类型，如果获取不到，则会抛出异常。获取到之后，则会创建<code>ConverterAdapter</code>实例，通过<code>void addConverter(GenericConverter converter)</code>方法进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ResolvableType[] typeInfo = getRequiredTypeInfo(converter.getClass(), Converter.class);</span><br><span class="line"><span class="comment">//如果是代理对象，还需要从代理类中获取</span></span><br><span class="line"><span class="keyword">if</span> (typeInfo == <span class="keyword">null</span> &amp;&amp; converter <span class="keyword">instanceof</span> DecoratingProxy) &#123;</span><br><span class="line">    typeInfo = getRequiredTypeInfo(((DecoratingProxy) converter).getDecoratedClass(), Converter.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (typeInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to determine source type &lt;S&gt; and target type &lt;T&gt; for your &quot;</span> + <span class="string">&quot;Converter [&quot;</span> + converter.getClass().getName() + <span class="string">&quot;]; does the class parameterize those types?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">addConverter(<span class="keyword">new</span> ConverterAdapter(converter, typeInfo[<span class="number">0</span>], typeInfo[<span class="number">1</span>]));</span><br></pre></td></tr></table></figure></li><li><p><code>&lt;S, T&gt; void addConverter(Class&lt;S&gt; sourceType, Class&lt;T&gt; targetType, Converter&lt;? super S, ? extends T&gt; converter)</code>：</p><p>由于指定了转换类型，直接注册就完事了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addConverter(<span class="keyword">new</span> ConverterAdapter(converter, ResolvableType.forClass(sourceType), ResolvableType.forClass(targetType)));</span><br></pre></td></tr></table></figure></li><li><p><code>void addConverterFactory(ConverterFactory&lt;?, ?&gt; factory)</code>：</p><p>也是先从泛型中推断出转换的类型，然后创建<code>ConverterFactoryAdapter</code>实例进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ResolvableType[] typeInfo = getRequiredTypeInfo(factory.getClass(), ConverterFactory.class);</span><br><span class="line"><span class="keyword">if</span> (typeInfo == <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> DecoratingProxy) &#123;</span><br><span class="line">    typeInfo = getRequiredTypeInfo(((DecoratingProxy) factory).getDecoratedClass(), ConverterFactory.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (typeInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to determine source type &lt;S&gt; and target type &lt;T&gt; for your &quot;</span> + <span class="string">&quot;ConverterFactory [&quot;</span> + factory.getClass().getName() + <span class="string">&quot;]; does the class parameterize those types?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">addConverter(<span class="keyword">new</span> ConverterFactoryAdapter(factory,  <span class="keyword">new</span> ConvertiblePair(typeInfo[<span class="number">0</span>].toClass(), typeInfo[<span class="number">1</span>].toClass())));</span><br></pre></td></tr></table></figure></li><li><p><code>void addConverter(GenericConverter converter)</code>：</p><p>上面几种注册方式最终都会调用此方法，也就是说会将<code>Converter</code>、<code>ConverterFactory</code>转换成<code>GenericConverter </code>。这里使用到了<code>适配器模式</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加到内部容器中去</span></span><br><span class="line"><span class="keyword">this</span>.converters.add(converter);</span><br><span class="line"><span class="comment">//使缓存失效</span></span><br><span class="line">invalidateCache();</span><br></pre></td></tr></table></figure></li></ol><h3 id="ConverterAdapter适配器"><a href="#ConverterAdapter适配器" class="headerlink" title="ConverterAdapter适配器"></a><code>ConverterAdapter</code>适配器</h3><p>实现了<code>ConditionalGenericConverter</code>接口，将<code>Converter</code>转换成<code>GenericConverter</code>。在<code>matches</code>方法去判断转换类型是否匹配。转换时直接调用内部转换器的转换方法。</p><h3 id="ConverterFactoryAdapter适配器"><a href="#ConverterFactoryAdapter适配器" class="headerlink" title="ConverterFactoryAdapter适配器"></a><code>ConverterFactoryAdapter</code>适配器</h3><p>实现了<code>ConditionalGenericConverter</code>接口，将<code>ConverterFactoryAdapter</code>转换成<code>GenericConverter</code>。在<code>matches</code>方法去判断转换类型是否匹配。转换时直接调用内部<code>ConverterFactory</code>获取的转换器的转换方法。</p><h3 id="ConvertiblePair"><a href="#ConvertiblePair" class="headerlink" title="ConvertiblePair"></a><code>ConvertiblePair</code></h3><p>该类保存了转换的源类型和目标类型，并重写了<code>equals</code>和<code>hashCode</code>方法用于比较。<code>GenericConverter</code>返回<code>ConvertiblePair</code>集合表示所支持的转换类型。</p><h3 id="Converters"><a href="#Converters" class="headerlink" title="Converters"></a><code>Converters</code></h3><p>此类用来管理所有注册的<code>Converter</code>。提供添加和删除的功能。添加时获取到此<code>Converter</code>支持的类型，如果为空并且是<code>ConditionalConverter</code>，则代表它支持所有类型。得到支持的类型后，遍历每个类型，获取到已经注册的<code>ConvertersForPair</code>，该类维护转换类型到<code>Converter</code>之间的关系，而且是一对多的关系，也就是说同一种转换类型，会存在多个<code>Converter</code>。拿到<code>ConvertersForPair</code>后，将该<code>Converter</code>添加进去，后添加的会在前面，获取时符合条件时会优先返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(GenericConverter converter)</span> </span>&#123;</span><br><span class="line">    Set&lt;ConvertiblePair&gt; convertibleTypes = converter.getConvertibleTypes();</span><br><span class="line">    <span class="keyword">if</span> (convertibleTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Assert.state(converter <span class="keyword">instanceof</span> ConditionalConverter,</span><br><span class="line">                     <span class="string">&quot;Only conditional converters may return null convertible types&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.globalConverters.add(converter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ConvertiblePair convertiblePair : convertibleTypes) &#123;</span><br><span class="line">            ConvertersForPair convertersForPair = getMatchableConverters(convertiblePair);</span><br><span class="line">            <span class="comment">//后添加的在前面</span></span><br><span class="line">            convertersForPair.add(converter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FormatterRegistry注册-Formatter"><a href="#FormatterRegistry注册-Formatter" class="headerlink" title="FormatterRegistry注册    Formatter"></a><code>FormatterRegistry</code>注册<code>    Formatter</code></h3><p>继承自<code>ConverterRegistry</code>接口，增加了注册<code>Formmater</code>的方法。</p><h3 id="FormattingConversionService-1"><a href="#FormattingConversionService-1" class="headerlink" title="FormattingConversionService"></a><code>FormattingConversionService</code></h3><p>该类继承自<code>GenericConversionService</code>类，并实现了<code>FormatterRegistry</code>接口。在添加<code>Formatter</code>时会将其转换为<code>PrinterConverter</code>，<code>ParserConverter</code>。在添加<code>AnnotationFormatterFactory</code>转换为<code>AnnotationPrinterConverter</code>和<code>AnnotationParserConverter</code>。可以想象到这四个类也是实现了<code>Converter</code>，最终通过<code>convert</code>方法来调用<code>parse</code>和<code>print</code>方法。</p><h3 id="获取Converter"><a href="#获取Converter" class="headerlink" title="获取Converter"></a>获取<code>Converter</code></h3><p>在<code>GenericConversionService</code>的转换过程中，来了一个转换类型，需要获取到对应的<code>Converter</code>。在<code>Converters</code>的<code>find</code>方法中先拿到源类型和目标类型继承的所有类型（包括接口），比如说源类型是<code>String</code>，那么获取到的就是<code>String</code>、<code>Serializable</code>、<code>Comparable</code>、<code>CharSequence</code>和<code>Object</code>，如果是枚举还将获取到<code>Enum</code>。找到之后一一进行组合去获取<code>Converter</code>，比如目标类型是<code>Integer</code>，则第一次组合就是<code>String</code>-&gt;<code>Integer</code>，如果找到了支持<code>String</code>-&gt;<code>Integer</code>的<code>Converter</code>，则会返回这个。这么做的目的是支持一个<code>Converter</code>可以转换多个类型，比如<code>String</code>-&gt; <code>Enum</code>，通过字面量转换成枚举，如果没有这个机制，那么我们就得为每个枚举都定义一个<code>Converter</code>，但是有了这个机制，我们就可以支持所有的枚举类型。其实就是通过这个机制来支持<code>ConverterFactory</code>。这个机制可以保证子类可以通过父类转换器进行转换（这种转换方式需要注意父类无法感知子类的特殊属性），但不能保证父类可以通过子类转换器，如果可以保证<code>Converter</code>能正确转换，则可以通过<code>&lt;S, T&gt; void addConverter(Class&lt;S&gt; sourceType, Class&lt;T&gt; targetType, Converter&lt;? super S, ? extends T&gt; converter)</code>方法显式进行注册。比如我们只有<code>String</code>-&gt;<code>Integer</code>的<code>Converter</code>，但是我们需要将<code>String</code>转换为<code>Number</code>，则可以通过这个方法注册<code>addConverter(String.class, Number.class, StringToIntegerConverter)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DefaultConversionService conversionService = <span class="keyword">new</span> DefaultConversionService();</span><br><span class="line"><span class="comment">//先去掉内置的转换器</span></span><br><span class="line">conversionService.removeConvertible(String.class, Number.class);</span><br><span class="line"><span class="comment">//再注册上我们自己定义的 String -&gt; Integer</span></span><br><span class="line">conversionService.addConverter(<span class="keyword">new</span> StringToIntegerConverter());</span><br><span class="line">System.out.println(conversionService.convert(<span class="string">&quot;1&quot;</span>, Number.class));</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种情况下是无法正确转换的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是通过这个方法显式注册之后可以正确转换</span></span><br><span class="line">conversionService.addConverter(String.class, Number.class, <span class="keyword">new</span> StringToIntegerConverter());</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>下面是查找的大致过程：</p><p><img src="/post/504e/%E6%9F%A5%E6%89%BEconverter.png" alt="查找converter的图示"></p><h1 id="DirectFieldAccessor"><a href="#DirectFieldAccessor" class="headerlink" title="DirectFieldAccessor"></a><code>DirectFieldAccessor</code></h1><p>通过反射直接访问Bean实例的字段。可以直接绑定到字段，而不需要通过JavaBean set方法。</p><p>从Spring 4.2开始，绝大多数<code>BeanWrapper</code>特性已经被合并到<code>AbstractPropertyAccessor</code>中，这意味着这个类也支持属性遍历以及集合和Map 访问。</p><p><code>DirectFieldAccessor</code>的<code>extractOldValueForEditor</code>属性默认为<code>true</code>，因为在读取字段的时候是直接通过反射去拿到的字段值，不需要调用<code>getter</code>方法。</p><h1 id="PropertyAccessorFactory"><a href="#PropertyAccessorFactory" class="headerlink" title="PropertyAccessorFactory"></a><code>PropertyAccessorFactory</code></h1><p>可以通过此类来获取<code>BeanWrapper</code>和<code>DirectFieldAccessor</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BeanWrapper&quot;&gt;&lt;a href=&quot;#BeanWrapper&quot; class=&quot;headerlink&quot; title=&quot;BeanWrapper&quot;&gt;&lt;/a&gt;BeanWrapper&lt;/h1&gt;&lt;h2 id=&quot;BeanWrapper是什么&quot;&gt;&lt;a href=&quot;#Bea
      
    
    </summary>
    
    
      <category term="BeanWrapper" scheme="http://qzztf.com/tags/BeanWrapper/"/>
    
      <category term="Converter" scheme="http://qzztf.com/tags/Converter/"/>
    
      <category term="Formatter" scheme="http://qzztf.com/tags/Formatter/"/>
    
      <category term="ConversionService" scheme="http://qzztf.com/tags/ConversionService/"/>
    
      <category term="类型转换" scheme="http://qzztf.com/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Bean初始化</title>
    <link href="http://qzztf.com/post/72a3/"/>
    <id>http://qzztf.com/post/72a3/</id>
    <published>2019-08-21T08:32:23.000Z</published>
    <updated>2024-06-16T07:25:26.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bean初始化过程"><a href="#Bean初始化过程" class="headerlink" title="Bean初始化过程"></a>Bean初始化过程</h1><p>如果说配置文件好比菜谱，解析配置文件好比洗菜、切菜，那么Bean初始化过程就好比炒菜的过程。Spring的核心基础就建立在对Bean的管理功能上。如何定义一个Bean，如何获取一个Bean，如何初始化一个Bean，如何销毁一个Bean。</p><h2 id="getBean方法-–-炒菜开始的信号"><a href="#getBean方法-–-炒菜开始的信号" class="headerlink" title="getBean方法 – 炒菜开始的信号"></a><code>getBean</code>方法 – 炒菜开始的信号</h2><p>想象一下<code>getBean</code>的场景，好比是食客点了一道菜（或者说菜单是由食客提供的，厨房代加工），厨房根据菜单做菜。想象一下在这个过程中需要做哪些工作？</p><ol><li>按照菜谱准备菜 – 解析配置文件</li><li>洗菜，切菜 - - 注册Bean定义</li><li>炒菜 – Bean 初始化</li><li>添加额外的佐料 – 动态注册Bean定义</li></ol><p>第1，2步可以看成是同时进行的，边准备菜，边洗菜切菜也就是边解析边注册。<code>getBean</code> 方法由<code>BeanFactory</code>接口提供。</p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a><code>BeanFactory</code></h2><p><code>BeanFactory</code>接口是整个Spring容器的核心接口。提供了多个获取 Bean 的方法。</p><ul><li>Object getBean(String name) throws BeansException;</li><li><T> T getBean(String name, Class<T> requiredType) throws BeansException;</T></T></li><li>Object getBean(String name, Object… args) throws BeansException;</li><li><T> T getBean(Class<T> requiredType) throws BeansException;</T></T></li><li><T> T getBean(Class<T> requiredType, Object… args) throws BeansException;</T></T></li><li><T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);</T></T></T></li><li><T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType);</T></T></li></ul><p>前三个是通过Bean的名字来获取，后面的是通过Bean的Class类型来获取。</p><h3 id="通过名称获取Bean"><a href="#通过名称获取Bean" class="headerlink" title="通过名称获取Bean"></a>通过名称获取Bean</h3><p>在Spring容器中，Bean的名字(id )是唯一的。</p><ol><li><p>先处理名称，获取真正的Bean的名称。</p><ol><li><p>如果 name 以 <code>&amp;</code>开头，去掉<code>&amp;</code>。</p></li><li><p>处理别名。参数有可能是别名，得跟据别名找到实际注册的 Bean 名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先看一下别名的结构</span></span><br><span class="line"><span class="comment">// aliasA ---&gt;  name</span></span><br><span class="line"><span class="comment">// aliasB ---&gt; name</span></span><br><span class="line"><span class="comment">// name ---&gt; realName</span></span><br><span class="line"><span class="comment">//name 也可以作为别名来注册，但是不能存在 name 和 alias正好相反的一对注册情况。也就是 alias --&gt; anme, name ---&gt; alias这样成对的出现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">canonicalName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">String canonicalName = name;</span><br><span class="line"><span class="comment">// Handle aliasing...</span></span><br><span class="line">String resolvedName;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 把参数当作别名来取出name, 如果能取到，说明当前参数是别名。将取到的值当作别名，继续取，如果不能取到值，那么这个就是真正的bean的名字了;如果还能取到，那么这个也是别名，重复这个过程，直到不能取到值为止。</span></span><br><span class="line">            resolvedName = <span class="keyword">this</span>.aliasMap.get(canonicalName);</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> (resolvedName != <span class="keyword">null</span>) &#123;</span><br><span class="line">canonicalName = resolvedName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (resolvedName != <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">return</span> canonicalName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>检查单例缓存中的单例。也就是说先看看有没有创建好的单例，有的就返回这个单例进一步处理。</p></li><li><p>没有在单例缓存中获取到Bean，那么就检查父容器中有没有这个Bean定义。当父容器中有这个Bean定义，并且当前容器中没有此Bean定义时，就从父容器中获取。如果父容器中没有，则从当前容器获取。</p></li><li><p>拿到Bean的定义，先对依赖Bean调用<code>getBean</code>方法。</p></li><li><p>如果Bean定义是单例<code>singleton</code>，则创建单例。如果是原型<code>prototype</code>，则创建Bean。如果是其他的scope作用域，则调用scope的<code>get</code>方法。这里可以看出，我们可以自已定义<code>scope</code>来扩展Spring提供的几种<code>scope</code>。具体的创建Bean的过程都会调用<code>createBean</code>方法。</p></li><li><p>拿到实例对象之后，如果获取时传了类型，那么将使用<code>TypeConverter</code>进行类型转换，如果转换成功，则返回这个Bean，否则将抛出异常。</p></li></ol><h3 id="通过Class-类型获取Bean"><a href="#通过Class-类型获取Bean" class="headerlink" title="通过Class 类型获取Bean"></a>通过Class 类型获取Bean</h3><p>在Spring中Bean的名称才是唯一的标识，所以根据类型获取Bean，会先获取到所有该类型的Bean 的名称。</p><ol><li>获取符合类型的Bean名称。如果有泛型的话，调用<code>doGetBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit)</code>方法；没有泛型则调用<code>getBeanNamesForType(@Nullable Class&lt;?&gt; type, boolean includeNonSingletons, boolean allowEagerInit)</code>方法。找到一个那就恭喜了。</li><li>如果获取的Bean名称多于1个，则需要根据优先权选择出一个名称，然后再跟据这个名称去获取Bean。</li></ol><h3 id="Bean-实例化"><a href="#Bean-实例化" class="headerlink" title="Bean 实例化"></a>Bean 实例化</h3><p>Bean的创建以及实例化</p><p>作为一个可扩展的框架，Spring在Bean实例化的过程中预留了大量的扩展点用于对框架进行扩展。包括修改Bean定义，获取对象类型，实例化之前，实例化的方式，实例化之后，初始化之前，初始化，初始化之后等方面。具体在<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</code>方法中实现。</p><p>参数： </p><ul><li><code>String beanName</code>: Bean的名称。</li><li><code>RootBeanDefinition mbd</code>: Bean定义。就像菜谱。</li><li><code>Object[] args</code>: 获取Bean时的参数</li></ul><p>大致过程如下：</p><ol><li><p>调用<code>InstantiationAwareBeanPostProcessor</code>接口方法。此接口继承自<code>BeanPostProcessor</code>，在实例化前和实例化后显式属性设置或自动装配发生之前调用。<br>通常用于禁止特定目标bean的默认实例化，例如创建具有特殊目标源的代理对象(池化目标、延迟初始化目标等)，或者实现额外的注入策略，如字段注入。注意: 此接口是一个专用接口，主要用于框架内部使用。建议尽可能实现简单的<code>BeanPostProcessor</code>接口，或者继承<code>InstantiationAwareBeanPostProcessorAdapter</code>，以便屏蔽对该接口的扩展。</p><ul><li><p><code>postProcessBeforeInstantiation</code> : 在实例化目标bean之前调用。默认实现返回null。返回的bean对象可以代替目标bean用作代理，从而有效地阻止了目标bean的默认实例化。<br>如果此方法返回非空对象，则bean创建过程将短路，不会再调用其他<code>InstantiationAwareBeanPostProcessor</code>的<code>postProcessBeforeInstantiation</code> 方法。进一步调用<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization</code>方法， 如果某个<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization</code>方法返回了<code>null</code>，则将返回上一个不为<code>null</code>的对象。<br>此方法仅应用于具有bean类的bean定义。尤其是不会应用于带有工厂方法的bean。后处理器可以实现<code>SmartInstantiationAwareBeanPostProcessor</code>接口，以便预测它们将在这里返回的bean对象的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">                <span class="comment">//任意一个返回了非null对象，将导致后续的不会执行</span></span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>postProcessAfterInitialization</code>: 当<code>postProcessBeforeInstantiation</code> 方法返回了非<code>null</code>对象时，则会调用此方法做进一步的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">Object result = existingBean;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">            <span class="comment">//如果当前postProcessAfterInitialization方法返回的为null,则直接返回上一个的结果</span></span><br><span class="line"><span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//否则继续调用下一个处理器</span></span><br><span class="line">result = current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果第1步中得到的Bean不为空，则直接会使用这个Bean，不会再调用后续的初始化过程。正如第一步中所说，<code>InstantiationAwareBeanPostProcessor</code>接口主要创建目标Bean的代理对象等。</p></li><li><p>如果第1步中得到的Bean为空，则走常规初始化过程。先创建Bean实例：</p><ol><li><p>从Spring 5.0开始加了<code>Supplier</code>方式来创建Bean。</p></li><li><p>工厂方法，可以是静态工厂，也可以是工厂Bean。找到对应的工厂方法过程有点儿复杂，主要是方法名和参数匹配。</p></li><li><p>从<code>SmartInstantiationAwareBeanPostProcessor</code>接口和Bean定义配置中的优先构造函数。再从获取到的构造函数中选出一个调用。</p></li><li><p>调用默认构造函数</p></li></ol></li><li><p>Bean已经创建出来了，接下来就是初始化这个Bean。先调用后处理器<code>MergedBeanDefinitionPostProcessor</code>接口的<code>postProcessMergedBeanDefinition</code>方法处理Bean定义。此接口用于在运行时对合并的bean定义（原始bean定义的已处理副本）进行后处理。</p><p>例如，<code>postProcessMergedBeanDefinition</code>方法可以内省bean定义，以便实际在对bean实例进行后的处理操作之前准备一些缓存的元数据，并且这个接口还允许修改bean定义。</p></li><li><p>提前暴露Bean，用于解决循环依赖问题，这个时候的Bean基本是个空的Bean。关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br></pre></td></tr></table></figure><p>先将Bean添加到一个Map中，后面取依赖Bean的时候会先检查这个Map。</p></li><li><p>真正初始化的过程。包括<code>InstantiationAwareBeanPostProcessor</code>接口<code>postProcessBeforeInitialization</code>方法，属性填充，Aware接口，<code>BeanPostProcessor</code>接口<code>postProcessBeforeInitialization</code>方法，<code>InitializingBean</code>的<code>afterPropertiesSet</code>方法，自定义init方法调用，调用<code>BeanPostProcessor</code>接口<code>postProcessAfterInitialization</code>方法。</p></li><li><p>注册<code>DisposableBean</code>， 当Bean销毁时回调。</p></li></ol><p>可以看一下下面的流程图，对实例化过程有个大概的了解。</p><p><img src="/post/72a3/Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="Bean实例化过程"></p><h3 id="初始化过程中的扩展点"><a href="#初始化过程中的扩展点" class="headerlink" title="初始化过程中的扩展点"></a>初始化过程中的扩展点</h3><p>这里只区分实例化和初始化两个阶段。可以看一下图：</p><p><img src="/post/72a3/Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%BB%84%E4%BB%B6%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4.png" alt="Bean实例化过程中组件作用范围"></p><h4 id="实例化之前"><a href="#实例化之前" class="headerlink" title="实例化之前"></a>实例化之前</h4><p>在实例化之前<code>InstantiationAwareBeanPostProcessor</code>有机会去阻拦常规的初始化流程，可以创建我们的代理对象。主要涉及到<code>Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)</code>和<code>Object postProcessAfterInitialization(Object bean, String beanName)</code>方法。这里<code>Object postProcessAfterInitialization(Object bean, String beanName)</code>方法实际上是<code>BeanPostProcessor</code>接口的方法，主要用在Bean初始化后做一些自定义操作。<strong>这个方法其实应该归到初始化之后阶段</strong>。</p><p>如果上面返回的是<code>null</code>，那么则走常规实例化流程。需要的话可以从<code>SmartInstantiationAwareBeanPostProcessor</code>接口的<code>Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName)</code>方法中返回构造方法。</p><h4 id="实例化之后"><a href="#实例化之后" class="headerlink" title="实例化之后"></a>实例化之后</h4><p>通过<code>MergedBeanDefinitionPostProcessor</code>接口<code>postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</code>方法获得修改Bean定义的机会，也可以通过这个方法缓存一些数据，辅助后面的初始化过程。</p><h4 id="初始化之前"><a href="#初始化之前" class="headerlink" title="初始化之前"></a>初始化之前</h4><p>通过<code>InstantiationAwareBeanPostProcessor</code>接口boolean postProcessAfterInstantiation(Object bean, String beanName)方法可以阻止(<code>return false</code>)接下来的属性设置过程。通过该接口<code>PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)</code>方法处理需要设置的属性。</p><p><code>TypeConverter</code> 接口进行属性值的类型转换。XML中配置的属性值是字符串形式的，需要转换成对应的属性类型。</p><p>调用<code>BeanNameAware</code>、<code>BeanClassLoaderAware</code>、<code>BeanFactoryAware</code>的设置方法。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>可以将上面的属性设置、Aware接口归到初始化阶段里。</p><p>调用<code>BeanPostProcessor</code>的<code>Object postProcessBeforeInitialization(Object bean, String beanName)</code>方法。</p><p>如果Bean实现了<code>InitializingBean</code>接口，则会调用<code>afterPropertiesSet</code>方法。或者调用自定义的初始化方法。</p><p>调用<code>BeanPostProcessor</code>接口的<code>Object postProcessAfterInitialization(Object bean, String beanName)</code>方法。</p><h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><p>如果Bean注册了销毁方法，则会注册为<code>DisposableBean</code>，当Bean销毁时会调用此方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bean初始化过程&quot;&gt;&lt;a href=&quot;#Bean初始化过程&quot; class=&quot;headerlink&quot; title=&quot;Bean初始化过程&quot;&gt;&lt;/a&gt;Bean初始化过程&lt;/h1&gt;&lt;p&gt;如果说配置文件好比菜谱，解析配置文件好比洗菜、切菜，那么Bean初始化过程就好比炒菜
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://qzztf.com/tags/Spring/"/>
    
      <category term="Bean" scheme="http://qzztf.com/tags/Bean/"/>
    
      <category term="初始化" scheme="http://qzztf.com/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>错误: 未报告的异常错误X; 必须对其进行捕获或声明以便抛出</title>
    <link href="http://qzztf.com/post/e88/"/>
    <id>http://qzztf.com/post/e88/</id>
    <published>2019-06-03T09:49:05.000Z</published>
    <updated>2024-06-16T07:25:26.161Z</updated>
    
    <content type="html"><![CDATA[<p>今天在jdk8环境中碰到一个诡异的异常：</p><blockquote><p>错误: 未报告的异常错误X; 必须对其进行捕获或声明以便抛出</p></blockquote><p>jdk8方便是方便，但是有点儿不好排查问题。看提示应该是有个方法抛出了异常，只能按方法去排查了。最后在<code>java.util.Optional#orElseThrow</code>方法中找到了疑似代码。<br><code>java.util.Optional#orElseThrow</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;X extends Throwable&gt; <span class="function">T <span class="title">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法参数为异常产生器，X是<code>Throwable</code>的子类。</p><p>我的原始写法是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.orElseThrow(() -&gt; &#123;<span class="keyword">throw</span> <span class="keyword">new</span> MaterialException(<span class="string">&quot;&quot;</span>);&#125;)</span><br></pre></td></tr></table></figure><p>本地<code>jdk1.8_111</code>版本可以正常编绎，但是在服务器<code>jdk1.8_152</code>、<code>jdk1.8_65</code>上编绎出现上述异常。<br>尝试换了几种写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.orElseThrow(() -&gt; &#123;<span class="keyword">return</span> <span class="keyword">new</span> MaterialException(<span class="string">&quot;&quot;</span>);&#125;)</span><br><span class="line">.orElseThrow(MaterialException::<span class="keyword">new</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按说上面几种写法语法上是差不多的，都出现异常。</p><p>最后在<a href="https://stackoverflow.com/questions/25523375/java8-lambdas-and-exceptions">stackoverflow</a>上找到了一些信息。这应该是jdk的一个bug，解决方案是在加上异常限定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&lt;MaterialException&gt;orElseThrow(() -&gt; &#123;<span class="keyword">return</span> <span class="keyword">new</span> MaterialException(<span class="string">&quot;&quot;</span>);&#125;)</span><br></pre></td></tr></table></figure><p>IDEA会提示此限定是不必要的。<em>其他版本未做测试。</em> 希望后期这个bug能修复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在jdk8环境中碰到一个诡异的异常：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;错误: 未报告的异常错误X; 必须对其进行捕获或声明以便抛出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;jdk8方便是方便，但是有点儿不好排查问题。看提示应该是有个方法抛出了异常，只能按方法去
      
    
    </summary>
    
    
      <category term="异常" scheme="http://qzztf.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Spring bean定义文件解析</title>
    <link href="http://qzztf.com/post/172b/"/>
    <id>http://qzztf.com/post/172b/</id>
    <published>2019-05-13T06:36:27.000Z</published>
    <updated>2024-06-16T07:25:26.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bean-定义文件的解析"><a href="#Bean-定义文件的解析" class="headerlink" title="Bean 定义文件的解析"></a>Bean 定义文件的解析</h1><h2 id="初始化工厂"><a href="#初始化工厂" class="headerlink" title="初始化工厂"></a>初始化工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化一个bean 工厂</span></span><br><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"><span class="comment">// 2. 初始化XmlBeanDefinitionReader,负责从xml文件中读取bean定义</span></span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line"><span class="comment">// 3. 加载bean 定义的入口方法</span></span><br><span class="line">reader.loadBeanDefinitions(<span class="string">&quot;classpath:app.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>上述代码使用起来很简单，创建一个工厂和阅读器，传入配置文件的位置。</p><p>我们可以考虑一下，这些代码做了什么。</p><ol><li>XmlBeanDefinitionReader 是如何定位配置文件的?</li><li>如何解析配置文件的？</li><li>XmlBeanDefinitionReader的构造函数传入了一个BeanDefinitionRegistry对象，这个对象是用来注册bean定义的，那么是如何注册的呢？</li></ol><h2 id="ResourceLoader-定位资源文件"><a href="#ResourceLoader-定位资源文件" class="headerlink" title="ResourceLoader 定位资源文件"></a>ResourceLoader 定位资源文件</h2><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>Spring将各种资源统一抽象为<code>Resource</code>,并使用<code>ResourceLoader</code>来定位<code>Resource</code>。如果资源以物理形式存在，那么它可以为每个资源打开一个InputStream，但是URL或文件句柄只能由某些特定资源返回。实际的行为取决于实现类。</p><h4 id="Resource的结构"><a href="#Resource的结构" class="headerlink" title="Resource的结构"></a><code>Resource</code>的结构</h4><p>下面是Resource的类关系图</p><p><img src="/post/172b/resource%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="resource类关系图"></p><p>下面是Resource的类结构图</p><p><img src="/post/172b/resource%E7%BB%93%E6%9E%84.png" alt="resource结构"></p><p><code>Resource</code>继承自<code>InputStreamSource</code>, 得到了获取<code>InputStream</code>的能力，可以以流的形式读取资源文件。</p><p>定义的方法：</p><ul><li>boolean exists()：确定此资源是实际物理存在。此方法执行确定的存在性检查，而资源句柄的存在仅保证有效的描述符句柄。</li><li>boolean isReadable()：指示是否可以通过<code>getInputStream()</code>读取此资源的非空内容。对于存在的典型资源描述符会返回<code>true</code>，因为从5.1开始它严格地暗示了<code>exist()</code>语义。请注意，在尝试读取实际内容时仍然可能失败。但是，如果返回值为<code>false</code>，则表示资源内容无法读取。</li><li>boolean isOpen(): 指示此资源是否表示具有打开流的句柄。如果为<code>true</code>，则不能多次读取InputStream，必须读取并关闭该资源，以避免资源泄漏。对于典型的资源描述符将为false。</li><li>boolean isFile()：确定此资源是否表示文件系统中的文件。返回<code>true</code>标志着(但不保证)<code>getFile()</code>将调用成功。<br>这在默认情况下返回<code>false</code>.</li><li>URL getURL(): 返回此资源的URL句柄。</li><li>URI getURI(): 返回此资源的URI句柄。</li><li>File getFile(): 返回此资源的文件句柄。如果资源不能被解析为绝对文件路径，也就是说，如果资源在文件系统中不可用将抛出<code>FileNotFoundException</code>异常。</li><li>ReadableByteChannel readableChannel()：返回一个<code>ReadableByteChannel</code>。希望每次调用都创建一个新的通道。<br>默认实现返回<code>Channels.newChannel(getInputStream())</code>。</li><li>long contentLength()：确定此资源的内容长度。</li><li>long lastModified()：确定此资源最后修改的时间戳。</li><li>Resource createRelative(String relativePath)：创建与此资源相对路径的资源。</li><li>String getFilename()：确定此资源的文件名，通常是路径的最后一部分:例如，“myfile.txt”。如果此类资源没有文件名，则返回<code>null</code>。</li><li>String getDescription(): 返回此资源的描述，用于处理该资源时的错误输出。实现类可以从它们的<code>toString</code>方法返回这个值。</li></ul><h4 id="Resource-的子接口"><a href="#Resource-的子接口" class="headerlink" title="Resource 的子接口"></a>Resource 的子接口</h4><h5 id="ContextResource"><a href="#ContextResource" class="headerlink" title="ContextResource"></a>ContextResource</h5><p>用于从封闭的“上下文”(例如从<code>javax.servlet.ServletContext</code>)加载资源的扩展接口，也可以从普通类路径或相对于文件系统路径(没有显式指定前缀，因此应用于相对于本地<code>ResourceLoader</code>的上下文)。</p><p>定义的方法：</p><ul><li>String getPathWithinContext()：返回包含在“上下文”中的路径。通常是相对于上下文特定的根目录的路径，例如<code>ServletContext</code>根目录或<code>PortletContext</code>根目录。</li></ul><h5 id="WritableResource"><a href="#WritableResource" class="headerlink" title="WritableResource"></a>WritableResource</h5><p>支持对资源进行写入的扩展接口。该接口提供一个<code>OutputStream</code>访问器。</p><p>定义的方法：</p><ul><li>boolean isWritable()：指示是否可以通过<code>getOutputStream()</code>向此资源写入内容。适用于典型的资源描述符;注意，实际在尝试写入时仍然可能失败。但是，如果值为false，则表示资源内容不能修改</li><li>OutputStream getOutputStream()：返回底层资源的<code>OutputStream</code>，允许(过度)写入其内容.</li><li>WritableByteChannel writableChannel(): 返回一个<code>WritableByteChannel</code>。希望每个调用都创建一个新的通道。默认实现返回<code>Channels.newChannel(getOutputStream())</code>。</li></ul><h5 id="HttpResource"><a href="#HttpResource" class="headerlink" title="HttpResource"></a>HttpResource</h5><p>将资源写入HTTP响应的扩展接口</p><p>定义的方法：</p><ul><li>HttpHeaders getResponseHeaders(): 服务于当前资源的HTTP响应头。</li></ul><h4 id="常用的Resource实现类"><a href="#常用的Resource实现类" class="headerlink" title="常用的Resource实现类"></a>常用的<code>Resource</code>实现类</h4><h5 id="ClassPathResource"><a href="#ClassPathResource" class="headerlink" title="ClassPathResource"></a>ClassPathResource</h5><p>类路径资源的实现类。使用给定的类加载器或给定的类来加载资源。如果类路径资源驻留在文件系统中，而不是JAR中的资源，则支持<code>java.io.File</code>方式来加载。该类始终支持URL方式来加载。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;app.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件：&quot;</span> + resource.getFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URI：&quot;</span> + resource.getURI());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line">Resource resourceRelative = resource.createRelative(<span class="string">&quot;relative.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;相对路径资源：&quot;</span> + resourceRelative);</span><br><span class="line">System.out.println(<span class="string">&quot;相对路径资源是否存在：&quot;</span> + resourceRelative.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;相对路径资源文件：&quot;</span> + resourceRelative.getFile());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">资源文件是否存在：<span class="keyword">true</span></span><br><span class="line">资源文件是否是文件：<span class="keyword">true</span></span><br><span class="line">资源文件是否可读：<span class="keyword">true</span></span><br><span class="line">资源文件名称：app.xml</span><br><span class="line">资源文件：F:\spring-code-study\chapter3\target\classes\app.xml</span><br><span class="line">资源文件描述：class path resource [app.xml]</span><br><span class="line">资源文件URL：file:/F:/spring-code-study/chapter3/target/classes/app.xml</span><br><span class="line">资源文件URI：file:/F:/spring-code-study/chapter3/target/classes/app.xml</span><br><span class="line">资源文件长度：<span class="number">307</span></span><br><span class="line">资源文件最后修改时间：Mon Apr <span class="number">08</span> <span class="number">10</span>:<span class="number">40</span>:<span class="number">17</span> CST <span class="number">2019</span></span><br><span class="line">资源文件数据：&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line">相对路径资源：class path resource [relative.xml]</span><br><span class="line">相对路径资源是否存在：<span class="keyword">false</span></span><br><span class="line">Exception in thread &quot;main&quot; java.io.FileNotFoundException: class path resource [relative.xml] cannot be resolved to URL because it does not exist</span><br><span class="line">at org.springframework.core.io.ClassPathResource.getURL(ClassPathResource.java:<span class="number">195</span>)</span><br><span class="line">at org.springframework.core.io.AbstractFileResolvingResource.getFile(AbstractFileResolvingResource.java:<span class="number">150</span>)</span><br><span class="line">at cn.sexycode.spring.study.chapter3.ClassPathResourceDemo.main(ClassPathResourceDemo.java:<span class="number">30</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="FileSystemResource"><a href="#FileSystemResource" class="headerlink" title="FileSystemResource"></a>FileSystemResource</h5><p>处理<code>java.io.File</code>和<code>java.nio.file.Path</code>文件系统的资源实现。支持作为一个文件，也可以作为一个URL。扩展自<code>WritableResource</code>接口。</p><p><strong>注意:从Spring Framework 5.0开始，这个资源实现使用NIO.2 API进行读/写交互。从5.1开始，它可能使用一个<code>java.nio.file.Path</code>句柄实例化，在这种情况下，它将通过NIO.2执行所有文件系统交互，<br>只能通过<code>getFile()</code>来返回<code>File</code></strong></p><h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>加载资源的策略接口(例如类路径或文件系统资源)。<code>org.springframework.context.ApplicationContext</code>需要提供此功能，以及扩展<code>org.springframework.core.io.support.ResourcePatternResolver</code>支持。<br><code>DefaultResourceLoader</code>是一个独立的实现，可以在<code>ApplicationContext</code>之外使用，也可以由<code>ResourceEditor</code>使用。<br>当在<code>ApplicationContext</code>中使用时，可以使用特定上下文的资源加载策略从字符串填充Resource类型和Resource数组的Bean属性。</p><p>ResourceLoader提供的方法：</p><ul><li>Resource getResource(String location)：返回指定资源位置的资源句柄。<br>句柄应该始终是一个可重用的资源描述符，允许多次调用<code>Resource#getInputStream()</code>。<br>必须支持完全限定的url，例如。“file:C:/test.dat”。<br>必须支持类路径伪url，例如。“classpath:test.dat”。<br>应该支持相对文件路径，例如。“WEB-INF/test.dat”。(这是基于特定实现的，通常由<code>ApplicationContext</code>实现类提供。)</li></ul><p><strong>注意，资源句柄并不意味着资源实际存在;还是需要调用<code>Resource#exists</code>检查资源是否存在</strong></p><h4 id="ResourcePatternResolver子接口"><a href="#ResourcePatternResolver子接口" class="headerlink" title="ResourcePatternResolver子接口"></a><code>ResourcePatternResolver</code>子接口</h4><p>用于将位置模式(例如，ant样式的路径模式)解析为资源对象的策略接口。<br>这是ResourceLoader接口的扩展。可以检查传入的ResourceLoader(例如，当运行在上下文中时，通过<code>ResourceLoaderAware</code>传入的<code>ApplicationContext</code>)是否也实现了这个接口。<br><code>PathMatchingResourcePatternResolver</code>是一个独立的实现，可以在ApplicationContext之外使用，<code>ResourceArrayPropertyEditor</code>也使用它来填充bean的<code>Resource</code> 数组属性。<br>可以与任何类型的位置模式(例如<code>/WEB-INF/*-context.xml</code>):输入模式必须匹配策略实现。这个接口只指定转换方法，而不是特定的模式格式。<br>这个接口还为类路径中所有匹配的资源提供了一个新的资源前缀<code>classpath*:</code>。注意，在这种情况下，资源位置应该是一个没有占位符的路径(例如 <code>/beans.xml</code>);JAR文件或类目录可以包含多个同名文件</p><p>此接口提供的方法：</p><ul><li>Resource[] getResources(String locationPattern)：将给定的位置模式解析为资源对象。应该尽可能避免指向相同物理资源的重复资源项。结果应该具有set语义</li></ul><h4 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h4><h5 id="DefaultResourceLoader"><a href="#DefaultResourceLoader" class="headerlink" title="DefaultResourceLoader"></a>DefaultResourceLoader</h5><p><code>ResourceLoader</code>接口的默认实现。由<code>ResourceEditor</code>使用，并作为<code>org.springframework.context.support.AbstractApplicationContext</code>的基类。也可以单独使用。<br>如果位置值是URL，则返回UrlResource;如果非URL路径或“classpath:”伪URL，则返回ClassPathResource。</p><p>这里提到了URL, URL 是用来在互联网中描述一个资源位置的，主要包括协议，主机，路径等组成部分。</p><p>Spring 支持的URL:</p><ul><li>classpath: 表示classpath下的资源文件</li><li>file： 表示文件系统中的资源文件</li><li>jar： 表示jar包中的资源文件</li><li>war： 表示war包中的资源文件</li><li>zip：zip包中的资源文件</li><li>wsjar： WebSphere jar文件</li><li>vfszip：JBoss jar文件</li><li>vfsfile：JBoss 文件系统</li><li>vfs：通用的JBoss VFS 文件</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">DefaultResourceLoader resourceLoader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line"><span class="comment">//读取file文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------读取本地文件------------------&quot;</span> );</span><br><span class="line">Resource resource = resourceLoader.getResource(<span class="string">&quot;file:///F:\\spring-code-study\\chapter3\\target\\classes/app.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件是否可写：&quot; + ((FileSystemResource)resource).isWritable());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件：&quot;</span> + resource.getFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URI：&quot;</span> + resource.getURI());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取jar包中的文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------读取jar文件----------------------&quot;</span> );</span><br><span class="line">resource = resourceLoader.getResource(<span class="string">&quot;jar:file:///F:\\spring-code-study\\chapter3\\target\\chapter3-1.0-SNAPSHOT.jar!/app.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件是否可写：&quot; + ((FileSystemResource)resource).isWritable());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件：&quot; + resource.getFile());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件URI：&quot; + resource.getURI());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取网络文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------读取网络文件-----------------&quot;</span> );</span><br><span class="line">resource = resourceLoader.getResource(<span class="string">&quot;https://raw.githubusercontent.com/qzzsunly/spring-code-study/master/chapter3/src/main/resources/app.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件是否可写：&quot; + ((FileSystemResource)resource).isWritable());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件：&quot; + resource.getFile());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件URI：&quot; + resource.getURI());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取classpath下的文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------读取classpath文件-----------------&quot;</span> );</span><br><span class="line">resource = resourceLoader.getResource(<span class="string">&quot;classpath:app.xml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件是否可写：&quot; + ((FileSystemResource)resource).isWritable());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件：&quot; + resource.getFile());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件URI：&quot; + resource.getURI());</span></span><br><span class="line">System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------读取本地文件------------------</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：true</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app.xml</span><br><span class="line">资源文件：F:\spring-code-study\chapter3\target\classes\app.xml</span><br><span class="line">资源文件描述：URL [file:&#x2F;F:&#x2F;spring-code-study&#x2F;chapter3&#x2F;target&#x2F;classes&#x2F;app.xml]</span><br><span class="line">资源文件URL：file:&#x2F;F:&#x2F;spring-code-study&#x2F;chapter3&#x2F;target&#x2F;classes&#x2F;app.xml</span><br><span class="line">资源文件URI：file:&#x2F;F:&#x2F;spring-code-study&#x2F;chapter3&#x2F;target&#x2F;classes&#x2F;app.xml</span><br><span class="line">资源文件长度：307</span><br><span class="line">资源文件最后修改时间：Mon Apr 08 10:40:17 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line">------------------------------------读取jar文件----------------------</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：false</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app.xml</span><br><span class="line">资源文件描述：URL [jar:file:&#x2F;&#x2F;&#x2F;F:\spring-code-study\chapter3\target\chapter3-1.0-SNAPSHOT.jar!&#x2F;app.xml]</span><br><span class="line">资源文件URL：jar:file:&#x2F;&#x2F;&#x2F;F:\spring-code-study\chapter3\target\chapter3-1.0-SNAPSHOT.jar!&#x2F;app.xml</span><br><span class="line">资源文件长度：307</span><br><span class="line">资源文件最后修改时间：Wed Apr 10 09:05:03 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line">------------------------------------读取网络文件-----------------</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：false</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app.xml</span><br><span class="line">资源文件描述：URL [https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;qzzsunly&#x2F;spring-code-study&#x2F;master&#x2F;chapter3&#x2F;src&#x2F;main&#x2F;resources&#x2F;app.xml]</span><br><span class="line">资源文件URL：https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;qzzsunly&#x2F;spring-code-study&#x2F;master&#x2F;chapter3&#x2F;src&#x2F;main&#x2F;resources&#x2F;app.xml</span><br><span class="line">资源文件长度：302</span><br><span class="line">资源文件最后修改时间：Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">资源文件数据：&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line">------------------------------------读取classpath文件-----------------</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：true</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app.xml</span><br><span class="line">资源文件描述：class path resource [app.xml]</span><br><span class="line">资源文件URL：file:&#x2F;F:&#x2F;spring-code-study&#x2F;chapter3&#x2F;target&#x2F;classes&#x2F;app.xml</span><br><span class="line">资源文件长度：307</span><br><span class="line">资源文件最后修改时间：Mon Apr 08 10:40:17 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>从上面的例子中可以看到使用<code>ResourceLoader</code>和<code>Resource</code>接口，我们可以很方便的读取文件内容。</p><h5 id="PathMatchingResourcePatternResolver"><a href="#PathMatchingResourcePatternResolver" class="headerlink" title="PathMatchingResourcePatternResolver"></a>PathMatchingResourcePatternResolver</h5><p>此实现支持ant风格的通配符形式路径。在有多个文件的情况下，我们可以利用这个类来加载多个配置文件。</p><h6 id="在没有通配符的情况"><a href="#在没有通配符的情况" class="headerlink" title="在没有通配符的情况"></a>在没有通配符的情况</h6><p>如果指定的路径没有<code>classpath*:</code>前缀，将通过底层ResourceLoader的getResource()返回单个的资源。比如“file:C:/context”。“classpath:/context”这样的伪url，以及简单的无前缀路径，如“/WEB-INF/context.xml”，后者将基于底层ResourceLoader的方式解析(例如，用于WebApplicationContext的ServletContextResource)。</p><h6 id="Ant-风格的路径"><a href="#Ant-风格的路径" class="headerlink" title="Ant 风格的路径"></a>Ant 风格的路径</h6><p>当路径包含一个ant样式的模式时，例如:<code>/WEB-INF/*-context.xml</code>、<code>com/mycompany/**/applicationContext.xml</code>、<code>file:C:/some/path/*-context.xml</code>、<code>classpath:com/mycompany/**/applicationContext.xml</code>, 解析器遵循一个更复杂但是已定义好的算法来尝试解析通配符。它为最后一个非通配符部分的路径生成一个资源，并获取一个URL。如果该URL不是<code>jar:</code> URL或特定于容器的变体(例如WebLogic中的<code>zip:</code>，WebSphere中的<code>wsjar</code>等等)，那么将从它获取<code>java.io.File</code>，并通过遍历文件系统来解析通配符。对于jar URL，解析器要么从中获取java.net.JarURLConnection，要么手动解析jar URL，然后遍历jar文件的内容来以解析通配符</p><h6 id="可移植性影响"><a href="#可移植性影响" class="headerlink" title="可移植性影响"></a>可移植性影响</h6><p>如果指定的路径已经是文件URL(由于基本ResourceLoader是基于文件系统的，所以可以显式或隐式地使用)，那么通配符就可以方便移植。如果指定的路径是类路径，那么解析器必须通过调用<code>Classloader.getResource()</code>获得最后一个非通配符路径部分的URL。由于这只是路径的一个节点(而不是末尾的文件)，所以它实际上是未定义的(在ClassLoader 的文档中有提及)。实际上，它通常是一个表示目录的<code>java.io.File</code>，其中类路径资源解析为文件系统位置，或者是某种jar URL，其中类路径解析为jar所在位置。尽管如此，这个操作仍然存在可移植性问题。为了从最后一个非通配符部分获取jar URL，解析器必须能够从中获得<code>java.net.JarURLConnection</code>，或者手动解析jar URL，以便能够遍历jar的内容并解析通配符。这将在大多数环境中工作，但在其他环境中可能会失败，强烈建议在依赖jar之前，在你的特定环境中彻底测试jar包资源的通配符解析。</p><h6 id="classpath-前缀"><a href="#classpath-前缀" class="headerlink" title="classpath*:前缀"></a>classpath*:前缀</h6><p>支持通过<code>classpath*:</code>前缀检索同名的多个类路径资源。例如,<code>classpath*:META-INF/beans.xml</code>将找到classpath下所有的<code>beans.xml</code>文件，无论是在<code>classes</code>目录中还是在JAR文件中。这对于自动检测每个jar文件中的相同位置的相同名称的配置文件特别有用。在内部是通过<code>ClassLoader.getResources()</code>方法实现的，并且是完全可移植的。<code>classpath*:</code>前缀还可以结合<code>PathMatcher</code> 模式，例如<code>classpath*:META-INF/*-beans.xml</code>。在本例中，解析策略相当简单:在最后一个非通配符路径部分上调用<code>ClassLoader.getResources()</code>来获取类加载器层次结构中所有匹配的资源，然后在每个资源之外使用上面描述的相同路径匹配器解析策略来处理通配符子路径。</p><h6 id="另注"><a href="#另注" class="headerlink" title="另注"></a>另注</h6><p>警告: 注意，<code>classpath*:</code>与ant样式的模式结合使用时，根目录在文件系统中必须存在。这意味着像<code>classpath*:*.xml</code>这样的模式不会从jar文件的根中检索文件，而是只从扩展目录的根中检索。这源于JDK的<code>ClassLoader.getResources()</code>方法中的一个限制，该方法传入空字符串只返回文件系统位置(指示潜在的要搜索的根目录)。这个<code>ResourcePatternResolver</code>实现试图通过URLClassLoader自省和<code>java.class.path</code>清单来减轻jar根目录查找的限制;但是不保证可移植性。<br><strong>警告: 当<code>classpath:</code>搭配Ant风格时，如果在多个类路径位置都能搜索到根包，则不能保证资源能够找到匹配的资源。这是因为如<br><code>com/mycompany/package1/service-context.xml</code>这样的资源可能只在一个位置，但当尝试解析这样路径时:<code>com/mycompany/**/service-context.xml</code>,解析器在处理<code>getResource(com/mycompany”)</code>返回的(第一个)URL，如果此存在于多个类加载器时，则实际的想要的资源可能不在返回的类加载器中。因此，在这种情况下，最好使用具有相同ant样式模式的<code>classpath*:</code>，它将搜索包含根包的所有类路径。</strong></p><h6 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PathMatchingResourcePatternResolver resourceLoader = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line"><span class="comment">//读取file文件</span></span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------读取多个文件------------------&quot;</span>);</span><br><span class="line">Resource[] resources = resourceLoader.getResources(<span class="string">&quot;classpath:app*.xml&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件是否存在：&quot;</span> + resource.exists());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件是否是文件：&quot;</span> + resource.isFile());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件是否可读：&quot;</span> + resource.isReadable());</span><br><span class="line"><span class="comment">//        System.out.println(&quot;资源文件是否可写：&quot; + ((FileSystemResource)resource).isWritable());</span></span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件名称：&quot;</span> + resource.getFilename());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件：&quot;</span> + resource.getFile());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件描述：&quot;</span> + resource.getDescription());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件URL：&quot;</span> + resource.getURL());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件URI：&quot;</span> + resource.getURI());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件长度：&quot;</span> + resource.contentLength());</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件最后修改时间：&quot;</span> + <span class="keyword">new</span> Date(resource.lastModified()));</span><br><span class="line">    System.out.println(<span class="string">&quot;资源文件数据：&quot;</span> + <span class="keyword">new</span> String(resource.getInputStream().readAllBytes()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------读取多个文件------------------</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：true</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app0.xml</span><br><span class="line">资源文件：F:\spring-code-study\chapter3\target\classes\app0.xml</span><br><span class="line">资源文件描述：file [F:\spring-code-study\chapter3\target\classes\app0.xml]</span><br><span class="line">资源文件URL：file:/F:/spring-code-study/chapter3/target/classes/app0.xml</span><br><span class="line">资源文件URI：file:/F:/spring-code-study/chapter3/target/classes/app0.xml</span><br><span class="line">资源文件长度：331</span><br><span class="line">资源文件最后修改时间：Wed Apr 10 20:57:17 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--配置文件0--&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：true</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app1.xml</span><br><span class="line">资源文件：F:\spring-code-study\chapter3\target\classes\app1.xml</span><br><span class="line">资源文件描述：file [F:\spring-code-study\chapter3\target\classes\app1.xml]</span><br><span class="line">资源文件URL：file:/F:/spring-code-study/chapter3/target/classes/app1.xml</span><br><span class="line">资源文件URI：file:/F:/spring-code-study/chapter3/target/classes/app1.xml</span><br><span class="line">资源文件长度：331</span><br><span class="line">资源文件最后修改时间：Wed Apr 10 10:46:52 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--配置文件1--&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line">资源文件是否存在：true</span><br><span class="line">资源文件是否是文件：true</span><br><span class="line">资源文件是否可读：true</span><br><span class="line">资源文件名称：app2.xml</span><br><span class="line">资源文件：F:\spring-code-study\chapter3\target\classes\app2.xml</span><br><span class="line">资源文件描述：file [F:\spring-code-study\chapter3\target\classes\app2.xml]</span><br><span class="line">资源文件URL：file:/F:/spring-code-study/chapter3/target/classes/app2.xml</span><br><span class="line">资源文件URI：file:/F:/spring-code-study/chapter3/target/classes/app2.xml</span><br><span class="line">资源文件长度：331</span><br><span class="line">资源文件最后修改时间：Wed Apr 10 10:46:50 CST 2019</span><br><span class="line">资源文件数据：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--配置文件2--&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="BeanDefinitionReader-加载bean定义资源"><a href="#BeanDefinitionReader-加载bean定义资源" class="headerlink" title="BeanDefinitionReader 加载bean定义资源"></a>BeanDefinitionReader 加载bean定义资源</h2><p>通过<code>ResourceLoader</code> 定位资源文件之后，那么就该<code>BeanDefinitionReader</code>开始着手加载bean定义了。</p><p>定义的方法：</p><ul><li>int loadBeanDefinitions(Resource resource)：从单个资源中加载，返回发现的bean 定义数量</li><li>int loadBeanDefinitions(Resource… resources)：从多个资源中加载</li><li>int loadBeanDefinitions(String location)：从单个资源位置加载</li><li>int loadBeanDefinitions(String… locations)：从多个资源位置加载</li></ul><p>从方法定义中可以看出，<code>BeanDefinitionReader</code>提供了多个从各种资源中加载bean定义的功能。</p><h3 id="BeanDefinitionReader-实现类"><a href="#BeanDefinitionReader-实现类" class="headerlink" title="BeanDefinitionReader 实现类"></a>BeanDefinitionReader 实现类</h3><p>Spring 提供了三个实现类，用于从不同格式的资源文件中加载bean定义。</p><h4 id="PropertiesBeanDefinitionReader"><a href="#PropertiesBeanDefinitionReader" class="headerlink" title="PropertiesBeanDefinitionReader"></a>PropertiesBeanDefinitionReader</h4><p>该类用于从properties文件中加载bean定义。</p><h4 id="GroovyBeanDefinitionReader"><a href="#GroovyBeanDefinitionReader" class="headerlink" title="GroovyBeanDefinitionReader"></a>GroovyBeanDefinitionReader</h4><p>基于Groovy的 reader。<br>这个bean定义reader还可以读取XML bean定义文件，允许与Groovy bean定义文件无缝搭配。</p><h4 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a>XmlBeanDefinitionReader</h4><p>读取xml bean定义文件，将资源解析成xml w3c document, 内部委托给<code>BeanDefinitionDocumentReader</code>接口(具体实现类是<code>DefaultBeanDefinitionDocumentReader</code>)去加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line"><span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line"><span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line"><span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line"><span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line"><span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line"><span class="comment">//任何内部的 &lt;beans&gt; 标签，将会递归调用这个方法， 为了正确地传播和保存&lt;beans&gt; 的`default-`属性值，需要跟踪当前(父)委托，它有可能为空。</span></span><br><span class="line"><span class="comment">//因为子beans 需要继承父beans的一些默认属性，比如说default-lazy-init=&quot;default&quot;, </span></span><br><span class="line"><span class="comment">//创建新的(子)委托，并使用父委托的引用进行回退，然后最终将this.delegate重置为其原始(父)引用。这种行为模拟了一堆委托，实际上并不需要委托。</span></span><br><span class="line">BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line"><span class="comment">// 为当前根节点创建新的委托解析器</span></span><br><span class="line"><span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前标签是不是在默认命名空间中，默认命名空间代表&lt;benas&gt;标签所在的命名空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="comment">//当前&lt;beans&gt; 标签指定了profile属性，则跟当前环境中激活的profile进行比较，如果是未激活，则跳过当前&lt;beans&gt; 标签</span></span><br><span class="line">String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line"><span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line"><span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line"><span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preProcessXml(root);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析当前&lt;beans&gt;标签</span></span><br><span class="line">parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">postProcessXml(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanDefinitionParserDelegate 对象是用来具体解析每个元素的，为什么需要创建一个新的。可以</p><p>再看看parseBeanDefinitions方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果当前元素属于默认命名空间，这里其实就是指&lt;beans&gt;标签</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    NodeList nl = root.getChildNodes();</span><br><span class="line">    <span class="comment">//遍历子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                <span class="comment">//如果该标签属性默认命名空间，Uri为空，或者是 http://www.springframework.org/schema/beans</span></span><br><span class="line">                <span class="comment">// import标签</span></span><br><span class="line">                <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">                    <span class="comment">// 先处理路径中的点位符，如：$&#123;user.dir&#125;</span></span><br><span class="line">                    <span class="comment">// 判断引入的资源是否绝对路径(classpath:, classpath*:, url资源)，再调用reader的loadBeanDefinitions 方法</span></span><br><span class="line">                    <span class="comment">// 相对路径则使用 当前的资源创建相对路径资源（getReaderContext().getResource().createRelative(location)）</span></span><br><span class="line">                    <span class="comment">//再调用reader的loadBeanDefinitions 方法</span></span><br><span class="line">                    importBeanDefinitionResource(ele);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//alias 标签</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">                    <span class="comment">//调用org.springframework.core.AliasRegistry.registerAlias 方法注册别名</span></span><br><span class="line">                    processAliasRegistration(ele);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// bean 标签</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">                    processBeanDefinition(ele, delegate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 内部 beans 标签， 则递归调用 doRegisterBeanDefinitions()方法，</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">                    <span class="comment">// recurse</span></span><br><span class="line">                    doRegisterBeanDefinitions(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是自定义标签，那么调用自定义标签解析</span></span><br><span class="line">                delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果是自定义标签，那么调用自定义标签解析</span></span><br><span class="line">    delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看一下 processBeanDefinition 方法，这个方法用来解析bean定义。<br>processBeanDefinition(): </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用了BeanDefinitionParserDelegate 来解析出BeanDefinitionHolder对象，这个对象中封装了 BeanDefinition 以及bean名称对象。</span></span><br><span class="line"><span class="comment">//BeanDefinition 是用来描述bean 定义的对象，主要包括 class, lazy-init ，依赖对象， 初始化方法，销毁方法，作用域, 父级bean定义等信息，这些信息都解析自xml bean标签。如果在有自定义的子标签和属性，则进一步调用自定义的 NamespaceHandler</span></span><br><span class="line"></span><br><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"><span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//处理标签中的自定义元素和自定义子标签， 调用自定义的 NamespaceHandler 来解析。</span></span><br><span class="line">    <span class="comment">// 这里返回的 BeanDefinitionHolder 可以是原始的，也可以是自己经过处理的。一切看 NamespaceHandler 里如何定义的</span></span><br><span class="line">    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">        <span class="comment">// 注册最终的 BeanDefinitionHolder</span></span><br><span class="line">        BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">        getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Send registration event.</span></span><br><span class="line">    getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看一下BeanDefinitionParserDelegate的parseBeanDefinitionElement方法，主要包括BeanDefinition的属性的设置，以及bean下的元素标签解析，bean 定义名称等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">    <span class="comment">// 解析bean name， 可以有多个，用 ,;  隔开</span></span><br><span class="line">String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String beanName = id;</span><br><span class="line"><span class="comment">// id 为空，则用第一个name 作为id</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//判断名称是否唯一</span></span><br><span class="line">checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 具体解析标签的每个元素，包括init-method, 构造参数等，设置 beanDefinition对应的属性</span></span><br><span class="line">AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"><span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"><span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line"><span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line"><span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line"><span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">!<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">aliases.add(beanClassName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line"><span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">error(ex.getMessage(), ele);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NamespaceHandler-解析自定义标签"><a href="#NamespaceHandler-解析自定义标签" class="headerlink" title="NamespaceHandler 解析自定义标签"></a>NamespaceHandler 解析自定义标签</h3><p>除了默认命名空间<code>http://www.springframework.org/schema/beans</code>之外，其他的都是自定义命名空间，需要用到<code>NamespaceHandler</code>来解析自定义标签。<code>NamespaceHandlerResolver</code>会找到命名空间所对应的<code>NamespaceHandler</code>。<code>NamespaceHandlerResolver</code>接口的默认实现类<code>DefaultNamespaceHandlerResolver</code> 会加载<code>META-INF/spring.handlers</code>文件，并根据命名空间地址来实例化<code>NamespaceHandler</code>实现类。Spring beans包下的这个文件内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/c=org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/p=org.springframework.beans.factory.xml.SimplePropertyNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler</span><br></pre></td></tr></table></figure><p><code>命名空间地址=解析器实现类</code>这样的形式。</p><h4 id="常用的-NamespaceHandler"><a href="#常用的-NamespaceHandler" class="headerlink" title="常用的 NamespaceHandler"></a>常用的 NamespaceHandler</h4><ul><li><p>SimplePropertyNamespaceHandler：简单的NamespaceHandler实现，它将特定属性直接映射到bean属性。需要注意的重要一点是，NamespaceHandler无法预知所有可能的属性名。下面是使用NamespaceHandler的一个例子: <bean id="rob" class="..TestBean" p:name="Rob Harrop" p:spouse-ref="sally">, 这里的<code>p:name</code>直接对应于类“TestBean”上的<code>name</code>属性。<code>p:spouse-ref</code>属性对应于<code>spouse</code>属性，将value 所对应的bean注入到该属性中。</bean></p></li><li><p>SimpleConstructorNamespaceHandler：设置构造函数参数。如： <bean id="author" class="..TestBean " c:name="Enescu" c:work-ref="compositions"> 。这里，“c:name”直接对应于类“TestBean”构造函数中声明的“name”参数。“c:work-ref”属性对应于“work”参数，它不作为具体值，而是包含作为参数的bean的名称。注意:这个实现支持命名参数, 下标——不支持类型。此外，容器使用这些名称作为提示，默认情况下，容器会进行类型自省 。</bean></p></li><li><p>NamespaceHandlerSupport：实现自定义NamespaceHandler的支持类。各个节点的解析和装饰分别通过<code>BeanDefinitionParser</code>和<code>BeanDefinitionDecorator</code>策略接口完成。提供<code>registerBeanDefinitionParser</code>和<code>registerBeanDefinitionDecorator</code>方法，用于注册<code>BeanDefinitionParser</code>或<code>BeanDefinitionDecorator</code>来处理特定元素。</p></li><li><p>AopNamespaceHandler: 用于 <code>aop</code> 命名空间的NamespaceHandler。为<a href="aop:config">aop:config</a>标签提供一个BeanDefinitionParser。<code>config</code>标记可以包含嵌套的<code>pointcut</code>、<code>advisor</code>和<code>aspect</code>标签。<code>pointcut</code>标签允许使用简单的语法创建命名的<code>AspectJExpressionPointcut</code> bean: &lt;aop:pointcut id=”getNameCalls” expression=”execution(* *..ITestBean.getName(..))”/&gt;. 使用<code>advisor</code>标签，你可以配置<code>org.springframework.aop.Advisor</code>并将其自动应用于你的<code>org.springframework.beans.factory.BeanFactory</code>中的所有相关bean。<code>advisor</code>标签支持内联和引用<code>org.springframework.aop.Pointcut</code>: &lt;aop:advisor id=”getAgeAdvisor”</p><pre><code> pointcut=&quot;execution(* *..ITestBean.getAge(..))&quot; advice-ref=&quot;getAgeCounter&quot;/&gt;</code></pre><p> &lt;aop:advisor id=”getNameAdvisor”</p><pre><code> pointcut-ref=&quot;getNameCalls&quot; advice-ref=&quot;getNameCounter&quot;/&gt;</code></pre><p> 标签对应的解析器：config -&gt; ConfigBeanDefinitionParser, aspectj-autoproxy -&gt; AspectJAutoProxyBeanDefinitionParser, scoped-proxy -&gt; ScopedProxyBeanDefinitionDecorator</p></li><li><p>ContextNamespaceHandler: 解析 <code>context</code> 命名空间。 标签对应的解析器：property-placeholder -&gt; PropertyPlaceholderBeanDefinitionParser, property-override -&gt; PropertyOverrideBeanDefinitionParser, annotation-config -&gt; AnnotationConfigBeanDefinitionParser, component-scan -&gt; ComponentScanBeanDefinitionParser, load-time-weaver -&gt; LoadTimeWeaverBeanDefinitionParser, spring-configured -&gt; SpringConfiguredBeanDefinitionParser, mbean-export -&gt; MBeanExportBeanDefinitionParser, mbean-server -&gt; MBeanServerBeanDefinitionParser   </p></li><li><p>LangNamespaceHandler: 解析 <code>lang</code> 命名空间。NamespaceHandler 支持由动态语言(如Groovy、JRuby和BeanShell)支持的对象织入。下面是一个示例(来自参考文档)，它详细描述了Groovy支持的bean的织入:<br>&lt;lang:groovy id=”messenger”</p><pre><code> refresh-check-delay=&quot;5000&quot; script-source=&quot;classpath:Messenger.groovy&quot;&gt;</code></pre><p> &lt;lang:property name=”message” value=”I Can Do The Frug”/&gt;<br><br>标签对应的解析器：groovy, bsh, std -&gt; ScriptBeanDefinitionParser, defaults -&gt; ScriptingDefaultsParser</p></li><li><p>UtilNamespaceHandler: 解析<code>util</code> 命名空间。标签对应的解析器：constant -&gt; ConstantBeanDefinitionParser, property-path -&gt; PropertyPathBeanDefinitionParser， list -&gt; ListBeanDefinitionParser , set -&gt; SetBeanDefinitionParser, map -&gt; MapBeanDefinitionParser , properties -&gt; PropertiesBeanDefinitionParser.</p></li><li><p>TaskNamespaceHandler: 解析<code>task</code> 命名空间. 标签对应的解析器：annotation-driven -&gt; AnnotationDrivenBeanDefinitionParser, executor -&gt; ExecutorBeanDefinitionParser , scheduled-tasks -&gt; ScheduledTasksBeanDefinitionParser, scheduler -&gt; SchedulerBeanDefinitionParser.</p></li><li><p>CacheNamespaceHandler: 允许使用XML或注释配置声明式缓存管理的NamespaceHandler。这个名称空间处理程序是Spring缓存管理工具中的核心功能。标签对应的解析器： annotation-driven -&gt; AnnotationDrivenCacheBeanDefinitionParser，advice -&gt; CacheAdviceParser. </p></li><li><p>MvcNamespaceHandler: 用于Spring MVC配置命名空间的NamespaceHandler . 标签对应的解析器：annotation-driven -&gt; AnnotationDrivenBeanDefinitionParser </p></li><li><p>JeeNamespaceHandler: 解析 <code>jee</code> 命名空间。标签对应的解析器：jndi-lookup -&gt; JndiLookupBeanDefinitionParser, local-slsb -&gt; LocalStatelessSessionBeanDefinitionParser, remote-slsb -&gt; RemoteStatelessSessionBeanDefinitionParser.</p></li></ul><h3 id="BeanDefinitionParser"><a href="#BeanDefinitionParser" class="headerlink" title="BeanDefinitionParser"></a>BeanDefinitionParser</h3><p><code>DefaultBeanDefinitionDocumentReader</code>用于处理自定义顶级标签的接口。实现类可以根据需要自由地将自定义标签中的元数据转换成任意多的bean定义。<br>解析器从关联的<code>NamespaceHandler</code>中为自定义标签所在的命名空间定位一个<code>BeanDefinitionParser</code>。通过<code>NamespaceHandlerSupport</code>的<code>registerBeanDefinitionParser</code>方法注册</p><h4 id="提供的方法"><a href="#提供的方法" class="headerlink" title="提供的方法"></a>提供的方法</h4><p>BeanDefinition parse(Element element, ParserContext parserContext)：解析指定的元素并将结果bean定义注册到所提供的ParserContext中嵌入的<code>BeanDefinitionRegistry</code>。<br>如果要以嵌套方式使用(例如作为<code>&lt;property/&gt;</code>标记中的内部标记)，实现类必须返回从解析中得到的主要bean定义。如果实现不以嵌套方式使用，则可能返回null。</p><h4 id="常用实现类-1"><a href="#常用实现类-1" class="headerlink" title="常用实现类"></a>常用实现类</h4><p>常用的就是上面所列的每个 <code>NamespaceHandler</code>中注册的解析器。</p><ul><li>ConfigBeanDefinitionParser：解析 <code>&lt;aop:config&gt;</code> 标签</li><li>AspectJAutoProxyBeanDefinitionParser: 解析 <code>&lt;aop:aspectj-autoproxy&gt;</code> 标签</li><li>ScopedProxyBeanDefinitionDecorator：解析 <code>&lt;aop:scoped-proxy&gt;</code> 标签</li><li>PropertyPlaceholderBeanDefinitionParser：解析 <code>&lt;context:property-placeholder&gt;</code> 标签</li><li>PropertyOverrideBeanDefinitionParser: 解析 <code>&lt;context:property-override&gt;</code> 标签</li><li>AnnotationConfigBeanDefinitionParser：解析 <code>&lt;context:annotation-config&gt;</code> 标签</li><li>ComponentScanBeanDefinitionParser: 解析 <code>&lt;context:component-scan&gt;</code> 标签</li><li>LoadTimeWeaverBeanDefinitionParser： 解析 <code>&lt;context:load-time-weaver&gt;</code> 标签</li><li>SpringConfiguredBeanDefinitionParser：解析 <code>&lt;context:spring-configured&gt;</code> 标签</li><li>MBeanExportBeanDefinitionParser：解析 <code>&lt;context:mbean-export&gt;</code> 标签</li><li>MBeanServerBeanDefinitionParser：解析 <code>&lt;context:mbean-server&gt;</code> 标签</li><li>ScriptBeanDefinitionParser：解析 <code>&lt;lang:groovy&gt;</code>,<code>&lt;lang:bsh&gt;</code>,<code>&lt;lang:std&gt;</code>。 实例化时需要传入一个脚本工厂类名。分别是 <code>org.springframework.scripting.groovy.GroovyScriptFactory</code>, <code>org.springframework.scripting.bsh.BshScriptFactory</code>, <code>org.springframework.scripting.support.StandardScriptFactory</code> </li><li>ScriptingDefaultsParser: 解析 <code>&lt;lang:defaults&gt;</code> 标签</li><li>ConstantBeanDefinitionParser：解析 <code>&lt;util:constant&gt;</code> 标签</li><li>PropertyPathBeanDefinitionParser：解析 <code>&lt;util:property-path&gt;</code> 标签</li><li>ListBeanDefinitionParser：解析 <code>&lt;util:list&gt;</code> 标签</li><li>SetBeanDefinitionParser：解析 <code>&lt;util:set&gt;</code> 标签</li><li>MapBeanDefinitionParser：解析 <code>&lt;util:map&gt;</code> 标签</li><li>PropertiesBeanDefinitionParser：解析 <code>&lt;util:properties&gt;</code> 标签</li><li>AnnotationDrivenBeanDefinitionParser：解析 <code>&lt;mvc:annotation-driven&gt;</code>，<code>&lt;task:annotation-driven&gt;</code> 标签</li><li>DefaultServletHandlerBeanDefinitionParser：解析 <code>&lt;mvc:default-servlet-handler&gt;</code> 标签</li><li>InterceptorsBeanDefinitionParser：解析 <code>&lt;mvc:interceptors&gt;</code> 标签</li><li>ResourcesBeanDefinitionParser：解析 <code>&lt;mvc:resources&gt;</code> 标签</li><li>ViewControllerBeanDefinitionParser：解析 <code>&lt;mvc:view-controller&gt;</code>,<code>&lt;mvc:redirect-view-controller&gt;</code>, <code>&lt;mvc:status-controller&gt;</code> 标签</li><li>ViewResolversBeanDefinitionParser：解析 <code>&lt;mvc:view-resolvers&gt; </code>标签</li><li>TilesConfigurerBeanDefinitionParser：解析 <code>&lt;mvc:tiles-configurer&gt;</code> 标签</li><li>FreeMarkerConfigurerBeanDefinitionParser：解析 <code>&lt;mvc:freemarker-configurer&gt;</code> 标签</li><li>GroovyMarkupConfigurerBeanDefinitionParser：解析 <code>&lt;mvc:groovy-configurer&gt;</code> 标签</li><li>ScriptTemplateConfigurerBeanDefinitionParser：解析 <code>&lt;mvc:script-template-configurer&gt;</code>标签</li><li>CorsBeanDefinitionParser：解析 <code>&lt;mvc:cors&gt;</code> 标签</li><li>ExecutorBeanDefinitionParser: 解析 <code>&lt;task:executor&gt;</code> 标签</li><li>ScheduledTasksBeanDefinitionParser: 解析 <code>&lt;task:scheduled-tasks&gt;</code> 标签</li><li>SchedulerBeanDefinitionParser: 解析 <code>&lt;task:scheduler&gt;</code> 标签</li><li>AnnotationDrivenCacheBeanDefinitionParser: 解析 <code>&lt;cache:annotation-driven&gt;</code> 标签</li><li>CacheAdviceParser: 解析 <code>&lt;cache:advice&gt;</code> 标签</li><li>JndiLookupBeanDefinitionParser: 解析 <code>&lt;jee:jndi-lookup&gt;</code> 标签</li><li>LocalStatelessSessionBeanDefinitionParser: 解析 <code>&lt;jee:local-slsb&gt;</code> 标签</li><li>RemoteStatelessSessionBeanDefinitionParser: 解析 <code>&lt;jee:remote-slsb&gt;</code> 标签</li></ul><h3 id="BeanDefinitionDecorator"><a href="#BeanDefinitionDecorator" class="headerlink" title="BeanDefinitionDecorator"></a>BeanDefinitionDecorator</h3><p><code>DefaultBeanDefinitionDocumentReader</code>使用的接口来处理自定义的嵌套标签(直接位于<code>&lt;bean&gt;</code>)标签下)。还可以装饰<code>&lt;bean&gt;</code>标签的自定义属性。实现类可以自由地将自定义标签中的元数据转换为所需的任意多个bean定义，并转换所包含的bean定义标签，甚至可能返回一个完全不同的<code>org.springframework.bean .factory.config.BeanDefinition</code>替换原来的。<br><code>BeanDefinitionDecorator</code> 应该意识到它们可能是解析链的一部分。特别是，应该知道，以前的BeanDefinitionDecorator可能已经用<code>ProxyFactoryBean</code>定义替换了原来的BeanDefinition，该定义允许添加自定义拦截器。希望向封闭bean添加拦截器的 <code>BeanDefinitionDecorator</code>应该扩展<code>AbstractInterceptorDrivenBeanDefinitionDecorator</code>，它处理解析链，确保只创建一个代理，并且它包含链中的所有拦截器。 解析器从<code>NamespaceHandler</code>中为自定义标签所在的命名空间定位一个<code>BeanDefinitionDecorator</code></p><h4 id="常用实现类-2"><a href="#常用实现类-2" class="headerlink" title="常用实现类"></a>常用实现类</h4><ul><li>ScopedProxyBeanDefinitionDecorator：负责解析<code>&lt;aop:scope-proxy/&gt;</code>标签</li><li>AbstractInterceptorDrivenBeanDefinitionDecorator：希望向生成的bean添加拦截器的<code>BeanDefinitionDecorator</code>的基本实现。这个基类控制<code>ProxyFactoryBean</code> bean 定义的创建，并将原始定义包装为<code>ProxyFactoryBean</code>目标属性的内部bean定义。正确处理链接，确保只创建一个<code>ProxyFactoryBean</code> 定义。如果前面的BeanDefinitionDecorator已经创建了<code>ProxyFactoryBean</code>，则只需将拦截器添加到现有定义中。子类只需要向它们希望添加的拦截器创建bean定义</li></ul><h2 id="BeanDefinitionRegistry-注册bean-定义"><a href="#BeanDefinitionRegistry-注册bean-定义" class="headerlink" title="BeanDefinitionRegistry 注册bean 定义"></a>BeanDefinitionRegistry 注册bean 定义</h2><p>BeanDefinitionReaderUtils.registerBeanDefinition()方法内部调用了org.springframework.beans.factory.support.BeanDefinitionRegistry.registerBeanDefinition 方法， 具体的实现就是beanFactory实现类（<code>org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition</code>）了。</p><p>DefaultListableBeanFactory.registerBeanDefinition():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//校验 BeanDefinition 的逻辑合法</span></span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果存在同名 bean 定义</span></span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="comment">//不允许bean 定义覆盖</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">                        existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//注册新的 bean 定义，如果正在创建 bean 实例</span></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="comment">//不能再修改启动时的集合，为了稳定的遍历</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">                    Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">                    updatedSingletons.remove(beanName);</span><br><span class="line">                    <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//还在注册阶段，直接放进去就完事了</span></span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 重置给定bean的所有bean定义缓存，包括派生自该bean的bean的缓存。</span></span><br><span class="line">        <span class="comment">//   在替换或删除现有bean定义之后调用，触发clearMergedBeanDefinition、destroySingleton和MergedBeanDefinitionPostProcessor。</span></span><br><span class="line">        <span class="comment">//   在给定bean和所有具有给定bean作为父bean的bean定义上重置beandefinition</span></span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bean-定义文件的解析&quot;&gt;&lt;a href=&quot;#Bean-定义文件的解析&quot; class=&quot;headerlink&quot; title=&quot;Bean 定义文件的解析&quot;&gt;&lt;/a&gt;Bean 定义文件的解析&lt;/h1&gt;&lt;h2 id=&quot;初始化工厂&quot;&gt;&lt;a href=&quot;#初始化工厂&quot; c
      
    
    </summary>
    
    
      <category term="Bean" scheme="http://qzztf.com/tags/Bean/"/>
    
      <category term="解析" scheme="http://qzztf.com/tags/%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Spring自定义命名空间解析</title>
    <link href="http://qzztf.com/post/75b6/"/>
    <id>http://qzztf.com/post/75b6/</id>
    <published>2019-05-13T06:35:52.000Z</published>
    <updated>2024-06-16T07:25:26.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义命名空间解析"><a href="#自定义命名空间解析" class="headerlink" title="自定义命名空间解析"></a>自定义命名空间解析</h1><p>当我们想要扩展Spring 的配置时，可以定义我们自己的标签，然后解析成 bean定义，注册到Spring 容器中。这时需要用到 <code>NamespaceHandler</code>。Spring 框架中除了beans顶级标签外，其他的顶级标签都是自定义命名空间中的标签。如，<code>p</code>、 <code>c</code>、<code>util</code>命名空间。</p><h2 id="NamespaceHandler-命名空间解析器"><a href="#NamespaceHandler-命名空间解析器" class="headerlink" title="NamespaceHandler 命名空间解析器"></a><code>NamespaceHandler</code> 命名空间解析器</h2><p>Spring 框架中<code>mvc</code>、<code>context</code>、<code>tx</code> 等功能都是通过扩展这个接口来实现的。这个接口负责将标签解析成bean 定义对象。该接口提供了<code>parse</code> 和<code>decorate</code> 方法。<code>parse</code>方法用来将顶级标签解析成<code>BeanDefinition</code>对象。<code>decorate</code> 方法负责对<code>parse</code>出来的<code>BeanDefinition</code>进行进一步处理，需要解析的可以是元素属性和标签。 可以返回原来的<code>BeanDefinition</code>，或者返回一个新的<code>BeanDefinition</code>。</p><p>为了解析的方便，Spring 提供了一个抽象类<code>NamespaceHandlerSupport</code>，封装了一些基础功能，并提供了两个新的接口(<code>BeanDefinitionParser</code>和<code>BeanDefinitionDecorator</code>)方便扩展。并提供了<code>registerBeanDefinitionDecorator</code>、<code>registerBeanDefinitionParser</code>、<code>registerBeanDefinitionDecoratorForAttribute</code>三个方法分别注册<code>BeanDefinitionParser</code>和<code>BeanDefinitionDecorator</code>实现类，内部用map来维护标签名或者属性名到<code>BeanDefinitionParser</code>和<code>BeanDefinitionDecorator</code>的映射关系，解析时用名称(无命名空间前缀)来查找。</p><h2 id="Spring提供的NamespaceHandler"><a href="#Spring提供的NamespaceHandler" class="headerlink" title="Spring提供的NamespaceHandler"></a>Spring提供的<code>NamespaceHandler</code></h2><p>Spring 提供了一些 <code>NamespaceHandler</code>来实现自身功能。下面详细了解一下。</p><h3 id="SimplePropertyNamespaceHandler-简单属性解析器"><a href="#SimplePropertyNamespaceHandler-简单属性解析器" class="headerlink" title="SimplePropertyNamespaceHandler 简单属性解析器"></a><code>SimplePropertyNamespaceHandler</code> 简单属性解析器</h3><p>解析的命名空间为 <code>http://www.springframework.org/schema/p</code>。它将特定属性直接映射到bean属性。需要注意的重要一点是，<code>NamespaceHandler</code>无法预知所有可能的属性名。该实现类直接实现了<code>NamespaceHandler</code>。</p><p>下面是使用<code>NamespaceHandler</code>的一个例子: </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;rob&quot;</span> <span class="attr">class</span> = <span class="string">&quot;..TestBean&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;Rob&quot;</span> <span class="attr">p:spouse-ref</span>=<span class="string">&quot;sally&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这里的<code>p:name</code>直接对应于类<code>TestBean</code>上的<code>name</code>属性。<code>p:spouse-ref</code>属性对应于<code>spouse</code>属性，将<code>value </code>所对应的bean注入到该属性中。</p><p><code>parse</code>方法直接记录日志信息，并返回 <code>null</code>。因为它只支持对属性进行解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">parserContext.getReaderContext().error(</span><br><span class="line"><span class="string">&quot;Class [&quot;</span> + getClass().getName() + <span class="string">&quot;] does not support custom elements.&quot;</span>, element);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>decorate</code>将元素属性表示的属性设置到对应的对象属性中。每个属性都会调用一次这个方法。拿上文提到的例子来解释一下下面代码的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorate</span><span class="params">(Node node, BeanDefinitionHolder definition, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Attr) &#123;</span><br><span class="line">       <span class="comment">//只处理标签属性</span></span><br><span class="line">      Attr attr = (Attr) node;</span><br><span class="line">       <span class="comment">//获取到属性名称，例子中为 name</span></span><br><span class="line">      String propertyName = parserContext.getDelegate().getLocalName(attr);</span><br><span class="line">       <span class="comment">//获取到属性值 例子中为 Rob</span></span><br><span class="line">      String propertyValue = attr.getValue();</span><br><span class="line">       <span class="comment">//从当前bean定义取出属性值集合</span></span><br><span class="line">      MutablePropertyValues pvs = definition.getBeanDefinition().getPropertyValues();</span><br><span class="line">       <span class="comment">//如果已经解析出了该属性，则记录一下错误日志。这里是因为我们可以用标签 &lt;property&gt; 来声明属性, p 标签实际上是一种简化形式。两种声明方式只能用一种来声明同一个属性</span></span><br><span class="line">      <span class="keyword">if</span> (pvs.contains(propertyName)) &#123;</span><br><span class="line">         parserContext.getReaderContext().error(<span class="string">&quot;Property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; is already defined using &quot;</span> +</span><br><span class="line">               <span class="string">&quot;both &lt;property&gt; and inline syntax. Only one approach may be used per property.&quot;</span>, attr);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 如果属性名以 _ref 结尾，则表示该属性值引用一个 bean ,_ref 前面是 bean 名称</span></span><br><span class="line">      <span class="keyword">if</span> (propertyName.endsWith(REF_SUFFIX)) &#123;</span><br><span class="line">         propertyName = propertyName.substring(<span class="number">0</span>, propertyName.length() - REF_SUFFIX.length());</span><br><span class="line">         <span class="comment">// 将标签属性名转换成属性名，小写，破折号形式转成驼峰形式，值转换成 RuntimeBeanReference，这个对象会在运行时转成具体的bean</span></span><br><span class="line">          pvs.add(Conventions.attributeNameToPropertyName(propertyName), <span class="keyword">new</span> RuntimeBeanReference(propertyValue));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//字面值直接添加进去就行了</span></span><br><span class="line">         pvs.add(Conventions.attributeNameToPropertyName(propertyName), propertyValue);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结：用这个自定义属性来替换<code>&lt;property&gt;</code>使用起来更方便。</strong></p><h3 id="SimpleConstructorNamespaceHandler-简单构造函数解析器"><a href="#SimpleConstructorNamespaceHandler-简单构造函数解析器" class="headerlink" title="SimpleConstructorNamespaceHandler 简单构造函数解析器"></a><code>SimpleConstructorNamespaceHandler</code> 简单构造函数解析器</h3><p>将自定义属性映射到构造函数参数。解析的命名空间地址为<code>http://www.springframework.org/schema/c</code>。需要注意该解析器无法预知所有的参数。</p><p>下面看一个简单例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;author&quot;</span> <span class="attr">class</span>=<span class="string">&quot;..TestBean&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;Enescu&quot;</span> <span class="attr">c:work-ref</span>=<span class="string">&quot;compositions&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>将<code>name</code>映射到<code>TestBean</code>的构造函数<code>name</code>参数，值为<code>Enescu</code>，而<code>work</code>参数引用了<code>compositions</code> bean。</p><p>下面看一下源代码：</p><p><code>parse</code> 方法不支持解析标签</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   parserContext.getReaderContext().error(</span><br><span class="line">         <span class="string">&quot;Class [&quot;</span> + getClass().getName() + <span class="string">&quot;] does not support custom elements.&quot;</span>, element);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>decorate</code> 方法， 每个参数都会调用一次这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorate</span><span class="params">(Node node, BeanDefinitionHolder definition, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Attr) &#123;</span><br><span class="line">       <span class="comment">//只解析标签属性</span></span><br><span class="line">      Attr attr = (Attr) node;</span><br><span class="line">       <span class="comment">//获取参数名,上例中为 name</span></span><br><span class="line">      String argName = StringUtils.trimWhitespace(parserContext.getDelegate().getLocalName(attr));</span><br><span class="line">       <span class="comment">// 获取参数值, Enescu</span></span><br><span class="line">      String argValue = StringUtils.trimWhitespace(attr.getValue());</span><br><span class="line"></span><br><span class="line">      ConstructorArgumentValues cvs = definition.getBeanDefinition().getConstructorArgumentValues();</span><br><span class="line">      <span class="keyword">boolean</span> ref = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// handle -ref arguments</span></span><br><span class="line">      <span class="keyword">if</span> (argName.endsWith(REF_SUFFIX)) &#123;</span><br><span class="line">          <span class="comment">//如果参数名以 -ref 结尾，获取到真正的参数名，work-ref 则为 work</span></span><br><span class="line">         ref = <span class="keyword">true</span>;</span><br><span class="line">         argName = argName.substring(<span class="number">0</span>, argName.length() - REF_SUFFIX.length());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果是 引用， 则创建 RuntimeBeanReference，运行时动态解析为实际bean </span></span><br><span class="line">      ValueHolder valueHolder = <span class="keyword">new</span> ValueHolder(ref ? <span class="keyword">new</span> RuntimeBeanReference(argValue) : argValue);</span><br><span class="line">      valueHolder.setSource(parserContext.getReaderContext().extractSource(attr));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// handle &quot;escaped&quot;/&quot;_&quot; arguments</span></span><br><span class="line">      <span class="keyword">if</span> (argName.startsWith(DELIMITER_PREFIX)) &#123;</span><br><span class="line">         <span class="comment">// 如果参数名以 _ 开头</span></span><br><span class="line">         String arg = argName.substring(<span class="number">1</span>).trim();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// fast default check</span></span><br><span class="line">         <span class="keyword">if</span> (!StringUtils.hasText(arg)) &#123;</span><br><span class="line">             <span class="comment">// 如果参数名为空，那么添加常规参数值</span></span><br><span class="line">            cvs.addGenericArgumentValue(valueHolder);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// assume an index otherwise</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//解析通过构造函数参数下标来指定的参数</span></span><br><span class="line">            <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               index = Integer.parseInt(arg);</span><br><span class="line">                <span class="comment">//如果不是下标，则记录一下错误</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">               parserContext.getReaderContext().error(</span><br><span class="line">                     <span class="string">&quot;Constructor argument &#x27;&quot;</span> + argName + <span class="string">&quot;&#x27; specifies an invalid integer&quot;</span>, attr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 下标小于0记录错误</span></span><br><span class="line">               parserContext.getReaderContext().error(</span><br><span class="line">                     <span class="string">&quot;Constructor argument &#x27;&quot;</span> + argName + <span class="string">&quot;&#x27; specifies a negative index&quot;</span>, attr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cvs.hasIndexedArgumentValue(index)) &#123;</span><br><span class="line">                <span class="comment">//已经通过&lt;constructor-arg&gt;标签定义了</span></span><br><span class="line">               parserContext.getReaderContext().error(</span><br><span class="line">                     <span class="string">&quot;Constructor argument &#x27;&quot;</span> + argName + <span class="string">&quot;&#x27; with index &quot;</span>+ index+<span class="string">&quot; already defined using &lt;constructor-arg&gt;.&quot;</span> +</span><br><span class="line">                     <span class="string">&quot; Only one approach may be used per argument.&quot;</span>, attr);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 到这里则解析成功，添加进到ConstructorArgumentValues中去</span></span><br><span class="line">            cvs.addIndexedArgumentValue(index, valueHolder);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// no escaping -&gt; ctr name</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 不是下标形式，则直接转换参数名</span></span><br><span class="line">         String name = Conventions.attributeNameToPropertyName(argName);</span><br><span class="line">         <span class="keyword">if</span> (containsArgWithName(name, cvs)) &#123;</span><br><span class="line">             <span class="comment">//检查是否已经定义过</span></span><br><span class="line">            parserContext.getReaderContext().error(</span><br><span class="line">                  <span class="string">&quot;Constructor argument &#x27;&quot;</span> + argName + <span class="string">&quot;&#x27; already defined using &lt;constructor-arg&gt;.&quot;</span> +</span><br><span class="line">                  <span class="string">&quot; Only one approach may be used per argument.&quot;</span>, attr);</span><br><span class="line">         &#125;</span><br><span class="line">         valueHolder.setName(Conventions.attributeNameToPropertyName(argName));</span><br><span class="line">         cvs.addGenericArgumentValue(valueHolder);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结：配置构造函数的方式"><a href="#小结：配置构造函数的方式" class="headerlink" title="小结：配置构造函数的方式"></a>小结：配置构造函数的方式</h4><ol><li><p>使用<code>&lt;constructor-arg&gt;</code>标签，可以使用名称来定义，也可以使用下标。</p></li><li><p>在<code>&lt;bean&gt;</code>标签中使用<code>c:</code>自定义属性, 属性名有两种方式：</p><ol><li>下标形式<code>_0</code> </li><li>构造函数参数名形式<code>c:name=&quot;value&quot;</code></li></ol><p>如果参数值需要引用bean，那么需要在属性名后加上<code>_ref</code>表示引用。</p></li></ol><p>两种方式对比：</p><table><thead><tr><th>方式</th><th>名称</th><th>下标</th></tr></thead><tbody><tr><td><code>&lt;constructor-arg&gt;</code>标签</td><td>name=“name” value=“value” (ref=“beanid”)</td><td>index=“0” value=“value”(ref=“beanid”)</td></tr><tr><td><code>c:</code>属性</td><td>c: name=“value”(c:name_ref=“beanid”)</td><td>c:_0=“value” (c:_0_ref=“beanid”)</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="NamespaceHandlerSupport-命名空间解析器支持类"><a href="#NamespaceHandlerSupport-命名空间解析器支持类" class="headerlink" title="NamespaceHandlerSupport 命名空间解析器支持类"></a><code>NamespaceHandlerSupport</code> 命名空间解析器支持类</h3><p>实现自定义<code>NamespaceHandler</code>的支持类。各个节点的解析和装饰分别通过<code>BeanDefinitionParser</code>和<code>BeanDefinitionDecorator</code>策略接口完成。提供<code>registerBeanDefinitionParser</code>和<code>registerBeanDefinitionDecorator</code>方法，用于注册<code>BeanDefinitionParser</code>或<code>BeanDefinitionDecorator</code>来处理特定元素。</p><h4 id="BeanDefinitionParser"><a href="#BeanDefinitionParser" class="headerlink" title="BeanDefinitionParser"></a><code>BeanDefinitionParser</code></h4><p><code>DefaultBeanDefinitionDocumentReader</code>用于处理自定义顶级标签的接口。实现类可以根据需要自由地将自定义标签中的元数据转换成任意多的bean定义。</p><h5 id="AbstractBeanDefinitionParser-类"><a href="#AbstractBeanDefinitionParser-类" class="headerlink" title="AbstractBeanDefinitionParser 类"></a><code>AbstractBeanDefinitionParser</code> 类</h5><p><code>BeanDefinitionParser</code>实现类，该类提供了许多方便的方法和模板方法，子类必须重写这些方法才能提供实际的解析逻辑。</p><p>当你想将任意复杂的XML解析为一个或多个bean定义时，请使用这个<code>BeanDefinitionParser</code>实现。如果只是想将一些XML解析为一个bean定义，那么可以考虑该类更简单的扩展类，即 <code>AbstractSingleBeanDefinitionParser</code> 和 <code>AbstractSimpleBeanDefinitionParser</code>。</p><h6 id="parse-方法"><a href="#parse-方法" class="headerlink" title="parse 方法"></a><code>parse</code> 方法</h6><p><code>parse</code> 方法是该解析器的入口，定义了整个解析的流程以及子类可以扩展的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//解析出 BeanDefinition， parseInternal 方法是一个抽象方法，子类需要实现</span></span><br><span class="line">   AbstractBeanDefinition definition = parseInternal(element, parserContext);</span><br><span class="line">   <span class="keyword">if</span> (definition != <span class="keyword">null</span> &amp;&amp; !parserContext.isNested()) &#123;</span><br><span class="line">       <span class="comment">// 不是嵌套定义</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//解析出 bean id， 该方法是 protected级别，子类可以重写</span></span><br><span class="line">         String id = resolveId(element, definition, parserContext);</span><br><span class="line">         <span class="keyword">if</span> (!StringUtils.hasText(id)) &#123;</span><br><span class="line">            parserContext.getReaderContext().error(</span><br><span class="line">                  <span class="string">&quot;Id is required for element &#x27;&quot;</span> + parserContext.getDelegate().getLocalName(element)</span><br><span class="line">                        + <span class="string">&quot;&#x27; when used as a top-level tag&quot;</span>, element);</span><br><span class="line">         &#125;</span><br><span class="line">         String[] aliases = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">if</span> (shouldParseNameAsAliases()) &#123;</span><br><span class="line">             <span class="comment">//是否需要将名字解析成 别名，默认为 true, 名称可以用逗号指定多个，那么分隔出来之后作为别名</span></span><br><span class="line">            String name = element.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(name)) &#123;</span><br><span class="line">               aliases = StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray(name));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(definition, id, aliases);</span><br><span class="line">          <span class="comment">//注册bean 定义</span></span><br><span class="line">         registerBeanDefinition(holder, parserContext.getRegistry());</span><br><span class="line">         <span class="keyword">if</span> (shouldFireEvents()) &#123;</span><br><span class="line">             <span class="comment">//发布事件</span></span><br><span class="line">            BeanComponentDefinition componentDefinition = <span class="keyword">new</span> BeanComponentDefinition(holder);</span><br><span class="line">            postProcessComponentDefinition(componentDefinition);</span><br><span class="line">             <span class="comment">//嵌套bean 定义不发布事件</span></span><br><span class="line">            parserContext.registerComponent(componentDefinition);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         String msg = ex.getMessage();</span><br><span class="line">         parserContext.getReaderContext().error((msg != <span class="keyword">null</span> ? msg : ex.toString()), element);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><p>解析流程：</p><ol><li><p>调用<code>parseInternal</code> 方法将 xml 解析成<code>BeanDefinition</code>，该方法由子类去实现</p></li><li><p>调用<code>resolveId</code>方法得到bean 定义id，可以由子类重写</p></li><li><p>别名解析</p></li><li><p>注册bean 定义</p></li><li><p>发布事件，实现<code>ReaderEventListener</code> 进行监听</p></li></ol><h5 id="AbstractSingleBeanDefinitionParser-类"><a href="#AbstractSingleBeanDefinitionParser-类" class="headerlink" title="AbstractSingleBeanDefinitionParser 类"></a><code>AbstractSingleBeanDefinitionParser</code> 类</h5><p>只需要解析和定义一个bean定义的<code>BeanDefinitionParser</code>实现基类，继承自<code>AbstractBeanDefinitionParser</code>类，实现<code>parseInternal</code>方法，近一步细化解析逻辑。</p><p>只需要从任意复杂的XML元素创建单个bean定义时，可以扩展这个解析器类。当你想从一个相对简单的自定义XML元素创建一个bean定义时，可以考虑扩展<code>AbstractSimpleBeanDefinitionParser</code>类。</p><p>生成的bean定义将自动注册到<code>org.springframework.beans.factory.support.BeanDefinitionRegistry</code>。只需要将自定义XML元素解析为一个bean定义就可以了。</p><h6 id="parseInternal方法"><a href="#parseInternal方法" class="headerlink" title="parseInternal方法"></a><code>parseInternal</code>方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建builder</span></span><br><span class="line">BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition();</span><br><span class="line">String parentName = getParentName(element);</span><br><span class="line"><span class="keyword">if</span> (parentName != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//是否有父定义，默认为空，表示顶层 定义 </span></span><br><span class="line">   builder.getRawBeanDefinition().setParentName(parentName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回与元素对应的bean class</span></span><br><span class="line"><span class="comment">//注意，对于应用程序层的类，通常最好重写getBeanClassName，以避免直接依赖于bean实现类。BeanDefinitionParser及其NamespaceHandler可以在IDE插件中使用，即使应用程序类不在插件的类路径中。</span></span><br><span class="line">Class&lt;?&gt; beanClass = getBeanClass(element);</span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">   builder.getRawBeanDefinition().setBeanClass(beanClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//没有设置 beanClass,则通过beanClassName去获取对应的bean</span></span><br><span class="line">   String beanClassName = getBeanClassName(element);</span><br><span class="line">   <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.getRawBeanDefinition().setBeanClassName(beanClassName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">builder.getRawBeanDefinition().setSource(parserContext.extractSource(element));</span><br><span class="line">BeanDefinition containingBd = parserContext.getContainingBeanDefinition();</span><br><span class="line"><span class="keyword">if</span> (containingBd != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//内部bean 定义从父级bean定义中获取scope</span></span><br><span class="line">   <span class="comment">// Inner bean definition must receive same scope as containing bean.</span></span><br><span class="line">   builder.setScope(containingBd.getScope());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (parserContext.isDefaultLazyInit()) &#123;</span><br><span class="line">   <span class="comment">// Default-lazy-init applies to custom bean definitions as well.</span></span><br><span class="line">   builder.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//留给子类去重写的方法，将xml标签属性等映射为bean 定义</span></span><br><span class="line">doParse(element, parserContext, builder);</span><br><span class="line"><span class="keyword">return</span> builder.getBeanDefinition();</span><br></pre></td></tr></table></figure><h6 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h6><p>解析流程：</p><ol><li><p>创建builder</p></li><li><p>设置父级定义名称</p></li><li><p>设置要转换成bean类，通过<code>getBeanClass</code>方法或者<code>getBeanClassName</code></p></li><li><p>根据父级bean定义设置scope</p></li><li><p>设置lazyInit属性</p></li><li><p>调用<code>doParse</code>方法将xml对应的相关属性设置到builder中</p></li><li><p>获取<code>BeanDefinition</code></p><p>对于只需要将xml映射为bean这样简单的解析情形，可以继承这个类实现<code>doParse</code>方法，将xml的属性设置到<code>BeanDefinitionBuilder</code>中即可。</p></li></ol><h3 id="ContextNamespaceHandler上下文命名空间解析器"><a href="#ContextNamespaceHandler上下文命名空间解析器" class="headerlink" title="ContextNamespaceHandler上下文命名空间解析器"></a><code>ContextNamespaceHandler</code>上下文命名空间解析器</h3><p>继承自<code>NamespaceHandlerSupport</code>类，在<code>init</code>方法中注册了<code>context</code>命名空间下的标签解析类。用来解析命名空间地址<code>http://www.springframework.org/schema/context</code>。</p><h4 id="context命名空间下的自定义标签"><a href="#context命名空间下的自定义标签" class="headerlink" title="context命名空间下的自定义标签"></a><code>context</code>命名空间下的自定义标签</h4><p><code>init</code>方法为每个标签都注册了一个解析类</p><table><thead><tr><th>标签</th><th>解析类</th></tr></thead><tbody><tr><td><code>property-placeholder</code></td><td><code>org.springframework.context.config.PropertyPlaceholderBeanDefinitionParser</code></td></tr><tr><td><code>property-override</code></td><td><code>org.springframework.context.config.PropertyOverrideBeanDefinitionParser</code></td></tr><tr><td><code>annotation-config</code></td><td><code>org.springframework.context.annotation.AnnotationConfigBeanDefinitionParser</code></td></tr><tr><td><code>component-scan</code></td><td><code>org.springframework.context.annotation.ComponentScanBeanDefinitionParser</code></td></tr><tr><td><code>load-time-weaver</code></td><td><code>org.springframework.context.config.LoadTimeWeaverBeanDefinitionParser</code></td></tr><tr><td><code>spring-configured</code></td><td><code>org.springframework.context.config.SpringConfiguredBeanDefinitionParser</code></td></tr><tr><td><code>mbean-export</code></td><td><code>org.springframework.context.config.MBeanExportBeanDefinitionParser</code></td></tr><tr><td><code>mbean-server</code></td><td><code>org.springframework.context.config.MBeanServerBeanDefinitionParser</code></td></tr></tbody></table><h5 id="property-placeholder标签解析"><a href="#property-placeholder标签解析" class="headerlink" title="property-placeholder标签解析"></a><code>property-placeholder</code>标签解析</h5><p><code>org.springframework.context.config.PropertyPlaceholderBeanDefinitionParser</code> 类用来解析该标签。继承自<code>AbstractPropertyLoadingBeanDefinitionParser</code>， 该类又继承自<code>AbstractSingleBeanDefinitionParser</code>，因此只返回单个<code>BeanDefinition</code>。</p><p><code>AbstractPropertyLoadingBeanDefinitionParser</code>的<code>doParse</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">   String location = element.getAttribute(<span class="string">&quot;location&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(location)) &#123;</span><br><span class="line">      location = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(location);</span><br><span class="line">      String[] locations = StringUtils.commaDelimitedListToStringArray(location);</span><br><span class="line">      builder.addPropertyValue(<span class="string">&quot;locations&quot;</span>, locations);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String propertiesRef = element.getAttribute(<span class="string">&quot;properties-ref&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(propertiesRef)) &#123;</span><br><span class="line">      builder.addPropertyReference(<span class="string">&quot;properties&quot;</span>, propertiesRef);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String fileEncoding = element.getAttribute(<span class="string">&quot;file-encoding&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(fileEncoding)) &#123;</span><br><span class="line">      builder.addPropertyValue(<span class="string">&quot;fileEncoding&quot;</span>, fileEncoding);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String order = element.getAttribute(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(order)) &#123;</span><br><span class="line">      builder.addPropertyValue(<span class="string">&quot;order&quot;</span>, Integer.valueOf(order));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   builder.addPropertyValue(<span class="string">&quot;ignoreResourceNotFound&quot;</span>,</span><br><span class="line">         Boolean.valueOf(element.getAttribute(<span class="string">&quot;ignore-resource-not-found&quot;</span>)));</span><br><span class="line"></span><br><span class="line">   builder.addPropertyValue(<span class="string">&quot;localOverride&quot;</span>,</span><br><span class="line">         Boolean.valueOf(element.getAttribute(<span class="string">&quot;local-override&quot;</span>)));</span><br><span class="line"></span><br><span class="line">   builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出只是简单的将xml标签的属性取出并设置到builder中。</p><p>再看看<code>PropertyPlaceholderBeanDefinitionParser</code>的<code>doParse</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.doParse(element, parserContext, builder);</span><br><span class="line"></span><br><span class="line">   builder.addPropertyValue(<span class="string">&quot;ignoreUnresolvablePlaceholders&quot;</span>,</span><br><span class="line">         Boolean.valueOf(element.getAttribute(<span class="string">&quot;ignore-unresolvable&quot;</span>)));</span><br><span class="line"></span><br><span class="line">   String systemPropertiesModeName = element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(systemPropertiesModeName) &amp;&amp;</span><br><span class="line">         !systemPropertiesModeName.equals(SYSTEM_PROPERTIES_MODE_DEFAULT)) &#123;</span><br><span class="line">       <span class="comment">// system-properties-mode 不是 ENVIRONMENT</span></span><br><span class="line">      builder.addPropertyValue(<span class="string">&quot;systemPropertiesModeName&quot;</span>, <span class="string">&quot;SYSTEM_PROPERTIES_MODE_&quot;</span> + systemPropertiesModeName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (element.hasAttribute(<span class="string">&quot;value-separator&quot;</span>)) &#123;</span><br><span class="line">      builder.addPropertyValue(<span class="string">&quot;valueSeparator&quot;</span>, element.getAttribute(<span class="string">&quot;value-separator&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (element.hasAttribute(<span class="string">&quot;trim-values&quot;</span>)) &#123;</span><br><span class="line">      builder.addPropertyValue(<span class="string">&quot;trimValues&quot;</span>, element.getAttribute(<span class="string">&quot;trim-values&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (element.hasAttribute(<span class="string">&quot;null-value&quot;</span>)) &#123;</span><br><span class="line">      builder.addPropertyValue(<span class="string">&quot;nullValue&quot;</span>, element.getAttribute(<span class="string">&quot;null-value&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的bean ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">   <span class="comment">// As of Spring 3.1, the default value of system-properties-mode has changed from</span></span><br><span class="line">   <span class="comment">// &#x27;FALLBACK&#x27; to &#x27;ENVIRONMENT&#x27;. This latter value indicates that resolution of</span></span><br><span class="line">   <span class="comment">// placeholders against system properties is a function of the Environment and</span></span><br><span class="line">   <span class="comment">// its current set of PropertySources.</span></span><br><span class="line">   <span class="keyword">if</span> (SYSTEM_PROPERTIES_MODE_DEFAULT.equals(element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE))) &#123;</span><br><span class="line">       <span class="comment">//3.1 开始 system-properties-mode 默认值为 ENVIRONMENT, </span></span><br><span class="line">      <span class="keyword">return</span> PropertySourcesPlaceholderConfigurer.class;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The user has explicitly specified a value for system-properties-mode: revert to</span></span><br><span class="line">   <span class="comment">// PropertyPlaceholderConfigurer to ensure backward compatibility with 3.0 and earlier.</span></span><br><span class="line">    <span class="comment">//3.0以前用这个</span></span><br><span class="line">   <span class="keyword">return</span> PropertyPlaceholderConfigurer.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h6><p>从<code>property-placeholder</code>标签中解析出的属性：</p><table><thead><tr><th>xml属性</th><th>bean 属性</th></tr></thead><tbody><tr><td>location</td><td>locations</td></tr><tr><td>properties-ref</td><td>properties</td></tr><tr><td>file-encoding</td><td>fileEncoding</td></tr><tr><td>order</td><td>order</td></tr><tr><td>ignore-resource-not-found</td><td>ignoreResourceNotFound</td></tr><tr><td>local-override</td><td>localOverride</td></tr><tr><td>ignore-unresolvable</td><td>ignoreUnresolvablePlaceholders</td></tr><tr><td>system-properties-mode</td><td>systemPropertiesModeName</td></tr><tr><td>value-separator</td><td>valueSeparator</td></tr><tr><td>trim-values</td><td>trimValues</td></tr><tr><td>null-value</td><td>nullValue</td></tr></tbody></table><h5 id="property-override标签解析"><a href="#property-override标签解析" class="headerlink" title="property-override标签解析"></a><code>property-override</code>标签解析</h5><p><code>org.springframework.context.config.PropertyOverrideBeanDefinitionParser</code>类用来解析该标签，与<code>property-placeholder</code>标签类似，该类也继承自<code>AbstractPropertyLoadingBeanDefinitionParser</code>，与<code>property-placeholder</code>标签有一些共有的属性。</p><p><code>doParse</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.doParse(element, parserContext, builder);</span><br><span class="line"></span><br><span class="line">   builder.addPropertyValue(<span class="string">&quot;ignoreInvalidKeys&quot;</span>,</span><br><span class="line">         Boolean.valueOf(element.getAttribute(<span class="string">&quot;ignore-unresolvable&quot;</span>)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getBeanClass</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">   <span class="keyword">return</span> PropertyOverrideConfigurer.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h6><p>从<code>property-override</code>标签中解析出的属性：</p><table><thead><tr><th>xml属性</th><th>bean 属性</th></tr></thead><tbody><tr><td>location</td><td>locations</td></tr><tr><td>properties-ref</td><td>properties</td></tr><tr><td>file-encoding</td><td>fileEncoding</td></tr><tr><td>order</td><td>order</td></tr><tr><td>ignore-resource-not-found</td><td>ignoreResourceNotFound</td></tr><tr><td>local-override</td><td>localOverride</td></tr><tr><td>ignore-unresolvable</td><td>ignoreInvalidKeys</td></tr></tbody></table><h5 id="annotation-config标签解析"><a href="#annotation-config标签解析" class="headerlink" title="annotation-config标签解析"></a><code>annotation-config</code>标签解析</h5><p><code>org.springframework.context.annotation.AnnotationConfigBeanDefinitionParser</code>用来解析该标签。该类直接实现了<code>BeanDefinitionParser</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   Object source = parserContext.extractSource(element);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Obtain bean definitions for all relevant BeanPostProcessors.</span></span><br><span class="line">    <span class="comment">// 获取所有相关 BeanPostProcessor 的bean定义。</span></span><br><span class="line">    <span class="comment">// 注册 ConfigurationClassPostProcessor，AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">    <span class="comment">// CommonAnnotationBeanPostProcessor, EventListenerMethodProcessor</span></span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; processorDefinitions =</span><br><span class="line">         AnnotationConfigUtils.registerAnnotationConfigProcessors(parserContext.getRegistry(), source);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register component for the surrounding &lt;context:annotation-config&gt; element.</span></span><br><span class="line">    <span class="comment">// 注册 &lt;context:annotation-config&gt; 标签代表的组件</span></span><br><span class="line">   CompositeComponentDefinition compDefinition = <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), source);</span><br><span class="line">    <span class="comment">//将该组件入栈，处理嵌套bean定义。</span></span><br><span class="line">    <span class="comment">//入栈代表当前组件是上层组件，后面注册的是其内部组件</span></span><br><span class="line">   parserContext.pushContainingComponent(compDefinition);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Nest the concrete beans in the surrounding component.</span></span><br><span class="line">    <span class="comment">//将上面注册的 BeanDefinitionHolder 作为组件的内部bean定义</span></span><br><span class="line">   <span class="keyword">for</span> (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123;</span><br><span class="line">      parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(processorDefinition));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Finally register the composite component.</span></span><br><span class="line">    <span class="comment">// 最后注册该组合组件，发布事件</span></span><br><span class="line">   parserContext.popAndRegisterContainingComponent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该解析器本身不返回bean 定义，只是注册其他相关的bean定义</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可以看到，该解析器注册了几个<code>BeanPostProcessor</code>， 用来处理注解配置，这里先不展开，后面再具体看一下这几个类的作用。其实整个解析器关键的代码只有这一句:</p><blockquote><p>AnnotationConfigUtils.registerAnnotationConfigProcessors(parserContext.getRegistry(), source);</p></blockquote><p>后面的代码用来保证整个解析链的完整性，需要发布解析完成的事件。</p><h5 id="component-scan标签解析"><a href="#component-scan标签解析" class="headerlink" title="component-scan标签解析"></a><code>component-scan</code>标签解析</h5><p><code>org.springframework.context.annotation.ComponentScanBeanDefinitionParser</code> 类用来解析该标签。该类直接实现了<code>BeanDefinitionParser</code>接口。</p><h6 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a><code>parse</code>方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取root 包名</span></span><br><span class="line">   String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line">    <span class="comment">//解析出完整的包名，配置的包名是可以写占位符的</span></span><br><span class="line">   basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);</span><br><span class="line">    <span class="comment">//将包名进行分隔，,; 可以配置多个包</span></span><br><span class="line">   String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</span><br><span class="line">         ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Actually scan for bean definitions and register them.</span></span><br><span class="line">    <span class="comment">// 配置 ClassPathBeanDefinitionScanner，主要包括 bean定义属性默认值，资源类型（**/*.class），</span></span><br><span class="line">    <span class="comment">//BeanNameGenerator，默认筛选注解类型(@Component), 以及筛选类型过滤器&lt;include-filter&gt;,&lt;exclude-filter&gt;</span></span><br><span class="line">   ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line">    <span class="comment">// 开始扫描所有bean定义</span></span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">   <span class="comment">// 注册组件， 这个解析器也调用了 AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source);方法注册BeanPostProcessor</span></span><br><span class="line">    registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h6><p>该解析器主要是配置一个<code>ClassPathBeanDefinitionScanner</code>，然后调用其<code>doScan</code>方法，默认扫描<code>@Component</code>注解的类，并且可以配置过滤器调整扫描范围。解析出来的扫描路径以<code>classpath*:</code>开头，因此可以扫描到jar里面的注解。</p><h5 id="load-time-weaver标签解析"><a href="#load-time-weaver标签解析" class="headerlink" title="load-time-weaver标签解析"></a><code>load-time-weaver</code>标签解析</h5><p><code>org.springframework.context.config.LoadTimeWeaverBeanDefinitionParser</code>标签用来解析该标签。继承自<code>org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser</code>，返回一个bean定义。</p><p><code>getBeanClassName</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getBeanClassName</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (element.hasAttribute(WEAVER_CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">      <span class="keyword">return</span> element.getAttribute(WEAVER_CLASS_ATTRIBUTE);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//默认返回 org.springframework.context.weaving.DefaultContextLoadTimeWeaver</span></span><br><span class="line">   <span class="keyword">return</span> DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doParse</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">   builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (isAspectJWeavingEnabled(element.getAttribute(ASPECTJ_WEAVING_ATTRIBUTE), parserContext)) &#123;</span><br><span class="line">       <span class="comment">//是否启用aspectj</span></span><br><span class="line">      <span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(ASPECTJ_WEAVING_ENABLER_BEAN_NAME)) &#123;</span><br><span class="line">          <span class="comment">//如果还没注册 org.springframework.context.config.internalAspectJWeavingEnabler 就注册</span></span><br><span class="line">         RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ASPECTJ_WEAVING_ENABLER_CLASS_NAME);</span><br><span class="line">         parserContext.registerBeanComponent(</span><br><span class="line">               <span class="keyword">new</span> BeanComponentDefinition(def, ASPECTJ_WEAVING_ENABLER_BEAN_NAME));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isBeanConfigurerAspectEnabled(parserContext.getReaderContext().getBeanClassLoader())) &#123;</span><br><span class="line">          <span class="comment">//如果引入了 org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect 类则调用</span></span><br><span class="line">          <span class="comment">//SpringConfiguredBeanDefinitionParser来解析标签</span></span><br><span class="line">         <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser().parse(element, parserContext);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="spring-configured标签解析"><a href="#spring-configured标签解析" class="headerlink" title="spring-configured标签解析"></a><code>spring-configured</code>标签解析</h5><p>该标签由<code>org.springframework.context.config.SpringConfiguredBeanDefinitionParser</code>来解析。</p><p><code>parse</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;  <span class="keyword">if</span>(!parserContext.getRegistry().containsBeanDefinition(BEAN_CONFIGURER_ASPECT_BEAN_NAME)) &#123;</span><br><span class="line">   <span class="comment">//如果没注册 org.springframework.context.config.internalBeanConfigurerAspect</span></span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">      <span class="comment">// org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect</span></span><br><span class="line">      def.setBeanClassName(BEAN_CONFIGURER_ASPECT_CLASS_NAME);</span><br><span class="line">      def.setFactoryMethodName(<span class="string">&quot;aspectOf&quot;</span>);</span><br><span class="line">      def.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">      def.setSource(parserContext.extractSource(element));</span><br><span class="line">      parserContext.registerBeanComponent(<span class="keyword">new</span> BeanComponentDefinition(def, BEAN_CONFIGURER_ASPECT_BEAN_NAME));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AopNamespaceHandler-Aop-命名空间解析器"><a href="#AopNamespaceHandler-Aop-命名空间解析器" class="headerlink" title="AopNamespaceHandler Aop 命名空间解析器"></a><code>AopNamespaceHandler</code> Aop 命名空间解析器</h3><p>用于<code>aop</code>命名空间的<code>NamespaceHandler</code>。继承自<code>NamespaceHandlerSupport</code>,注册以下<code>BeanDefinitionParser</code>:</p><table><thead><tr><th>标签</th><th>解析类</th></tr></thead><tbody><tr><td><code>config</code></td><td><code>ConfigBeanDefinitionParser</code></td></tr><tr><td><code>aspectj-autoproxy</code></td><td><code>AspectJAutoProxyBeanDefinitionParser</code></td></tr></tbody></table><p>注册<code>BeanDefinitionDecorator</code>:</p><table><thead><tr><th>属性</th><th>解析类</th></tr></thead><tbody><tr><td><code>scoped-proxy</code></td><td><code>ScopedProxyBeanDefinitionDecorator</code></td></tr></tbody></table><p>为<code>&lt;aop:config&gt;</code>标签提供一个<code>BeanDefinitionParser</code>。<code>config</code>标签可以包含嵌套的<code>pointcut</code>、<code>advisor</code>和<code>aspect</code>标签。</p><p><code>pointcut</code>标签允许使用简单的语法创建命名的<code>AspectJExpressionPointcut</code> bean:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;getNameCalls&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..ITestBean.getName(..))&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>advisor</code>标签，可以配置<code>org.springframework.aop.Advisor</code>并自动将其应用于<code>org.springframework.beans.factory.BeanFactory</code>中所有相关bean。<code>advisor</code>标签支持内联和引用<code>pointcut</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">id</span>=<span class="string">&quot;getAgeAdvisor&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *..ITestBean.getAge(..))&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">advice-ref</span>=<span class="string">&quot;getAgeCounter&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">id</span>=<span class="string">&quot;getNameAdvisor&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">pointcut-ref</span>=<span class="string">&quot;getNameCalls&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">advice-ref</span>=<span class="string">&quot;getNameCounter&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="lt-aop-config-gt-标签解析"><a href="#lt-aop-config-gt-标签解析" class="headerlink" title="&lt;aop:config&gt;标签解析"></a><code>&lt;aop:config&gt;</code>标签解析</h4><p><code>org.springframework.aop.config.ConfigBeanDefinitionParser</code>类用来解析该标签。实现了<code>BeanDefinitionParser</code> 接口</p><h5 id="parse方法："><a href="#parse方法：" class="headerlink" title="parse方法："></a><code>parse</code>方法：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   CompositeComponentDefinition compositeDef =</span><br><span class="line">         <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element));</span><br><span class="line">    <span class="comment">//标识当前组件是容器组件</span></span><br><span class="line">   parserContext.pushContainingComponent(compositeDef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册 AspectJAwareAdvisorAutoProxyCreator</span></span><br><span class="line">   configureAutoProxyCreator(parserContext, element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析子标签 pointcut advisor aspect</span></span><br><span class="line">   List&lt;Element&gt; childElts = DomUtils.getChildElements(element);</span><br><span class="line">   <span class="keyword">for</span> (Element elt: childElts) &#123;</span><br><span class="line">      String localName = parserContext.getDelegate().getLocalName(elt);</span><br><span class="line">      <span class="keyword">if</span> (POINTCUT.equals(localName)) &#123;</span><br><span class="line">         parsePointcut(elt, parserContext);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ADVISOR.equals(localName)) &#123;</span><br><span class="line">         parseAdvisor(elt, parserContext);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ASPECT.equals(localName)) &#123;</span><br><span class="line">         parseAspect(elt, parserContext);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈并注册当前容器组件，容器组件会发布事件</span></span><br><span class="line">   parserContext.popAndRegisterContainingComponent();</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="parsePointcut-方法解析切入点"><a href="#parsePointcut-方法解析切入点" class="headerlink" title="parsePointcut 方法解析切入点"></a><code>parsePointcut </code>方法解析切入点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractBeanDefinition <span class="title">parsePointcut</span><span class="params">(Element pointcutElement, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// id</span></span><br><span class="line">   String id = pointcutElement.getAttribute(ID);</span><br><span class="line">    <span class="comment">// 表达式</span></span><br><span class="line">   String expression = pointcutElement.getAttribute(EXPRESSION);</span><br><span class="line"></span><br><span class="line">   AbstractBeanDefinition pointcutDefinition = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 将当前元素入栈</span></span><br><span class="line">      <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> PointcutEntry(id));</span><br><span class="line">       <span class="comment">// 创建切入点对应的bean定义，bean类型为 AspectJExpressionPointcut</span></span><br><span class="line">      pointcutDefinition = createPointcutDefinition(expression);</span><br><span class="line">      pointcutDefinition.setSource(parserContext.extractSource(pointcutElement));</span><br><span class="line"></span><br><span class="line">      String pointcutBeanName = id;</span><br><span class="line">       <span class="comment">// 注册当前bean定义</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(pointcutBeanName)) &#123;</span><br><span class="line">         parserContext.getRegistry().registerBeanDefinition(pointcutBeanName, pointcutDefinition);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         pointcutBeanName = parserContext.getReaderContext().registerWithGeneratedName(pointcutDefinition);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将切入点组件加入到 config标签容器组件中，作为其内部组件</span></span><br><span class="line">      parserContext.registerComponent(</span><br><span class="line">            <span class="keyword">new</span> PointcutComponentDefinition(pointcutBeanName, pointcutDefinition, expression));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">// 解析完当前切入点元素，出栈</span></span><br><span class="line">      <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> pointcutDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="parseAdvisor-解析advisor标签"><a href="#parseAdvisor-解析advisor标签" class="headerlink" title="parseAdvisor 解析advisor标签"></a><code>parseAdvisor</code> 解析<code>advisor</code>标签</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseAdvisor</span><span class="params">(Element advisorElement, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对应的bean定义，bean类型为 DefaultBeanFactoryPointcutAdvisor, advice-ref 属性需要引用一个实现了org.aopalliance.aop.Advice 接口的bean</span></span><br><span class="line">   AbstractBeanDefinition advisorDef = createAdvisorBeanDefinition(advisorElement, parserContext);</span><br><span class="line">   String id = advisorElement.getAttribute(ID);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> AdvisorEntry(id));</span><br><span class="line">      String advisorBeanName = id;</span><br><span class="line">       <span class="comment">//注册当前bean定义</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(advisorBeanName)) &#123;</span><br><span class="line">         parserContext.getRegistry().registerBeanDefinition(advisorBeanName, advisorDef);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         advisorBeanName = parserContext.getReaderContext().registerWithGeneratedName(advisorDef);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//解析pointcut</span></span><br><span class="line">      Object pointcut = parsePointcutProperty(advisorElement, parserContext);</span><br><span class="line">       <span class="comment">//如果是pointcut bean定义，其实就是expression</span></span><br><span class="line">      <span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> BeanDefinition) &#123;</span><br><span class="line">         advisorDef.getPropertyValues().add(POINTCUT, pointcut);</span><br><span class="line">         parserContext.registerComponent(</span><br><span class="line">               <span class="keyword">new</span> AdvisorComponentDefinition(advisorBeanName, advisorDef, (BeanDefinition) pointcut));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">         advisorDef.getPropertyValues().add(POINTCUT, <span class="keyword">new</span> RuntimeBeanReference((String) pointcut));</span><br><span class="line">         parserContext.registerComponent(</span><br><span class="line">               <span class="keyword">new</span> AdvisorComponentDefinition(advisorBeanName, advisorDef));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="parseAspect-解析切面"><a href="#parseAspect-解析切面" class="headerlink" title="parseAspect 解析切面"></a><code>parseAspect</code> 解析切面</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseAspect</span><span class="params">(Element aspectElement, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   String aspectId = aspectElement.getAttribute(ID);</span><br><span class="line">    <span class="comment">//切面bean</span></span><br><span class="line">   String aspectName = aspectElement.getAttribute(REF);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> AspectEntry(aspectId, aspectName));</span><br><span class="line">      List&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      List&lt;BeanReference&gt; beanReferences = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//解析declare-parents 子标签， 对应的bean为 DeclareParentsAdvisor</span></span><br><span class="line">      List&lt;Element&gt; declareParents = DomUtils.getChildElementsByTagName(aspectElement, DECLARE_PARENTS);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = METHOD_INDEX; i &lt; declareParents.size(); i++) &#123;</span><br><span class="line">         Element declareParentsElement = declareParents.get(i);</span><br><span class="line">         beanDefinitions.add(parseDeclareParents(declareParentsElement, parserContext));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We have to parse &quot;advice&quot; and all the advice kinds in one loop, to get the</span></span><br><span class="line">      <span class="comment">// ordering semantics right.</span></span><br><span class="line">       <span class="comment">// 必须得在一个循环中解析出所有的advice，保证其顺序</span></span><br><span class="line">      NodeList nodeList = aspectElement.getChildNodes();</span><br><span class="line">      <span class="keyword">boolean</span> adviceFoundAlready = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">         Node node = nodeList.item(i);</span><br><span class="line">         <span class="keyword">if</span> (isAdviceNode(node, parserContext)) &#123;</span><br><span class="line">             <span class="comment">// 通知类型 before，after，after-returning，after-throwing，around</span></span><br><span class="line">            <span class="keyword">if</span> (!adviceFoundAlready) &#123;</span><br><span class="line">               adviceFoundAlready = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">if</span> (!StringUtils.hasText(aspectName)) &#123;</span><br><span class="line">                  parserContext.getReaderContext().error(</span><br><span class="line">                        <span class="string">&quot;&lt;aspect&gt; tag needs aspect bean reference via &#x27;ref&#x27; attribute when declaring advices.&quot;</span>,</span><br><span class="line">                        aspectElement, <span class="keyword">this</span>.parseState.snapshot());</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               beanReferences.add(<span class="keyword">new</span> RuntimeBeanReference(aspectName));</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 为每个 advice创建 AspectJPointcutAdvisor</span></span><br><span class="line">            AbstractBeanDefinition advisorDefinition = parseAdvice(</span><br><span class="line">                  aspectName, i, aspectElement, (Element) node, parserContext, beanDefinitions, beanReferences);</span><br><span class="line">            beanDefinitions.add(advisorDefinition);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      AspectComponentDefinition aspectComponentDefinition = createAspectComponentDefinition(</span><br><span class="line">            aspectElement, aspectId, beanDefinitions, beanReferences, parserContext);</span><br><span class="line">      parserContext.pushContainingComponent(aspectComponentDefinition);</span><br><span class="line"></span><br><span class="line">      List&lt;Element&gt; pointcuts = DomUtils.getChildElementsByTagName(aspectElement, POINTCUT);</span><br><span class="line">       <span class="comment">//解析切入点，跟单独定义在外面的切入点一样解析</span></span><br><span class="line">      <span class="keyword">for</span> (Element pointcutElement : pointcuts) &#123;</span><br><span class="line">         parsePointcut(pointcutElement, parserContext);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      parserContext.popAndRegisterContainingComponent();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h5><p>注册的<code>BeanDefinition</code>如下：</p><table><thead><tr><th>标签</th><th>BeanDefinition</th></tr></thead><tbody><tr><td>config</td><td><code>AspectJAwareAdvisorAutoProxyCreator</code></td></tr><tr><td>pointcut</td><td>AspectJExpressionPointcut</td></tr><tr><td>advisor</td><td>DefaultBeanFactoryPointcutAdvisor</td></tr><tr><td>before，after，after-returning，after-throwing，around</td><td>AspectJPointcutAdvisor</td></tr><tr><td>declare-parents</td><td>DeclareParentsAdvisor</td></tr></tbody></table><h4 id="lt-aop-aspectj-autoproxy-gt-标签解析"><a href="#lt-aop-aspectj-autoproxy-gt-标签解析" class="headerlink" title="&lt;aop:aspectj-autoproxy&gt;标签解析"></a><code>&lt;aop:aspectj-autoproxy&gt;</code>标签解析</h4><p><code>AspectJAutoProxyBeanDefinitionParser</code>类用来解析该标签，实现了<code>BeanDefinitionParser</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">//注册或增强 AnnotationAwareAspectJAutoProxyCreator类</span></span><br><span class="line">   <span class="comment">// 解析 proxy-target-class和 expose-proxy</span></span><br><span class="line">    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">   extendBeanDefinition(element, parserContext);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">extendBeanDefinition</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">   BeanDefinition beanDef =</span><br><span class="line">         parserContext.getRegistry().getBeanDefinition(AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">   <span class="keyword">if</span> (element.hasChildNodes()) &#123;</span><br><span class="line">       <span class="comment">//解析 include 标签</span></span><br><span class="line">      addIncludePatterns(element, parserContext, beanDef);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addIncludePatterns</span><span class="params">(Element element, ParserContext parserContext, BeanDefinition beanDef)</span> </span>&#123;</span><br><span class="line">   ManagedList&lt;TypedStringValue&gt; includePatterns = <span class="keyword">new</span> ManagedList&lt;&gt;();</span><br><span class="line">   NodeList childNodes = element.getChildNodes();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childNodes.getLength(); i++) &#123;</span><br><span class="line">      Node node = childNodes.item(i);</span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">         Element includeElement = (Element) node;</span><br><span class="line">         TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(includeElement.getAttribute(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">         valueHolder.setSource(parserContext.extractSource(includeElement));</span><br><span class="line">         includePatterns.add(valueHolder);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!includePatterns.isEmpty()) &#123;</span><br><span class="line">      includePatterns.setSource(parserContext.extractSource(element));</span><br><span class="line">      beanDef.getPropertyValues().add(<span class="string">&quot;includePatterns&quot;</span>, includePatterns);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h6><p>注册的<code>BeanDefinition</code>如下：</p><table><thead><tr><th>标签</th><th>BeanDefinition</th></tr></thead><tbody><tr><td>aspectj-autoproxy</td><td>AnnotationAwareAspectJAutoProxyCreator</td></tr></tbody></table><h3 id="MvcNamespaceHandler解析MVC命名空间"><a href="#MvcNamespaceHandler解析MVC命名空间" class="headerlink" title="MvcNamespaceHandler解析MVC命名空间"></a><code>MvcNamespaceHandler</code>解析MVC命名空间</h3><p>该类<code>init</code>方法中注册了下面的解析器：</p><table><thead><tr><th>annotation-driven</th><th>AnnotationDrivenBeanDefinitionParser</th></tr></thead><tbody><tr><td>default-servlet-handler</td><td>DefaultServletHandlerBeanDefinitionParser</td></tr><tr><td>interceptors</td><td>InterceptorsBeanDefinitionParser</td></tr><tr><td>resources</td><td>ResourcesBeanDefinitionParser</td></tr><tr><td>view-controller</td><td>ViewControllerBeanDefinitionParser</td></tr><tr><td>redirect-view-controller</td><td>ViewControllerBeanDefinitionParser</td></tr><tr><td>status-controller</td><td>ViewControllerBeanDefinitionParser</td></tr><tr><td>view-resolvers</td><td>ViewResolversBeanDefinitionParser</td></tr><tr><td>tiles-configurer</td><td>TilesConfigurerBeanDefinitionParser</td></tr><tr><td>freemarker-configurer</td><td>FreeMarkerConfigurerBeanDefinitionParser</td></tr><tr><td>groovy-configurer</td><td>GroovyMarkupConfigurerBeanDefinitionParser</td></tr><tr><td>script-template-configurer</td><td>ScriptTemplateConfigurerBeanDefinitionParser</td></tr><tr><td>cors</td><td>CorsBeanDefinitionParser</td></tr></tbody></table><p>后面再专门写一篇讲MVC的。</p><h2 id="自定义命名空间示例"><a href="#自定义命名空间示例" class="headerlink" title="自定义命名空间示例"></a>自定义命名空间示例</h2><p>自定义命名空间可以分为步：</p><ol><li>定义<code>NamespaceHandler</code></li><li>定义命名空间地址，创建<code>META-INF/spring.handlers</code>文件，注册<code>NamespaceHandler</code></li><li>如果<code>NamespaceHandler</code>继承自<code>NamespaceHandlerSupport</code>，则定义<code>BeanDefinitionParser</code>。用来解析具体的标签</li></ol><h3 id="自定义NamespaceHandler"><a href="#自定义NamespaceHandler" class="headerlink" title="自定义NamespaceHandler"></a>自定义<code>NamespaceHandler</code></h3><p>为了方便，通常是继承<code>NamespaceHandlerSupport</code>。在<code>init</code>方法中注册标签解析器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;start-up&quot;</span>,<span class="keyword">new</span> MyNamespaceStartUpBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册NamespaceHandler"><a href="#注册NamespaceHandler" class="headerlink" title="注册NamespaceHandler"></a>注册<code>NamespaceHandler</code></h3><p>在<code>META-INF</code>目录下创建<code>spring.handlers</code>文件，文件内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;my &#x3D;cn.sexycode.spring.study.chapter3.MyNamespaceHandler</span><br></pre></td></tr></table></figure><p>Spring 在会读到自定义命名空间时，从这个文件中解析对应的handler。<code>=</code> 前面为命名空间地址</p><h3 id="实现BeanDefinitionParser"><a href="#实现BeanDefinitionParser" class="headerlink" title="实现BeanDefinitionParser"></a>实现<code>BeanDefinitionParser</code></h3><p>由于handler继承自<code>NamespaceHandlerSupport</code>，那么我们可以实现这个接口用来解析标签。Spring 为我们提供了一个抽象类，用来只返回一个bean 定义的时候使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNamespaceStartUpBeanDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractSingleBeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">        <span class="comment">// 这里我们注册的bean为 MyBeanPostProcessor, 换成我们实际想要注册的类，这里仅供演示</span></span><br><span class="line">        <span class="keyword">return</span> MyBeanPostProcessor.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldGenerateId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为我们生成id</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>上述几步之后，我们就可以在例子中使用了。xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:my</span>=<span class="string">&quot;http://www.springframework.org/schema/my&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my:start-up</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为我们没有定义dtd，导致无法通过校验。我们使用时可以设置为不校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNamespaceHandlerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初始化一个bean 工厂</span></span><br><span class="line">        DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 2. 初始化XmlBeanDefinitionReader,负责从xml文件中读取bean定义</span></span><br><span class="line">        XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">        <span class="comment">//不校验dtd</span></span><br><span class="line">        reader.setValidating(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 3. 加载bean 定义的入口方法</span></span><br><span class="line">        reader.loadBeanDefinitions(<span class="string">&quot;MyNamespaceHandlerDemo.xml&quot;</span>);</span><br><span class="line">        System.out.println(factory.getBean(MyBeanPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>cn.sexycode.spring.study.chapter3.MyBeanPostProcessor@78b1cc93</p></blockquote><p>可以看到已经正确注册到容器中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自定义命名空间解析&quot;&gt;&lt;a href=&quot;#自定义命名空间解析&quot; class=&quot;headerlink&quot; title=&quot;自定义命名空间解析&quot;&gt;&lt;/a&gt;自定义命名空间解析&lt;/h1&gt;&lt;p&gt;当我们想要扩展Spring 的配置时，可以定义我们自己的标签，然后解析成 bean定
      
    
    </summary>
    
    
      <category term="自定义" scheme="http://qzztf.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
      <category term="命名空间" scheme="http://qzztf.com/tags/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    
      <category term="NamespaceHandler" scheme="http://qzztf.com/tags/NamespaceHandler/"/>
    
  </entry>
  
  <entry>
    <title>Spring ApplicationContext初始化过程</title>
    <link href="http://qzztf.com/post/736b/"/>
    <id>http://qzztf.com/post/736b/</id>
    <published>2019-05-13T06:31:43.000Z</published>
    <updated>2024-06-16T07:25:26.148Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>ApplicationContext</code>初始化过程中各组件所处的位置。</p><p><img src="/post/736b/1557729188468.png" alt="初始化"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;code&gt;ApplicationContext&lt;/code&gt;初始化过程中各组件所处的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post/736b/1557729188468.png&quot; alt=&quot;初始化&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="初始化" scheme="http://qzztf.com/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
      <category term="ApplicationContext" scheme="http://qzztf.com/tags/ApplicationContext/"/>
    
  </entry>
  
  <entry>
    <title>Spring 常用接口</title>
    <link href="http://qzztf.com/post/dac1/"/>
    <id>http://qzztf.com/post/dac1/</id>
    <published>2019-03-18T08:26:06.000Z</published>
    <updated>2024-06-16T07:25:26.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-常用接口"><a href="#Spring-常用接口" class="headerlink" title="Spring 常用接口"></a>Spring 常用接口</h1><h2 id="Bean-工厂相关"><a href="#Bean-工厂相关" class="headerlink" title="Bean 工厂相关"></a>Bean 工厂相关</h2><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p><img src="/post/dac1/59e2e5d2.png" alt="类图"></p><p>这个接口是访问Spring bean 容器的顶层接口。实现类会持有一些bean定义，每一个都有唯一的名称。根据bean定义，这个工厂将返回一个独立的（原型设计模式），或者是一个共享的实例(单例模式的强力替代品，实例在工厂的生存周期内是一个单例),返回的实例类型取决于工厂配置。</p><p>这种方式的要点是BeanFactory是应用程序组件的注册中心，并集中配置应用的组件(例如，单个对象不再需要读取配置文件)。</p><h4 id="ListableBeanFactory"><a href="#ListableBeanFactory" class="headerlink" title="ListableBeanFactory"></a>ListableBeanFactory</h4><p>继承自<code>BeanFactory</code>, 这个接口的用途是枚举所有bean 实例，而不是客户端通过名称一个个查找。</p><h4 id="HierarchicalBeanFactory"><a href="#HierarchicalBeanFactory" class="headerlink" title="HierarchicalBeanFactory"></a>HierarchicalBeanFactory</h4><p>这个接口用来实现工厂的继承关系，</p><h4 id="AutowireCapableBeanFactory"><a href="#AutowireCapableBeanFactory" class="headerlink" title="AutowireCapableBeanFactory"></a>AutowireCapableBeanFactory</h4><p>此工厂提供bean自动注入功能。</p><h4 id="ConfigurableBeanFactory"><a href="#ConfigurableBeanFactory" class="headerlink" title="ConfigurableBeanFactory"></a>ConfigurableBeanFactory</h4><p>提供配置bean工厂的功能，但是此工厂一般是框架内部使用。</p><h4 id="ConfigurableListableBeanFactory"><a href="#ConfigurableListableBeanFactory" class="headerlink" title="ConfigurableListableBeanFactory"></a>ConfigurableListableBeanFactory</h4><p>提供分析和修改bean定义和预初始化单例bean的功能。</p><h3 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h3><p>用于类型转换的服务接口。这是转换系统的入口点。调用<code>convert(Object, Class)</code>方法来使用此系统执行线程安全类型转换</p><h3 id="AliasRegistry"><a href="#AliasRegistry" class="headerlink" title="AliasRegistry"></a>AliasRegistry</h3><p>用来注册别名的顶层接口</p><h4 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h4><p>用来注册bean 定义</p><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>接口由BeanFactory中的对象实现，这些对象本身是用于单个对象的工厂。如果一个bean实现了这个接口，那么它将被用作要公开的对象的工厂，而不是将自己公开的bean实例。</p><p><strong>注意:实现此接口的bean不能作为普通bean使用。FactoryBean是以bean形式定义的，但是bean引用公开的对象(<code>getObject()</code>)总是它创建的对象。</strong></p><p><code>FactoryBean</code>s可以支持单例和原型，可以根据需要创建对象，也可以在启动时创建对象。<code>SmartFactoryBean</code>接口允许公开更细粒度的行为元数据。</p><p>这个接口在框架本身中大量使用，例如在AOP <code>org.springframework.aop.framework.ProxyFactoryBean</code>或<code>org.springframework.jndi.JndiObjectFactoryBean</code>中。它也可以用于定制组件; 然而，这只在基础组件代码中很常见。<br><code>FactoryBean</code>是一个编程契约。实现不应该依赖于<code>annotation-driven</code>注入或其他反射工具。可能会在启动过程中提前调用<code>getObjectType()</code> 和<code>getObject()</code>，甚至比任何后处理器设置都要早。如果需要访问其他bean，请实现<code>BeanFactoryAware</code>并通过编写代码获取。</p><p>最后，<code>FactoryBean</code>对象参与bean工厂的bean创建同步过程。通常不需要内部同步，只需要在<code>FactoryBean</code>本身(或类似的东西)中进行延迟初始化即可</p><h3 id="SmartFactoryBean"><a href="#SmartFactoryBean" class="headerlink" title="SmartFactoryBean"></a>SmartFactoryBean</h3><p><code>FactoryBean</code>接口的扩展。当<code>isSingleton()</code>实现返回<code>false</code>而没有明确表示独立实例时，实现类可能会指示它们是否总是返回独立实例。</p><p>如果它们的<code>isSingleton()</code>实现返回false，那么不实现这个扩展接口的纯<code>FactoryBean</code>实现类将始终返回独立实例;只有在需要时才访问公开的对象。</p><p><strong>注意:这个接口是一个特殊用途的接口，主要用于框架内部和协作框架内部。通常，应用程序提供的<code>FactoryBean</code>应该简单地实现普通的<code>FactoryBean</code>接口。新的方法可能会被添加到这个扩展的接口中.</strong></p><h3 id="BeanNameGenerator"><a href="#BeanNameGenerator" class="headerlink" title="BeanNameGenerator"></a>BeanNameGenerator</h3><p>用于为bean定义生成bean名称的策略接口</p><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>允许自定义修改应用程序上下文的bean定义，调整上下文的底层bean工厂的bean属性值。</p><p>应用程序上下文可以自动检测bean定义中的<code>BeanFactoryPostProcessor</code> bean，并在创建任何其他bean之前应用它们。</p><p>系统管理员使用自定义配置文件覆盖在应用程序上下文中配置的bean属性非常有用。</p><p>有关解决此类配置需求的开箱即用解决方案，请参见<code>PropertyResourceConfigurer</code>及其具体实现。</p><p><code>BeanFactoryPostProcessor</code>可以与bean定义交互并修改bean定义，但不能与bean实例交互。这样做可能会导致过早的bean实例化，破坏容器并导致意想不到的副作用。如果需要与bean实例交互，可以考虑实现<code>BeanPostProcessor</code>。</p><h4 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h4><p>扩展标准的<code>BeanFactoryPostProcessor</code> SPI，允许在常规的<code>BeanFactoryPostProcessor</code>检测开始之前注册更多的bean定义。特别是，<code>BeanDefinitionRegistryPostProcessor</code>可以注册更多的bean定义，这些bean定义又定义<code>BeanFactoryPostProcessor</code>实例。</p><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>工厂允许自定义修改新的bean实例的入口，例如检查标记接口或用代理包装它们。</p><p><code>ApplicationContext</code>可以自动检测bean定义中的<code>BeanPostProcessor</code> bean，并将它们应用于随后创建的任何bean。普通bean工厂允许编程式注册后处理程序，适用于通过该工厂创建的所有bean。</p><p>通常，通过标记接口或类似方法填充bean的后处理程序将实现<code>postProcessBeforeInitialization</code>方法，而使用代理包装bean的后处理器通常实现<code>postProcessAfterInitialization</code>方法.</p><h3 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="ImportSelector"></a>ImportSelector</h3><p>根据给定的选择标准(通常是一个或多个注解属性)确定应该导入哪个<code>@Configuration</code>类。<br><code>ImportSelector</code>可以实现以下任何一个感知接口，它们各自的方法将在<code>selectImports</code>之前被调用:</p><ul><li><code>EnvironmentAware</code></li><li><code>BeanFactoryAware</code></li><li><code>BeanClassLoaderAware</code></li><li><code>ResourceLoaderAware</code><br><code>ImportSelector</code>通常以与常规<code>@Import</code>注解相同的方式处理，但是，也可以推迟选择导入，直到处理完所有<code>@Configuration</code>类(有关详细信息，请参阅<code>DeferredImportSelector</code>)</li></ul><h4 id="DeferredImportSelector"><a href="#DeferredImportSelector" class="headerlink" title="DeferredImportSelector"></a>DeferredImportSelector</h4><p><code>ImportSelector</code>的一个变体，它在处理完所有<code>@Configuration</code> bean之后运行。当选择的导入是<code>@Conditional</code>时，这种类型的选择器特别有用。<br>实现类还可以扩展<code>org.springframework.core.Ordered</code>接口或使用<code>org.springframework.core.annotation.Order</code>注解，指示相对于其他<code>DeferredImportSelector</code>的优先级。</p><p>实现类还可以提供一个导入组（<code>getImportGroup()</code>），该导入组可以跨不同的选择器提供额外的排序和过滤逻辑.</p><h3 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h3><p>可以用来在处理<code>@Configuration</code>类时注册其他bean定义。在bean定义级别(与<code>@Bean</code>方法/实例级别相反)操作是需要的或必要的。<br>与<code>@Configuration</code>和<code>ImportSelector</code>一起，可以向<code>@Import</code>注解提供这种类型的类(或者也可以从<code>ImportSelector</code>返回)。<br><code>ImportBeanDefinitionRegistrar</code>可以实现以下任何一个可感知的接口，它们各自的方法将在<code>registerBeanDefinitions</code>之前被调用:</p><ul><li><code>EnvironmentAware</code></li><li><code>BeanFactoryAware</code></li><li><code>BeanClassLoaderAware</code></li><li><code>ResourceLoaderAware</code></li></ul><h2 id="应用上下文相关"><a href="#应用上下文相关" class="headerlink" title="应用上下文相关"></a>应用上下文相关</h2><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p><img src="/post/dac1/990d4ca9.png" alt="类图"></p><p>此接口用来为应用程序提供配置。在应用运行过程中，配置应该是只读的，但是可以根据实现类来实现重新加载。</p><p><code>ApplicationContext</code> 提供：</p><ul><li>访问应用组件的工厂方法，从<code>ListableBeanFactory</code> 接口继承而来。</li><li>通用的方式加载资源文件，从<code>ResourceLoader</code>接口继承而来。</li><li>向注册的监听器发布事件。从<code>ApplicationEventPublisher</code>接口继承而来。</li><li>转换消息，并支持国际化，从<code>MessageSource</code>接口继承而来。</li><li>继承父级上下文能力。后代上下文中的定义将保持优先。这意味着，比如说一个父上下文可以被整个web应用访问，然而每个servlet有它自己的子类上下文，这个上下文是和别的servlet隔离的。</li></ul><h4 id="ConfigurableApplicationContext"><a href="#ConfigurableApplicationContext" class="headerlink" title="ConfigurableApplicationContext"></a>ConfigurableApplicationContext</h4><p>此接口提供配置应用上下文的方法</p><h3 id="AttributeAccessor"><a href="#AttributeAccessor" class="headerlink" title="AttributeAccessor"></a>AttributeAccessor</h3><p>该接口定义用于向任意对象设置和访问元数据的通用协议。</p><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p>bean定义描述了一个bean实例的属性值、构造函数参数值和由具体实现提供的进一步信息。<br>这只是一个最小的接口:主要目的是允许<code>BeanFactoryPostProcessor</code>(如<code>PropertyPlaceholderConfigurer</code>)反省和修改属性值和bean其他的元数据</p><h4 id="AnnotatedBeanDefinition"><a href="#AnnotatedBeanDefinition" class="headerlink" title="AnnotatedBeanDefinition"></a>AnnotatedBeanDefinition</h4><p>bean定义的扩展接口，它暴露<code>AnnotationMetadata</code>的bean 类型——而不需要加载该类。</p><h2 id="类型元数据相关"><a href="#类型元数据相关" class="headerlink" title="类型元数据相关"></a>类型元数据相关</h2><h3 id="ClassMetadata"><a href="#ClassMetadata" class="headerlink" title="ClassMetadata"></a>ClassMetadata</h3><p>该接口定义特定类的抽象元数据，不需要加载该类。</p><h3 id="AnnotatedTypeMetadata"><a href="#AnnotatedTypeMetadata" class="headerlink" title="AnnotatedTypeMetadata"></a>AnnotatedTypeMetadata</h3><p>定义对特定类型(类<code>AnnotationMetadata</code>或方法<code>MethodMetadata</code>)的注解的访问，其方式不一定需要加载类</p><h3 id="AnnotationMetadata"><a href="#AnnotationMetadata" class="headerlink" title="AnnotationMetadata"></a>AnnotationMetadata</h3><p>定义访问特定类型注解的方式</p><h3 id="MethodMetadata"><a href="#MethodMetadata" class="headerlink" title="MethodMetadata"></a>MethodMetadata</h3><h3 id="MetadataReader"><a href="#MetadataReader" class="headerlink" title="MetadataReader"></a>MetadataReader</h3><p>用于访问类元数据的简单门面，由ASM<code>org.springframework.asm.ClassReader</code>类实现</p><h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>加载资源的策略接口(例如类路径或文件系统资源)。<code>org.springframework.context.ApplicationContext</code>需要提供此功能，以及扩展<code>org.springframework.core.io.support.ResourcePatternResolver</code>支持。</p><p><code>DefaultResourceLoader</code>是一个独立的实现，可以在<code>ApplicationContext</code>之外使用，也可以由<code>ResourceEditor</code>使用。</p><p>当在<code>ApplicationContext</code>中使用时，可以使用特定上下文的资源加载策略从字符串填充Resource类型和Resource数组的Bean属性</p><h4 id="ResourcePatternResolver"><a href="#ResourcePatternResolver" class="headerlink" title="ResourcePatternResolver"></a>ResourcePatternResolver</h4><p>用于将位置模式(例如，ant样式的路径模式)解析为资源对象的策略接口。</p><p>这是<code>ResourceLoader</code>接口的扩展。可以检查传入的ResourceLoader(比如在容器中运行时，通过<code>org.springframework.context.ResourceLoaderAware</code>)是否也实现了这个扩展接口。</p><p><code>PathMatchingResourcePatternResolver</code>是一个独立的实现，可以在<code>ApplicationContext</code>之外使用，<code>ResourceArrayPropertyEditor</code>也使用它来填充bean的资源数组属性。</p><p>可以与任何类型的位置模式(例如<code>/WEB-INF/*-context.xml</code>):输入模式必须匹配策略实现。这个接口只指定转换方法，而不是特定的模式格式。</p><p>这个接口还为类路径中所有匹配的资源提供了一个新的资源前缀<code>classpath*:</code>。注意，在这种情况下，资源位置应该是一个没有占位符的路径(例如<code>/beans.xml</code>); JAR文件或类目录可以包含多个同名文件</p><h3 id="MessageSource"><a href="#MessageSource" class="headerlink" title="MessageSource"></a>MessageSource</h3><p>用于解析消息的策略接口，支持此类消息的参数化和国际化。<br>Spring为生产提供了两种开箱即用的实现:</p><ul><li><code>org.springframework.context.support.ResourceBundleMessageSource</code>, 基于<code>java.util.ResourceBundle</code></li><li><code>org.springframework.context.support.ReloadableResourceBundleMessageSource</code> , 不重启的情况下重新加载消息定义</li></ul><h4 id="HierarchicalMessageSource"><a href="#HierarchicalMessageSource" class="headerlink" title="HierarchicalMessageSource"></a>HierarchicalMessageSource</h4><p>继承自<code>MessageSource</code>, 体现层次结构</p><h3 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h3><p>封装事件发布功能。作为<code>ApplicationContext</code>的顶级接口</p><h3 id="EnvironmentCapable"><a href="#EnvironmentCapable" class="headerlink" title="EnvironmentCapable"></a>EnvironmentCapable</h3><p>此接口标志着组件包含和暴露<code>Environment</code>引用。</p><p>所有Spring应用程序上下文都是<code>EnvironmentCapable</code>，并且该接口主要用于在框架方法中执行<code>instanceof</code>检查，这些框架方法接受<code>BeanFactory</code>实例(这些实例可能是，也可能不是实际的<code>ApplicationContext</code>实例)，以便在环境确实可用时与环境进行交互。</p><p>如前所述，<code>ApplicationContext</code>扩展了<code>EnvironmentCapable</code>，从而公开了<code>getEnvironment()</code>方法; 然而，<code>ConfigurableApplicationContext</code>重新定义了<code>getEnvironment()</code>，并缩小了方法签名的范围，返回一个<code>ConfigurableEnvironment</code>。其结果是，在从<code>ConfigurableApplicationContext</code>访问环境对象之前，<code>Environment</code>对象是“只读的”，此时也可以配置它</p><h3 id="PropertyResolver"><a href="#PropertyResolver" class="headerlink" title="PropertyResolver"></a>PropertyResolver</h3><p>此接口用于根据任何来源解析属性。</p><h4 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h4><p>此接口表示当前应用程序运行所在的环境。对应用程序环境的两个关键方面建模:<code>profiles</code>和<code>properties</code>。与属性访问相关的方法通过<code>PropertyResolver</code>父接口公开。</p><p><code>profile</code>是一个命名的bean定义逻辑组，只有在给定<code>profile</code>处于<code>active</code>状态时才向容器注册。可以将bean分配给一个<code>profile</code>，无论是在XML中定义的还是通过注解定义的; 有关语法细节，请参阅spring-beans 3.1 schema 或<code>@Profile</code>注解。与 profiles 相关的<code>Environment</code>对象的角色是确定哪些profiles(如果有的话)当前(<code>getActiveProfiles</code>)是<code>active</code>的，以及哪些profiles (如果有的话)在默认情况(<code>getDefaultProfiles</code>)下应该是<code>active</code>的。</p><p><code>Properties</code>几乎在所有的应用程序中都扮演着重要的角色，并且可能来自各种各样的源:属性文件、JVM系统属性、系统环境变量、JNDI、servlet上下文参数、特殊属性对象、Maps 等等。<code>Environment</code>对象与<code>Properties</code>之间的关系的作用是为用户提供一个方便的服务接口，用于配置<code>Properties</code>源并从中解析<code>Properties</code>。</p><p>在<code>ApplicationContext</code>中管理的bean可以注册为<code>EnvironmentAware</code> bean或<code>@Inject</code> <code>Environment</code>bean，以便直接查询<code>profile</code>状态或解析属性。</p><p>然而，在大多数情况下，应用级bean不需要直接与<code>Environment</code>交互，而是必须使用<code>$&#123;…&#125;</code>属性值替换为属性占位符配置程序，如<code>PropertySourcesPlaceholderConfigurer</code>，它本身是<code>EnvironmentAware</code>的，从Spring 3.1开始，默认情况下使用<code>&lt;context:property-placeholder/&gt;</code>注册。</p><p><code>environment</code>对象的配置必须通过<code>ConfigurableEnvironment</code>接口完成，该接口由所有<code>AbstractApplicationContext</code>子类的<code>getEnvironment()</code>方法返回。有关在应用程序上下文<code>refresh()</code>之前操作属性源的使用示例，请参阅<code>ConfigurableEnvironment</code> Javadoc。</p><h4 id="ConfigurableEnvironment"><a href="#ConfigurableEnvironment" class="headerlink" title="ConfigurableEnvironment"></a>ConfigurableEnvironment</h4><p>此接口提供设置<code>active</code>和<code>default</code>配置文件以及操作基础属性源的工具。允许客户端通过<code>ConfigurablePropertyResolver</code> 父接口设置和验证所需的属性、定制转换服务等等。</p><h4 id="ConfigurablePropertyResolver"><a href="#ConfigurablePropertyResolver" class="headerlink" title="ConfigurablePropertyResolver"></a>ConfigurablePropertyResolver</h4><p>此接口提供访问的工具和自定义转换属性值时使用的<code>ConversionService</code>。</p><h2 id="xml-解析与BeanDefinition-解析相关"><a href="#xml-解析与BeanDefinition-解析相关" class="headerlink" title="xml 解析与BeanDefinition 解析相关"></a>xml 解析与BeanDefinition 解析相关</h2><h3 id="NamespaceHandler"><a href="#NamespaceHandler" class="headerlink" title="NamespaceHandler"></a>NamespaceHandler</h3><p><code>DefaultBeanDefinitionDocumentReader</code>使用的基本接口，用于处理Spring XML配置文件中的自定义名称空间。</p><p>实现类将返回用于自定义顶级标签的<code>BeanDefinitionParser</code>接口的实现，以及用于自定义嵌套标签的<code>BeanDefinitionDecorator</code>接口的实现。</p><p>解析器将在遇到<code>&lt;beans&gt;</code>标签下的自定义标签时调用<code>parse</code>方法，并在遇到<code>&lt;bean&gt;</code>标签下的自定义标签时进行调用<code>decorate</code>方法。</p><p>编写自己的自定义元素扩展时通常不需要直接实现这个接口，而是使用提供的<code>NamespaceHandlerSupport</code>类</p><h3 id="NamespaceHandlerResolver"><a href="#NamespaceHandlerResolver" class="headerlink" title="NamespaceHandlerResolver"></a>NamespaceHandlerResolver</h3><p><code>DefaultBeanDefinitionDocumentReader</code>用这个接口为特定名称空间URI定位<code>NamespaceHandler</code>实现类</p><h3 id="BeanDefinitionParser"><a href="#BeanDefinitionParser" class="headerlink" title="BeanDefinitionParser"></a>BeanDefinitionParser</h3><p><code>DefaultBeanDefinitionDocumentReader</code>用来处理自定义顶级(直接位于<code>&lt;beans/&gt;</code>下)标签的接口。</p><p>实现类可以根据需要自由地将自定义标记中的元数据转换成任意多的<code>BeanDefinition</code>。</p><p>解析器从相关联的<code>NamespaceHandler</code>中为自定义标记所在的命名空间定位一个<code>BeanDefinitionParser</code></p><h3 id="BeanDefinitionDecorator"><a href="#BeanDefinitionDecorator" class="headerlink" title="BeanDefinitionDecorator"></a>BeanDefinitionDecorator</h3><p><code>DefaultBeanDefinitionDocumentReader</code>使用该接口来处理自定义的嵌套(直接位于<code>&lt;bean&gt;</code>下)标签。</p><p>还可以用于装饰<code>&lt;bean&gt;</code>标签的自定义属性。实现类可以自由地将自定义标签中的元数据转换为所需的任意多个<code>BeanDefinition</code>，并转换包含的<code>&lt;bean&gt;</code>标签为<code>BeanDefinition</code>，甚至可能返回一个完全不同的<code>BeanDefinition</code>来替换原来的。</p><p><code>BeanDefinitionDecorator</code>应该感知到它们可能是解析链的一部分。特别是，<code>BeanDefinitionDecorator</code>应该感知到之前的<code>BeanDefinitionDecorator</code>可能已经用<code>org.springframework.aop.framework.ProxyFactoryBean</code>定义替换了原来的<code>org.springframework.bean.factory.config.BeanDefinition</code>，它允许添加自定义拦截器。</p><p>希望向所包含的bean添加拦截器的<code>BeanDefinitionDecorator</code>应该扩展<code>org.springframework.aop.config.AbstractInterceptorDrivenBeanDefinitionDecorator</code>，它处理解析链，确保只创建一个代理，并且它包含链中的所有拦截器。</p><p>解析器从<code>NamespaceHandler</code>中为自定义标签所在的命名空间定位一个<code>BeanDefinitionDecorator</code>。</p><h3 id="MergedBeanDefinitionPostProcessor"><a href="#MergedBeanDefinitionPostProcessor" class="headerlink" title="MergedBeanDefinitionPostProcessor"></a>MergedBeanDefinitionPostProcessor</h3><p>用于在运行时<code>合并</code>bean定义的后处理器回调接口。为了后处理Spring <code>BeanFactory</code>用来创建bean实例的合并bean定义(原始bean定义的已处理副本)，BeanPostProcessor实现可以实现这个子接口。</p><p>例如，<code>postProcessMergedBeanDefinition</code>方法可以内省bean定义，以便在对bean的实际实例进行后处理之前准备一些缓存的元数据。它还允许修改bean定义，但是<code>只</code>允许修改实际上用于并发修改的定义属性。本质上，这只适用于在<code>RootBeanDefinition</code>本身上定义的操作，而不适用于其基类的属性</p><h3 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h3><p>bean定义阅读器的简单接口。定义带有<code>Resource</code>和<code>String</code>位置参数的加载方法。</p><p>当然具体的bean定义阅读器可以为bean定义添加额外的加载和注册方法，具体到它们的bean定义格式。</p><p>请注意，bean定义阅读器不必实现此接口。它仅为希望遵循标准命名约定的bean定义读者提供建议。</p><h3 id="BeanDefinitionDocumentReader"><a href="#BeanDefinitionDocumentReader" class="headerlink" title="BeanDefinitionDocumentReader"></a>BeanDefinitionDocumentReader</h3><p>用于解析包含Spring bean定义的XML文档的SPI。<code>XmlBeanDefinitionReader</code>用于实际解析DOM文档。</p><p>要解析的每个文档实例化:实现类可以在<code>registerBeanDefinitions</code>方法执行期间在实例变量中保存状态——例如，为文档中所有bean定义定义的全局设置</p><h3 id="DestructionAwareBeanPostProcessor"><a href="#DestructionAwareBeanPostProcessor" class="headerlink" title="DestructionAwareBeanPostProcessor"></a>DestructionAwareBeanPostProcessor</h3><h3 id="InstantiationAwareBeanPostProcessor"><a href="#InstantiationAwareBeanPostProcessor" class="headerlink" title="InstantiationAwareBeanPostProcessor"></a>InstantiationAwareBeanPostProcessor</h3><h3 id="SmartInstantiationAwareBeanPostProcessor"><a href="#SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="SmartInstantiationAwareBeanPostProcessor"></a>SmartInstantiationAwareBeanPostProcessor</h3><h2 id="标记接口相关"><a href="#标记接口相关" class="headerlink" title="标记接口相关"></a>标记接口相关</h2><h3 id="Aware"><a href="#Aware" class="headerlink" title="Aware"></a>Aware</h3><h4 id="BeanFactoryAware"><a href="#BeanFactoryAware" class="headerlink" title="BeanFactoryAware"></a>BeanFactoryAware</h4><h4 id="ApplicationEventPublisherAware"><a href="#ApplicationEventPublisherAware" class="headerlink" title="ApplicationEventPublisherAware"></a>ApplicationEventPublisherAware</h4><h4 id="NotificationPublisherAware"><a href="#NotificationPublisherAware" class="headerlink" title="NotificationPublisherAware"></a>NotificationPublisherAware</h4><h4 id="MessageSourceAware"><a href="#MessageSourceAware" class="headerlink" title="MessageSourceAware"></a>MessageSourceAware</h4><h4 id="EnvironmentAware"><a href="#EnvironmentAware" class="headerlink" title="EnvironmentAware"></a>EnvironmentAware</h4><h4 id="EmbeddedValueResolverAware"><a href="#EmbeddedValueResolverAware" class="headerlink" title="EmbeddedValueResolverAware"></a>EmbeddedValueResolverAware</h4><h4 id="ResourceLoaderAware"><a href="#ResourceLoaderAware" class="headerlink" title="ResourceLoaderAware"></a>ResourceLoaderAware</h4><h4 id="ImportAware"><a href="#ImportAware" class="headerlink" title="ImportAware"></a>ImportAware</h4><h4 id="LoadTimeWeaverAware"><a href="#LoadTimeWeaverAware" class="headerlink" title="LoadTimeWeaverAware"></a>LoadTimeWeaverAware</h4><h4 id="BeanNameAware"><a href="#BeanNameAware" class="headerlink" title="BeanNameAware"></a>BeanNameAware</h4><h4 id="BeanClassLoaderAware"><a href="#BeanClassLoaderAware" class="headerlink" title="BeanClassLoaderAware"></a>BeanClassLoaderAware</h4><h4 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-常用接口&quot;&gt;&lt;a href=&quot;#Spring-常用接口&quot; class=&quot;headerlink&quot; title=&quot;Spring 常用接口&quot;&gt;&lt;/a&gt;Spring 常用接口&lt;/h1&gt;&lt;h2 id=&quot;Bean-工厂相关&quot;&gt;&lt;a href=&quot;#Bean-工厂相
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://qzztf.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>年会</title>
    <link href="http://qzztf.com/post/821c/"/>
    <id>http://qzztf.com/post/821c/</id>
    <published>2019-01-15T03:05:47.000Z</published>
    <updated>2024-06-16T07:25:26.160Z</updated>
    
    <content type="html"><![CDATA[<p>果然不出意外，今年年会又没中奖。号码为<code>96</code>, 这么顺的号码，依然没中。果然是没有中奖的运气，长这么大好像没中过。总共160人左右，56个奖品，中奖率<code>35%</code>左右。我坐的是11号桌，10个人有7个中奖了，跟我邻座的同事没中。感觉有点儿被愚弄了啊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;果然不出意外，今年年会又没中奖。号码为&lt;code&gt;96&lt;/code&gt;, 这么顺的号码，依然没中。果然是没有中奖的运气，长这么大好像没中过。总共160人左右，56个奖品，中奖率&lt;code&gt;35%&lt;/code&gt;左右。我坐的是11号桌，10个人有7个中奖了，跟我邻座的同事没中。感
      
    
    </summary>
    
    
      <category term="年会" scheme="http://qzztf.com/tags/%E5%B9%B4%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>创建my-jpa初衷</title>
    <link href="http://qzztf.com/post/b6a/"/>
    <id>http://qzztf.com/post/b6a/</id>
    <published>2019-01-07T12:07:00.000Z</published>
    <updated>2024-06-16T07:25:26.160Z</updated>
    
    <content type="html"><![CDATA[<p>现在项目中大多数都用Mybatis来做持久化框架，虽然mybatis很灵活，能够定制sql，但是在基础的curd功能上，还是很繁琐，每次都需要创建xml文件，添加相应的sql。也有一些第三方框架如mybatis-plus等，对mybatis做了增强，提供了基础的curd，以及其他的高级功能。但是需要在我们的源代码上加入一些框架里的注解，侵入性大。如果需要更换为hibernate，则代码更改起来非常麻烦，而且这些注解在jpa中都已经定义好了。因此在想如果让mybatis-plus支持jpa的注解就可以了，最开始也只打算做到这一步。但是无意中看到了spring-data-jpa，发现spring对jpa提供了更好的支持，比如通过方法名来转换成查询条件。因此在想干脆用mybatis来实现一个jpa，一来是使用标准的注解，二来是保持mybatis的灵活性。由此便有了<code>my-jpa</code>项目。</p><p>my-jpa项目需要达到的目标：</p><ol><li>支持jpa的大部分注解。</li><li>支持mybatis的sql定制。</li><li>集成<code>spring-data-jpa</code>。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在项目中大多数都用Mybatis来做持久化框架，虽然mybatis很灵活，能够定制sql，但是在基础的curd功能上，还是很繁琐，每次都需要创建xml文件，添加相应的sql。也有一些第三方框架如mybatis-plus等，对mybatis做了增强，提供了基础的curd，以
      
    
    </summary>
    
    
      <category term="my-jpa" scheme="http://qzztf.com/tags/my-jpa/"/>
    
      <category term="jpa" scheme="http://qzztf.com/tags/jpa/"/>
    
  </entry>
  
  <entry>
    <title>org.springframework.boot.actuate.endpoint.EndpointId cannot be cast to java.lang.String 异常处理</title>
    <link href="http://qzztf.com/post/b2e0/"/>
    <id>http://qzztf.com/post/b2e0/</id>
    <published>2018-12-28T03:57:26.000Z</published>
    <updated>2024-06-16T07:25:26.159Z</updated>
    
    <content type="html"><![CDATA[<p>用了<code>spring-boot-starter-actuator</code> 之后出现异常: <code>java.lang.ClassCastException:    org.springframework.boot.actuate.endpoint.EndpointId cannot be cast to java.lang.String</code>.<br>详细的异常如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Failed to instantiate [org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar]: Factory method <span class="string">&#x27;servletEndpointRegistrar&#x27;</span> threw exception; nested exception is java.lang.ClassCastException: org.springframework.boot.actuate.endpoint.EndpointId cannot be cast to java.lang.String</span><br><span class="line">at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:<span class="number">185</span>) ~[spring-beans-<span class="number">5.1</span>.<span class="number">3.</span>RELEASE.jar:<span class="number">5.1</span>.<span class="number">3.</span>RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:<span class="number">622</span>) ~[spring-beans-<span class="number">5.1</span>.<span class="number">3.</span>RELEASE.jar:<span class="number">5.1</span>.<span class="number">3.</span>RELEASE]</span><br><span class="line">... <span class="number">55</span> common frames omitted</span><br><span class="line">Caused by: java.lang.ClassCastException: org.springframework.boot.actuate.endpoint.EndpointId cannot be cast to java.lang.String</span><br><span class="line">at org.springframework.boot.MvcEndpointUtil.filterCanonicalEndpoints(MvcEndpointUtil.java:<span class="number">102</span>) ~[MvcEndpointUtil.class:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at org.springframework.boot.MvcEndpointUtil.filterEndpoints(MvcEndpointUtil.java:<span class="number">73</span>) ~[MvcEndpointUtil.class:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.discoverEndpoints(EndpointDiscoverer.java:<span class="number">125</span>) ~[spring-boot-actuator-<span class="number">2.1</span>.<span class="number">1.</span>RELEASE.jar:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.getEndpoints(EndpointDiscoverer.java:<span class="number">119</span>) ~[spring-boot-actuator-<span class="number">2.1</span>.<span class="number">1.</span>RELEASE.jar:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at org.springframework.boot.actuate.autoconfigure.endpoint.web.ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration.servletEndpointRegistrar(ServletEndpointManagementContextConfiguration.java:<span class="number">76</span>) ~[spring-boot-actuator-autoconfigure-<span class="number">2.1</span>.<span class="number">1.</span>RELEASE.jar:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at org.springframework.boot.actuate.autoconfigure.endpoint.web.ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration$$EnhancerBySpringCGLIB$$<span class="number">1005825f</span>.CGLIB$servletEndpointRegistrar$<span class="number">0</span>(&lt;generated&gt;) ~[spring-boot-actuator-autoconfigure-<span class="number">2.1</span>.<span class="number">1.</span>RELEASE.jar:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at org.springframework.boot.actuate.autoconfigure.endpoint.web.ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration$$EnhancerBySpringCGLIB$$<span class="number">1005825f</span>$$FastClassBySpringCGLIB$$<span class="number">1</span>c44d4f2.invoke(&lt;generated&gt;) ~[spring-boot-actuator-autoconfigure-<span class="number">2.1</span>.<span class="number">1.</span>RELEASE.jar:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:<span class="number">244</span>) ~[spring-core-<span class="number">5.1</span>.<span class="number">3.</span>RELEASE.jar:<span class="number">5.1</span>.<span class="number">3.</span>RELEASE]</span><br><span class="line">at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:<span class="number">363</span>) ~[spring-context-<span class="number">5.1</span>.<span class="number">3.</span>RELEASE.jar:<span class="number">5.1</span>.<span class="number">3.</span>RELEASE]</span><br><span class="line">at org.springframework.boot.actuate.autoconfigure.endpoint.web.ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration$$EnhancerBySpringCGLIB$$<span class="number">1005825f</span>.servletEndpointRegistrar(&lt;generated&gt;) ~[spring-boot-actuator-autoconfigure-<span class="number">2.1</span>.<span class="number">1.</span>RELEASE.jar:<span class="number">2.1</span>.<span class="number">1.</span>RELEASE]</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:<span class="number">1.8</span>.<span class="number">0_111</span>]</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>) ~[na:<span class="number">1.8</span>.<span class="number">0_111</span>]</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.__invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>) ~[na:<span class="number">1.8</span>.<span class="number">0_111</span>]</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">45009</span>) ~[na:<span class="number">1.8</span>.<span class="number">0_111</span>]</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">45012</span>) ~[na:<span class="number">1.8</span>.<span class="number">0_111</span>]</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>) ~[na:<span class="number">1.8</span>.<span class="number">0_111</span>]</span><br><span class="line">at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:<span class="number">154</span>) ~[spring-beans-<span class="number">5.1</span>.<span class="number">3.</span>RELEASE.jar:<span class="number">5.1</span>.<span class="number">3.</span>RELEASE]</span><br><span class="line">... <span class="number">56</span> common frames omitted</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很奇怪的异常，看EndpointId的代码也重写了<code>toString()</code>方法，更奇怪的是找不到<code>MvcEndpointUtil</code>的代码出处。困扰了好几天，关键是百度了好久也没到有用的信息，也在群里问了一下，没有人回复。今天用google搜了一下，本来也不太抱希望。最后无意中发现了一篇文章(异常处理)[<a href="http://www.codeleading.com/article/8276162799/]%EF%BC%8C">http://www.codeleading.com/article/8276162799/]，</a> 发现跟我碰到同一个问题，最后解决方法不显眼，但还是被我发现了。</p><p><strong>更新 IDEA Jreble 插件</strong></p><p>果断试了一下不用jrebel来启动，果然可以了。不晓得jrebel在这个过程中做了什么操作。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用了&lt;code&gt;spring-boot-starter-actuator&lt;/code&gt; 之后出现异常: &lt;code&gt;java.lang.ClassCastException:    org.springframework.boot.actuate.endpoint.Endp
      
    
    </summary>
    
    
      <category term="EndpointId" scheme="http://qzztf.com/tags/EndpointId/"/>
    
      <category term="MvcEndpointUtil" scheme="http://qzztf.com/tags/MvcEndpointUtil/"/>
    
      <category term="异常" scheme="http://qzztf.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="jrebel" scheme="http://qzztf.com/tags/jrebel/"/>
    
  </entry>
  
  <entry>
    <title>在controller 参数中使用枚举</title>
    <link href="http://qzztf.com/post/4085/"/>
    <id>http://qzztf.com/post/4085/</id>
    <published>2018-11-11T08:47:49.000Z</published>
    <updated>2024-06-16T07:25:26.160Z</updated>
    
    <content type="html"><![CDATA[<p>我们通常将一些固定的值定义为枚举类型, 这样就可以限制别人在接口中不能随便传参数,只能是其中的几个.</p><p>但是作为框架的设计者, 这样定义之后,框架的使用者想要扩展的话非学不方便, 因为枚举类型默认就继承<code>Enum</code> 类型,无法再继承其他的类. 因此我们考虑将枚举类实现一个接口,同时,使用时也是用这个接口来定义变量类型.</p><p>定义枚举接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEnum</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 默认就是枚举值的name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个子接口来表示某一类枚举值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormFiledType</span> <span class="keyword">extends</span> <span class="title">IEnum</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> <span class="keyword">implements</span> <span class="title">FormFiledType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        VARCHAR, DATE, NUMBER, INT;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name().toLowerCase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FormFiledType</code>是一个接口类型, <code>Type</code>枚举实现这个接口, 在类中使用接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> FormFiledType type;</span><br></pre></td></tr></table></figure><p>但这样存在问题:</p><ol><li>controller接收时,传的json数据如何转换成正确的枚举值</li><li>mybatis 如何解析这个枚举值.</li></ol><p>由于传的是枚举的值, 需要将这个值转换成对应的枚举类型,那么我们需要:</p><ol><li>目标变量的接口类型</li><li>根据这个类型获取到所有实现这个接口的枚举类</li><li>遍历所有的枚举类,看看是否跟这个值匹配</li></ol><p>Spring MVC 默认使用Jackson来将json数据转换成java对象. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们通常将一些固定的值定义为枚举类型, 这样就可以限制别人在接口中不能随便传参数,只能是其中的几个.&lt;/p&gt;
&lt;p&gt;但是作为框架的设计者, 这样定义之后,框架的使用者想要扩展的话非学不方便, 因为枚举类型默认就继承&lt;code&gt;Enum&lt;/code&gt; 类型,无法再继承其他的类
      
    
    </summary>
    
    
  </entry>
  
</feed>
